(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result â€” either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],2:[function(require,module,exports){
window._ = window._ || require('underscore');

require('./lib/clientBaseBrowserify');
require('./lib/Object');
require('./lib/Exception');
require('./lib/NeatCometClient');
require('./lib/router/ConnectionClient');
require('./lib/router/OpenedProfileClient');

module.exports = window.NeatComet;
},{"./lib/Exception":3,"./lib/NeatCometClient":4,"./lib/Object":5,"./lib/clientBaseBrowserify":6,"./lib/router/ConnectionClient":7,"./lib/router/OpenedProfileClient":8,"underscore":1}],3:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.Exception
 */
NeatComet.Exception = function(msg) {

    this.msg = msg;
};

NeatComet.Exception.prototype = {

    msg: null

};

NeatComet.Exception.warning = function(msg) {

    if (typeof console !== 'undefined') {
        console.error("NeatComet warning: " + msg);
    }
};

},{}],4:[function(require,module,exports){
/**
 * @callback NeatComet.NeatCometClient~createCollection
 * @param {string} profileId
 * @param {string} bindingId
 * @param {*} profilesDefinition
 * @param {NeatComet.router.OpenedProfileClient} openedProfile
 * @returns {NeatComet.api.ICollectionClient}
 */

/**
 * @class NeatComet.NeatCometClient
 * @extends NeatComet.Object
 */
NeatComet.NeatCometClient = NeatComet.Object.extend(/** @lends NeatComet.NeatCometClient.prototype */{

    /** @type {NeatComet.api.ICometClient} */
    comet: null,

    /** @type {NeatComet.NeatCometClient~createCollection} */
    createCollection: null,

    /** @type {Object.<string, Object.<string, *>>} */
    profilesDefinition: null,

    /** @type {Object} */
    _openedProfileParams: null,

    /** @type {Object.<number, NeatComet.router.OpenedProfileClient>} */
    _openedProfiles: null,

    /** @type {Object.<string, NeatComet.router.OpenedProfileClient[]>} */
    _openedProfilesByProfileId: null,

    /** @type {NeatComet.router.ConnectionClient} */
    _connection: null,

    /** @type {number} */
    _lastId: 0,

    init: function() {

        this._openedProfileParams = [];
        this._openedProfiles = {};
        this._openedProfilesByProfileId = {};

        // Setup channel
        this._connection = new NeatComet.router.ConnectionClient({
            comet: this.comet,
            onConnectionRestore: _.bind(this.refresh, this),
            onInit: _.bind(this._onRefreshResponse, this),
            onMessage: _.bind(this._onChannelMessage, this)
        });
    },

    refresh: function() {

        // Call server
        if (this._openedProfileParams.length) {
            this._connection.sendOpen(this._openedProfileParams);
        }
    },

    /**
     *
     * @param {string} profileId
     * @param {object} [params]
     * @returns {NeatComet.router.OpenedProfileClient}
     */
    openProfile: function(profileId, params) {

        var openedProfileId = ++this._lastId;

        this._openedProfileParams.push([openedProfileId, profileId, params || {}]);

        // Init openedProfile
        var openedProfile = new NeatComet.router.OpenedProfileClient();
        openedProfile.id = openedProfileId;
        openedProfile.profileId = profileId;
        openedProfile.createCollection = this.createCollection || /* legacy */ this.getCollection;
        openedProfile.profileDefinition = this.profilesDefinition[profileId];
        openedProfile.init();
        this._openedProfiles[openedProfileId] = openedProfile;

        if (!this._openedProfilesByProfileId[profileId]) {
            this._openedProfilesByProfileId[profileId] = [];
        }
        this._openedProfilesByProfileId[profileId].push(openedProfile);

        // Connect
        // TODO: optimize
        if (this._connection && this._connection.isReady) {
            this.refresh();
        }

        return openedProfile;
    },

    /**
     * @param profiles
     * @param callback
     * @deprecated
     */
    open: function(profiles, callback) {

        // Mark
        _.each(profiles, function(params, profileId) {

            var openedProfile = this.openProfile(profileId, params);

            if (callback) {
                callback(openedProfile, openedProfile.profileId, openedProfile.id);
            }

        }, this);
    },

    _onRefreshResponse: function(profileData) {

        // Setup enabled bindings
        _.each(profileData, function(profileBindings, profileId) {

            _.each(profileBindings, function(bindingId_data) {

                var bindingId = bindingId_data[0];

                _.each(this._openedProfilesByProfileId[profileId], function(openedProfile) {

                    // Init call
                    openedProfile.getCollection(bindingId).reset(bindingId_data[1]);
                }, this);

            }, this);

        }, this);
    },

    _onChannelMessage: function(channel, data) {

        var regs = channel.match(/^([^:]+):([^:]+)(:.+)?/);
        this._callCollections(regs[1], regs[2], data);
    },

    _callCollections: function(profileRef, bindingId, args) {

        var command = args[0];
        args = args.slice(1);

        function callCollection(openedProfile) {
            var collection = openedProfile.getCollection(bindingId);
            collection[command].apply(collection, args);
        }

        if (profileRef.substr(0, 1) === '!') {
            callCollection(this._openedProfiles[profileRef.substr(1)]);
        }
        else {
            _.each(this._openedProfilesByProfileId[profileRef], callCollection);
        }
    }

});

},{}],5:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * Basic class supports two types of initialization
 *
 * I. Single operator call. Note: init() is being called internally
 * var x = new X({
 *     abc: 123
 * });
 *
 * II. Explicit initialization
 * var x = new X; // Don't pass any parameter in constructor. init() won't be called implicitly.
 * x.abc = 123;
 * x.init();
 *
 * @class NeatComet.Object
 *
 * @param {Object.<string, *>} [config]
 */
NeatComet.Object = function(config) {

    if (config) {
        _.assign(this, config);
        this.init();
    }
};

NeatComet.Object.prototype = {

    init: function() {
    }

};

/**
 * Function to define subclasses
 *
 * It is a part of Backbone.js 1.2.3 http://backbonejs.org
 * (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 *
 * @param {Object} protoProps
 * @param {Object} [staticProps]
 */
NeatComet.Object.extend = function(protoProps, staticProps) {

    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    } else {
        child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
};
},{}],6:[function(require,module,exports){
// Enough jsdoc is in serverBase.js
window.NeatComet = {
    adapters: {},
    router: {}
};

},{}],7:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.router.ConnectionClient
 * @extends NeatComet.Object
 */
NeatComet.router.ConnectionClient = NeatComet.Object.extend(/** @lends NeatComet.router.ConnectionClient.prototype */{

    /** @type {NeatComet.api.ICometClient} */
    comet: null,

    /** @type {Function} */
    onConnectionRestore: null,

    /** @type {Function} */
    onInit: null,

    /** @type {Function} */
    onMessage: null,

    isReady: false,

    _lastInitId: 0,
    _waitingFor: 1, // Lock initially. Null = not waiting
    _messageQueue: [],

    init: function() {

        // Install comet listeners
        this.comet.bindEvents({
            onConnectionRestore: _.bind(this._onCometConnectionRestore, this),
            onMessage: _.bind(this._onCometMessage, this)
        });
    },

    _onCometConnectionRestore: function() {

        this.isReady = true;
        this.onConnectionRestore();
    },

    _onCometMessage: function(channel, data) {

        if (this._waitingFor) {
            this._messageQueue.push([channel, data]);
        }
        else {
            this.onMessage(channel, data);
        }
    },

    sendOpen: function(params) {

        // Force initialization-time messages to run after initialization
        var requestId = ++this._lastInitId;
        this._waitingFor = requestId;
        this._messageQueue = [];

        this.comet.sendOpen(params, _.bind(function(data) {

            // Drop the result of a wrong call
            if (this._waitingFor != requestId) {
                return;
            }

            // Stop waiting
            this._waitingFor = null;

            // Effective init
            this.onInit(data);

            // Flush pending messages
            _.each(this._messageQueue, function(message) {
                this.onMessage.apply(this, message);
            }, this);
            this._messageQueue = [];

        }, this));
    }

});

},{}],8:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.router.OpenedProfileClient
 * @extends NeatComet.Object
 */
NeatComet.router.OpenedProfileClient = NeatComet.Object.extend(/** @lends NeatComet.router.OpenedProfileServer.prototype */{

    /** @type {Number} */
    id: null,

    /** @type {String} */
    profileId: null,

    /** @type {NeatComet.NeatCometClient~createCollection} */
    createCollection: null,

    /** @type {Object.<string, Object.<string, *>>} */
    profileDefinition: null,

    /** @type {Object.<string, NeatComet.api.ICollectionClient>} */
    collections: null,

    init: function() {
        this.collections = {};
    },

    getCollection: function(bindingId) {

        // Lazy init
        if (!_.has(this.collections, bindingId)) {
            
            if (!_.has(this.profileDefinition, bindingId)) {
                throw new NeatComet.Exception('Wrong bindingId ' + bindingId);
            }

            this.collections[bindingId] = this.createCollection(
                this.profileId,
                bindingId,
                this.profileDefinition[bindingId],
                this
            );
        }

        return this.collections[bindingId];
    },

    /**
     * @param {Object} target
     */
    populateNamespace: function(target) {

        _.each(this.profileDefinition, function (params, bindingId) {
            target[bindingId] = this.getCollection(bindingId).getNative();
        }, this);
    }

});

},{}],9:[function(require,module,exports){
'use strict';

require('jii');
require('jii-model');

// Load framework files
require('./lib/ActiveRecord');
require('./lib/Expression');
require('./lib/AfterSaveEvent');
require('./lib/remote/Command');
require('./lib/remote/Connection');
require('./lib/remote/Schema');
require('./lib/remote/TransportInterface');
},{"./lib/ActiveRecord":10,"./lib/AfterSaveEvent":11,"./lib/Expression":12,"./lib/remote/Command":13,"./lib/remote/Connection":14,"./lib/remote/Schema":15,"./lib/remote/TransportInterface":16,"jii":124,"jii-model":96}],10:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @abstract
 * @class Jii.sql.ActiveRecord
 * @extends Jii.base.ActiveRecord
 */
Jii.defineClass('Jii.sql.ActiveRecord', /** @lends Jii.sql.ActiveRecord.prototype */{

	__extends: Jii.base.ActiveRecord,
	
	__static: /** @lends Jii.sql.ActiveRecord */{

		/**
		 * Returns the database connection used by this AR class.
		 * By default, the "db" application component is used as the database connection.
		 * You may override this method if you want to use a different database connection.
		 * @returns {Jii.sql.Connection} the database connection used by this AR class.
		 */
		getDb: function () {
			return Jii.app.getComponent('db');
		},

		/**
		 * Creates an [[ActiveQuery]] instance with a given SQL statement.
		 *
		 * Note that because the SQL statement is already specified, calling additional
		 * query modification methods (such as `where()`, `order()`) on the created [[ActiveQuery]]
		 * instance will have no effect. However, calling `with()`, `asArray()` or `indexBy()` is
		 * still fine.
		 *
		 * Below is an example:
		 *
		 * ~~~
		 * customers = Customer.findBySql('SELECT * FROM customer').all();
		 * ~~~
		 *
		 * @param {string} sql the SQL statement to be executed
		 * @param {[]} params parameters to be bound to the SQL statement during execution.
		 * @returns {Jii.sql.ActiveQuery} the newly created [[ActiveQuery]] instance
		 */
		findBySql: function (sql, params) {
			params = params || [];

			var query = this.find();
			query.setSql(sql);

			return query.params(params);
		},

		/**
		 * Updates the whole table using the provided attribute values and conditions.
		 * For example, to change the status to be 1 for all customers whose status is 2:
		 *
		 * ~~~
		 * Customer.updateAll({status: 1}, 'status = 2');
		 * ~~~
		 *
		 * @param {[]} attributes attribute values (name-value pairs) to be saved into the table
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * @returns {Promise.<number>} the number of rows updated
		 */
		updateAll: function (attributes, condition, params) {
			condition = condition || '';
			params = params || {};

			return this.getDb().createCommand().update(this.tableName(), attributes, condition, params);
		},

		/**
		 * Updates the whole table using the provided counter changes and conditions.
		 * For example, to increment all customers' age by 1,
		 *
		 * ~~~
		 * Customer.updateAllCounters({age: 1});
		 * ~~~
		 *
		 * @param {[]} counters the counters to be updated (attribute name => increment value).
		 * Use negative values if you want to decrement the counters.
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * Do not name the parameters as `:bp0`, `:bp1`, etc., because they are used internally by this method.
		 * @returns {number} the number of rows updated
		 */
		updateAllCounters: function (counters, condition, params) {
			condition = condition || '';
			params = params || {};

			var n = 0;
			Jii._.each(counters, Jii._.bind(function(value, name) {
				var params = {};
				params[':bp{' + n + '}'] = value;
				counters[name] = new Jii.sql.Expression('[[' + name + ']]+:bp{' + n + '}', params);
				n++;
			}, this));

			return this.getDb().createCommand().update(this.tableName(), counters, condition, params);
		},

		/**
		 * Deletes rows in the table using the provided conditions.
		 * WARNING: If you do not specify any condition, this method will delete ALL rows in the table.
		 *
		 * For example, to delete all customers whose status is 3:
		 *
		 * ~~~
		 * Customer.deleteAll('status = 3');
		 * ~~~
		 *
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the DELETE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * @returns {number} the number of rows deleted
		 */
		deleteAll: function (condition, params) {
			condition = condition || '';
			params = params || {};

			return this.getDb().createCommand().delete(this.tableName(), condition, params);
		},

		/**
		 * @inheritdoc
		 */
		find: function () {
			return new Jii.sql.ActiveQuery(this);
		},

		/**
		 * Declares the name of the database table associated with this AR class.
		 * By default this method returns the class name as the table name by calling [[Inflector.camel2id()]]
		 * with prefix [[Connection.tablePrefix]]. For example if [[Connection.tablePrefix]] is 'tbl_',
		 * 'Customer' becomes 'tbl_customer', and 'OrderItem' becomes 'tbl_order_item'. You may override this method
		 * if the table is not named after this convention.
		 * @returns {string} the table name
		 */
		tableName: function () {
			var className = this.className();
			var name = className.substr(className.lastIndexOf('.') + 1);

			return '{{%' + Jii._s.underscored(name) + '}}';
		},

		/**
		 * Returns the schema information of the DB table associated with this AR class.
		 * @returns {Jii.sql.TableSchema} the schema information of the DB table associated with this AR class.
		 * @throws {Jii.exceptions.InvalidConfigException} if the table for the AR class does not exist.
		 */
		getTableSchema: function () {
			var schema = this.getDb().getTableSchema(this.tableName());
			if (schema === null) {
				throw new Jii.exceptions.InvalidConfigException("The table does not exist: " + this.tableName());
			}

			return schema;
		},

		/**
		 * Returns the primary key name(s) for this AR class.
		 * The default implementation will return the primary key(s) as declared
		 * in the DB table that is associated with this AR class.
		 *
		 * If the DB table does not declare any primary key, you should override
		 * this method to return the attributes that you want to use as primary keys
		 * for this AR class.
		 *
		 * Note that an array should be returned even for a table with single primary key.
		 *
		 * @returns {string[]} the primary keys of the associated database table.
		 */
		primaryKey: function () {
			return this.getTableSchema().primaryKey;
		},

		populateRecord: function (record, row) {

			var columns = this.__static.getTableSchema().columns;
			Jii._.each(row, function(value, name) {
				if (Jii._.has(columns, name)) {
					row[name] = columns[name].typecast(value);
				}
			});

			this.__super(record, row);
		}

	},


	/**
	 * Loads default values from database table schema
	 *
	 * @param {boolean} [skipIfSet] if existing value should be preserved
	 * @returns {Promise} model instance
	 */
	loadDefaultValues: function (skipIfSet) {
		skipIfSet = skipIfSet !== false;

		Jii._.each(this.__static.getTableSchema().columns, function(column) {
			if (column.defaultValue !== null && (!skipIfSet || this.get(column.name) === null)) {
				this.set(column.name, column.defaultValue);
			}
		}.bind(this));
	},

	/**
	 * Returns the list of all attribute names of the model.
	 * The default implementation will return all column names of the table associated with this AR class.
	 * @returns {[]} list of attribute names.
	 */
	attributes: function () {
		return Jii._.keys(this.__static.getTableSchema().columns);
	},

	/**
	 * Inserts a row into the associated database table using the attribute values of this record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. insert the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_INSERT]], [[EVENT_AFTER_INSERT]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be inserted into database.
	 *
	 * If the table's primary key is auto-incremental and is null during insertion,
	 * it will be populated with the actual value after insertion.
	 *
	 * For example, to insert a customer record:
	 *
	 * ~~~
	 * customer = new Customer();
	 * customer.name = name;
	 * customer.email = email;
	 * customer.insert();
	 * ~~~
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {[]} attributes list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the attributes are valid and the record is inserted successfully.
	 * @throws \Exception in case insert failed.
	 */
	insert: function (runValidation, attributes) {
		runValidation = runValidation !== false;
		attributes = attributes || null;

		return Promise.resolve().then(function() {
			if (runValidation) {
				return this.validate(attributes);
			}

			return true;
		}.bind(this)).then(function(isValidate) {
			if (!isValidate) {
				Jii.info('Model not inserted due to validation error.');
				return false;
			}

			/*var db = this.__static.getDb();
			 if (this.isTransactional(self.OP_INSERT)) {
			 transaction = db.beginTransaction();
			 try {
			 result = this.insertInternal(attributes);
			 if (result === false) {
			 transaction.rollBack();
			 } else {
			 transaction.commit();
			 }
			 } catch (\Exception e) {
			 transaction.rollBack();
			 throw e;
			 }
			 } else {*/
			return this._insertInternal(attributes);
			//}
		}.bind(this));
	},

	/**
	 * Inserts an ActiveRecord into DB without considering transaction.
	 * @param {[]} attributes list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the record is inserted successfully.
	 */
	_insertInternal: function (attributes) {
		attributes = attributes || null;

		return this.beforeSave(true).then(function(bool) {
			if (!bool) {
				return false;
			}

			var values = this.getDirtyAttributes(attributes);
			if (Jii._.isEmpty(values)) {
				Jii._.each(this.getPrimaryKey(true), function(value, key) {
					values[key] = value;
				});
			}

			return this.__static.getDb().createCommand().insertModel(this, values).then(function(insertInfo) {
				if (!insertInfo) {
					return false;
				}

				var table = this.__static.getTableSchema();
				if (table.sequenceName !== null) {
					for (var i = 0, l = table.primaryKey.length; i < l; i++) {
						var name = table.primaryKey[i];
						if (this.getAttribute(name) === null) {
							var id = table.columns[name].typecast(insertInfo.insertId);
							this.setAttribute(name, id);
							values[name] = id;
							break;
						}
					}
				}

                var changedAttributes = {};
                Jii._.each(values, function(num, key) {
                    changedAttributes[key] = null;
                });
				this.setOldAttributes(values);
				return this.afterSave(true, changedAttributes).then(function() {
					return true;
				});
			}.bind(this));
		}.bind(this));
	},

	/**
	 * Saves the changes to this active record into the associated database table.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. save the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_UPDATE]], [[EVENT_AFTER_UPDATE]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be saved into database.
	 *
	 * For example, to update a customer record:
	 *
	 * ~~~
	 * customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.update();
	 * ~~~
	 *
	 * Note that it is possible the update does not affect any row in the table.
	 * In this case, this method will return 0. For this reason, you should use the following
	 * code to check if update() is successful or not:
	 *
	 * ~~~
	 * if (this.update() !== false) {
     *     // update successful
     * } else {
     *     // update failed
     * }
	 * ~~~
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {[]} attributeNames list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {number|boolean} the number of rows affected, or false if validation fails
	 * or [[beforeSave()]] stops the updating process.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being updated is outdated.
	 * @throws \Exception in case update failed.
	 */
	update: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		return Promise.resolve().then(function() {
			if (runValidation) {
				return this.validate(attributeNames);
			}

			return true;
		}.bind(this)).then(function(isValidate) {
			if (!isValidate) {
				Jii.info('Model not updated due to validation error.');
				return false;
			}

			/*db = static.getDb();
			if (this.isTransactional(self.OP_UPDATE)) {
				transaction = db.beginTransaction();
				try {
					result = this.updateInternal(attributeNames);
					if (result === false) {
						transaction.rollBack();
					} else {
						transaction.commit();
					}
				} catch (\Exception e) {
					transaction.rollBack();
					throw e;
				}
			} else {*/
				return this._updateInternal(attributeNames);
			//}

		}.bind(this));


	},

	/**
	 * Deletes the table row corresponding to this active record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeDelete()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 2. delete the record from the database;
	 * 3. call [[afterDelete()]].
	 *
	 * In the above step 1 and 3, events named [[EVENT_BEFORE_DELETE]] and [[EVENT_AFTER_DELETE]]
	 * will be raised by the corresponding methods.
	 *
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being deleted is outdated.
	 * @throws \Exception in case delete failed.
	 */
	delete: function () {
		/*db = static.getDb();
		if (this.isTransactional(self.OP_DELETE)) {
			transaction = db.beginTransaction();
			try {
				result = this.deleteInternal();
				if (result === false) {
					transaction.rollBack();
				} else {
					transaction.commit();
				}
			} catch (\Exception e) {
				transaction.rollBack();
				throw e;
			}
		} else {*/
			return this._deleteInternal();
		//}

		//return result;
	},

	/**
	 * Deletes an ActiveRecord without considering transaction.
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException
	 */
	_deleteInternal: function () {

		return this.beforeDelete().then(function(bool) {
			if (!bool) {
				return false;
			}

            return this.__static.getDb().createCommand().deleteModel(this).then(function(result) {
				/*if (lock !== null && !result) {
				 throw new StaleObjectException('The object being deleted is outdated.');
				 }*/
				this.setOldAttributes(null);

				return this.afterDelete().then(function() {
					return result;
				});
			}.bind(this));
		}.bind(this));
	},

	/**
	 * Returns a value indicating whether the given active record is the same as the current one.
	 * The comparison is made by comparing the table names and the primary key values of the two active records.
	 * If one of the records [[isNewRecord|is new]] they are also considered not equal.
	 * @param {Jii.sql.ActiveRecord} record record to compare to
	 * @returns {boolean} whether the two active records refer to the same row in the same database table.
	 */
	equals: function (record) {
		if (this.isNewRecord() || record.isNewRecord()) {
			return false;
		}

		return this.__static.tableName() === record.__static.tableName() && this.getPrimaryKey() === record.getPrimaryKey();
	}

});

},{"jii":124}],11:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.AfterSaveEvent
 * @extends Jii.base.ModelEvent
 */
Jii.defineClass('Jii.sql.AfterSaveEvent', /** @lends Jii.sql.AfterSaveEvent.prototype */{

	__extends: Jii.base.ModelEvent,

	/**
	 * The attribute values that had changed and were saved.
	 * @type {string[]}
	 */
	changedAttributes: null

});

},{"jii":124}],12:[function(require,module,exports){
/**
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * Expression represents a DB expression that does not need escaping or quoting.
 * When an Expression object is embedded within a SQL statement or fragment,
 * it will be replaced with the [[expression]] property value without any
 * DB escaping or quoting. For example,
 *
 * ~~~
 * expression = new Expression('NOW()');
 * sql = 'SELECT ' . expression;  // SELECT NOW()
 * ~~~
 *
 * An expression can also be bound with parameters specified via [[params]].
 *
 * @class Jii.sql.Expression
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.sql.Expression', /** @lends Jii.sql.Expression.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {string} the DB expression
	 */
	expression: null,

	/**
	 * @type {object} list of parameters that should be bound for this expression.
	 * The keys are placeholders appearing in [[expression]] and the values
	 * are the corresponding parameter values.
	 */
	params: null,

	/**
	 * Constructor.
	 * @param {string} expression the DB expression
	 * @param {object} params parameters
	 * @param {[]} config name-value pairs that will be used to initialize the object properties
	 * @constructor
	 */
	constructor: function (expression, params, config) {
		params = params || [];
		config = config || [];

		this.expression = expression;
		this.params = params;
		this.__super(config);
	},

	/**
	 * String magic method
	 * @returns {string} the DB expression
	 */
	toString: function() {
		return this.expression;
	}

});
},{"jii":124}],13:[function(require,module,exports){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.Command
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.Command', /** @lends Jii.sql.remote.Command.prototype */{

	__extends: Jii.base.Component,

    __static: /** @lends Jii.sql.remote.Command */{

        METHOD_INSERT: 'insert',
        METHOD_UPDATE: 'update',
        METHOD_DELETE: 'delete'

    },

	/**
	 * @type {Jii.sql.BaseConnection} the DB connection that this command is associated with
	 */
	db: null,

	/**
	 * @returns {Promise}
	 */
	queryAll: function () {
		return this._queryInternal('all');
	},

	/**
	 * @returns {Promise}
	 */
	queryOne: function () {
		return this._queryInternal('one');
	},

	/**
	 * @returns {Promise}
	 */
	queryScalar: function () {
		return this._queryInternal('scalar');
	},

	/**
	 * @returns {Promise}
	 */
	queryColumn: function () {
		return this._queryInternal('column');
	},

	/**
	 * Performs the actual DB query of a SQL statement.
	 * @param {string} method
	 * @returns {Promise} the method execution result
	 * @throws Exception if the query causes any problem
	 */
	_queryInternal: function (method) {
	},

    /**
     *
     * @param {Jii.sql.ActiveRecord} model
     * @param {object} values
     * @returns {Promise}
     */
    insertModel: function(model, values) {
        return this.db.exec(this.__static.METHOD_INSERT, model.className(), {
            values: values
        }).then(function(result) {
            if (!result) {
                return null;
            }

            if (!Jii._.isEmpty(result.errors)) {
                model.setErrors(result.errors);
                return null;
            }
            if (result.attributes) {
                model.setAttributes(result.attributes);
            }

            return {
                insertId: model.getPrimaryKey()
            };
        });
    },

    /**
     *
     * @param {Jii.base.ActiveRecord} model
     * @param {object} values
     * @returns {Promise}
     */
    updateModel: function(model, values) {
        return this.db.exec(this.__static.METHOD_UPDATE, model.className(), {
            primaryKey: model.getOldPrimaryKey(true),
            values: values
        }).then(function(result) {
            if (!result) {
                return 0;
            }

            if (!Jii._.isEmpty(result.errors)) {
                model.setErrors(result.errors);
                return 0;
            }

            return result.success ? 1 : 0;
        });
    },


    /**
     *
     * @param {Jii.base.ActiveRecord} model
     * @returns {Promise}
     */
    deleteModel: function(model) {
        return this.db.exec(this.__static.METHOD_DELETE, model.className(), {
            primaryKey: model.getPrimaryKey(true)
        }).then(function(result) {
            return result && result.success ? 1 : 0;
        });
    }

});
},{"jii":124}],14:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 *
 * @class Jii.sql.remote.Connection
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.Connection', /** @lends Jii.sql.remote.Connection.prototype */{

	__extends: Jii.base.Component,

    /**
     * @type {Jii.sql.remote.Schema} the database schema
     */
    schema: {
        className: 'Jii.sql.remote.Schema'
    },

    /**
     * @type {Jii.sql.remote.TransportInterface}
     */
    transport: null,

    /**
     * @type {string}
     */
    route: 'api/ar',

    init: function() {
        this.schema = Jii.createObject(this.schema);
    },

    getTransport: function() {
        if (this.transport === null) {
            this.transport = Jii.app.get('comet');
        } else if (!(this.transport instanceof Jii.base.Component)) {
            this.transport = Jii.createObject(this.transport);
        }
        return this.transport;
    },

    /**
     * Creates a command for execution.
     * @returns {Jii.sql.remote.Command} the DB command
     */
    createCommand: function () {
        return new Jii.sql.remote.Command({
            db: this
        });
    },

    /**
     *
     * @param {string} method
     * @param {string} modelClassName
     * @param {object} [params]
     * @returns {Promise}
     */
    exec: function(method, modelClassName, params) {
        params = params || {};
        params.method = method;
        params.modelClassName = modelClassName;

        return this.getTransport().request(this.route, params);
    },

    /**
     * Returns the schema information for the database opened by this connection.
     * @returns {Jii.sql.remote.Schema} the schema information for the database opened by this connection.
     */
    getSchema: function () {
        return this.schema;
    },

    /**
     * Obtains the schema information for the named table.
     * @param {string} name table name.
     * @returns {*} table schema information. Null if the named table does not exist.
     */
    getTableSchema: function (name) {
        return this.getSchema().getTableSchema(name);
    }

});
},{"jii":124}],15:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.Schema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.sql.remote.Schema', /** @lends Jii.sql.remote.Schema.prototype */{

	__extends: Jii.base.Object,


    tables: {},

    /**
     *
     * @param name
     * @returns {Jii.base.ModelSchema}
     */
    getTableSchema: function (name) {
        if (Jii._.isObject(this.tables[name]) && !(this.tables[name] instanceof Jii.base.ModelSchema)) {
            this.tables[name] = Jii.base.ModelSchema.createFromObject(this.tables[name]);
        }

        return this.tables[name] || null;
    },

    getTableNames: function () {
        return Jii._.keys(this.tables);
    }

});

},{"jii":124}],16:[function(require,module,exports){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.TransportInterface
 * @interface Jii.sql.remote.TransportInterface
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.TransportInterface', /** @lends Jii.sql.remote.TransportInterface.prototype */{

	__extends: Jii.base.Component,

    /**
     * Send request to backend
     * @param {string} route
     * @param {object} [params]
     * @returns {Promise}
     */
	request: function(route, params) {
	}

});
},{"jii":124}],17:[function(require,module,exports){
'use strict';

require('jii');

// Load framework files
require('./lib/client/plugin/AutoReconnect');
require('./lib/client/plugin/PluginInterface');
require('./lib/client/transport/TransportInterface');
require('./lib/client/Client');
require('./lib/client/LogMessageEvent');
require('./lib/client/MessageEvent');
require('./lib/client/RequestEvent');
require('./lib/ChannelEvent');
require('./lib/LogEvent');

},{"./lib/ChannelEvent":18,"./lib/LogEvent":19,"./lib/client/Client":20,"./lib/client/LogMessageEvent":21,"./lib/client/MessageEvent":22,"./lib/client/RequestEvent":24,"./lib/client/plugin/AutoReconnect":25,"./lib/client/plugin/PluginInterface":26,"./lib/client/transport/TransportInterface":28,"jii":124}],18:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.ChannelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.ChannelEvent', /** @lends Jii.comet.ChannelEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
	channel: null,

	/**
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],19:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.LogEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.LogEvent', /** @lends Jii.comet.LogEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * Level: debug/info/warning/error
	 * @type {string}
	 */
	level: null,

	/**
	 * Log message
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],20:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * Read-only from api stationUid
 * @type {null}
 */
var stationUid = null;

/**
 * @class Jii.comet.client.Client
 * @extends Jii.base.Component
 * @implements Jii.sql.remote.TransportInterface
 */
Jii.defineClass('Jii.comet.client.Client', /** @lends Jii.comet.client.Client.prototype */{

	__extends: Jii.base.Component,

	__static: /** @lends Jii.comet.client.Client */{

		/**
		 * @event Jii.comet.client.Client#open
		 * @property {Jii.base.Event} event
		 */
		EVENT_OPEN: 'open',

		/**
		 * @event Jii.comet.client.Client#close
		 * @property {Jii.base.Event} event
		 */
		EVENT_CLOSE: 'close',

		/**
		 * @event Jii.comet.client.Client#beforeSend
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_BEFORE_SEND: 'beforeSend',

		/**
		 * @event Jii.comet.client.Client#channel
		 * @property {Jii.comet.ChannelEvent} event
		 */
		EVENT_CHANNEL: 'channel',

		/**
		 * @event Jii.comet.client.Client#channel:
		 * @property {Jii.comet.ChannelEvent} event
		 */
		EVENT_CHANNEL_NAME: 'channel:',

		/**
		 * @event Jii.comet.client.Client#message
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_MESSAGE: 'message',

        /**
         * @event Jii.comet.client.Client#beforeRequest
         * @property {Jii.comet.client.RequestEvent} event
         */
        EVENT_BEFORE_REQUEST: 'beforeRequest',

        /**
         * @event Jii.comet.client.Client#request
         * @property {Jii.comet.client.RequestEvent} event
         */
        EVENT_REQUEST: 'request'

	},

	/**
	 * @type {Jii.comet.client.transport.TransportInterface}
	 */
	transport: {
		className: 'Jii.comet.client.transport.Sockjs'
	},

	plugins: {

		/**
		 * @type {Jii.comet.client.plugin.AutoReconnect}
		 */
		autoReconnect: {
			className: 'Jii.comet.client.plugin.AutoReconnect'
		}

	},

	/**
	 * Max comet workers number. Used for auto generate different server urls (balancer).
	 */
	workersCount: null,

	/**
	 * @type {boolean}
	 */
	autoOpen: true,

	/**
	 * Url to comet server
	 * @type {string}
	 */
	_serverUrl: '',

	/**
	 * @type {boolean}
	 */
	_isOpened: false,

	/**
	 * @type {boolean}
	 */
	_forceClosed: false,

    /**
     * @type {object}
     */
    _requestsInProcess: {},

	init: function () {
		stationUid = Jii.helpers.String.generateUid();

		// Init transport
		this.transport = Jii.createObject(this.transport);
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_OPEN, this._onOpen.bind(this));
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_CLOSE, this._onClose.bind(this));
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_MESSAGE, this._onMessage.bind(this));

		// Init plugins
		Jii._.each(this.plugins, function(config, name) {
			config.comet = this;
			this.plugins[name] = Jii.createObject(config);
		}.bind(this));

		// Auto open
		if (this.autoOpen) {
			this.open();
		}
	},

	/**
	 * Set url to comet server
	 * Detect server url by pattern, if set. Used for balancer server by clients random().
	 * @param {string} value
	 */
	setServerUrl: function(value) {
		// Normalize
		if (value.indexOf('//') === 0) {
			var sslSuffix = location.protocol === 'https' ? 's' : ''
			value = 'http' + sslSuffix + ':' + value;
		}

		// Balancer
		if (value.indexOf('{workerIndex}') !== -1) {
			var min = 0;
			var max = Math.max(this.workersCount || 0, 1) - 1;
			var workerIndex = min + Math.floor(Math.random() * (max - min + 1));
			value = value.replace('{workerIndex}', String(workerIndex));
		}

		// Switch server URL protocol to HTTP instead of HTTPS if browser is IE9 or lesser
		var isIE = window.navigator && (/MSIE/.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent));
		if (isIE && window.document && window.document.all && !window.atob) {
			var isSsl = /^(http|ws)s/.test(value);
			if (isSsl === location.protocol === 'https') {
				value = value.replace(/^(http|ws)s/, '$1');
			}
		}

		this._serverUrl = value;
	},

	/**
	 * Return comet server url
	 * @returns {string}
	 */
	getServerUrl: function() {
		return this._serverUrl;
	},

	/**
	 * Return station UID - unique id of current javascript environment (browser tab)
	 * @returns {null}
	 */
	getStationUid: function() {
		return stationUid;
	},

	/**
	 * Return true, if connection is opened
	 * @returns {boolean}
	 */
	isOpened: function() {
		return this._isOpened;
	},

	/**
	 * Return true, if connection closed by client (manually)
	 * @returns {boolean}
	 */
	isForceClosed: function() {
		return this._forceClosed;
	},

	/**
	 * Open connection
	 */
	open: function() {
		this._forceClosed = false;
		if (!this._isOpened) {
			this.transport.open(this._serverUrl);
		}
	},

	/**
	 * Close connection
	 */
	close: function() {
		this._forceClosed = true;
		if (this._isOpened) {
			this.transport.close();
		}
	},

	/**
	 *
	 * @param {string} channel
	 * @param {object} data
	 */
	send: function(channel, data) {
		this._sendInternal('channel ' + channel + ' ' + JSON.stringify(data));
	},

    /**
     *
     * @param {string} route
     * @param {object} [data]
     */
    request: function (route, data) {
        data = data || {};
        data.requestUid = Jii.helpers.String.generateUid();

        // Trigger event for append data
        var event = new Jii.comet.client.RequestEvent({
            route: route,
            params: data
        });
        this.trigger(this.__static.EVENT_BEFORE_REQUEST, event);
        data = event.params;

        // Generate promise for wait response
        var promise = new Promise(function(resolve) {
            this._requestsInProcess[data.requestUid] = {
                route: route,
                resolve: resolve
            };
        }.bind(this));

        // Send request
        this._sendInternal('action ' + route + ' ' + JSON.stringify(data));

        return promise;
    },

	/**
	 *
	 * @param {string} message
	 * @private
	 */
	_sendInternal: function(message) {
		// Trigger event before send message
        var event = new Jii.comet.client.MessageEvent({
            message: message
        });
		this.trigger(this.__static.EVENT_BEFORE_SEND, event);
        message = event.message;

		if (this._isOpened) {
			this.transport.send(message);
		}
	},

	_onOpen: function (event) {
		if (!this._isOpened) {
			this._isOpened = true;
			this.trigger(this.__static.EVENT_OPEN, event);
		}
	},

	_onClose: function (event) {
		if (this._isOpened) {
			this._isOpened = false;
			this.trigger(this.__static.EVENT_CLOSE, event);
		}
	},

    _onMessage: function (event) {
        if (event.message.indexOf('action ') === 0) {
            var response = JSON.parse(event.message.substr(7));
            if (response.requestUid && this._requestsInProcess[response.requestUid]) {
                this._requestsInProcess[response.requestUid].resolve(response);

                // Trigger request event
                this.trigger(this.__static.EVENT_REQUEST, new Jii.comet.client.RequestEvent({
                    route: this._requestsInProcess[response.requestUid].route,
                    params: response
                }));

                delete this._requestsInProcess[response.requestUid];
            }
        }

		if (event.message.indexOf('channel ') === 0) {
			var message = event.message.substr(8);
			var i = message.indexOf(' ');
			var channelEvent = new Jii.comet.ChannelEvent({
				channel: message.substr(0, i),
				params: JSON.parse(message.substr(i + 1))
			});

			// Trigger channel and channel:* events
			this.trigger(this.__static.EVENT_CHANNEL_NAME + channelEvent.channel, channelEvent);
			this.trigger(this.__static.EVENT_CHANNEL, channelEvent);
		}

		// Trigger message event
		this.trigger(this.__static.EVENT_MESSAGE, new Jii.comet.client.MessageEvent({
			message: event.message
		}));
	}

});

},{"jii":124}],21:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.LogMessageEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.LogMessageEvent', /** @lends Jii.comet.client.LogMessageEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 *  Level: debug/info/warning/error
	 * @type {string}
	 */
	level: null,

	/**
	 * Log message
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],22:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.MessageEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.MessageEvent', /** @lends Jii.comet.client.MessageEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],23:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

var NeatComet = require('neatcomet');


/**
 * @class Jii.comet.client.NeatClient
 * @extends Jii.base.Component
 * @implements NeatComet.api.ICometClient
 */
Jii.defineClass('Jii.comet.client.NeatClient', /** @lends Jii.comet.client.NeatClient.prototype */{

    __extends: Jii.base.Component,

    __static: /** @lends Jii.comet.client.NeatClient */{

        ROUTE_PREFIX: 'profiles:'

    },

    /**
     * @type {Jii.comet.client.Client}
     */
    comet: null,

    /**
     * @type {object}
     */
    bindings: null,

    /**
     * @type {NeatComet.NeatCometClient}
     */
    engine: {
        className: 'NeatComet.NeatCometClient'
    },

    init: function () {
        this.__super();

        this.comet = this.comet === null ?
            Jii.app.get('comet') :
            (
                this.comet instanceof Jii.base.Component ?
                    this.comet :
                    Jii.createObject(this.comet)
            );

        // Move NeatComet to Jii namespace
        Jii._.extend(Jii.namespace('NeatComet'), NeatComet);

        this.engine.comet = this;
        this.engine.profilesDefinition = this.bindings;
        this.engine.createCollection = this.engine.createCollection || this._createCollection.bind(this);
        this.engine = Jii.createObject(this.engine);
    },

    /**
     *
     * @param profileId
     * @param params
     * @returns {NeatComet.router.OpenedProfileClient}
     */
    openProfile: function(profileId, params) {
        return this.engine.openProfile(profileId, params);
    },

    getCollection: function(profileId, bindingId) {

    },

    /**
     * Allowed to expect that it will be called only once per ICometServer instance
     * @param {NeatComet.api.ICometClientEvents} eventsHandler
     */
    bindEvents: function(eventsHandler) {
        this.comet.on(Jii.comet.client.Client.EVENT_CHANNEL, function(event) {
            if (event.channel.indexOf(this.__static.ROUTE_PREFIX) === 0) {
                eventsHandler.onMessage(event.channel.substr(this.__static.ROUTE_PREFIX.length), event.params);
            }
        }.bind(this));

        this.comet.on('open', function() {
            eventsHandler.onConnectionRestore();
        });
    },

    /**
     * @param {object} params
     * @param {NeatComet.api.ICometClient~openSuccess} successCallback
     */
    sendOpen: function(params, successCallback) {
        this.comet.request('neat/open', { neat: params }).then(function(data) {

            // Chain with NeatComet handler
            successCallback(data.neat);
        });
    },

    /**
     * @param {string[]} ids
     */
    sendClose: function(ids) {
        this.comet.request('neat/close', { neat: ids });
    },

    _createCollection: function(profileId, bindingId, definition, openedProfile) {
        var modelClassName = definition.clientModel || definition.serverModel || Jii.base.ActiveRecord;
        return new Jii.base.Collection([], {
            modelClass: Jii.namespace(modelClassName)
        });
    }

});

},{"jii":124,"neatcomet":2}],24:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.RequestEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.RequestEvent', /** @lends Jii.comet.client.RequestEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
    route: null

});

},{"jii":124}],25:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./PluginInterface');

/**
 * @class Jii.comet.client.plugin.AutoReconnect
 * @extends Jii.comet.client.plugin.PluginInterface
 */
Jii.defineClass('Jii.comet.client.plugin.AutoReconnect', /** @lends Jii.comet.client.plugin.AutoReconnect.prototype */{

	__extends: Jii.comet.client.plugin.PluginInterface,

	/**
	 * @type {boolean}
	 */
	enable: true,

	/**
	 * Minimal retry interval in milliseconds
	 * @type {number}
	 */
	minRetryInterval: 2000,

	/**
	 * Maximal retry interval in milliseconds
	 * @type {number}
	 */
	maxRetryInterval: 20000,

	/**
	 * @type {number}
	 */
	_tryReconnectNumber: 0,

	init: function() {
		this.comet.on(Jii.comet.client.Client.EVENT_OPEN, this._onOpen.bind(this));
		this.comet.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_CLOSE, this._onClose.bind(this));
	},

	_onOpen: function() {
		this._tryReconnectNumber = 0;
	},

	_onClose: function() {
		if (this.enable && !this.comet.isForceClosed()) {
			setTimeout(function() {
				this._tryReconnectNumber++;
				this.comet.open();
			}.bind(this), this._tryReconnectNumber > 10 ? this.maxRetryInterval : this.minRetryInterval);
		}
	}

});
},{"./PluginInterface":26,"jii":124}],26:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.plugin.PluginInterface
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.comet.client.plugin.PluginInterface', /** @lends Jii.comet.client.plugin.PluginInterface.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {Jii.comet.client.Client}
	 */
	comet: null

});
},{"jii":124}],27:[function(require,module,exports){
(function (global){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

// sockjs global fix: sockjs expect that global object is equal window, but it is not always, for example in node-webkit
if (typeof global !== 'undefined' && typeof window !== 'undefined' && global !== window) {
    var usedWindowKeys = ['document', 'location', 'XMLHttpRequest', 'EventSource', 'WebSocket', 'MozWebSocket',
        'XDomainRequest', 'crypto', 'navigator', 'chrome', 'addEventListener', 'attachEvent',
        'removeEventListener', 'detachEvent', 'parent', 'postMessage', 'console'];
    Jii._.each(usedWindowKeys, function(key) {
        global[key] = window[key];
    });
}
// @todo jsonp callbacks

var SockJS = require('sockjs-client');

/**
 * @class Jii.comet.client.transport.Sockjs
 * @extends Jii.comet.client.transport.TransportInterface
 */
Jii.defineClass('Jii.comet.client.transport.Sockjs', /** @lends Jii.comet.client.transport.Sockjs.prototype */{

	__extends: Jii.comet.client.transport.TransportInterface,

    /**
     * Available:
     * - websocket
     * - xdr-polling
     * - xdr-streaming
     * - xhr-polling
     * - xhr-streaming
     * - eventsource
     * - htmlfile
     * - iframe
     * - jsonp-polling
     */
    transports: null,

	/**
	 * @type {SockJS}
	 */
	_websocket: null,

	/**
	 * Open connection
	 * @param {string} url
	 */
	open: function(url) {
		this._websocket = new SockJS(url, null, {
			//debug: HelpOnClick.debug,
            transports: this.transports
		});

		this._websocket.onopen = this._onOpen.bind(this);
		this._websocket.onmessage = this._onMessage.bind(this);
		this._websocket.onclose = this._onClose.bind(this);
	},

	/**
	 * Close connection
	 */
	close: function() {
		if (this._websocket) {
			this._websocket.close();
			this._websocket = null;
		}
	},

	/**
	 * Send message to server
	 * @param {string} message
	 */
	send: function(message) {
		if (this._websocket) {
			this._websocket.send(message);
		}
	},

	_onOpen: function() {
		this.trigger(this.__static.EVENT_OPEN, new Jii.base.Event());
	},

	_onClose: function(errorEvent) {
		this.trigger(this.__static.EVENT_CLOSE, new Jii.base.Event());
	},

	_onMessage: function (event) {
		if (event.type === 'message') {
			this.trigger(this.__static.EVENT_MESSAGE, new Jii.comet.client.MessageEvent({
				message: event.data
			}));
		}
	}

});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"jii":124,"sockjs-client":31}],28:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.transport.TransportInterface
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.comet.client.transport.TransportInterface', /** @lends Jii.comet.client.transport.TransportInterface.prototype */{

	__extends: Jii.base.Component,

	__static: /** @lends Jii.comet.client.transport.TransportInterface */{

		/**
		 * @event Jii.comet.client.transport.TransportInterface#open
		 * @property {Jii.base.Event} event
		 */
		EVENT_OPEN: 'open',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#close
		 * @property {Jii.base.Event} event
		 */
		EVENT_CLOSE: 'close',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#message
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_MESSAGE: 'message',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#log
		 * @property {Jii.comet.client.LogMessageEvent} event
		 */
		EVENT_LOG: 'log'

	},

	/**
	 * Open connection
	 * @param {string} url
	 */
	open: function(url) {
	},

	/**
	 * Close connection
	 */
	close: function() {
	},

	/**
	 * Send message to server
	 * @param {string} message
	 */
	send: function(message) {
	}

});
},{"jii":124}],29:[function(require,module,exports){
require('./index-client');
require('./lib/client/NeatClient');
},{"./index-client":17,"./lib/client/NeatClient":23}],30:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],31:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./main":44,"./transport-list":46}],32:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":34,"inherits":87}],33:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function(type) {
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  var args = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":35,"inherits":87}],34:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault  = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET       = 2;
Event.BUBBLING_PHASE  = 3;

module.exports = Event;

},{}],35:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function(event) {
  var t = event.type;
  var args = Array.prototype.slice.call(arguments, 0);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],36:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":34,"inherits":87}],37:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":77,"json3":88}],38:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatibile SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,require('_process'))
},{"./facade":37,"./info-iframe-receiver":40,"./location":43,"./utils/event":76,"./utils/iframe":77,"./utils/url":82,"_process":30,"debug":84,"json3":88}],39:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,require('_process'))
},{"./utils/object":79,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":39,"./transport/sender/xhr-local":67,"events":33,"inherits":87,"json3":88}],41:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./info-iframe-receiver":40,"./transport/iframe":52,"./utils/event":76,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],42:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,require('_process'))
},{"./info-ajax":39,"./info-iframe":41,"./transport/sender/xdr":64,"./transport/sender/xhr-cors":65,"./transport/sender/xhr-fake":66,"./transport/sender/xhr-local":67,"./utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],43:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],44:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  // Make debug module available globally so you can enable via the console easily
  global.dbg = require('debug');
  debug = global.dbg('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError("If sessionId is used in the options, it needs to be a number or a function.");
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event/close":32,"./event/event":34,"./event/eventtarget":35,"./event/trans-message":36,"./iframe-bootstrap":38,"./info-receiver":42,"./location":43,"./shims":45,"./utils/browser":74,"./utils/escape":75,"./utils/event":76,"./utils/log":78,"./utils/object":79,"./utils/random":80,"./utils/transport":81,"./utils/url":82,"./version":83,"_process":30,"debug":84,"inherits":87,"json3":88,"url-parse":89}],45:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ES5 15.5.4.20
// whitespace from: http://es5.github.io/#x15.5.4.20
var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
    '\u2029\uFEFF';
var zeroWidth = '\u200b';
var wsRegexChars = '[' + ws + ']';
var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
defineProperties(StringPrototype, {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    trim: function trim() {
        if (this === void 0 || this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
    }
}, hasTrimWhitespaceBug);

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],46:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":50,"./transport/htmlfile":51,"./transport/jsonp-polling":53,"./transport/lib/iframe-wrap":56,"./transport/websocket":68,"./transport/xdr-polling":69,"./transport/xdr-streaming":70,"./transport/xhr-polling":71,"./transport/xhr-streaming":72}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {}

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = 'true';
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {}
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {}
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/event":76,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],48:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(require,module,exports){
(function (global){
module.exports = global.WebSocket || global.MozWebSocket;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],50:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":54,"./receiver/eventsource":59,"./sender/xhr-cors":65,"eventsource":48,"inherits":87}],51:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":54,"./receiver/htmlfile":60,"./sender/xhr-local":67,"inherits":87}],52:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {}
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,require('_process'))
},{"../utils/event":76,"../utils/iframe":77,"../utils/random":80,"../utils/url":82,"../version":83,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],53:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/sender-receiver":58,"./receiver/jsonp":61,"./sender/jsonp":63,"inherits":87}],54:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type':'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,require('_process'))
},{"../../utils/url":82,"./sender-receiver":58,"_process":30,"debug":84,"inherits":87}],55:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self._cleanup();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.stop = function() {
  debug('stop');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],56:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/object":79,"../iframe":52,"inherits":87}],57:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],58:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
  this.stop();
};

module.exports = SenderReceiver;

}).call(this,require('_process'))
},{"../../utils/url":82,"./buffered-sender":55,"./polling":57,"_process":30,"debug":84,"inherits":87}],59:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"eventsource":48,"inherits":87}],60:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {}
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/iframe":77,"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],61:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {}
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {}
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/browser":74,"../../utils/iframe":77,"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],62:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],63:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84}],64:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {}
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/browser":74,"../../utils/event":76,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],65:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":47,"inherits":87}],66:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":33,"inherits":87}],67:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":47,"inherits":87}],68:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  if (this.ws) {
    this.ws.close();
  }
  this._cleanup();
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,require('_process'))
},{"../utils/event":76,"../utils/url":82,"./driver/websocket":49,"_process":30,"debug":84,"events":33,"inherits":87}],69:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xdr":64,"./xdr-streaming":70,"inherits":87}],70:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xdr":64,"inherits":87}],71:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xhr-cors":65,"./sender/xhr-local":67,"inherits":87}],72:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils/browser":74,"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xhr-cors":65,"./sender/xhr-local":67,"inherits":87}],73:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],74:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],75:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":88}],76:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./random":80}],77:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {}
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {}
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* jshint undef: false, newcap: false */
/* eslint no-undef: 0, new-cap: 0 */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r)  {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {}
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./browser":74,"./event":76,"_process":30,"debug":84,"json3":88}],78:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists = global.console && global.console[level] && global.console[level].apply;
  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],79:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],80:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":73}],81:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,require('_process'))
},{"_process":30,"debug":84}],82:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,require('_process'))
},{"_process":30,"debug":84,"url-parse":89}],83:[function(require,module,exports){
module.exports = '1.0.3';
},{}],84:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":85}],85:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":86}],86:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],87:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],88:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],89:[function(require,module,exports){
'use strict';

var required = require('requires-port')
  , lolcation = require('./lolcation')
  , qs = require('querystringify')
  , relativere = /^\/(?!\/)/;

/**
 * These are the parse instructions for the URL parsers, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var instructions = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['//', 'protocol', 2, 1, 1],          // Extract from the front.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/\:(\d+)$/, 'port'],                 // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my CDO.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Boolean|function} parser Parser for the query string.
 * @param {Object} location Location defaults for relative paths.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative = relativere.test(address)
    , parse, instruction, index, key
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) {
    parser = qs.parse;
  }

  location = lolcation(location);

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse.exec(address)) {
      url[key] = index[1];
      address = address.slice(0, address.length - index[0].length);
    }

    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) {
      url[key] = url[key].toLowerCase();
    }
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} prop Property we need to adjust.
 * @param {Mixed} value The newly assigned value.
 * @returns {URL}
 * @api public
 */
URL.prototype.set = function set(part, value, fn) {
  var url = this;

  if ('query' === part) {
    if ('string' === typeof value && value.length) {
      value = (fn || qs.parse)(value);
    }

    url[part] = value;
  } else if ('port' === part) {
    url[part] = value;

    if (!required(value, url.protocol)) {
      url.host = url.hostname;
      url[part] = '';
    } else if (value) {
      url.host = url.hostname +':'+ value;
    }
  } else if ('hostname' === part) {
    url[part] = value;

    if (url.port) value += ':'+ url.port;
    url.host = value;
  } else if ('host' === part) {
    url[part] = value;

    if (/\:\d+/.test(value)) {
      value = value.split(':');
      url.hostname = value[0];
      url.port = value[1];
    }
  } else {
    url[part] = value;
  }

  url.href = url.toString();
  return url;
};

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
URL.prototype.toString = function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , result = url.protocol +'//';

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.hostname;
  if (url.port) result += ':'+ url.port;

  result += url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
};

//
// Expose the URL parser and some additional properties that might be useful for
// others.
//
URL.qs = qs;
URL.location = lolcation;
module.exports = URL;

},{"./lolcation":90,"querystringify":91,"requires-port":92}],90:[function(require,module,exports){
(function (global){
'use strict';

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as the a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 }
  , URL;

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
module.exports = function lolcation(loc) {
  loc = loc || global.location || {};
  URL = URL || require('./');

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) for (key in loc) {
    if (key in ignore) continue;
    finaldestination[key] = loc[key];
  }

  return finaldestination;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./":89}],91:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],92:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 22;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],93:[function(require,module,exports){
require('./index-client');
require('./lib/client/transport/Sockjs');
},{"./index-client":17,"./lib/client/transport/Sockjs":27}],94:[function(require,module,exports){
require('jii/deps');
require('jii-comet/sockjs');
require('jii-comet/neat');
require('jii-ar-sql');

var app = Jii.namespace('app');

require('../models/DemoRow');

$(function () {

    Jii.createWebApplication(Jii.mergeConfigs({
        application: {
            basePath: '/',
            components: {
                /**
                 * @name Jii.app.comet
                 * @type {Jii.comet.client.Client}
                 */
                comet: {
                    className: 'Jii.comet.client.Client',
                    serverUrl: 'http://127.0.0.1:3100/stat/node-comet/0/'
                },

                /**
                 * @name Jii.app.neat
                 * @type {Jii.comet.client.NeatClient}
                 */
                neat: {
                    className: 'Jii.comet.client.NeatClient',
                    engine: {
                        className: 'NeatComet.NeatCometClient'
                    }
                },

                /**
                 * @name Jii.app.db
                 * @type {Jii.sql.remote.Connection}
                 */
                db: {
                    className: 'Jii.sql.remote.Connection',
                    schema: {
                        className: 'Jii.sql.remote.Schema'
                    }
                }
            }
        }
    }, window.JII_CONFIG)).start();

    var profile = Jii.app.neat.openProfile('test', {
        category: 'n',
        filter: 'nn'
    });

    profile.getCollection('all').on(Jii.base.Collection.EVENT_CHANGE, function (event) {
        Jii._.each(event.added, function (model) {
            $('' +
                '<tr data-id="' + model.get('id') + '">' +
                '<td>' + model.get('id') + '</td>' +
                '<td><input class="form-control" value="' + model.get('subject') + '" /></td>' +
                '<td>' + model.get('kind') + '</td>' +
                '<td>' + model.get('category') + '</td>' +
                '<td><a href="#" class="btn-remove">x</a></td>' +
                '</tr>'
            )
                .appendTo($('#demo-rows tbody'))
                .on('click', 'a.btn-remove', function (e) {
                    e.preventDefault();
                    model.delete();
                });
        });
        Jii._.each(event.removed, function (model) {
            $('#demo-rows tbody').find('[data-id=' + model.get('id') + ']').remove();
        });
    });

    var form = $('#demo-form');

    var randValues = function () {
        form.find('[name=subject]').val(Jii._.random(1, 100));
        form.find('[name=category]').val(Jii._.random(1, 9));
        form.find('[name=kind]').val(Jii._.random(1, 9));
    }
    randValues();

    form.on('submit', function (e) {
        e.preventDefault();

        new app.models.DemoRow({
            subject: form.find('[name=subject]').val(),
            category: form.find('[name=category]').val(),
            kind: form.find('[name=kind]').val()
        }).save();

        randValues();
    });

});
},{"../models/DemoRow":95,"jii-ar-sql":9,"jii-comet/neat":29,"jii-comet/sockjs":93,"jii/deps":123}],95:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class app.models.DemoRow
 * @extends Jii.sql.ActiveRecord
 */
Jii.defineClass('app.models.DemoRow', /** @lends app.models.DemoRow.prototype */{

	__extends: Jii.sql.ActiveRecord,

	__static: /** @lends Jii.comet.server.HubServer */{

        tableName: function () {
            return 'ep_comet_sample_demo_rows';
        }

	},

    rules: function() {
        return [
            [['subject'], 'string', {max: 255}],
            [['category', 'kind'], 'string', {max: 1}]
        ];
    }

});

},{"jii":124}],96:[function(require,module,exports){

'use strict';

require('jii');

// Load framework files
require('./lib/base/ActiveRecord');
require('./lib/base/Collection');
require('./lib/base/DataProvider');
require('./lib/base/Model');
require('./lib/base/ModelAttributeSchema');
require('./lib/base/ModelSchema');
require('./lib/model/ArrayDataProvider');
require('./lib/model/ChangeAttributeEvent');
require('./lib/model/ChangeEvent');
require('./lib/model/CollectionEvent');
require('./lib/model/LinkModelEvent');
require('./lib/validators/BooleanValidator');
require('./lib/validators/CompareValidator');
require('./lib/validators/DateValidator');
require('./lib/validators/DefaultValueValidator');
require('./lib/validators/EmailValidator');
require('./lib/validators/FilterValidator');
require('./lib/validators/InlineValidator');
require('./lib/validators/NumberValidator');
require('./lib/validators/RangeValidator');
require('./lib/validators/RegularExpressionValidator');
require('./lib/validators/RequiredValidator');
require('./lib/validators/SafeValidator');
require('./lib/validators/StringValidator');
require('./lib/validators/UrlValidator');
require('./lib/validators/Validator');
},{"./lib/base/ActiveRecord":97,"./lib/base/Collection":98,"./lib/base/DataProvider":99,"./lib/base/Model":100,"./lib/base/ModelAttributeSchema":101,"./lib/base/ModelSchema":102,"./lib/model/ArrayDataProvider":103,"./lib/model/ChangeAttributeEvent":104,"./lib/model/ChangeEvent":105,"./lib/model/CollectionEvent":106,"./lib/model/LinkModelEvent":107,"./lib/validators/BooleanValidator":108,"./lib/validators/CompareValidator":109,"./lib/validators/DateValidator":110,"./lib/validators/DefaultValueValidator":111,"./lib/validators/EmailValidator":112,"./lib/validators/FilterValidator":113,"./lib/validators/InlineValidator":114,"./lib/validators/NumberValidator":115,"./lib/validators/RangeValidator":116,"./lib/validators/RegularExpressionValidator":117,"./lib/validators/RequiredValidator":118,"./lib/validators/SafeValidator":119,"./lib/validators/StringValidator":120,"./lib/validators/UrlValidator":121,"./lib/validators/Validator":122,"jii":124}],97:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Model');

/**
 * @abstract
 * @class Jii.base.ActiveRecord
 * @extends Jii.base.Model
 */
Jii.defineClass('Jii.base.ActiveRecord', /** @lends Jii.base.ActiveRecord.prototype */{

	__extends: Jii.base.Model,
	
	__static: /** @lends Jii.base.ActiveRecord */{

        /**
         * @event Jii.base.ActiveRecord#init
         * @property {Jii.base.Event} event an event that is triggered when the record is initialized via [[init()]].
         */
		EVENT_INIT: 'init',

        /**
         * @event Jii.base.ActiveRecord#afterFind
         * @property {Jii.base.Event} event an event that is triggered after the record is created and populated with query result.
         */
		EVENT_AFTER_FIND: 'afterFind',

        /**
         * You may set [[Jii.base.ModelEvent.isValid]] to be false to stop the insertion.
         * @event Jii.base.ActiveRecord#beforeInsert
         * @property {Jii.base.ModelEvent} event an event that is triggered before inserting a record.
         */
		EVENT_BEFORE_INSERT: 'beforeInsert',

        /**
         * Event an event that is triggered after a record is inserted.
         * @event Jii.base.ActiveRecord#afterInsert
         * @property {Jii.sql.AfterSaveEvent} event
         */
		EVENT_AFTER_INSERT: 'afterInsert',

        /**
         * You may set [[ModelEvent.isValid]] to be false to stop the update.
         * @event Jii.base.ActiveRecord#beforeUpdate
         * @property {Jii.base.ModelEvent} event an event that is triggered before updating a record.
         */
		EVENT_BEFORE_UPDATE: 'beforeUpdate',

        /**
         * @event Jii.base.ActiveRecord#afterUpdate
         * @property {Jii.sql.AfterSaveEvent} event an event that is triggered after a record is updated.
         */
		EVENT_AFTER_UPDATE: 'afterUpdate',

		/**
         * You may set [[ModelEvent.isValid]] to be false to stop the deletion.
         * @event Jii.base.ActiveRecord#beforeDelete
		 * @property {Jii.base.ModelEvent} event an event that is triggered before deleting a record.
		 */
		EVENT_BEFORE_DELETE: 'beforeDelete',

		/**
         * @event Jii.base.ActiveRecord#afterDelete
		 * @property {Jii.base.Event} event an event that is triggered after a record is deleted.
		 */
		EVENT_AFTER_DELETE: 'afterDelete',

        /**
         * @event Jii.base.ActiveRecord#link
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_LINK: 'link',

        /**
         * @event Jii.base.ActiveRecord#link:
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_LINK_NAME: 'link:',

        /**
         * @event Jii.base.ActiveRecord#unlink
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_UNLINK: 'unlink',

        /**
         * @event Jii.base.ActiveRecord#unlink:
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_UNLINK_NAME: 'unlink:',

        _modelSchema: null,

        /**
         * @returns {{}}
         */
        modelSchema: function() {
            return {};
        },

        /**
         * @returns {Jii.sql.TableSchema}
         */
        getTableSchema: function() {
            if (this._modelSchema === null) {
                this._modelSchema = this.modelSchema();

                if (!(this._modelSchema instanceof Jii.base.ModelSchema)) {
                    this._modelSchema = Jii.base.ModelSchema.createFromObject(this._modelSchema);
                }
            }
            return this._modelSchema;
        },

        tableName: function() {
            return null;
        },

		/**
		 * @inheritdoc
		 * @returns {Jii.base.ActiveRecord} ActiveRecord instance matching the condition, or `null` if nothing matches.
		 */
		findOne: function (condition) {
			return this._findByCondition(condition, true);
		},

		/**
		 * @inheritdoc
		 * @returns {Jii.base.ActiveRecord[]} an array of ActiveRecord instances, or an empty array if nothing matches.
		 */
		findAll: function (condition) {
			return this._findByCondition(condition, false);
		},

        /**
         * @inheritdoc
         */
        find: function () {
            // @todo
            return new Jii.sql.ActiveQuery(this);
        },

        /**
         * Returns the primary key name(s) for this AR class.
         * The default implementation will return the primary key(s) as declared
         * in the DB table that is associated with this AR class.
         *
         * If the DB table does not declare any primary key, you should override
         * this method to return the attributes that you want to use as primary keys
         * for this AR class.
         *
         * Note that an array should be returned even for a table with single primary key.
         *
         * @returns {string[]} the primary keys of the associated database table.
         */
        primaryKey: function () {
            return this.getTableSchema().primaryKey;
        },

		/**
		 * Finds ActiveRecord instance(s) by the given condition.
		 * This method is internally called by [[findOne()]] and [[findAll()]].
		 * @param {*} condition please refer to [[findOne()]] for the explanation of this parameter
		 * @param {boolean} one whether this method is called by [[findOne()]] or [[findAll()]]
		 * @returns {Jii.base.ActiveRecord|Jii.base.ActiveRecord[]}
		 * @throws {Jii.exceptions.InvalidConfigException} if there is no primary key defined
		 * @internal
		 */
		_findByCondition: function (condition, one) {
			var query = this.find();

			return Promise.resolve().then(function() {
				if (Jii._.isArray(condition) || Jii._.isObject(condition)) {
					return Promise.resolve(condition);
				}

				var primaryKey = this.primaryKey();

				// query by primary key
				if (primaryKey.length > 0) {
					var pk = primaryKey[0];
					if (!Jii._.isEmpty(query.getJoin()) || !Jii._.isEmpty(query.getJoinWith())) {
						pk = this.tableName() + '.' + pk;
					}

					var conditionObject = {};
					conditionObject[pk] = condition;
					return conditionObject;
				}

				throw new Jii.exceptions.InvalidConfigException(this.className() + ' must have a primary key.');
			}.bind(this)).then(function(condition) {
				query.andWhere(condition);

				return one ? query.one() : query.all();
			}.bind(this));
		},

		/**
		 * Updates the whole table using the provided attribute values and conditions.
		 * For example, to change the status to be 1 for all customers whose status is 2:
		 *
		 * ~~~
		 * Customer.updateAll({status: 1}, 'status = 2');
		 * ~~~
		 *
		 * @param {object} attributes attribute values (name-value pairs) to be saved into the table
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @returns {Promise.<number>} the number of rows updated
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		updateAll: function (attributes, condition) {
			condition = condition || '';

			throw new Jii.exceptions.NotSupportedException('updateAll() is not supported.');
		},

		/**
		 * Updates the whole table using the provided counter changes and conditions.
		 * For example, to increment all customers' age by 1,
		 *
		 * ~~~
		 * Customer.updateAllCounters({age: 1});
		 * ~~~
		 *
		 * @param {[]} counters the counters to be updated (attribute name => increment value).
		 * Use negative values if you want to decrement the counters.
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @returns {number} the number of rows updated
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		updateAllCounters: function (counters, condition) {
			condition = condition || '';

			throw new Jii.exceptions.NotSupportedException('updateAllCounters() is not supported.');
		},

		/**
		 * Deletes rows in the table using the provided conditions.
		 * WARNING: If you do not specify any condition, this method will delete ALL rows in the table.
		 *
		 * For example, to delete all customers whose status is 3:
		 *
		 * ~~~
		 * Customer.deleteAll('status = 3');
		 * ~~~
		 *
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the DELETE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {[]} [params] the parameters (name => value) to be bound to the query.
		 * @returns {number} the number of rows deleted
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		deleteAll: function (condition, params) {
			condition = condition || '';
			params = params || [];

			throw new Jii.exceptions.NotSupportedException('deleteAll() is not supported.');
		},

		/**
		 * Populates an active record object using a row of data from the database/storage.
		 *
		 * This is an internal method meant to be called to create active record objects after
		 * fetching data from the database. It is mainly used by [[ActiveQuery]] to populate
		 * the query results into active records.
		 *
		 * When calling this method manually you should call [[afterFind()]] on the created
		 * record to trigger the [[EVENT_AFTER_FIND|afterFind Event]].
		 *
		 * @param {Jii.base.ActiveRecord} record the record to be populated. In most cases this will be an instance
		 * created by [[instantiate()]] beforehand.
		 * @param {object} row attribute values (name => value)
		 */
		populateRecord: function (record, row) {
			var columns = record.attributes();

			Jii._.each(row, Jii._.bind(function(value, name) {
				if (Jii._.indexOf(columns, name) !== -1) {
					record._attributes[name] = value;
				} else if (record.canSetProperty(name)) {
					record.set(name, value);
				}
			}, this));
			record.setOldAttributes(Jii._.clone(record._attributes));
		},

		/**
		 * Creates an active record instance.
		 *
		 * This method is called together with [[populateRecord()]] by [[ActiveQuery]].
		 * It is not meant to be used for creating new records() directly.
		 *
		 * You may override this method if the instance being created
		 * depends on the row data to be populated into the record.
		 * For example, by creating a record based on the value of a column,
		 * you may implement the so-called single-table inheritance mapping.
		 * @param {object} row row data to be populated into the record.
		 * @returns {Jii.base.ActiveRecord} the newly created active record
		 */
		instantiate: function (row) {
			return new this();
		},

		/**
		 * Returns a value indicating whether the given set of attributes represents the primary key for this model
		 * @param {[]} keys the set of attributes to check
		 * @returns {boolean} whether the given set of attributes represents the primary key for this model
		 */
		isPrimaryKey: function (keys) {
			var pks = this.primaryKey();

			if (keys.length !== Jii._.size(pks)) {
				return false;
			}
            return (!Jii._.isArray(pks) ? Jii._.keys(pks) : pks).sort().toString() === keys.sort().toString();
		}

	},

	/**
	 * @type {object} related models indexed by the relation names
	 */
	_related: {},

	/**
	 * @type {object}
	 */
	_relatedLazyEvents: {},

	/**
	 * @type {object|null} old attribute values indexed by attribute names.
	 * This is `null` if the record [[isNewRecord|is new]].
	 */
	_oldAttributes: null,

	/**
	 * Initializes the object.
	 * This method is called at the end of the constructor.
	 * The default implementation will trigger an [[EVENT_INIT]] event.
	 * If you override this method, make sure you call the parent implementation at the end
	 * to ensure triggering of the event.
	 */
	init: function () {
		this.trigger(this.__static.EVENT_INIT);

		this.__super();
	},

	/**
	 * Declares a `has-one` relation.
	 * The declaration is returned in terms of a relational [[ActiveQuery]] instance
	 * through which the related record can be queried and retrieved back.
	 *
	 * A `has-one` relation means that there is at most one related record matching
	 * the criteria set by this relation, e.g., a customer has one country.
	 *
	 * For example, to declare the `country` relation for `Customer` class, we can write
	 * the following code in the `Customer` class:
	 *
	 * ~~~
	 * public function getCountry()
	 * {
     *     return this.hasOne(Country.className(), {id: 'country_id'});
     * }
	 * ~~~
	 *
	 * Note that in the above, the 'id' key in the `link` parameter refers to an attribute name
	 * in the related class `Country`, while the 'country_id' value refers to an attribute name
	 * in the current AR class.
	 *
	 * Call methods declared in [[ActiveQuery]] to further customize the relation.
	 *
	 * @param {string} className the class name of the related record
	 * @param {object} link the primary-foreign key constraint. The keys of the array refer to
	 * the attributes of the record associated with the `class` model, while the values of the
	 * array refer to the corresponding attributes in **this** AR class.
	 * @returns {Jii.sql.ActiveQuery} the relational query object.
	 */
	hasOne: function (className, link) {
		/** @typedef {Jii.sql.ActiveRecord} classObject */
		var classObject = Jii.namespace(className);

		/** @typedef {Jii.data.ActiveQuery} query */
		var query = classObject.find();
		query.primaryModel = this;
		query.link = link;
		query.multiple = false;
		return query;
	},

	/**
	 * Declares a `has-many` relation.
	 * The declaration is returned in terms of a relational [[ActiveQuery]] instance
	 * through which the related record can be queried and retrieved back.
	 *
	 * A `has-many` relation means that there are multiple related records matching
	 * the criteria set by this relation, e.g., a customer has many orders.
	 *
	 * For example, to declare the `orders` relation for `Customer` class, we can write
	 * the following code in the `Customer` class:
	 *
	 * ~~~
	 * public function getOrders()
	 * {
		 *     return this.hasMany(Order.className(), {customer_id: 'id'});
		 * }
	 * ~~~
	 *
	 * Note that in the above, the 'customer_id' key in the `link` parameter refers to
	 * an attribute name in the related class `Order`, while the 'id' value refers to
	 * an attribute name in the current AR class.
	 *
	 * Call methods declared in [[ActiveQuery]] to further customize the relation.
	 *
	 * @param {string} className the class name of the related record
	 * @param {object} link the primary-foreign key constraint. The keys of the array refer to
	 * the attributes of the record associated with the `class` model, while the values of the
	 * array refer to the corresponding attributes in **this** AR class.
	 * @returns {Jii.sql.ActiveQuery} the relational query object.
	 */
	hasMany: function (className, link) {
		/** @type {class} ActiveRecordInterface */
		var classObject = Jii.namespace(className);

		/** @type {Jii.sql.ActiveQuery} */
		var query = classObject.find();
		query.primaryModel = this;
		query.link = link;
		query.multiple = true;
		return query;
	},

	load: function(name) {
		if (this._related[name]) {
			return Promise.resolve(this._related[name]);
		}

		var relation = this.getRelation(name);
		if (relation instanceof Jii.sql.ActiveQuery) {
			return relation.findFor(name, this).then(function(models) {
                this._setRelated(name, relation.multiple ? new Jii.base.Collection(models, {modelClass: relation.modelClass}) : models);
				return this._related[name];
			}.bind(this));
		}

		return relation;
	},

	/**
	 * Populates the named relation with the related records.
	 * Note that this method does not check if the relation exists or not.
	 * @param {string} name the relation name (case-sensitive)
	 * @param {Jii.base.ActiveRecord|Jii.base.ActiveRecord[]|null} records the related records to be populated into the relation.
	 */
	populateRelation: function (name, records) {
        this._setRelated(name, Jii._.isArray(records) ? new Jii.base.Collection(records) : records);
	},

	/**
	 * Check whether the named relation has been populated with records.
	 * @param {string} name the relation name (case-sensitive)
	 * @returns {boolean} whether relation has been populated with records.
	 */
	isRelationPopulated: function (name) {
		return Jii._.has(this._related, name);
	},

	/**
	 * Returns all populated related records.
	 * @returns {object} an array of related records indexed by relation names.
	 */
	getRelatedRecords: function () {
		return this._related;
	},

    /**
     * Get attribute value
     * @param {String} name
     * @returns {*}
     */
    get: function (name) {
        if (this.hasRelation(name)) {
            var relation = this.getRelation(name);
            if (!this._related[name] && relation.multiple) {
                this._setRelated(name, new Jii.base.Collection([], {modelClass: relation.modelClass}));
            }
            return this._related[name] || null;
        }

        return this.__super(name);
    },

    /**
     * Set attribute value
     * @param {object|string} name
     * @param {*} [value]
     */
    set: function (name, value) {
        if (this.hasRelation(name)) {
            if (this._related[name]) {
                this._related[name].set(value);
            } else {
                var relation = this.getRelation(name);
                if (relation.multiple) {
                    var models = !Jii._.isArray(value) ? [value] : value;
                    this._setRelated(name, new Jii.base.Collection(models, {
                        modelClass: relation.modelClass
                    }));
                } else {
                    var _class = relation.modelClass;

                    /** @typedef {Jii.sql.ActiveRecord} model */
                    var model = _class.instantiate(value);
                    _class.populateRecord(model, value);
                    this._setRelated(name, model);
                }
            }
            return;
        }

        this.__super(name, value);
    },

    /**
     * @param {string|string[]} name
     * @param {function} handler
     * @param {*} [data]
     * @param {boolean} [isAppend]
     */
    on: function(name, handler, data, isAppend) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, this.__static.EVENT_CHANGE_NAME);
        if (collectionFormat) {
            var collEventName = collectionFormat.subName || this.__static.EVENT_CHANGE;
            collectionFormat.model.on(collEventName, handler, data, isAppend);
            return;
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name, this.__static.EVENT_CHANGE_NAME);
        if (modelFormat) {
            if (modelFormat.model) {
                modelFormat.model.on(modelFormat.subName, handler, data, isAppend);
            } else {
                // Lazy subscribe
                this._relatedLazyEvents[modelFormat.name] = this._relatedLazyEvents[modelFormat.name] || [];
                this._relatedLazyEvents[modelFormat.name].push([modelFormat.subName, handler, data, isAppend]);
            }
            return;
        }

        // Relation support
        var relationFormat = this._detectKeyFormatRelation(name, this.__static.EVENT_CHANGE_NAME);
        if (relationFormat) {
            var relationEvent = relationFormat.multiple ? Jii.base.Collection.EVENT_CHANGE : this.__static.EVENT_CHANGE;
            if (relationFormat.model) {
                relationFormat.model.on(relationEvent, handler, data, isAppend);
            } else {
                // Lazy subscribe
                this._relatedLazyEvents[relationFormat.name] = this._relatedLazyEvents[relationFormat.name] || [];
                this._relatedLazyEvents[relationFormat.name].push([relationEvent, handler, data, isAppend]);
            }
        }

        this.__super(name, handler, data, isAppend);
    },

    /**
     * @param {string|string[]} name
     * @param {function} [handler]
     * @return boolean
     */
    off: function(name, handler) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, this.__static.EVENT_CHANGE_NAME);
        if (collectionFormat) {
            var collEventName = collectionFormat.subName || this.__static.EVENT_CHANGE;
            return collectionFormat.model.off(collEventName, handler);
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name, this.__static.EVENT_CHANGE_NAME);
        if (modelFormat) {
            if (modelFormat.model) {
                return modelFormat.model.off(modelFormat.subName, handler);
            } else {
                // Lazy unsubscribe
                if (this._relatedLazyEvents[modelFormat.name]) {
                    this._relatedLazyEvents[modelFormat.name] = Jii._.filter(this._relatedLazyEvents[modelFormat.name], function(arr) {
                        return arr[0] !== modelFormat.subName || arr[1] !== handler;
                    });
                }
            }
        }

        // Relation support
        var relationFormat = this._detectKeyFormatRelation(name, this.__static.EVENT_CHANGE_NAME);
        if (relationFormat) {
            var relationEvent = relationFormat.multiple ? Jii.base.Collection.EVENT_CHANGE : this.__static.EVENT_CHANGE;
            if (relationFormat.model) {
                return relationFormat.model.off(relationEvent, handler);
            } else {
                // Lazy unsubscribe
                if (this._relatedLazyEvents[relationFormat.name]) {
                    this._relatedLazyEvents[relationFormat.name] = Jii._.filter(this._relatedLazyEvents[relationFormat.name], function(arr) {
                        return arr[0] !== relationEvent || arr[1] !== handler;
                    });
                }
            }
        }

        return this.__super(name, handler);
    },

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @returns {{model: Jii.base.ActiveRecord|null, name: string}|null}
     * @protected
     */
    _detectKeyFormatRelation: function(name, prefix) {
        prefix = prefix || '';

        if (prefix && name.indexOf(prefix) !== 0) {
            return null;
        }
        name = name.substr(prefix.length);

        if (!this.hasRelation(name)) {
            return null;
        }

        var multiple = null;
        if (this._related[name]) {
            multiple = this._related[name] instanceof Jii.base.Collection;
        }
        if (multiple === null) {
            multiple = this.getRelation(name).multiple;
        }

        return {
            model: this.get(name),
            name: name,
            multiple: multiple
        };
    },

    /**
     *
     * @param {string} name
     * @param value
     * @protected
     */
    _setRelated: function(name, value) {
        this._related[name] = value;

        // Attach lazy events
        Jii._.each(this._relatedLazyEvents[name] || {}, function(args) {
            this._related[name].on.apply(this._related[name], args);
        }.bind(this));
        this.trigger(this.__static.EVENT_LINK, new Jii.model.LinkModelEvent({
            relationName: name
        }));
        this.trigger(this.__static.EVENT_LINK_NAME + name, new Jii.model.LinkModelEvent({
            relationName: name
        }));
    },

    /**
     *
     * @param {string} name
     * @protected
     */
    _removeRelated: function(name) {
        delete this._related[name];

        this.trigger(this.__static.EVENT_UNLINK, new Jii.model.LinkModelEvent({
            relationName: name
        }));
        this.trigger(this.__static.EVENT_UNLINK_NAME + name, new Jii.model.LinkModelEvent({
            relationName: name
        }));
    },

	/**
	 *
	 * @param {string} name
	 * @returns {boolean}
	 */
	hasAttribute: function (name) {
		return Jii._.has(this._attributes, name) || Jii._.indexOf(this.attributes(), name) !== -1;
	},

	/**
	 * Returns the old attribute values.
	 * @returns {object} the old attribute values (name-value pairs)
	 */
	getOldAttributes: function () {
		return this._oldAttributes || {};
	},

	/**
	 * Sets the old attribute values.
	 * All existing old attribute values will be discarded.
	 * @param {{}|null} values old attribute values to be set.
	 * If set to `null` this record is considered to be [[isNewRecord|new]].
	 */
	setOldAttributes: function (values) {
		this._oldAttributes = values;
	},

	/**
	 * Returns the old value of the named attribute.
	 * If this record is the result of a query and the attribute is not loaded,
	 * null will be returned.
	 * @param {string} name the attribute name
	 * @returns {*} the old attribute value. Null if the attribute is not loaded before
	 * or does not exist.
	 * @see hasAttribute()
	 */
	getOldAttribute: function (name) {
		return Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
	},

	/**
	 * Sets the old value of the named attribute.
	 * @param {string} name the attribute name
	 * @param {*} value the old attribute value.
	 * @throws {Jii.exceptions.InvalidParamException} if the named attribute does not exist.
	 * @see hasAttribute()
	 */
	setOldAttribute: function (name, value) {
		if (Jii._.has(this._oldAttributes, name) || this.hasAttribute(name)) {
			if (this._oldAttributes === null) {
				this._oldAttributes = {};
			}
			this._oldAttributes[name] = value;
		}

		throw new Jii.exceptions.InvalidParamException(this.className() + ' has no attribute named "' + name + '".');
	},

	/**
	 * Marks an attribute dirty.
	 * This method may be called to force updating a record when calling [[update()]],
	 * even if there is no change being made to the record.
	 * @param {string} name the attribute name
	 */
	markAttributeDirty: function (name) {
		delete this._oldAttributes[name];
	},

	/**
	 * Returns a value indicating whether the named attribute has been changed.
	 * @param {string} name the name of the attribute
	 * @returns {boolean} whether the attribute has been changed
	 */
	isAttributeChanged: function (name) {
		if (Jii._.has(this._attributes, name) && this._oldAttributes && Jii._.has(this._oldAttributes, name)) {
			return !Jii._.isEqual(this._attributes[name], this._oldAttributes[name]);
		}

		return Jii._.has(this._attributes, name) || (this._oldAttributes && Jii._.has(this._oldAttributes, name));
	},

	/**
	 * Returns the attribute values that have been modified since they are loaded or saved most recently.
	 * @param {string[]|null} names the names of the attributes whose values may be returned if they are
	 * changed recently. If null, [[attributes()]] will be used.
	 * @returns {object} the changed attribute values (name-value pairs)
	 */
	getDirtyAttributes: function (names) {
		names = names || null;

		if (names === null) {
			names = this.attributes();
		}

		var attributes = {};
		Jii._.each(this._attributes, Jii._.bind(function(value, name) {
			if (Jii._.indexOf(names, name) === -1) {
				return;
			}

			if (this._oldAttributes === null || !Jii._.has(this._oldAttributes, name) || !Jii._.isEqual(this._oldAttributes[name], value)) {
				attributes[name] = value;
			}
		}, this));

		return attributes;
	},


	/**
	 * Returns the list of all attribute names of the model.
	 * The default implementation will return all column names of the table associated with this AR class.
	 * @return {string[]} list of attribute names.
	 */
	attributes: function() {
		return Jii._.keys(this.__static.getTableSchema().columns);
	},

	/**
	 * Saves the current record.
	 *
	 * This method will call [[insert()]] when [[isNewRecord]] is true, or [[update()]]
	 * when [[isNewRecord]] is false.
	 *
	 * For example, to save a customer record:
	 *
	 * ~~~
	 * customer = new Customer();  // or customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.save();
	 * ~~~
	 *
	 *
	 * @param {boolean} [runValidation] whether to perform validation before saving the record.
	 * If the validation fails, the record will not be saved to database.
	 * @param {string[]} [attributeNames] list of attribute names that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the saving succeeds
	 */
	save: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		if (this.isNewRecord()) {
			return this.insert(runValidation, attributeNames);
		} else {
			return this.update(runValidation, attributeNames).then(function(result) {
				return result !== false;
			});
		}
	},

	/**
	 * Inserts the record into the database using the attribute values of this record.
	 *
	 * Usage example:
	 *
	 * ```php
	 * $customer = new Customer;
	 * $customer->name = $name;
	 * $customer->email = $email;
	 * $customer->insert();
	 * ```
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {object} attributeNames list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @return boolean whether the attributes are valid and the record is inserted successfully.
	 */
	insert: function (runValidation, attributeNames) {

	},

	/**
	 * Saves the changes to this active record into the associated database table.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. save the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_UPDATE]], [[EVENT_AFTER_UPDATE]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be saved into database.
	 *
	 * For example, to update a customer record:
	 *
	 * ~~~
	 * customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.update();
	 * ~~~
	 *
	 * Note that it is possible the update does not affect any row in the table.
	 * In this case, this method will return 0. For this reason, you should use the following
	 * code to check if update() is successful or not:
	 *
	 * ~~~
	 * if (this.update() !== false) {
     *     // update successful
     * } else {
     *     // update failed
     * }
	 * ~~~
	 *
	 * @param {boolean} [runValidation] whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {string[]} [attributeNames] list of attribute names that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {Promise.<number|boolean>} the number of rows affected, or false if validation fails
	 * or [[beforeSave()]] stops the updating process.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being updated is outdated.
	 * @throws \Exception in case update failed.
	 */
	update: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		var validatePromise = runValidation ? this.validate(attributeNames) : Promise.resolve(true);
		return validatePromise.then(Jii._.bind(function(isValid) {
			if (!isValid) {
				return false;
			}

			return this._updateInternal(attributeNames);
		}, this));
	},

	/**
	 * Updates the specified attributes.
	 *
	 * This method is a shortcut to [[update()]] when data validation is not needed
	 * and only a small set attributes need to be updated.
	 *
	 * You may specify the attributes to be updated as name list or name-value pairs.
	 * If the latter, the corresponding attribute values will be modified accordingly.
	 * The method will then save the specified attributes into database.
	 *
	 * Note that this method will **not** perform data validation and will **not** trigger events.
	 *
	 * @param {[]} attributes the attributes (names or name-value pairs) to be updated
	 * @returns {Promise.<number>} the number of rows affected.
	 */
	updateAttributes: function (attributes) {
		var attrs = [];
		Jii._.each(attributes, Jii._.bind(function(value, name) {
			if (Jii._.isNumber(name)) {
				attrs.push(value);
			} else {
				this.set(name, value);
				attrs.push(name);
			}
		}, this));

		var values = this.getDirtyAttributes(attrs);
		if (Jii._.isEmpty(values)) {
			return Promise.resolve(0);
		}

		var oldPrimaryKey = this.getOldPrimaryKey(true);

		return this.__static.updateAll(values, oldPrimaryKey)
			.then(Jii._.bind(function(rows) {
				Jii._.each(values, Jii._.bind(function(value, name) {
					this._oldAttributes[name] = this._attributes[name];
				}, this));

				return rows;
			}, this));
	},

	/**
	 * @see update()
	 * @param {[]} [attributes] attributes to update
	 * @returns {Promise.<number>} number of rows updated
	 * @throws StaleObjectException
	 */
	_updateInternal: function (attributes) {
        attributes = attributes || null;

		var values = null;

		return this.beforeSave(false).then(function(bool) {
            if (!bool) {
                return Promise.resolve(false);
            }

            values = this.getDirtyAttributes(attributes);
            if (Jii._.isEmpty(values)) {
                return this.afterSave(false, values).then(function() {
                    return 0;
                });
            }

            return this.__static.getDb().createCommand().updateModel(this, values);
        }.bind(this)).then(Jii._.bind(function(rows) {

			var changedAttributes = {};
			Jii._.each(values, Jii._.bind(function(value, name) {
				changedAttributes[name] = Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
				this._oldAttributes[name] = value;
			}, this));

			return this.afterSave(false, changedAttributes).then(function() {
				return rows;
			});
		}, this));
	},

	/**
	 * Updates one or several counter columns for the current AR object.
	 * Note that this method differs from [[updateAllCounters()]] in that it only
	 * saves counters for the current AR object.
	 *
	 * An example usage is as follows:
	 *
	 * ~~~
	 * post = Post.findOne(id);
	 * post.updateCounters({view_count: 1});
	 * ~~~
	 *
	 * @param {[]} counters the counters to be updated (attribute name => increment value)
	 * Use negative values if you want to decrement the counters.
	 * @returns {boolean} whether the saving is successful
	 * @see updateAllCounters()
	 */
	updateCounters: function (counters) {
		var oldPrimaryKey = this.getOldPrimaryKey(true);
		return this.__static.updateAllCounters(Jii._.clone(counters), oldPrimaryKey)
			.then(Jii._.bind(function(affectedRows) {
				if (affectedRows === 0) {
					return Promise.resolve(false);
				}

				Jii._.each(counters, function(value, name) {
					this._attributes[name] += value;
					this._oldAttributes[name] = this._attributes[name];
				}.bind(this));
				return Promise.resolve(true);
			}, this));
	},

	/**
	 * Deletes the table row corresponding to this active record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeDelete()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 2. delete the record from the database;
	 * 3. call [[afterDelete()]].
	 *
	 * In the above step 1 and 3, events named [[EVENT_BEFORE_DELETE]] and [[EVENT_AFTER_DELETE]]
	 * will be raised by the corresponding methods.
	 *
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being deleted is outdated.
	 * @throws \Exception in case delete failed.
	 */
	delete: function () {
		return this.beforeDelete().then(Jii._.bind(function(bool) {
			if (!bool) {
				return Promise.resolve(false);
			}

			var condition = this.getOldPrimaryKey(true);

			// we do not check the return value of deleteAll() because it's possible
			// the record is already deleted in the database and thus the method will return 0
			return this.__static.deleteAll(condition);
		}, this)).then(Jii._.bind(function(result) {

			this._oldAttributes = null;

			return this.afterDelete().then(function() {
				return result;
			});
		}, this));
	},

	/**
	 * Returns a value indicating whether the current record is new.
	 * @returns {boolean} whether the record is new and() should be inserted when calling [[save()]].
	 */
	isNewRecord: function () {
		return this._oldAttributes === null;
	},

	/**
	 * Sets the value indicating whether the record is new.
	 * @param {boolean} value whether the record is new and() should be inserted when calling [[save()]].
	 * @see isNewRecord()
	 */
	setIsNewRecord: function (value) {
		this._oldAttributes = value ? null : this._attributes;
	},

	/**
	 * This method is called when the AR object is created and populated with the query result.
	 * The default implementation will trigger an [[EVENT_AFTER_FIND]] event.
	 * When overriding this method, make sure you call the parent implementation to ensure the
	 * event is triggered.
	 */
	afterFind: function () {
		this.trigger(this.__static.EVENT_AFTER_FIND);

		return Promise.resolve();
	},

	/**
	 * This method is called at the beginning of inserting or updating a record.
	 * The default implementation will trigger an [[EVENT_BEFORE_INSERT]] event when `insert` is true,
	 * or an [[EVENT_BEFORE_UPDATE]] event if `insert` is false.
	 * When overriding this method, make sure you call the parent implementation like the following:
	 *
	 * ~~~
	 * public function beforeSave(insert)
	 * {
     *     if (parent.beforeSave(insert)) {
     *         // ...custom code here...
     *         return true;
     *     } else {
     *         return false;
     *     }
     * }
	 * ~~~
	 *
	 * @param {boolean} insert whether this method called while inserting a record.
	 * If false, it means the method is called while updating a record.
	 * @returns {Promise.<boolean>} whether the insertion or updating should continue.
	 * If false, the insertion or updating will be cancelled.
	 */
	beforeSave: function (insert) {
		var event = new Jii.base.ModelEvent();
		this.trigger(insert ? this.__static.EVENT_BEFORE_INSERT : this.__static.EVENT_BEFORE_UPDATE, event);

		return Promise.resolve(event.isValid);
	},

	/**
	 * This method is called at the end of inserting or updating a record.
	 * The default implementation will trigger an [[EVENT_AFTER_INSERT]] event when `insert` is true,
	 * or an [[EVENT_AFTER_UPDATE]] event if `insert` is false. The event class used is [[AfterSaveEvent]].
	 * When overriding this method, make sure you call the parent implementation so that
	 * the event is triggered.
	 * @param {boolean} insert whether this method called while inserting a record.
	 * If false, it means the method is called while updating a record.
	 * @param {object} changedAttributes The old values of attributes that had changed and were saved.
	 * You can use this parameter to take action based on the changes made for example send an email
	 * when the password had changed or implement audit trail that tracks all the changes.
	 * `changedAttributes` gives you the old attribute values while the active record (`this`) has
	 * already the new, updated values.
	 */
	afterSave: function (insert, changedAttributes) {
		var eventName = insert ? this.__static.EVENT_AFTER_INSERT : this.__static.EVENT_AFTER_UPDATE;

		this.trigger(eventName, new Jii.sql.AfterSaveEvent({
			changedAttributes: changedAttributes
		}));

		return Promise.resolve();
	},

	/**
	 * This method is invoked before deleting a record.
	 * The default implementation raises the [[EVENT_BEFORE_DELETE]] event.
	 * When overriding this method, make sure you call the parent implementation like the following:
	 *
	 * ~~~
	 * public function beforeDelete()
	 * {
     *     if (parent.beforeDelete()) {
     *         // ...custom code here...
     *         return true;
     *     } else {
     *         return false;
     *     }
     * }
	 * ~~~
	 *
	 * @returns {boolean} whether the record should be deleted. Defaults to true.
	 */
	beforeDelete: function () {
		var event = new Jii.base.ModelEvent();
		this.trigger(this.__static.EVENT_BEFORE_DELETE, event);

		return Promise.resolve(event.isValid);
	},

	/**
	 * This method is invoked after deleting a record.
	 * The default implementation raises the [[EVENT_AFTER_DELETE]] event.
	 * You may override this method to do postprocessing after the record is deleted.
	 * Make sure you call the parent implementation so that the event is raised properly.
	 */
	afterDelete: function () {
		this.trigger(this.__static.EVENT_AFTER_DELETE);
		return Promise.resolve();
	},

	/**
	 * Repopulates this active record with the latest data.
	 * @returns {boolean} whether the row still exists in the database. If true, the latest data
	 * will be populated to this active record. Otherwise, this record will remain unchanged.
	 */
	refresh: function () {
		var primaryKey = this.getPrimaryKey(true);

		return this.__static.findOne(primaryKey).then(Jii._.bind(function(record) {
			if (record === null) {
				return Promise.resolve(false);
			}

			Jii._.each(this.attributes(), Jii._.bind(function(name) {
				this._attributes[name] = Jii._.has(record._attributes, name) ? record._attributes[name] : null;
			}, this));
			this._oldAttributes = Jii._.clone(this._attributes);

            Jii._.each(this._related, function(relation, name) {
                this._removeRelated(name);
            }.bind(this))

			return Promise.resolve(true);
		}, this));
	},

	/**
	 * Returns a value indicating whether the given active record is the same as the current one.
	 * The comparison is made by comparing the table names and the primary key values of the two active records.
	 * If one of the records [[isNewRecord|is new]] they are also considered not equal.
	 * @param {Jii.base.ActiveRecord} record record to compare to
	 * @returns {boolean} whether the two active records refer to the same row in the same database table.
	 */
	equals: function (record) {
		if (this.isNewRecord() || record.isNewRecord()) {
			return false;
		}

		if (this.className() !== record.className()) {
			return false;
		}

		return this.getPrimaryKey().toString() === record.getPrimaryKey().toString();
	},

	/**
	 * Returns the primary key value(s).
	 * @param {boolean} [asArray] whether to return the primary key value as an array. If true,
	 * the return value will be an array with column names as keys and column values as values.
	 * Note that for composite primary keys, an array will always be returned regardless of this parameter value.
	 * @property mixed The primary key value. An array (column name => column value) is returned if
	 * the primary key is composite. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 * @returns {*} the primary key value. An array (column name => column value) is returned if the primary key
	 * is composite or `asArray` is true. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 */
	getPrimaryKey: function (asArray) {
		asArray = asArray || false;

		var keys = this.__static.primaryKey();
		if (keys.length === 1 && !asArray) {
			return Jii._.has(this._attributes, keys[0]) ? this._attributes[keys[0]] : null;
		}

		var values = {};
		Jii._.each(keys, Jii._.bind(function(name) {
			values[name] = Jii._.has(this._attributes, name) ? this._attributes[name] : null;
		}, this));

		return values;
	},

	/**
	 * Returns the old primary key value(s).
	 * This refers to the primary key value that is populated into the record
	 * after executing a find method (e.g. find(), findOne()).
	 * The value remains unchanged even if the primary key attribute is manually assigned with a different value.
	 * @param {boolean} [asArray] whether to return the primary key value as an array. If true,
	 * the return value will be an array with column name as key and column value as value.
	 * If this is false (default), a scalar value will be returned for non-composite primary key.
	 * @property mixed The old primary key value. An array (column name => column value) is
	 * returned if the primary key is composite. A string is returned otherwise (null will be
	 * returned if the key value is null).
	 * @returns {*} the old primary key value. An array (column name => column value) is returned if the primary key
	 * is composite or `asArray` is true. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 */
	getOldPrimaryKey: function (asArray) {
		asArray = asArray || false;

		var keys = this.__static.primaryKey();

		if (keys.length === 1 && !asArray) {
			return Jii._.has(this._oldAttributes, keys[0]) ? this._oldAttributes[keys[0]] : null;
		}

		var values = {};
		Jii._.each(keys, Jii._.bind(function(name) {
			values[name] = Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
		}, this));

		return values;
	},

	/**
	 * Returns the relation object with the specified name.
	 * A relation is defined by a getter method which returns an [[ActiveQueryInterface]] object.
	 * It can be declared in either the Active Record class itself or one of its behaviors.
	 * @param {string} name the relation name
	 * @param {boolean} [throwException] whether to throw exception if the relation does not exist.
	 * @returns {Promise.<Jii.sql.ActiveQuery>} the relational query object. If the relation does not exist
	 * and `throwException` is false, null will be returned.
	 * @throws {Jii.exceptions.InvalidParamException} if the named relation does not exist.
	 */
	getRelation: function (name, throwException) {
		throwException = !Jii._.isUndefined(throwException) ? throwException : true;

		var getter = 'get' + Jii._s.capitalize(name);
		if (Jii._.isFunction(this[getter])) {
			return this[getter]();
		} else if (throwException) {
			throw new Jii.exceptions.InvalidParamException(this.className() + ' has no relation named `' + name + '`.');
		}

		return null;
	},

    /**
     *
     * @param {string} name
     * @returns {boolean}
     */
    hasRelation: function(name) {
        var getter = 'get' + Jii._s.capitalize(name);
        return Jii._.isFunction(this[getter]);
    },

	/**
	 * Establishes the relationship between two models.
	 *
	 * The relationship is established by setting the foreign key value(s) in one model
	 * to be the corresponding primary key value(s) in the other model.
	 * The model with the foreign key will be saved into database without performing validation.
	 *
	 * If the relationship involves a pivot table, a new row() will be inserted into the
	 * pivot table which contains the primary key values from both models.
	 *
	 * Note that this method requires that the primary key value is not null.
	 *
	 * @param {string} name the case sensitive name of the relationship
	 * @param {Jii.base.ActiveRecord} model the model to be linked with the current one.
	 * @param {object} [extraColumns] additional column values to be saved into the pivot table.
	 * This parameter is only meaningful for a relationship involving a pivot table
	 * (i.e., a relation set with [[ActiveRelationTrait.via()]] or `[[ActiveQuery.viaTable()]]`.)
	 * @returns {Promise}
	 * @throws {Jii.exceptions.InvalidCallException} if the method is unable to link two models.
	 */
	link: function (name, model, extraColumns) {
		extraColumns = extraColumns || {};

		var relation = this.getRelation(name);

		return Promise.resolve().then(function() {
			if (relation.getVia() !== null) {
				if (this.isNewRecord() || model.isNewRecord()) {
					throw new Jii.exceptions.InvalidCallException('Unable to link models: both models must NOT be newly created.');
				}

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

					// unset viaName so that it can be reloaded to reflect the change
                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var columns = {};
				Jii._.each(viaRelation.link, function(b, a) {
					columns[a] = this.get(b);
				}.bind(this));
				Jii._.each(relation.link, function(b, a) {
					columns[b] = model.get(a);
				}.bind(this));
				Jii._.each(extraColumns, function(v, k) {
					columns[k] = v;
				}.bind(this));

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					var record = new viaClass();
					Jii._.each(columns, Jii._.bind(function(value, column) {
						record.set(column, value);
					}, this));
					return record.insert(false);
				}

				/* @type {viaTable} string */
				return this.__static.getDb().createCommand().insert(viaTable, columns);
			}

			var p1 = model.__static.isPrimaryKey(Jii._.keys(relation.link));
			var p2 = this.__static.isPrimaryKey(Jii._.values(relation.link));
			if (p1 && p2) {
				if (this.isNewRecord() && model.isNewRecord()) {
					throw new Jii.exceptions.InvalidCallException('Unable to link models: both models are newly created.');
				} else if (this.isNewRecord()) {
					var link = {};
					for (var fk in relation.link) {
						if (relation.link.hasOwnProperty(fk)) {
							link[relation.link[fk]] = fk;
						}
					}
					return this._bindModels(link, this, model);
				} else {
					return this._bindModels(relation.link, model, this);
				}
			} else if (p1) {
				var link2 = {};
				for (var fk2 in relation.link) {
					if (relation.link.hasOwnProperty(fk2)) {
						link2[relation.link[fk2]] = fk2;
					}
				}
				return this._bindModels(link2, this, model);
			} else if (p2) {
				return this._bindModels(relation.link, model, this);
			} else {
				throw new Jii.exceptions.InvalidCallException('Unable to link models: the link does not involve any primary key.');
			}
		}.bind(this)).then(Jii._.bind(function() {
			// update lazily loaded related objects
			if (!relation.multiple) {
                this._setRelated(name, model);
			} else if (Jii._.has(this._related, name)) {
                this._related[name].add(model);
			}

			return Promise.resolve();
		}, this));
	},

	/**
	 * Destroys the relationship between two models.
	 *
	 * The model with the foreign key of the relationship will be deleted if `delete` is true.
	 * Otherwise, the foreign key will be set null and the model will be saved without validation.
	 *
	 * @param {string} name the case sensitive name of the relationship.
	 * @param {Jii.base.ActiveRecord} model the model to be unlinked from the current one.
	 * @param {boolean} [isDelete] whether to delete the model that contains the foreign key.
	 * If false, the model's foreign key will be set null and saved.
	 * If true, the model containing the foreign key will be deleted.
	 * @returns {Promise}
	 * @throws InvalidCallException if the models cannot be unlinked
	 */
	unlink: function (name, model, isDelete) {
		isDelete = isDelete || false;

		var relation = this.getRelation(name);

		return Promise.resolve().then(function() {

			if (relation.getVia() !== null) {

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var columns = {};
				var nulls = {};
				Jii._.each(viaRelation.link, Jii._.bind(function(b, a) {
					columns[a] = this.get(b);
				}, this));
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					columns[b] = model.get(a);
				}, this));
				Jii._.each(Jii._.keys(columns), Jii._.bind(function(k) {
					nulls[k] = null;
				}, this));

				if (Jii._.isArray(relation.getVia())) {
					if (isDelete) {
						return viaClass.deleteAll(columns);
					}

					return viaClass.updateAll(nulls, columns);
				}

				/* @type Jii.sql.Command */
				var command = this.__static.getDb().createCommand();
				if (isDelete) {
					return command.delete(viaTable, columns);
				}

				return command.update(viaTable, nulls, columns);
			}

			var p1 = model.__static.isPrimaryKey(Jii._.keys(relation.link));
			var p2 = this.__static.isPrimaryKey(Jii._.values(relation.link));

			if (p1 && p2 || p2) {
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					model.set(a, null);
				}, this));

				return isDelete ? model.delete() : model.save(false);
			}

			if (p1) {
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					var values = this.get(b);

					if (Jii._.isArray(values)) { // relation via array valued attribute
						var index = Jii._.indexOf(values, model.get(a));
						if (index !== -1) {
							values.splice(index, 1);
						}
					} else {
						this.set(b, null);
					}
				}, this));

				return isDelete ? this.delete() : this.save(false);
			}

			throw new Jii.exceptions.InvalidCallException('Unable to unlink models: the link does not involve any primary key.');
		}.bind(this)).then(function() {
				if (!relation.multiple) {
                    this._removeRelated(name);
					return;
				}

				if (Jii._.has(this._related, name)) {
					this._related[name].remove(model);
				}
		}.bind(this));
	},

	/**
	 * Destroys the relationship in current model.
	 *
	 * The model with the foreign key of the relationship will be deleted if `delete` is true.
	 * Otherwise, the foreign key will be set null and the model will be saved without validation.
	 *
	 * Note that to destroy the relationship without removing records make sure your keys can be set to null
	 *
	 * @param {string} name the case sensitive name of the relationship.
	 * @param {boolean} [isDelete] whether to delete the model that contains the foreign key.
	 * @returns {Promise}
	 */
	unlinkAll: function (name, isDelete) {
		isDelete = isDelete || false;

		var relation = this.getRelation(name);

		return Promise.resolve().then(Jii._.bind(function() {

			if (relation.getVia() !== null) {

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var condition = {};
				var nulls = {};
				Jii._.each(viaRelation.link, Jii._.bind(function(b, a) {
					nulls[a] = null;
					condition[a] = this.get(b);
				}, this));

				if (Jii._.isArray(relation.getVia())) {
					if (isDelete) {
						return viaClass.deleteAll(condition);
					}
					return viaClass.updateAll(nulls, condition);
				}

				/** @type {Jii.sql.Command} */
				var command = this.__static.getDb().createCommand();
				if (isDelete) {
					return command.delete(viaTable, condition);
				}

				return command.update(viaTable, nulls, condition);
			}

			/** @typedef {Jii.base.ActiveRecord} relatedModel */
			var relatedModel = relation.modelClass;
			var key = relation.link[0];
			if (!isDelete && relation.link.length == 1 && Jii._.isArray(this.get(key))) {
				// relation via array valued attribute
				this.set(key, []);
				return this.save(false);
			} else {
				var nulls2 = {};
				var condition2 = {};

				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					nulls2[a] = null;
					condition2[a] = this.get(b);
				}, this));
				if (relation.getWhere()) {
					condition2 = ['and', condition2, relation.getWhere()];
				}

				if (isDelete) {
					return relatedModel.deleteAll(condition2);
				}
				return relatedModel.updateAll(nulls2, condition2);
			}
		}, this)).then(Jii._.bind(function() {
            this._removeRelated(name);
		}, this));
	},

	/**
	 * @param {object} link
	 * @param {Jii.base.ActiveRecord} foreignModel
	 * @param {Jii.base.ActiveRecord} primaryModel
	 * @throws {Jii.exceptions.InvalidCallException}
	 * @returns {Promise}
	 */
	_bindModels: function (link, foreignModel, primaryModel) {
		Jii._.each(link, Jii._.bind(function(pk, fk) {
			var value = primaryModel.get(pk);
			if (value === null) {
				throw new Jii.exceptions.InvalidCallException('Unable to link models: the primary key of `' + primaryModel.className() + '` is null.');
			}

			if (Jii._.isArray(foreignModel.get(fk))) { // relation via array valued attribute
				foreignModel.get(fk).concat(value);
			} else {
				foreignModel.set(fk, value);
			}
		}, this));

		return foreignModel.save(false);
	},




	/**
	 * Returns the text label for the specified attribute.
	 * If the attribute looks like `relatedModel.attribute`, then the attribute will be received from the related model.
	 * @param {string} attribute the attribute name
	 * @returns {string} the attribute label
	 * @see generateAttributeLabel()
	 * @see attributeLabels()
	 */
	getAttributeLabel: function (attribute) {
		var labels = this.attributeLabels();

		if (Jii._.has(labels[attribute])) {
			return labels[attribute];
		}

		if (attribute.indexOf('.') !== -1) {
			var attributeParts = attribute.split('.');
			var neededAttribute = attributeParts.pop();

			var relatedModel = this;
			Jii._.each(attributeParts, Jii._.bind(function(relationName) {
				if (Jii._.has(this._related, relationName) && this._related[relationName] instanceof Jii.base.ActiveRecord) {
					relatedModel = this._related[relationName];
				} else {
					// @todo
					/*try {
						relation = relatedModel.getRelation(relationName);
					} catch (InvalidParamException e) {
						return this.generateAttributeLabel(attribute);
					}
					relatedModel = new relation.modelClass();*/
				}
			}, this));

			labels = relatedModel.attributeLabels();

			if (Jii._.has(labels[attribute])) {
				return labels[attribute];
			}
		}

		return this.generateAttributeLabel(attribute);
	}

});

},{"./Model":100,"jii":124}],98:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * BaseCollection provides a base class that implements the [[CollectionInterface]].
 *
 * @class Jii.base.Collection
 * @extends Jii.base.Component
 * @extends Array
 */
Jii.defineClass('Jii.base.Collection', /** @lends Jii.base.Collection.prototype */{

    __extends: Jii.base.Component,

    __static: /** @lends Jii.base.Collection */{

        /**
         * @event Jii.base.Collection#add
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_ADD: 'add',

        /**
         * @event Jii.base.Collection#change
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_CHANGE: 'change',

        /**
         * @event Jii.base.Collection#change:
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_CHANGE_NAME: 'change:',

        /**
         * @event Jii.base.Collection#remove
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_REMOVE: 'remove'

    },

    /**
     * @type {number}
     */
    length: 0,

    /**
     * @type {string|Jii.base.Model}
     */
    modelClass: null,

    _byId: {},

    _eventsChangeName: [],

    /**
     * @param {[]|object} [models]
     * @param {object} [config]
     * @constructor
     */
    constructor: function (models, config) {
        this.__super(config);

        if (Jii._.isArray(models)) {
            this.add(models);
        }
    },

    /**
     * @returns {[]|object}
     */
    getModels: function () {
        return this.map(function(model) {
            return model;
        });
    },

    /**
     *
     * @param {object|object[]|Jii.base.Model|Jii.base.Model[]} models
     */
    setModels: function(models) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        this._change(this.length, models, [], true);
    },

    /**
     *
     * @param {object|object[]|Jii.base.Model|Jii.base.Model[]} models
     * @param {number} [index]
     */
    add: function(models, index) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        if (!index && index !== 0) {
            index = this.length;
        }
        this._change(index, models, []);
    },

    /**
     *
     * @param {*|*[]} models
     */
    remove: function(models) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        this._change(0, [], models);
    },

    /**
     *
     * @param {string|object|object[]} name
     * @param {*} [value]
     * @returns {*}
     */
    set: function(name, value) {
        // Format [0].name
        var indexFormat = this._detectKeyFormatIndex(name);
        if (indexFormat) {
            var model = this.at(indexFormat.index);
            if (model) {
                return model.set(indexFormat.subName, value);
            }

            throw new Jii.exceptions.InvalidParamException('Not found model with index `' + indexFormat.index + '` for set attribute `' + indexFormat.subName + '`.');
        }

        // Object format
        if (Jii._.isObject(name) && !Jii._.has(name, 'modelClass')) {
            return this.setModels(name);
        }

        // Array format
        if (Jii._.isArray(name)) {
            return this.setModels(name);
        }

        return this.__super(name, value);
    },

    /**
     *
     * @param {string} name
     * @returns {*}
     */
    get: function(name) {
        // Format [0].name
        var indexFormat = this._detectKeyFormatIndex(name);
        if (indexFormat) {
            var model = this.at(indexFormat.index);
            if (model) {
                return indexFormat.subName ? model.get(indexFormat.subName) : model;
            }
            return null;
        }

        // Get by pk
        var primaryKey = this._getPrimaryKey(name);
        if (Jii._.has(this._byId, primaryKey)) {
            return this._byId[primaryKey];
        }

        return this.__super(name);
    },

    /**
     * Method for NeatComet api
     * @param newAttributes
     * @param oldAttributes
     */
    update: function(newAttributes, oldAttributes) {
        var model = this.getById(oldAttributes);
        if (model) {
            model.set(newAttributes);
        } else {
            this.add(newAttributes);
        }
    },

    /**
     *
     * @param name
     * @returns {{index: number, subName: string|null}}
     * @private
     */
    _detectKeyFormatIndex: function(name) {
        var matches = /^\[([0-9]+)\]\.?(.*)/.exec(name);
        if (matches === null) {
            return null;
        }

        return {
            index: parseInt(matches[1]),
            subName: matches[2] || null
        };
    },

    /**
     *
     *
     * @param {number|string|object} primaryKey
     * @returns {*|null}
     */
    getById: function(primaryKey) {
        return this._byId[this._getPrimaryKey(primaryKey)] || null;
    },

    /**
     *
     * @returns {number}
     */
    getCount: function () {
        return this.length;
    },

    /**
     * @param options
     * @returns {*}
     */
    toJSON: function(options) {
        return this.map(function(model) {
            return model.toJSON(options);
        });
    },

    /**
     *
     * @param {number} index
     * @returns {*}
     */
    at: function(index) {
        if (index < 0) {
            index = Math.max(0, this.length + index);
        }
        return this[index] || null;
    },

    /**
     *
     * @param {*} [models]
     */
    reset: function(models) {
        models = models || [];
        if (!Jii._.isArray(models)) {
            models = [models];
        }

        var toAdd = [];
        Jii._.each(models, function(data) {
            var finedModels = this._findModels(data);
            if (finedModels.length) {
                // Convert data to model
                Jii._.each(this._findModels(data), function(model) {
                    if (Jii._.indexOf(toAdd, model) === -1) {
                        toAdd.push(model);
                    }
                });
            } else {
                toAdd.push(data);
            }
        }.bind(this));

        var toRemove = [];
        Jii._.each(this.getModels(), function(model) {
            if (Jii._.indexOf(toAdd, model) === -1) {
                toRemove.push(model);
            }
        });

        this._change(0, toAdd, toRemove, true);
    },

    /**
     *
     * @returns {Jii.base.Object.__super}
     */
    clone: function() {
        return new this.__super(this.getModels(), {
            modelClass: this.modelClass
        });
    },

    _reset: function() {
        this._byId  = {};
        Array.prototype.splice.call(this, 0, this.length);
    },

    _change: function(startIndex, toAdd, toRemove, unique) {
        unique = unique || false;

        var added = [];
        var removed = [];
        var isSorted = false;

        // Remove
        Jii._.each(toRemove, function(data) {
            Jii._.each(this._findModels(data), function(model) {
                var index = this.indexOf(model);
                if (index < startIndex) {
                    startIndex--;
                }

                removed.push(model);

                // Array access
                Array.prototype.splice.call(this, index, 1);

                // By id
                if (model instanceof Jii.base.ActiveRecord) {
                    delete this._byId[this._getPrimaryKey(model)];
                }
            }.bind(this));
        }.bind(this));

        // Add
        Jii._.each(toAdd, function(data) {
            var existsModels = unique ? this._findModels(data) : [];
            var models = existsModels.length > 0 ? existsModels : [this._createModel(data)];

            Jii._.each(models, function(model) {
                // Check moving
                if (existsModels.length > 0) {
                    isSorted = true;

                    // Update model attributes
                    if (model instanceof Jii.base.Model && Jii._.isObject(data) && !(data instanceof Jii.base.Model)) {
                        model.set(data);
                    }
                } else {
                    added.push(model);

                    // Array access
                    Array.prototype.splice.call(this, startIndex++, 0, model);

                    // By id
                    if (model instanceof Jii.base.ActiveRecord) {
                        this._byId[this._getPrimaryKey(model)] = model;
                    }
                }
            }.bind(this));
        }.bind(this));

        // Lazy subscribe on added
        Jii._.each(added, function(model) {
            Jii._.each(this._eventsChangeName, function(arr) {
                model.on.apply(model, arr);
            });
        }.bind(this));

        // Unsubscribe on removed
        Jii._.each(removed, function(model) {
            Jii._.each(this._eventsChangeName, function(arr) {
                model.off.apply(model, arr.slice(0, 2));
            });
        }.bind(this));

        // Trigger events
        var event = new Jii.model.CollectionEvent({
            added: added,
            removed: removed
        })
        if (added.length > 0) {
            this.trigger(this.__static.EVENT_ADD, event);
        }
        if (removed.length > 0) {
            this.trigger(this.__static.EVENT_REMOVE, event);
        }
        if (added.length > 0 || removed.length > 0) {
            this.trigger(this.__static.EVENT_CHANGE, event);
        }

        if (isSorted) {
            this._onSort();
        }
    },

    /**
     *
     * @param {number|string|object} data
     * @returns {*|*[]}
     * @private
     */
    _findModels: function(data) {
        var primaryKey = this._getPrimaryKey(data);
        return this.filter(function(model) {
            return primaryKey == this._getPrimaryKey(model);
        }.bind(this));
    },

    /**
     *
     * @param {number|string|object} data
     * @returns {string}
     */
    _getPrimaryKey: function(data) {
        if (Jii._.isObject(data) && this.modelClass && !(data instanceof Jii.base.ActiveRecord)) {
            data = this._createModel(data);
        }

        if (data instanceof Jii.base.ActiveRecord) {
            data = data.getPrimaryKey();
        }

        if (Jii._.isObject(data)) {
            return JSON.stringify(data);
        }
        return data;
    },

    /**
     *
     * @param {object|*} data
     * @returns {Jii.base.Model}
     * @private
     */
    _createModel: function(data) {
        // Already model
        if (data instanceof Jii.base.Model) {
            return data;
        }

        // Disabled model auto create
        if (this.modelClass === false) {
            return data;
        }

        // Required
        if (this.modelClass === null) {
            Jii.exceptions.InvalidConfigException('Property `modelClass` in collection is required (or set false to force disable).');
        }

        if (Jii._.isObject(data)) {
            var modelClass = this.modelClass;
            if (Jii._.isString(modelClass)) {
                modelClass = Jii.namespace(modelClass);
            }
            if (!Jii._.isFunction(modelClass)) {
                Jii.exceptions.InvalidConfigException('Not found model class for create instance in collection, modelClass: ' + this.modelClass);
            }

            return new modelClass(data);
        }

        throw new Jii.exceptions.InvalidParamException('Cannot create model instance from data: ' + JSON.stringify(data));
    },

    _onSort: function() {
        // @todo Trigger sort event
    },

    /**
     * @param {string|string[]} name
     * @param {function} handler
     * @param {*} [data]
     * @param {boolean} [isAppend]
     */
    on: function(name, handler, data, isAppend) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        // Attributes in models
        var changeNameFormat = this._detectKeyFormatChangeName(name);
        if (changeNameFormat) {
            var changeNameEvent = Jii.base.Model.EVENT_CHANGE_NAME + changeNameFormat.subName;
            this._eventsChangeName.push([changeNameEvent, handler, data, isAppend]);
            this.each(function(model) {
                model.on(changeNameEvent, handler, data, isAppend);
            })
            return;
        }

        this.__super(name, handler, data, isAppend);
    },

    /**
     * @param {string|string[]} name
     * @param {function} [handler]
     * @return boolean
     */
    off: function(name, handler) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

        // Attributes in models
        var changeNameFormat = this._detectKeyFormatChangeName(name);
        if (changeNameFormat) {
            var changeNameEvent = Jii.base.Model.EVENT_CHANGE_NAME + changeNameFormat.subName;
            this._eventsChangeName = Jii._.filter(this._eventsChangeName, function(arr) {
                return arr[0] !== changeNameEvent || arr[1] !== handler;
            });

            var bool = false;
            this.each(function(model) {
                if (model.off(changeNameEvent, handler)) {
                    bool = true;
                }
            })
            return bool;
        }

        return this.__super(name, handler);
    },

    _detectKeyFormatChangeName: function(name) {
        if (name.indexOf(this.__static.EVENT_CHANGE_NAME) !== 0) {
            return null;
        }

        return {
            subName: name.substr(this.__static.EVENT_CHANGE_NAME.length)
        };
    },

    // Array prototype
    /////////////////////

    /**
     *
     * @param {...*} value1
     * @returns {self}
     */
    concat: function(value1) {
        this.add(Jii._.toArray(arguments));
        return this;
    },

    /**
     *
     */
    reverse: function() {
        Array.prototype.reverse.call(this);
    },

    /**
     *
     */
    sort: function() {
        Array.prototype.sort.call(this);
        this._onSort();
    },

    /**
     *
     */
    join: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     */
    toString: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     */
    toLocaleString: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     *
     * @param {number} start
     * @param {number} deleteCount
     * @param {...object} [model1]
     * @returns {[]}
     */
    splice: function(start, deleteCount, model1) {
        var toRemove = Array.prototype.slice.call(this, start, start + deleteCount);
        this.remove(toRemove);
        this.add(Jii._.toArray(arguments).slice(2), start);
        return toRemove;
    },

    /**
     *
     * @param begin
     * @param end
     * @returns {*}
     */
    slice: function(begin, end) {
        return new this.__static(Array.prototype.slice.call(this, begin, end), {
            modelClass: this.modelClass
        });
    },

    /**
     *
     * @param {...object} model1
     */
    push: function(model1) {
        this.add(Jii._.toArray(arguments));
    },

    /**
     *
     * @returns {object}
     */
    pop: function() {
        if (this.length === 0) {
            return null;
        }

        var model = this[this.length - 1];
        this.remove(model);
        return model;
    },

    /**
     *
     * @param {...object} model1
     * @returns {number}
     */
    unshift: function(model1) {
        this.add(Jii._.toArray(arguments), 0);
        return this.length;
    },

    /**
     *
     * @returns {object}
     */
    shift: function() {
        if (this.length === 0) {
            return null;
        }

        var model = this[0];
        this.remove(model);
        return model;
    },

    // @todo ES6 methods
    //es6 copyWithin: function() {},
    //es6 entries: function() {},
    //es6 fill: function() {},
    //es6 keys: function() {},
    //es6 values: function() {},

    // Underscore methods
    /////////////////////

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     */
    each: function(iteratee, context) {
        return Jii._.each(this, iteratee, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     */
    forEach: function(iteratee, context) {
        return this.each.apply(this, arguments);
    },

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     * @returns {[]}
     */
    map: function(iteratee, context) {
        return Jii._.map(this, iteratee, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {*} [memo]
     * @param {object} [context]
     * @returns {[]}
     */
    reduce: function(iteratee, memo, context) {
        return Jii._.reduce(this, iteratee, memo, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {*} [memo]
     * @param {object} [context]
     * @returns {[]}
     */
    reduceRight: function(iteratee, memo, context) {
        return Jii._.reduceRight(this, iteratee, memo, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {object}
     */
    find: function(predicate, context) {
        return Jii._.find(this, predicate, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {[]}
     */
    filter: function(predicate, context) {
        return Jii._.filter(this, predicate, context);
    },

    /**
     *
     * @param {object} properties
     * @returns {object}
     */
    where: function(properties) {
        return Jii._.where(this, properties);
    },

    /**
     *
     * @param {object} properties
     * @returns {object}
     */
    findWhere: function(properties) {
        return Jii._.findWhere(this, properties);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {[]}
     */
    reject: function(predicate, context) {
        return Jii._.reject(this, predicate, context);
    },

    /**
     *
     * @param {function} [predicate]
     * @param {object} [context]
     */
    every: function(predicate, context) {
        return Jii._.every(this, predicate, context);
    },

    /**
     *
     * @param {function} [predicate]
     * @param {object} [context]
     */
    some: function(predicate, context) {
        return Jii._.some(this, predicate, context);
    },

    /**
     *
     * @param {object} value
     * @param {number} [fromIndex]
     */
    contains: function(value, fromIndex) {
        return Jii._.contains(this, value, fromIndex);
    },

    /**
     *
     * @param {object} value
     * @param {number} [fromIndex]
     */
    includes: function(value, fromIndex) {
        return this.contains.apply(this, arguments);
    },

    /**
     *
     * @param {string} [methodName]
     * @param {...*} [methodParam]
     * @returns {Array}
     */
    invoke: function(methodName, methodParam) {
        var args = Jii._.toArray(arguments);
        args.unshift(this);
        return Jii._.invoke.apply(Jii._, args);
    },

    /**
     *
     * @param {string} propertyName
     * @returns {Array}
     */
    pluck: function(propertyName) {
        return Jii._.map(this, function(model) {
            return Jii._.isFunction(model.get) ? model.get(propertyName) : model[propertyName];
        });
    },

    /**
     *
     * @param {function} [iteratee]
     * @param {object} [context]
     * @returns {object}
     */
    max: function(iteratee, context) {
        return Jii._.max(this, iteratee, context);
    },

    /**
     *
     * @param {function} [iteratee]
     * @param {object} [context]
     * @returns {object}
     */
    min: function(iteratee, context) {
        return Jii._.min(this, iteratee, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    sortBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        Jii._.each(Jii._.sortBy(this, iterator, context), function(model, i) {
            this[i] = model;
        }.bind(this));
        this._onSort();
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    groupBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.groupBy(this, iterator, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    indexBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.indexBy(this, iterator, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    countBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.countBy(this, iterator, context);
    },

    /**
     *
     * @returns {number}
     */
    size: function() {
        return this.length;
    },

    /**
     *
     * @param [num]
     * @returns {number}
     */
    first: function(num) {
        return Jii._.first(this, num);
    },

    /**
     *
     * @param [num]
     * @returns {[]}
     */
    initial: function(num) {
        return Jii._.initial(this, num);
    },

    /**
     *
     * @param [num]
     * @returns {number}
     */
    last: function(num) {
        return Jii._.last(this, num);
    },

    /**
     *
     * @param [index]
     * @returns {number}
     */
    rest: function(index) {
        return Jii._.rest(this, index);
    },

    /**
     *
     * @param {...*} [value]
     * @returns {[]}
     */
    without: function(value) {
        var args = Jii._.toArray(arguments);
        args.unshift(this);
        return Jii._.without.apply(Jii._, args);
    },

    /**
     *
     * @param {*} [value]
     * @param {boolean} [isSorted]
     * @returns {number}
     */
    indexOf: function(value, isSorted) {
        return Jii._.indexOf(this, value, isSorted);
    },

    /**
     *
     * @param {*} value
     * @param {number} [fromIndex]
     * @returns {object}
     */
    lastIndexOf: function(value, fromIndex) {
        return Jii._.lastIndexOf(this, value, fromIndex);
    },

    /**
     *
     * @param {object} model
     * @param {*} value
     * @param {object} [context]
     * @returns {number}
     */
    sortedIndex: function(model, value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.sortedIndex(this, model, iterator, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {number}
     */
    findIndex: function(predicate, context) {
        return Jii._.findIndex(this, predicate, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {number}
     */
    findLastIndex: function(predicate, context) {
        return Jii._.findLastIndex(this, predicate, context);
    },

    /**
     *
     */
    shuffle: function() {
        Jii._.shuffle(this);
    },

    /**
     *
     * @returns {boolean}
     */
    isEmpty: function() {
        return this.length === 0;
    }

});

},{"jii":124}],99:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Collection');

/**
 * BaseDataProvider provides a base class that implements the [[DataProviderInterface]].
 *
 * @class Jii.base.DataProvider
 * @extends Jii.base.Collection
 */
Jii.defineClass('Jii.base.DataProvider', /** @lends Jii.base.DataProvider.prototype */{

    __extends: Jii.base.Collection,

    /**
     * @type {string} an ID that uniquely identifies the data provider among all data providers.
     * You should set this property if the same page contains two or more different data providers.
     * Otherwise, the [[pagination]] and [[sort]] may not work properly.
     */
    id: null,

    _sort: null,
    _pagination: null,
    _keys: null,
    _isModelsPrepare: false,
    _totalCount: null,

    /**
     * Prepares the data models that will be made available in the current page.
     * @returns {[]} the available data models
     */
    prepareModels: function () {

    },

    /**
     * Prepares the keys associated with the currently available data models.
     * @param {[]} models the available data models
     * @returns {[]} the keys
     */
    prepareKeys: function (models) {

    },

    /**
     * Returns a value indicating the total number of data models in this data provider.
     * @returns {number} total number of data models in this data provider.
     */
    prepareTotalCount: function () {

    },

    /**
     * Prepares the data models and keys.
     *
     * This method will prepare the data models and keys that can be retrieved via
     * [[getModels()]] and [[getKeys()]].
     *
     * This method will be implicitly called by [[getModels()]] and [[getKeys()]] if it has not been called before.
     *
     * @param {boolean} [forcePrepare] whether to force data preparation even if it has been done before.
     */
    prepare: function (forcePrepare) {
        forcePrepare = forcePrepare || false;

        if (forcePrepare || !this._isModelsPrepare) {
            this.splice(0, this.length);
            Jii._.each(this.prepareModels(), function (model) {
                this.push(model);
            }.bind(this));
        }
        if (forcePrepare || this._keys === null) {
            this._keys = this.prepareKeys(this._models);
        }
    },

    /**
     * Returns the data models in the current page.
     * @returns {[]} the list of data models in the current page.
     */
    getModels: function () {
        this.prepare();
        return this._super();
    },

    /**
     * Returns the key values associated with the data models.
     * @returns {[]} the list of key values corresponding to [[models]]. Each data model in [[models]]
     * is uniquely identified by the corresponding key value in this array.
     */
    getKeys: function () {
        this.prepare();

        return this._keys;
    },

    /**
     * Sets the key values associated with the data models.
     * @param {[]} keys the list of key values corresponding to [[models]].
     */
    setKeys: function (keys) {
        this._keys = keys;
    },

    /**
     * Returns the total number of data models.
     * When [[pagination]] is false, this returns the same value as [[count]].
     * Otherwise, it will call [[prepareTotalCount()]] to get the count.
     * @returns {number} total number of possible data models.
     */
    getTotalCount: function () {
        if (this.getPagination() === false) {
            return this.getCount();
        } else if (this._totalCount === null) {
            this._totalCount = this.prepareTotalCount();
        }

        return this._totalCount;
    },

    /**
     * Sets the total number of data models.
     * @param {number} value the total number of data models.
     */
    setTotalCount: function (value) {
        this._totalCount = value;
    },

    /**
     * Returns the pagination object used by this data provider.
     * Note that you should call [[prepare()]] or [[getModels()]] first to get correct values
     * of [[Pagination.totalCount]] and [[Pagination.pageCount]].
     * @returns {jii.data.Pagination|boolean} the pagination object. If this is false, it means the pagination is disabled.
     */
    getPagination: function () {
        // @todo Pagination & Sort
        /*if (this._pagination === null) {
         this.setPagination({});
         }

         return this._pagination;*/
    },

    /**
     * Sets the pagination for this data provider.
     * @param {[]|jii.data.Pagination|boolean} value the pagination to be used by this data provider.
     * This can be one of the following:
     *
     * - a configuration array for creating the pagination object. The "class" element defaults
     *   to 'jii\data\Pagination'
     * - an instance of [[Pagination]] or its subclass
     * - false, if pagination needs to be disabled.
     *
     * @throws InvalidParamException
     */
    setPagination: function (value) {
        // @todo Pagination & Sort
        /*if (Jii._.isObject(value)) {
         config = {class: Pagination.className()};
         if (this.id !== null) {
         config['pageParam'] = this.id . '-page';
         config['pageSizeParam'] = this.id . '-per-page';
         }
         this._pagination = Jii.createObject(array_merge(config, value));
         } else if (value instanceof Pagination || value === false) {
         this._pagination = value;
         } else {
         throw new InvalidParamException('Only Pagination instance, configuration array or false is allowed.');
         }*/
    },

    /**
     * @returns {jii.data.Sort|boolean} the sorting object. If this is false, it means the sorting is disabled.
     */
    getSort: function () {
        // @todo Pagination & Sort
        /*if (this._sort === null) {
         this.setSort({});
         }

         return this._sort;*/
    },

    /**
     * Sets the sort definition for this data provider.
     * @param {[]|jii.data.Sort|boolean} value the sort definition to be used by this data provider.
     * This can be one of the following:
     *
     * - a configuration array for creating the sort definition object. The "class" element defaults
     *   to 'jii\data\Sort'
     * - an instance of [[Sort]] or its subclass
     * - false, if sorting needs to be disabled.
     *
     * @throws InvalidParamException
     */
    setSort: function (value) {
        // @todo Pagination & Sort
        /*if (Jii._.isObject(value)) {
         config = {class: Sort.className()};
         if (this.id !== null) {
         config['sortParam'] = this.id . '-sort';
         }
         this._sort = Jii.createObject(array_merge(config, value));
         } else if (value instanceof Sort || value === false) {
         this._sort = value;
         } else {
         throw new InvalidParamException('Only Sort instance, configuration array or false is allowed.');
         }*/
    },

    /**
     * Refreshes the data provider.
     * After calling this method, if [[getModels()]], [[getKeys()]] or [[getTotalCount()]] is called again,
     * they will re-execute the query and return the latest data available.
     */
    refresh: function () {
        this.splice(0, this.length);
        this._totalCount = null;
        this._keys = null;
    }


});

},{"./Collection":98,"jii":124}],100:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.Model
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Model', /** @lends Jii.base.Model.prototype */{

	__extends: Jii.base.Component,

	_attributes: {},
	_errors: {},
	_validators: null,
	_scenario: 'default',

    _editedLevel: 0,
    _editedSubModels: [],
    _editedChanges: {},

    __static: /** @lends Jii.base.Model */{

        /**
         * @event Jii.base.Model#change
         * @property {Jii.model.ChangeEvent} event
         */
        EVENT_CHANGE: 'change',

        /**
         * @event Jii.base.Model#change:
         * @property {Jii.model.ChangeAttributeEvent} event
         */
        EVENT_CHANGE_NAME: 'change:'

    },

    /**
     * @constructor
     */
    constructor: function (attributes, config) {
        if (Jii._.isObject(attributes)) {
            this.set(attributes);
        }

        this.__super(config);
    },

    /**
     * Validation rules
     * @returns {Array}
     */
    rules: function () {
        return [];
    },

    /**
     * Begin change operation
     */
    beginEdit: function() {
        this._editedLevel++;
    },

    /**
     * Cancel all changes after beginEdit() call
     */
    cancelEdit: function() {
        if (this._editedLevel > 0) {
            this._editedLevel--;
        }

        // Cancel in sub-models
        if (this._editedLevel === 0) {
            Jii._.each(this._editedSubModels, function (subModel) {
                subModel.cancelEdit();
            });

            // Revert attribute changes
            Jii._.each(this._editedChanges, function (values, name) {
                this._attributes[name] = values[0];
            }.bind(this));
        }
    },

    /**
     * End change operation - trigger change events
     */
    endEdit: function() {
        if (this._editedLevel > 0) {
            this._editedLevel--;
        }

        if (this._editedLevel === 0) {
            // End in sub-models
            Jii._.each(this._editedSubModels, function(subModel) {
                subModel.endEdit();
            });

            // Trigger change attribute events
            if (!Jii._.isEmpty(this._editedChanges)) {
                Jii._.each(this._editedChanges, function(values, name) {
                    this.trigger(this.__static.EVENT_CHANGE_NAME + name, new Jii.model.ChangeAttributeEvent({
                        sender: this,
                        attribute: name,
                        oldValue: values[0],
                        newValue: values[1],
                        changedAttributes: this._editedChanges
                    }));
                }.bind(this));

                // Trigger change event
                this.trigger(this.__static.EVENT_CHANGE, new Jii.model.ChangeEvent({
                    sender: this,
                    changedAttributes: this._editedChanges
                }));
            }

            // Reset state
            this._editedSubModels = [];
            this._editedChanges = {};
        }
    },

	/**
	 * Get attribute value
	 * @param {String} name
	 * @returns {*}
	 */
	get: function (name) {
        if (this.hasAttribute(name)) {
            return this.getAttribute(name);
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, '', true);
        if (collectionFormat) {
            return collectionFormat.subName ?
                collectionFormat.model.get(collectionFormat.subName) :
                collectionFormat.model;
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name);
        if (modelFormat) {
            return modelFormat.model ?
                modelFormat.model.get(modelFormat.subName) :
                null;
        }

        try {
            return this.__super(name);
        } catch (e) {
            if (!(e instanceof Jii.exceptions.UnknownPropertyException)) {
                throw e;
            }
            return null;
        }
	},

	/**
	 * Set attribute value
	 * @param {object|string} name
	 * @param {*} [value]
	 */
	set: function (name, value) {
        // Object format support
        if (Jii._.isObject(name)) {
            this.beginEdit();

            var isChanged = false;
            Jii._.each(name, function(value, name) {
                if (this.set(name, value)) {
                    isChanged = true;
                }
            }.bind(this));

            this.endEdit();
            return isChanged;
        }

        // Sub models support: foo[0].bar.zen
        var subMatches = /^(.+)\.([^\[\].]+)$/.exec(name);
        if (subMatches !== null) {
            var subModel = this.get(subMatches[1]);

            // Check sub-model is Jii.base.Model
            if (subModel instanceof Jii.base.Collection) {
                throw new Jii.exceptions.InvalidParamException('Try set property of array models: `' + name + '`');
            } else if (!(subModel instanceof Jii.base.Model)) {
                throw new Jii.exceptions.UnknownPropertyException('Setting property of null sub-model `' + name + '`');
            }

            subModel.beginEdit();
            this._editedSubModels.push(subModel);

            var isSubChanged = subModel.set(subMatches[2], value);

            this.endEdit();
            return isSubChanged;
        }

        if (this.hasAttribute(name)) {
            this.beginEdit();

            var oldValue = this._attributes[name];
            var isAttributeChanged = !Jii._.isEqual(oldValue, value);
            this._attributes[name] = value;

            if (isAttributeChanged) {
                this._editedChanges[name] = [oldValue, value];
            }

            this.endEdit();
            return isAttributeChanged;
        }

        this.__super(name, value);
	},

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @param {boolean} [skipThrow]
     * @returns {{model: Jii.base.ActiveRecord, name: string, subName: string}|null}
     * @protected
     */
    _detectKeyFormatCollection: function(name, prefix, skipThrow) {
        prefix = prefix || '';
        skipThrow = skipThrow || false;

        // Sub models support: change:foo[0]
        var arrRegExp = new RegExp('^' + prefix + '([^\\[\\].]+)\\[([-0-9]+)\\](\\.(.+))?$');
        var arrMatches = arrRegExp.exec(name);
        if (arrMatches === null) {
            return null;
        }

        var collection = this.get(arrMatches[1]);
        if (collection instanceof Jii.base.Collection) {
            var index = parseInt(arrMatches[2]);
            var arrSubModel = collection.at(index);
            if (arrSubModel) {
                return {
                    model: arrSubModel,
                    subName: arrMatches[4] ? prefix + arrMatches[4] : null,
                    index: index
                };
            } else if (!skipThrow) {
                throw new Jii.exceptions.InvalidParamException('Model with index `' + index + '` in collection `' + arrMatches[1] + '` is not found.');
            }
        } else if (!skipThrow) {
            throw new Jii.exceptions.InvalidParamException('Relation `' + arrMatches[1] + '` is not collection.');
        }

        return null;
    },

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @returns {{model: Jii.base.ActiveRecord|null, name: string, subName: string}|null}
     * @protected
     */
    _detectKeyFormatModel: function(name, prefix) {
        prefix = prefix || '';

        if (prefix && name.indexOf(prefix) !== 0) {
            return null;
        }
        name = name.substr(prefix.length);

        var dotIndex = name.indexOf('.');
        if (dotIndex === -1) {
            return null;
        }

        var relationName = name.substr(0, dotIndex);

        return {
            model: this.get(relationName),
            name: relationName,
            subName: prefix + name.substr(dotIndex + 1)
        };
    },

    /**
     * Returns the named attribute value.
     * If this record is the result of a query and the attribute is not loaded,
     * null will be returned.
     * @param {string} name the attribute name
     * @returns {*} the attribute value. Null if the attribute is not set or does not exist.
     * @see hasAttribute()
     */
    getAttribute: function (name) {
        return Jii._.has(this._attributes, name) ? this._attributes[name] : null;
    },

    /**
     * Sets the named attribute value.
     * @param {string} name the attribute name
     * @param {*} value the attribute value.
     * @throws {Jii.exceptions.InvalidParamException} if the named attribute does not exist.
     * @see hasAttribute()
     */
    setAttribute: function (name, value) {
        if (this.hasAttribute(name)) {
            this.set(name, value);
        } else {
            throw new Jii.exceptions.InvalidParamException(this.className() + ' has no attribute named "' + name + '".');
        }
    },

	/**
	 * Update model attributes. This method run change
	 * and change:* events, if attributes will be changes
	 * @param attributes
	 * @param {Boolean} [safeOnly]
	 * @returns {boolean}
	 */
	setAttributes: function (attributes, safeOnly) {
		if (Jii._.isUndefined(safeOnly)) {
			safeOnly = true;
		}

        var filteredAttributes = {};
		var attributeNames = safeOnly ? this.safeAttributes() : this.attributes();

		Jii._.each(attributes, Jii._.bind(function (value, key) {
			if (Jii._.indexOf(attributeNames, key) !== -1) {
                filteredAttributes[key] = value;
			} else if (safeOnly) {
				this.onUnsafeAttribute(key, value);
			}
		}, this));

		return this.set(filteredAttributes);
	},

	/**
	 * This method is invoked when an unsafe attribute is being massively assigned.
	 * The default implementation will log a warning message if YII_DEBUG is on.
	 * It does nothing otherwise.
	 * @param {string} name the unsafe attribute name
	 * @param {*} value the attribute value
	 */
	onUnsafeAttribute: function (name, value) {
		if (Jii.debug) {
			Jii.trace('Failed to set unsafe attribute `' + name + '` in ' + this.className() + '`');
		}
	},

	/**
	 * Returns attribute values.
	 * @param {Array} [names]
	 * @param {Array} [except]
	 * @returns {{}} Attribute values (name => value).
	 */
	getAttributes: function (names, except) {
		var values = {};

		if (!Jii._.isArray(names)) {
			names = this.attributes();
		}

		Jii._.each(names, Jii._.bind(function (name) {
			if (!Jii._.isArray(except) || Jii._.indexOf(name, except) === -1) {
				values[name] = this.get(name);
			}
		}, this));

		return values;
	},

	/**
	 * Get attributes list for this model
	 * @return {Array}
	 */
	attributes: function () {
		return Jii._.keys(this._attributes);
	},

	/**
	 * Check attribute exists in this model
	 * @param {String} name
	 * @returns {boolean}
	 */
	hasAttribute: function (name) {
		//return true;
		return Jii._.indexOf(this.attributes(), name) !== -1;
	},

	/**
	 * Format: attribute => label
	 * @return {object}
	 */
	attributeLabels: function () {
		return {};
	},

	/**
	 * Get label by attribute name
	 * @param {string} name
	 * @returns {string}
	 */
	getAttributeLabel: function (name) {
		var attributes = this.attributeLabels();
		return Jii._.has(attributes, name) ? attributes[name] : name;
	},

	/**
	 *
	 * @param scenario
	 */
	setScenario: function (scenario) {
		this._scenario = scenario;
	},

	/**
	 *
	 * @returns {string}
	 */
	getScenario: function () {
		return this._scenario;
	},

	safeAttributes: function () {
		var scenario = this.getScenario();
		var scenarios = this.scenarios();

		if (!Jii._.has(scenarios, scenario)) {
			return [];
		}

		var attributes = [];
		Jii._.each(scenarios[scenario], function (attribute, i) {
			if (attribute.substr(0, 1) !== '!') {
				attributes.push(attribute);
			}
		});
		return attributes;
	},

	/**
	 *
	 * @returns {*}
	 */
	activeAttributes: function () {
		var scenario = this.getScenario();
		var scenarios = this.scenarios();

		if (!Jii._.has(scenarios, scenario)) {
			return [];
		}

		var attributes = scenarios[scenario];
		Jii._.each(attributes, function (attribute, i) {
			if (attribute.substr(0, 1) === '!') {
				attributes[i] = attribute.substr(1);
			}
		});

		return attributes;
	},

	/**
	 *
	 * @returns {Object}
	 */
	scenarios: function () {
		var scenarios = {};
		scenarios['default'] = [];

		Jii._.each(this.getValidators(), function (validator) {
			Jii._.each(validator.on, function(scenario) {
				scenarios[scenario] = [];
			});
			Jii._.each(validator.except, function(scenario) {
				scenarios[scenario] = [];
			});
		});
		var names = Jii._.keys(scenarios);

		Jii._.each(this.getValidators(), function (validator) {
			var validatorScenarios = validator.on && validator.on.length > 0 ? validator.on : names;
			Jii._.each(validatorScenarios, function (name) {
				if (!scenarios[name]) {
					scenarios[name] = [];
				}

				if (Jii._.indexOf(validator.except, name) !== -1) {
					return;
				}

				Jii._.each(validator.attributes, function (attribute) {

					if (Jii._.indexOf(scenarios[name], attribute) !== -1) {
						return;
					}

					scenarios[name].push(attribute);
				});
			});
		});

		return scenarios;
	},

	/**
	 *
	 * @returns {Array}
	 */
	createValidators: function () {
		var validators = [];
		Jii._.each(this.rules(), Jii._.bind(function (rule) {
			if (rule instanceof Jii.validators.Validator) {
				validators.push(rule);
			} else if (Jii._.isArray(rule) && rule.length >= 2) {
				var attributes = Jii._.isString(rule[0]) ? [rule[0]] : rule[0];
				var params = rule[2] || {};
				params.on = Jii._.isString(params.on) ? [params.on] : params.on;

				var validator = Jii.validators.Validator.create(rule[1], this, attributes, params);
				validators.push(validator);
			} else {
				throw new Jii.exceptions.ApplicationException('Invalid validation rule: a rule must specify both attribute names and validator type.');
			}
		}, this));
		return validators;
	},

	/**
	 *
	 * @returns {*}
	 */
	getValidators: function () {
		if (this._validators === null) {
			this._validators = this.createValidators();
		}
		return this._validators;
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {Array}
	 */
	getActiveValidators: function (attribute) {
		var validators = [];
		var scenario = this.getScenario();

		Jii._.each(this.getValidators(), function (validator) {
			if (!validator.isActive(scenario)) {
				return;
			}

			if (attribute && Jii._.indexOf(validator.attributes, attribute) === -1) {
				return;
			}

			validators.push(validator);
		});

		return validators;
	},

	/**
	 * Validate model by rules, see rules() method.
	 * @param {Array} [attributes]
	 * @param {Boolean} [isClearErrors]
	 */
	validate: function (attributes, isClearErrors) {
		if (Jii._.isUndefined(isClearErrors)) {
			isClearErrors = true;
		}
		if (!attributes) {
			attributes = this.activeAttributes();
		}

		var scenarios = this.scenarios();
		var scenario = this.getScenario();
		if (!Jii._.has(scenarios, scenario)) {
			throw new Jii.exceptions.ApplicationException('Unknown scenario `' + scenario + '`.');
		}

		if (isClearErrors) {
			this.clearErrors();
		}

		return Promise.resolve(this.beforeValidate())
			.then(Jii._.bind(function (bool) {
				if (!bool) {
					return Promise.resolve(false);
				}

				var promises = Jii._.map(this.getActiveValidators(), Jii._.bind(function (validator) {
					return validator.validate(this, attributes);
				}, this));
				return Promise.all(promises);
			}, this))
			.then(this.afterValidate)
			.then(Jii._.bind(function () {
				if (this.hasErrors()) {
					return Promise.resolve(false);
				}

				// Return result
				return Promise.resolve(true);
			}, this));
	},

	addError: function (attribute, error) {
		if (!this._errors[attribute]) {
			this._errors[attribute] = [];
		}

		this._errors[attribute].push(error);
	},

	setErrors: function (errors) {
		this._errors = errors;
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	getErrors: function (attribute) {
		return !attribute ? this._errors : this._errors[attribute] || {};
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	hasErrors: function (attribute) {
		return attribute ? Jii._.has(this._errors, attribute) : !Jii._.isEmpty(this._errors);
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	clearErrors: function (attribute) {
		if (!attribute) {
			this._errors = {};
		} else if (this._errors) {
			delete this._errors[attribute];
		}
	},

	beforeValidate: function () {
		return true;
	},

	afterValidate: function () {
	},

	/**
	 * Returns a value indicating whether the attribute is required.
	 * This is determined by checking if the attribute is associated with a
	 * [[\jii\validators\RequiredValidator|required]] validation rule in the
	 * current [[scenario]].
	 *
	 * Note that when the validator has a conditional validation applied using
	 * [[\jii\validators\RequiredValidator.when|when]] this method will return
	 * `false` regardless of the `when` condition because it may be called be
	 * before the model is loaded with data.
	 *
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is required
	 */
	isAttributeRequired: function (attribute) {
		var bool = false;
		Jii._.each(this.getActiveValidators(attribute), Jii._.bind(function(validator) {
			if (validator instanceof Jii.validators.RequiredValidator && validator.when === null) {
				bool = true;
			}
		}, this));
		return bool;
	},

	/**
	 * Returns a value indicating whether the attribute is safe for massive assignments.
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is safe for massive assignments
	 * @see safeAttributes()
	 */
	isAttributeSafe: function (attribute) {
		return Jii._.indexOf(this.safeAttributes(), attribute) !== -1;
	},

	/**
	 * Returns a value indicating whether the attribute is active in the current scenario.
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is active in the current scenario
	 * @see activeAttributes()
	 */
	isAttributeActive: function (attribute) {
		return Jii._.indexOf(this.activeAttributes(), attribute) !== -1;
	},

	/**
	 * Returns the first error of every attribute in the model.
	 * @returns {object} the first errors. The array keys are the attribute names, and the array
	 * values are the corresponding error messages. An empty array will be returned if there is no error.
	 * @see getErrors()
	 * @see getFirstError()
	 */
	getFirstErrors: function () {
		if (Jii._.isEmpty(this._errors)) {
			return {};
		}

		var errors = {};
		Jii._.each(this._errors, Jii._.bind(function(es, name) {
			if (es.length > 0) {
				errors[name] = es[0];
			}
		}, this));

		return errors;
	},

	/**
	 * Returns the first error of the specified attribute.
	 * @param {string} attribute attribute name.
	 * @returns {string} the error message. Null is returned if no error.
	 * @see getErrors()
	 * @see getFirstErrors()
	 */
	getFirstError: function (attribute) {
		return Jii._.has(this._errors, attribute) ? this._errors[attribute][0] : null;
	},

	/**
	 * Generates a user friendly attribute label based on the give attribute name.
	 * This is done by replacing underscores, dashes and dots with blanks and
	 * changing the first letter of each word to upper case.
	 * For example, 'department_name' or 'DepartmentName' will generate 'Department Name'.
	 * @param {string} name the column name
	 * @returns {string} the attribute label
	 */
	generateAttributeLabel: function (name) {
		return Jii._s.humanize(name);
	}

});

},{"jii":124}],101:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.ModelAttributeSchema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.ModelAttributeSchema', /** @lends Jii.base.ModelAttributeSchema.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {string} name of this column (without quotes).
	 */
	name: null,

	/**
	 * @var {string} abstract type of this column. Possible abstract types include:
	 * string, text, boolean, smallint, integer, bigint, float, decimal, datetime,
	 * timestamp, time, date, binary, and money.
	 */
	type: null,

	/**
	 * @var {string} the JS type of this column. Possible JS types include:
	 * string, boolean, number, double.
	 */
	jsType: null,

	/**
	 * @var {*} default value of this column
	 */
	defaultValue: null,

	/**
	 * @var {boolean} whether this column is a primary key
	 */
	isPrimaryKey: false,

	/**
	 * Converts the input value according to [[jsType]].
	 * If the value is null or an [[Expression]], it will not be converted.
	 * @param {*} value input value
	 * @return {*} converted value
	 */
	typecast: function(value) {
		if (value === '' && this.type !== Jii.sql.BaseSchema.TYPE_TEXT &&
			this.type !== Jii.sql.BaseSchema.TYPE_STRING &&
			this.type !== Jii.sql.BaseSchema.TYPE_BINARY) {
			return null;
		}

		// @todo php->js types
		if (value === null || typeof(value) === this.jsType || value instanceof Jii.sql.Expression) {
			return value;
		}

		switch (this.jsType) {
			case 'string':
				return String(value);

			case 'number':
				return Jii._.isBoolean(value) ?
					(value ? 1 : 0) :
					parseFloat(value);

			case 'boolean':
				return !!value;
		}

		return value;
	},

    toJSON: function() {
        var obj = {};

        if (this.defaultValue !== null) {
            obj.defaultValue = this.defaultValue;
        }
        if (this.isPrimaryKey) {
            obj.isPrimaryKey = this.isPrimaryKey;
        }
        if (this.jsType !== null) {
            obj.jsType = this.jsType;
        }
        if (this.name !== null) {
            obj.name = this.name;
        }

        if (Jii._.isEmpty(obj)) {
            return this.type;
        }

        if (this.type !== null) {
            obj.type = this.type;
        }
        return obj;
    }

});

},{"jii":124}],102:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.ModelSchema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.ModelSchema', /** @lends Jii.base.ModelSchema.prototype */{

	__extends: Jii.base.Object,

    __static: /** @lends Jii.base.ModelSchema */{

        /**
         *
         * @param {object} obj
         * @returns {Jii.base.ModelSchema}
         */
        createFromObject: function(obj) {
            Jii._.each(obj.columns, function(column, name) {
                if (!(column instanceof Jii.base.ModelAttributeSchema)) {
                    if (Jii._.isString(column)) {
                        if (Jii._.isNumber(name)) {
                            var parts = column.split(':');
                            column = {
                                name: parts[0],
                                type: 'string'
                            };
                        } else {
                            column = {
                                name: name,
                                type: column
                            }
                        }
                    }

                    if (!Jii._.isObject(column)) {
                        throw new Jii.exceptions.InvalidConfigException('Invalid column format: ' + column);
                    }
                    if (!Jii._.isString(name)) {
                        column.name = name;
                    }
                    obj.columns[name] = new Jii.base.ModelAttributeSchema(column);
                }
            }.bind(this));

            return new Jii.base.ModelSchema(obj);
        }

    },

	/**
	 * @var {string} the name of the schema that this table belongs to.
	 */
	schemaName: '',

	/**
	 * @var {string[]} primary keys of this table.
	 */
	primaryKey: [],

	/**
	 * @var {{string: Jii.base.ModelAttributeSchema}} column metadata of this table. Each array element is a [[Jii.base.ModelAttributeSchema]] object, indexed by column names.
	 */
	columns: {},

	/**
	 * Gets the named column metadata.
	 * This is a convenient method for retrieving a named column even if it does not exist.
	 * @param {string} name column name
	 * @return {Jii.base.ModelAttributeSchema} metadata of the named column. Null if the named column does not exist.
	 */
	getColumn: function (name) {
		return Jii._.has(this.columns, name) ? this.columns[name] : null;
	},

	/**
	 * Returns the names of all columns in this table.
	 * @return {[]} list of column names
	 */
	getColumnNames: function () {
		return Jii._.keys(this.columns);
	},

    toJSON: function() {
        var obj = {};

        if (!Jii._.isEmpty(this.primaryKey)) {
            obj.primaryKey = this.primaryKey;
        }
        if (!Jii._.isEmpty(this.schemaName)) {
            obj.schemaName = this.schemaName;
        }
        if (!Jii._.isEmpty(this.columns)) {
            obj.columns = {};
            Jii._.each(this.columns, function(column, name) {
                obj.columns[name] = column.toJSON();
            });
        }

        return obj;
    }

});

},{"jii":124}],103:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * ArrayDataProvider implements a data provider based on a data array.
 *
 * The [[allModels]] property contains all data models that may be sorted and/or paginated.
 * ArrayDataProvider will provide the data after sorting and/or pagination.
 * You may configure the [[sort]] and [[pagination]] properties to
 * customize the sorting and pagination behaviors.
 *
 * Elements in the [[allModels]] array may be either objects (e.g. model objects)
 * or associative arrays (e.g. query results of DAO).
 * Make sure to set the [[key]] property to the name of the field that uniquely
 * identifies a data record or false if you do not have such a field.
 *
 * Compared to [[ActiveDataProvider]], ArrayDataProvider could be less efficient
 * because it needs to have [[allModels]] ready.
 *
 * @class Jii.base.ArrayDataProvider
 * @extends Jii.base.DataProvider
 */
Jii.defineClass('Jii.base.ArrayDataProvider', /** @lends Jii.base.ArrayDataProvider.prototype */{

    __extends: Jii.base.DataProvider,

    /**
     * @type {string|function} the column that is used as the key of the data models.
     * This can be either a column name, or a callable that returns the key value of a given data model.
     * If this is not set, the index of the [[models]] array will be used.
     * @see getKeys()
     */
    key: null,

    /**
     * @type {[]} the data that is not paginated or sorted. When pagination is enabled,
     * this property usually contains more elements than [[models]].
     * The array elements must use zero-based integer keys.
     */
    allModels: null,

    /**
     * @inheritdoc
     */
    _prepareModels: function () {
        var models = this.allModels;
        if (models === null) {
            return [];
        }

        // @todo Pagination & Sort
        /*var sort = this.getSort();
        if (sort !== false) {
            models = this._sortModels(Jii._.clone(models), sort);
        }

        var pagination = this.getPagination();
        if (pagination !== false) {
            pagination.totalCount = this.getTotalCount();

            if (pagination.getPageSize() > 0) {
                models = array_slice(models, pagination.getOffset(), pagination.getLimit(), true);
            }
        }*/

        return models;
    },

    /**
     * @inheritdoc
     */
    _prepareKeys: function (models) {
        if (this.key !== null) {
            return Jii._.map(models, function(model) {
                if (Jii._.isString(this.key)) {
                    return model[this.key];
                }
                return this.key.call(null, model);
            }.bind(this));
        }

        return Jii._.keys(models);
    },

    /**
     * @inheritdoc
     */
    _prepareTotalCount: function () {
        return this.allModels.length;
    },

    /**
     * Sorts the data models according to the given sort definition
     * @param {[]} models the models to be sorted
     * @param {jii.data.Sort} sort the sort definition
     * @returns {[]} the sorted data models
     */
    _sortModels: function (models, sort) {
        // @todo Pagination & Sort
        /*var orders = sort.getOrders();
        if (!Jii._.isEmpty(orders)) {
            ArrayHelper.multisort(models, array_keys(orders), array_values(orders));
        }

        return models;*/
    }

});

},{"jii":124}],104:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./ChangeEvent');

/**
 * @class Jii.model.ChangeAttributeEvent
 * @extends Jii.model.ChangeEvent
 */
Jii.defineClass('Jii.model.ChangeAttributeEvent', /** @lends Jii.model.ChangeAttributeEvent.prototype */{

	__extends: Jii.model.ChangeEvent,

    /**
     * @type {string}
     */
    attribute: '',

    /**
     * @type {*}
     */
    oldValue: null,

    /**
     * @type {*}
     */
    newValue: null

});

},{"./ChangeEvent":105,"jii":124}],105:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.ChangeEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.ChangeEvent', /** @lends Jii.model.ChangeEvent.prototype */{

	__extends: Jii.base.Event,

    changedAttributes: {}

});

},{"jii":124}],106:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.CollectionEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.CollectionEvent', /** @lends Jii.model.CollectionEvent.prototype */{

	__extends: Jii.base.Event,

    /**
     *
     * @type {Jii.base.Model[]}
     */
    added: [],

    /**
     *
     * @type {Jii.base.Model[]}
     */
    removed: []

});

},{"jii":124}],107:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.LinkModelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.LinkModelEvent', /** @lends Jii.model.LinkModelEvent.prototype */{

	__extends: Jii.base.Event,

    /**
     * Relation name
     * @type {string}
     */
    relationName: null

});

},{"jii":124}],108:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.BooleanValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.BooleanValidator', /** @lends Jii.validators.BooleanValidator.prototype */{

	__extends: Jii.validators.Validator,

    trueValue: '1',

    falseValue: '0',

    strict: false,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message, {
                trueValue: this.trueValue,
                falseValue: this.falseValue
            });
        }
    },

    validateValue: function(value) {
        if (this.strict) {
            return value === this.trueValue || value === this.falseValue;
        } else {
            return value == this.trueValue || value == this.falseValue;
        }
    }

});

},{"./Validator":122,"jii":124}],109:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.CompareValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.CompareValidator', /** @lends Jii.validators.CompareValidator.prototype */{

	__extends: Jii.validators.Validator,

    compareAttribute: null,

    compareValue: null,

    operator: '==',

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var compareLabel = null;
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, Jii.t('{attribute} is invalid.'));
            return;
        }

        if (this.compareValue === null) {
            if (this.compareAttribute === null) {
                this.compareAttribute = attribute + '_repeat';
            }
            compareLabel = object.getAttributeLabel(this.compareAttribute);
            this.compareValue = object.get(this.compareAttribute);
        } else {
            compareLabel = this.compareValue;
        }

        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message, {
                compareAttribute: compareLabel,
                compareValue: this.compareValue
            });
        }
    },

    validateValue: function(value) {
        if (!this.compareValue) {
            throw new Jii.exceptions.ApplicationException('CompareValidator::compareValue must be set.');
        }

        switch (this.operator) {
            case '==': return this.compareValue == value;
            case '===': return this.compareValue === value;
            case '!=': return this.compareValue != value;
            case '!==': return this.compareValue !== value;
            case '>': return this.compareValue > value;
            case '>=': return this.compareValue >= value;
            case '<': return this.compareValue < value;
            case '<=': return this.compareValue <= value;
        }
        return false;
    }

});

},{"./Validator":122,"jii":124}],110:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.DateValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.DateValidator', /** @lends Jii.validators.DateValidator.prototype */{

	__extends: Jii.validators.Validator,

	format: 'Y-m-d',

    timestampAttribute: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', 'The format of {attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, this.message);
            return;
        }

        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        } else if (this.timestampAttribute !== null) {
            // @todo Parse by format
            var timestamp = Date.parse(value);
            object.set(this.timestampAttribute, Math.round(timestamp / 1000));
        }
    },

    validateValue: function(value) {
        // @todo Validate by format
        var timestamp = Date.parse(value);
        return !Jii._.isNaN(timestamp);
    }

});

},{"./Validator":122,"jii":124}],111:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.DefaultValueValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.DefaultValueValidator', /** @lends Jii.validators.DefaultValueValidator.prototype */{

	__extends: Jii.validators.Validator,

	value: null,

    skipOnEmpty: false,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        if (this.isEmpty(object.get(attribute))) {
            object.set(attribute, this.value);
        }

    }

});

},{"./Validator":122,"jii":124}],112:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.EmailValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.EmailValidator', /** @lends Jii.validators.EmailValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: /^[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/,

    fullPattern: /^[^@]*<[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?>$/,

    allowName: false,

    init: function () {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is not a valid email address.');
        }
    },

    validateAttribute: function (object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function (value) {
        if (!Jii._.isString(value) || value.length > 320) {
            return false;
        }

        return this.pattern.test(value) || (this.allowName && this.fullPattern.test(value));
    }

});

},{"./Validator":122,"jii":124}],113:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.FilterValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.FilterValidator', /** @lends Jii.validators.FilterValidator.prototype */{

	__extends: Jii.validators.Validator,

	filter: null,

    skipOnEmpty: false,

    init: function() {
        this.__super();
        if (this.filter === null) {
            throw new Jii.exceptions.ApplicationException('The `filter` property must be set.');
        }
    },

    validateAttribute: function(object, attribute) {
        object.set(attribute, this.filter.call(object, object.get(attribute)));
    }

});

},{"./Validator":122,"jii":124}],114:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.InlineValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.InlineValidator', /** @lends Jii.validators.InlineValidator.prototype */{

	__extends: Jii.validators.Validator,

	method: null,

    params: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var method = object[this.method];

        if (!Jii._.isFunction(method)) {
            throw new Jii.exceptions.ApplicationException('Not find method `' + this.method + '` in model `' + object.debugClassName + '`.');
        }

        return method.call(object, attribute, this.params || {});
    }

});

},{"./Validator":122,"jii":124}],115:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.NumberValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.NumberValidator', /** @lends Jii.validators.NumberValidator.prototype */{

	__extends: Jii.validators.Validator,

	integerOnly: false,

    max: null,

    min: null,

    tooBig: null,

    tooSmall: null,

    integerPattern: /^\s*[+-]?\d+\s*$/,

    numberPattern: /^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/,

    init: function() {
        this.__super();

        if (this.message === null) {
            this.message = this.integerOnly ?
                Jii.t('jii', '{attribute} must be an integer.') :
                Jii.t('jii', '{attribute} must be an number.');
        }
        if (this.min !== null && this.tooSmall === null) {
            this.tooSmall = Jii.t('jii', '{attribute} must be no less than {min}.');
        }
        if (this.max !== null && this.tooBig === null) {
            this.tooBig = Jii.t('jii', '{attribute} must be no greater than {max}.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, Jii.t('{attribute} is invalid.'));
            return;
        }

        var pattern = this.integerOnly ? this.integerPattern : this.numberPattern;
        if (!pattern.test(value)) {
            this.addError(object, attribute, this.message);
        }

        if (this.min !== null && value < this.min) {
            this.addError(object, attribute, this.tooSmall, {
                min: this.min
            });
        }
        if (this.max !== null && value > this.max) {
            this.addError(object, attribute, this.tooBig, {
                max: this.max
            });
        }
    },

    validateValue: function(value) {
        var pattern = this.integerOnly ? this.integerPattern : this.numberPattern;
        return pattern.test(value) &&
            (this.min === null || value >= this.min) &&
            (this.max === null || value <= this.max);
    }

});

},{"./Validator":122,"jii":124}],116:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RangeValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RangeValidator', /** @lends Jii.validators.RangeValidator.prototype */{

	__extends: Jii.validators.Validator,

	range: null,

    strict: false,

    not: false,

    init: function() {
        this.__super();

        if (!Jii._.isArray(this.range)) {
            throw new Jii.exceptions.ApplicationException('The `range` property must be set.');
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function(value) {
        var isFined = false;

        Jii._.each(this.range, Jii._.bind(function(item) {
            if (this.strict && value === item) {
                isFined = true;
                return false;
            }

            if (!this.strict && value == item) {
                isFined = true;
                return false;
            }
        }, this));

        return !this.not ? isFined : !isFined;
    }

});

},{"./Validator":122,"jii":124}],117:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RegularExpressionValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RegularExpressionValidator', /** @lends Jii.validators.RegularExpressionValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: null,

    not: false,

    init: function() {
        this.__super();

        if (!Jii._.isRegExp(this.pattern)) {
            throw new Jii.exceptions.ApplicationException('The `pattern` property must be set.');
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function(value) {
        var isMatch = this.pattern.test(value);
        return !this.not ? isMatch : !isMatch;
    }

});

},{"./Validator":122,"jii":124}],118:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RequiredValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RequiredValidator', /** @lends Jii.validators.RequiredValidator.prototype */{

	__extends: Jii.validators.Validator,

	skipOnEmpty: false,

    requiredValue: null,

    strict: false,

    init: function () {
        this.__super();
        if (this.message === null) {
            this.message = this.requiredValue === null ?
                Jii.t('jii', '{attribute} cannot be blank.') :
                Jii.t('jii', '{attribute} must be `{requiredValue}`.');
        }
    },

    validateAttribute: function (object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            var params = this.requiredValue !== null ? {requiredValue: this.requiredValue} : {};
            this.addError(object, attribute, this.message, params);
        }
    },

    validateValue: function (value) {
        if (this.requiredValue === null) {
            return this.strict ? value !== null : !this.isEmpty(value, true);
        }
        return this.strict ? value !== this.requiredValue : value != this.requiredValue;
    }

});

},{"./Validator":122,"jii":124}],119:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.SafeValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.SafeValidator', /** @lends Jii.validators.SafeValidator.prototype */{

	__extends: Jii.validators.Validator,

	validateAttribute: function(object, attribute) {
    }

});

},{"./Validator":122,"jii":124}],120:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.StringValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.StringValidator', /** @lends Jii.validators.StringValidator.prototype */{

	__extends: Jii.validators.Validator,

	length: null,

    max: null,

    min: null,

    tooLong: null,

    tooShort: null,

    notEqual: null,

    init: function() {
        this.__super();

        if (Jii._.isArray(this.length)) {
            if (this.length[0]) {
                this.min = this.length[0];
            }
            if (this.length[1]) {
                this.max = this.length[1];
            }
            this.length = null;
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} must be a string.');
        }
        if (this.min !== null && this.tooShort === null) {
            this.tooShort = Jii.t('jii', '{attribute} should contain at least {min} characters.');
        }
        if (this.max !== null && this.tooLong === null) {
            this.tooLong = Jii.t('jii', '{attribute} should contain at most {max} characters.');
        }
        if (this.length !== null && this.notEqual === null) {
            this.notEqual = Jii.t('jii', '{attribute} should contain {length} characters.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (!Jii._.isString(value)) {
            this.addError(object, attribute, this.message);
            return;
        }

        var length = value.length;

        if (this.min !== null && length < this.min) {
            this.addError(object, attribute, this.tooShort, {
                min: this.min
            });
        }
        if (this.max !== null && length > this.max) {
            this.addError(object, attribute, this.tooLong, {
                max: this.max
            });
        }
        if (this.length !== null && length !== this.length) {
            this.addError(object, attribute, this.notEqual, {
                length: this.length
            });
        }
    },

    validateValue: function(value) {
        if (!Jii._.isString(value)) {
            return false;
        }

        var length = value.length;
        return (this.min === null || length >= this.min) &&
            (this.max === null || length <= this.max) &&
            (this.length === null || length === this.length);
    }

});

},{"./Validator":122,"jii":124}],121:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.UrlValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.UrlValidator', /** @lends Jii.validators.UrlValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: /^{schemes}:\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)/i,

    validSchemes: [
        'http',
        'https'
    ],

    defaultScheme: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is not a valid URL.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        } else if (this.defaultScheme !== null && value.indexOf('://') === -1) {
            object.set(attribute, this.defaultScheme + '://' + value);
        }
    },

    validateValue: function(value) {
        if (!Jii._.isString(value) || value.length > 2000) {
            return false;
        }

        if (this.defaultScheme !== null && value.indexOf('://') === -1) {
            value = this.defaultScheme + '://' + value;
        }

        var pattern = this.pattern.source;
        pattern = pattern.replace('{schemes}', '(' + this.validSchemes.join('|') + ')');

        var flags = '';
        Jii._.each({global: 'g', ignoreCase: 'i', multiline: 'm'}, Jii._.bind(function(flag, key) {
            if (this.pattern[key]) {
                flags += flag;
            }
        }, this));

        return (new RegExp(pattern, flags)).test(value);
    }

});

},{"./Validator":122,"jii":124}],122:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.validators.Validator
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.validators.Validator', /** @lends Jii.validators.Validator.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.validators.Validator */{

		defaultValidators: {

			'boolean': 'Jii.validators.BooleanValidator',
			'compare': 'Jii.validators.CompareValidator',
			'date': 'Jii.validators.DateValidator',
			'default': 'Jii.validators.DefaultValueValidator',
			'double': 'Jii.validators.NumberValidator',
			'email': 'Jii.validators.EmailValidator',
			//'exist': 'Jii.validators.ExistValidator',
			//'file': 'Jii.validators.FileValidator',
			'filter': 'Jii.validators.FilterValidator',
			//'image': 'Jii.validators.ImageValidator',
			'in': 'Jii.validators.RangeValidator',
			'integer': {
				'className': 'Jii.validators.NumberValidator',
				'integerOnly': true
			},
			'match': 'Jii.validators.RegularExpressionValidator',
			'number': 'Jii.validators.NumberValidator',
			'required': 'Jii.validators.RequiredValidator',
			'safe': 'Jii.validators.SafeValidator',
			'string': 'Jii.validators.StringValidator',
			//'unique': 'Jii.validators.UniqueValidator',
			'url': 'Jii.validators.UrlValidator'
		},

		create: function (type, object, attributes, params) {
			params = params || {};
			params.attributes = attributes;

			if (Jii._.isFunction(object[type])) {
				params.className = 'Jii.validators.InlineValidator';
				params.method = type;
			} else {
				if (Jii._.has(this.defaultValidators, type)) {
					type = this.defaultValidators[type];
				}

				if (Jii._.isArray(type)) {
					Jii._.extend(params, type);
				} else {
					params.className = type;
				}
			}

			return Jii.createObject(params);
		}

	},

    attributes: [],
    message: null,
    on: [],
    except: [],
    skipOnError: true,
    skipOnEmpty: true,
    deferred: null,

    /**
     * @abstract
     * @param object
     * @param attribute
	 * @returns {Promise|null}
     */
    validateAttribute: function (object, attribute) {
    },

    validateValue: function() {
        throw new Jii.exceptions.ApplicationException('Not found implementation for method `validateValue()`.');
    },

    validate: function(object, attributes) {
        attributes = Jii._.isArray(attributes) ?
            Jii._.intersection(this.attributes, attributes) :
            this.attributes;

        var promises = Jii._.map(attributes, Jii._.bind(function(attribute) {
            if (this.skipOnError && object.hasErrors(attribute)) {
                return;
            }

            if (this.skipOnEmpty && this.isEmpty(object.get(attribute))) {
                return;
            }

            return this.validateAttribute(object, attribute);
        }, this));

        return Promise.all(promises);
    },

    isActive: function(scenario) {
        return Jii._.indexOf(this.except, scenario) === -1 &&
            (!this.on || this.on.length === 0 || Jii._.indexOf(this.on, scenario) !== -1);
    },

    addError: function(object, attribute, message, params) {
        params = params || {};
        params.attribute = object.getAttributeLabel(attribute);
        params.value = object.get(attribute);

        // @todo
        //message = Jii.t('jii', message);
        Jii._.each(params, function(value, key) {
            message = message.replace('{' + key + '}', value);
        });

        object.addError(attribute, message);
        Jii.warning('Validation error in model `' + object.className() + '`: ' + message);
    },

    isEmpty: function(value, isTrim) {
        return value === null ||
            value === '' ||
            (isTrim && Jii._.isString(value) && value.replace(/^\s+|\s+$/g, '') === '') ||
            (Jii._.isArray(value) && value.length === 0);
    }


});

},{"jii":124}],123:[function(require,module,exports){
var Jii = require('jii');
Jii._ = require('underscore');
Jii._s = require('underscore.string');

module.exports = Jii;
},{"jii":124,"underscore":161,"underscore.string":160}],124:[function(require,module,exports){
/**
 * Require relations libs and jii files
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = module.exports = window.Jii = require('./lib/Jii');

// Global libraries
Jii._ = window._ || null;
Jii._s = window._s || window.s || (window._ ? window._.string : null) || null;
Jii.isNode = false;

// Load framework files
require('./lib/application/WebApplication');
require('./lib/base/Action');
require('./lib/base/ActionEvent');
require('./lib/base/Application');
require('./lib/base/Behavior');
require('./lib/base/Component');
require('./lib/base/Context');
require('./lib/base/Controller');
require('./lib/base/Event');
require('./lib/base/HttpRequest');
require('./lib/base/ModelEvent');
require('./lib/base/Module');
require('./lib/base/Object');
require('./lib/base/Request');
require('./lib/base/Response');
require('./lib/exceptions/ApplicationException');
require('./lib/exceptions/InvalidCallException');
require('./lib/exceptions/InvalidConfigException');
require('./lib/exceptions/InvalidParamException');
require('./lib/exceptions/InvalidRouteException');
require('./lib/exceptions/NotSupportedException');
require('./lib/exceptions/UnknownPropertyException');
require('./lib/helpers/File');
require('./lib/helpers/String');
require('./lib/helpers/Url');
require('./lib/request/AnonymousAction');
require('./lib/request/HeaderCollection');
require('./lib/request/InlineAction');

},{"./lib/Jii":125,"./lib/application/WebApplication":126,"./lib/base/Action":127,"./lib/base/ActionEvent":128,"./lib/base/Application":129,"./lib/base/Behavior":130,"./lib/base/Component":131,"./lib/base/Context":132,"./lib/base/Controller":133,"./lib/base/Event":134,"./lib/base/HttpRequest":135,"./lib/base/ModelEvent":136,"./lib/base/Module":137,"./lib/base/Object":138,"./lib/base/Request":139,"./lib/base/Response":140,"./lib/exceptions/ApplicationException":141,"./lib/exceptions/InvalidCallException":142,"./lib/exceptions/InvalidConfigException":143,"./lib/exceptions/InvalidParamException":144,"./lib/exceptions/InvalidRouteException":145,"./lib/exceptions/NotSupportedException":146,"./lib/exceptions/UnknownPropertyException":147,"./lib/helpers/File":148,"./lib/helpers/String":149,"./lib/helpers/Url":150,"./lib/request/AnonymousAction":151,"./lib/request/HeaderCollection":152,"./lib/request/InlineAction":153}],125:[function(require,module,exports){
(function (process,__dirname){
/**
 * Jii â€” Full-Stack JavaScript Framework based on PHP Yii 2 Framework architecture.
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

var Neatness = require('neatness').newContext();

/**
 * @namespace
 * @alias module:jii
 */
var Jii = Neatness.namespace('Jii');

/**
 * @class Jii
 */
Jii = Neatness.defineClass('Jii', {

	__static: /** @lends Jii */{

		/**
		 * @alias lodash
		 */
		_: null,

		/**
		 * @alias _s
		 */
		_s: null,

		/**
		 * @type module:when
		 */
		when: null,

		/**
		 * @type {Jii.base.Application}
		 */
		app: null,

		/**
		 * @type {object}
		 */
		aliases: null,

		/**
		 * True, if running in node js
		 * @type {boolean}
		 */
		isNode: false,

		_contextConfig: null,

		/**
		 * Returns framework version
		 * @returns {string}
		 */
		getVersion: function () {
			return require('../package.json').version;
		},

		/**
		 * Get class by full namespace.
		 * @param {string} name
		 * @returns {function|object}
		 */
		namespace: function (name) {
			return Jii._.isString(name) ? Neatness.namespace.apply(Neatness, arguments) : name;
		},

		/**
		 * Move namespace to other object
		 * @param {object} newContext
		 * @param {boolean} [removeFromOld]
		 * @returns {*|Function|Object}
		 */
		namespaceMoveContext: function (newContext, removeFromOld) {
			return Neatness.moveContext.apply(Neatness, arguments);
		},

		/**
		 * Method for define class. Options object will be converter to class prototype.
		 * For set static properties and methods, set param `__static` as object with properties and methods.
		 * For extends from class, set `__extends` property as extended class (function). Example format:
		 *    {
		 *      __extends: Jii.base.Object,
		 *      __static: {
		 *          staticParam: 10,
		 *          MY_CONSTANT: 'constant',
		 *          normalizeName: function() {},
		 *      },
		 *      prototypeParam: 20,
		 *      getName: function() {}
		 * }
		 * @param {string} globalName
		 * @param {object} options
		 * @return {object}
		 */
		defineClass: function (globalName, options) {
			return Neatness.defineClass.apply(Neatness, arguments);
		},

		/**
		 * Create web application, which available by Jii.app
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createWebApplication: function (config) {
			return this.createApplication('Jii.application.WebApplication', config);
		},

		/**
		 * Create console application, which available by Jii.app
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createConsoleApplication: function (config) {
			return this.createApplication('Jii.application.ConsoleApplication', config);
		},

		/**
		 * Main method which create application by class name and config.
		 * @param {string} className
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createApplication: function(className, config) {
			config = config || {};
			config.application = config.application || {};

			// Save context config
			this._contextConfig = config.context || {};

			var ApplicationClass = this.namespace(className);
			if (!Jii._.isFunction(ApplicationClass)) {
				throw new Jii.exceptions.InvalidParamException('Not found application class: ' + className);
			}

			// Init aliases
			this.aliases = {};
			if (this.isNode) {
				this.aliases['@jii'] = __dirname;
			}

			// Create application instance
			return new ApplicationClass(config.application);
		},

		/**
		 * Main method which create application by class name and config.
		 * @param {object} config
		 * @returns {Jii.base.Context}
		 */
		createContext: function(config) {
			config = config || {};

			// Merge with default context config
            config = this.mergeConfigs(this._contextConfig || {}, config);

			if (config.className) {
				var ContextClass = this.namespace(config.className);
				if (!Jii._.isFunction(ContextClass)) {
					throw new Jii.exceptions.InvalidParamException('Not found context class: ' + className);
				}

				return new ContextClass(config);
			}

			return new Jii.base.Context(config);
		},

		/**
		 * Translates a path alias into an actual path.
		 *
		 * The translation is done according to the following procedure:
		 *
		 * 1. If the given alias does not start with '@', it is returned back without change;
		 * 2. Otherwise, look for the longest registered alias that matches the beginning part
		 *    of the given alias. If it exists, replace the matching part of the given alias with
		 *    the corresponding registered path.
		 * 3. Throw an exception or return false, depending on the `$throwException` parameter.
		 *
		 * For example, by default '@jii' is registered as the alias to the Jii framework directory,
		 * say '/path/to/jii'. The alias '@jii/web' would then be translated into '/path/to/jii/web'.
		 *
		 * If you have registered two aliases '@foo' and '@foo/bar'. Then translating '@foo/bar/config'
		 * would replace the part '@foo/bar' (instead of '@foo') with the corresponding registered path.
		 * This is because the longest alias takes precedence.
		 *
		 * However, if the alias to be translated is '@foo/barbar/config', then '@foo' will be replaced
		 * instead of '@foo/bar', because '/' serves as the boundary character.
		 *
		 * Note, this method does not check if the returned path exists or not.
		 *
		 * @param {string} alias the alias to be translated.
		 * @param {boolean} [throwException] whether to throw an exception if the given alias is invalid.
		 * If this is false and an invalid alias is given, false will be returned by this method.
		 * @return {string|boolean} the path corresponding to the alias, false if the root alias is not previously registered.
		 * @throws {Jii.exceptions.InvalidParamException} if the alias is invalid while throwException is true.
		 * @see setAlias()
		 */
		getAlias: function (alias, throwException) {
			if (Jii._.isUndefined(throwException)) {
				throwException = true;
			}

			if (alias.indexOf('@') !== 0) {
				return alias;
			}

			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (Jii._.has(this.aliases, root)) {
				if (Jii._.isString(this.aliases[root])) {
					return this.aliases[root] + (index !== -1 ? alias.substr(index) : '');
				}

				var finedPath = null;
				Jii._.each(this.aliases[root], function (path, name) {
					var testAlias = alias + '/';
					if (testAlias.indexOf(name + '/') === 0) {
						finedPath = path + alias.substr(name.length);
						return false;
					}
				});
				if (finedPath !== null) {
					return finedPath;
				}
			}

			if (throwException) {
				throw new Jii.exceptions.InvalidParamException('Invalid path alias: ' + alias);
			}
			return false;
		},

		/**
		 * Returns the root alias part of a given alias.
		 * A root alias is an alias that has been registered via [[setAlias()]] previously.
		 * If a given alias matches multiple root aliases, the longest one will be returned.
		 * @param {string} alias the alias
		 * @return {string|boolean} the root alias, or false if no root alias is found
		 */
		getRootAlias: function (alias) {
			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (Jii._.has(this.aliases, root)) {
				if (Jii._.isString(this.aliases[root])) {
					return root;
				}

				var finedPath = null;
				Jii._.each(this.aliases[root], function (path, name) {
					if (Jii._.indexOf(alias + '/', name + '/') === 0) {
						finedPath = name;
						return false;
					}
				});
				if (finedPath !== null) {
					return finedPath;
				}
			}

			return false;
		},

		/**
		 * Registers a path alias.
		 *
		 * A path alias is a short name representing a long path (a file path, a URL, etc.)
		 * For example, we use '@jii' as the alias of the path to the Jii framework directory.
		 *
		 * A path alias must start with the character '@' so that it can be easily differentiated
		 * from non-alias paths.
		 *
		 * Note that this method does not check if the given path exists or not. All it does is
		 * to associate the alias with the path.
		 *
		 * Any trailing '/' and '\' characters in the given path will be trimmed.
		 *
		 * @param {string} alias the alias name (e.g. "@jii"). It must start with a '@' character.
		 * It may contain the forward slash '/' which serves as boundary character when performing
		 * alias translation by [[getAlias()]].
		 * @param {string} path the path corresponding to the alias. Trailing '/' and '\' characters
		 * will be trimmed. This can be
		 *
		 * - a directory or a file path (e.g. `/tmp`, `/tmp/main.txt`)
		 * - a URL (e.g. `http://example.com`)
		 * - a path alias (e.g. `@jii/base`). In this case, the path alias will be converted into the
		 *   actual path first by calling [[getAlias()]].
		 *
		 * @throws {Jii.exceptions.InvalidParamException} if $path is an invalid alias.
		 * @see getAlias()
		 */
		setAlias: function (alias, path) {
			if (alias.indexOf('@') !== 0) {
				alias = '@' + alias;
			}

			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (path !== null) {
				path = alias.indexOf('@') !== 0 ? Jii._s.rtrim(path, '/') : this.getAlias(path);

				if (!Jii._.has(this.aliases, root)) {
					if (index === -1) {
						this.aliases[root] = path;
					} else {
						this.aliases[root] = {};
						this.aliases[root][alias] = path;
					}
				} else if (Jii._.isString(this.aliases[root])) {
					if (index === -1) {
						this.aliases[root] = path;
					} else {
						var oldPath = this.aliases[root];
						this.aliases[root] = {};
						this.aliases[root][alias] = path;
						this.aliases[root][root] = oldPath;
					}
				} else {
					this.aliases[root][alias] = path;
					//krsort(static::$aliases[$root]);
				}
			} else if (Jii._.has(this.aliases, root)) {
				if (Jii._.isObject(this.aliases[root])) {
					delete this.aliases[root][alias];
				} else if (index === -1) {
					delete this.aliases[root];
				}
			}
		},

		/**
		 * Creates a new instance using the given configuration.
		 * @param {string|object} config Class name or object with param `className`
		 * @returns {object}
		 */
		createObject: function (config) {
			var className = null;

			// Normalize config
			if (Jii._.isString(config)) {
				className = config;
				config = {};
			} else if (Jii._.has(config, 'className')) {
				config = Jii._.clone(config);
				className = config.className;
				delete config.className;
			} else {
				throw new Jii.exceptions.ApplicationException('Wrong configuration for create object.');
			}

			// Get class
			var objectClass = Jii.namespace(className);
			if (!Jii._.isFunction(objectClass)) {
				throw new Jii.exceptions.ApplicationException('Not found class `' + className + '` for create instance.');
			}

			// Arguments for constructor of class
			var args = [objectClass];
			args = args.concat(Jii._.rest(arguments));
			if (!Jii._.isEmpty(config)) {
				args.push(config);
			}

			// @todo Support old browsers (bind function)
			return new (objectClass.bind.apply(objectClass, args))();
		},

		/**
		 * Set configuration to object. This method find public param in object or setter method.
		 * You can not use setter and public param at the same time for safety reason
		 * @param {Jii.base.Object} object Class instance
		 * @param {object} config Configuration object {key: value, ..}
		 */
		configure: function (object, config) {
			for (var key in config) {
				if (!config.hasOwnProperty(key)) {
					continue;
				}

                if (object instanceof Jii.base.Component) {
                    object.set(key, config[key]);
                    continue;
                }

				// Generate setter name
				var setter = 'set' + Jii._s.capitalize(key);

				if (!Jii._.isFunction(object[setter])) {
					if (Jii._.isFunction(object[key])) {
						throw new Jii.exceptions.InvalidConfigException('You can not replace from config function `' + key + '` in object `' + object.className() + '`.');
					}

					if (Jii._.isUndefined(object[key])) {
						throw new Jii.exceptions.InvalidConfigException('Config param `' + key + '` is undefined in object `' + object.className() + '`.');
					}
				}

				if (!Jii._.isUndefined(object[key]) && !Jii._.isFunction(object[key]) && Jii._.isFunction(object[setter])) {
					throw new Jii.exceptions.InvalidConfigException('You have two setters (function and public param) for config param `' + key + '` in object `' + object.className() + '`.  Please change param access (to `_' + key + '`) or remove setter method.');
				}

				if (!Jii._.isUndefined(object[key]) && !Jii._.isFunction(object[key])) {
					if (Jii._.isObject(object[key]) && Jii._.isObject(config[key]) && !Jii._.isArray(object[key]) && !Jii._.isArray(config[key])) {
						object[key] = Jii.mergeConfigs(object[key], config[key]);
					} else {
						object[key] = config[key];
					}
				} else if (Jii._.isFunction(object[setter])) {
					object[setter].call(object, config[key]);
				}
			}
		},

		/**
		 * Logs a trace message.
		 * Trace messages are logged mainly for development purpose to see
		 * the execution work flow of some code.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		trace: function (message, category) {
			category = category || '';

			console.log(message);
			//if (YII_DEBUG) {
				// @todo static.getLogger().log(message, Logger.LEVEL_TRACE, category);
			//}
		},

		/**
		 * Logs an error message.
		 * An error message is typically logged when an unrecoverable error occurs
		 * during the execution of an application.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		error: function (message, category) {
			category = category || '';

			console.error(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_ERROR, category);
		},

		/**
		 * Logs a warning message.
		 * A warning message is typically logged when an error occurs while the execution
		 * can still continue.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		warning: function (message, category) {
			category = category || '';

			console.warn(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_WARNING, category);
		},

		/**
		 * Logs an informative message.
		 * An informative message is typically logged by an application to keep record of
		 * something important (e.g. an administrator logs in).
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		info: function (message, category) {
			category = category || '';

			console.info(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_INFO, category);
		},

		/**
		 * Short alias for translate texts
		 * @param group
		 * @param [message]
		 * @returns {*}
		 */
		t: function (group, message) {
			// @todo
			return message;
		},

        /**
         * @param {object} [obj]
         * @param {object} [obj]
         * @param {object} [obj]
         * @param {object} [obj]
         * @returns {object}
         */
        mergeConfigs: function(obj) {
            var dst = {};

            for (var i = 0, ii = arguments.length; i < ii; ++i) {
                var obj = arguments[i];
                if (!Jii._.isObject(obj)) {
                    continue;
                }

                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (Jii._.isObject(obj[key]) && !Jii._.isArray(obj[key]) && !Jii._.isFunction(obj[key])) {
                            dst[key] = this.mergeConfigs(dst[key], obj[key]);
                        } else {
                            dst[key] = obj[key];
                        }
                    }
                }
            }

            return dst;
        },

        catchHandler: function(e) {
            console.error(e.stack || e)
        }
	}

});

// @todo Move to Errors module
process.on('unhandledRejection', function(reason, promise) {
    console.warn("Possibly Unhandled Rejection at: Promise ", promise, " reason: ", reason);
});

/**
 * @module Jii
 */
module.exports = Jii;
}).call(this,require('_process'),"/../../../jii/lib")
},{"../package.json":162,"_process":30,"neatness":154}],126:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Application');

/**
 * @class Jii.application.WebApplication
 * @extends Jii.base.Application
 */
Jii.defineClass('Jii.application.WebApplication', /** @lends Jii.application.WebApplication.prototype */{

	__extends: Jii.base.Application,

	/**
	 * @var {string|boolean} the layout that should be applied for views in this application. Defaults to 'main'.
	 * If this is false, layout will be disabled.
	 */
	layout: 'main',

    defaultRoute: 'site',

	_preInit: function(config) {
		this.__super(config);

		// Set default webroot
		this.setWebPath(config.webPath || this.getBasePath() + '/web');
		this.setWebUrl(config.webUrl || '/');
	},

	/**
	 * @return {String}
	 */
	getWebPath: function () {
		return Jii.getAlias('@webroot');
	},

	/**
	 * @param  {String} path
	 */
	setWebPath: function (path) {
		Jii.setAlias('@webroot', path);
	},

	/**
	 * @return {String}
	 */
	getWebUrl: function () {
		return Jii.getAlias('@web');
	},

	/**
	 * @param  {String} path
	 */
	setWebUrl: function (path) {
		Jii.setAlias('@web', path);
	}

});
},{"../Jii":125,"../base/Application":129}],127:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Action
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Action', /** @lends Jii.base.Action.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {string} ID of the action
	 */
	id: null,

	/**
	 * @type {Jii.base.Controller} the controller that owns this action
	 */
	controller: null,

	constructor: function (id, controller, config) {
		this.id = id;
		this.controller = controller;
		this.__super(config);
	},

	/**
	 * Returns the unique ID of this action among the whole application.
	 * @returns {string} the unique ID of this action among the whole application.
	 */
	getUniqueId: function () {
		return this.controller.getUniqueId() + '/' + this.id;
	},

	/**
	 * @param {Jii.base.Context} context
	 */
	run: function (context) {
	},

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {Promise} the result of the action
	 * @throws {Jii.exceptions.InvalidConfigException} if the action class does not have a run() method
	 */
	runWithParams: function (context) {
		if (!Jii._.isFunction(this.run)) {
			throw new Jii.exceptions.InvalidConfigException(this.debugClassName + ' must define a `run()` method.');
		}

		//Yii::trace('Running action: ' . get_class($this) . '::run()', __METHOD__);

		return Promise.resolve(this.beforeRun(context))
			.then(Jii._.bind(function (bool) {
				if (!bool) {
					return Promise.reject();
				}

				return this.run(context);
			}, this))
			.then(Jii._.bind(function (result) {
				return Promise.resolve(this.afterRun()).then(function () {
					return result;
				});
			}, this));
	},

	/**
	 * This method is called right before `run()` is executed.
	 * You may override this method to do preparation work for the action run.
	 * If the method returns false, it will cancel the action.
	 * @param {Jii.base.Context} context
	 * @return {Promise|boolean} whether to run the action.
	 */
	beforeRun: function (context) {
		return true;
	},

	/**
	 * This method is called right after `run()` is executed.
	 * You may override this method to do post-processing work for the action run.
	 */
	afterRun: function () {
	}

});

},{"../Jii":125,"./Object":138}],128:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Event');

/**
 * @class Jii.base.ActionEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.base.ActionEvent', /** @lends Jii.base.ActionEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {Jii.base.Action}
	 */
	action: null,

	/**
	 * @type {Jii.base.Context}
	 */
	context: null

});

},{"../Jii":125,"./Event":134}],129:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Module');

/**
 * @class Jii.base.Application
 * @extends Jii.base.Module
 */
Jii.defineClass('Jii.base.Application', /** @lends Jii.base.Application.prototype */{

	__extends: Jii.base.Module,

	__static: /** @lends Jii.base.Application */{

		ENVIRONMENT_PRODUCTION: 'production',
		ENVIRONMENT_DEVELOPMENT: 'development',
		ENVIRONMENT_TEST: 'test'

	},

	/**
	 * @type {string} the namespace that controller classes are in. If not set,
	 * it will use the "app\controllers" namespace.
	 */
	controllerNamespace: 'app.controllers',

	/**
	 * @type {string} the application name.
	 */
	name: 'My Application',

	/**
	 * @type {string} the version of this application.
	 */
	version: '1.0',

	/**
	 * @type {string} the charset currently used for the application.
	 */
	charset: 'UTF-8',

	/**
	 * @type {string} the language that is meant to be used for end users.
	 * @see sourceLanguage
	 */
	language: 'en',

	/**
	 * @type {string} the language that the application is written in. This mainly refers to
	 * the language that the messages and view files are written in.
	 * @see language
	 */
	sourceLanguage: 'en',

	/**
	 * The IDs of the components or modules that should be preloaded right after initialization.
	 * @type {string[]}
	 */
	bootstrap: null,

	/**
	 * @type {string}
	 */
	environment: 'development',

	/**
	 * @constructs
	 */
	constructor: function (config) {
		Jii.app = this;

		this.bootstrap = [];

		// Merge with default config
		config = Jii.mergeConfigs(this._getBaseConfig(), config);

		this._preInit(config);
		this._loadBootstrapComponents();

		this.__super(null, null, config);
	},

	/**
	 *
	 * @returns {string}
	 */
	getUniqueId: function () {
		return '';
	},

	/**
	 * Sets the root directory of the application and the @app alias.
	 * This method can only be invoked at the beginning of the constructor.
	 * @param {string} path the root directory of the application.
	 */
	setBasePath: function (path) {
		this.__super(path);
		Jii.setAlias('@app', this.getBasePath());
	},

	/**
	 * Overwrite this method for return default configuration specified for application
	 * @type {object} base application's config.
	 */
	_getBaseConfig: function() {
		return {};
	},

	/**
	 *
	 * @param config
	 * @private
	 */
	_preInit: function (config) {
		if (Jii._.has(config, 'basePath')) {
			this.setBasePath(config.basePath);
			delete config.basePath;
		} else {
			throw new Jii.exceptions.InvalidConfigException('The `basePath` configuration is required.');
		}
	},

	/**
	 * Loads components that are declared in [[bootstrap]].
	 * @throws {Jii.exceptions.InvalidConfigException} if a component or module to be preloaded is unknown
	 */
	_loadBootstrapComponents: function () {
		Jii._.each(this.bootstrap, Jii._.bind(function (id) {
			if (this.hasComponent(id)) {
				this.getComponent(id);
			} else if (this.hasModule(id)) {
				this.getModule(id);
			} else {
				throw new Jii.exceptions.InvalidConfigException("Unknown component or module: " + id);
			}
		}, this));
	}
});

},{"../Jii":125,"./Module":137}],130:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Behavior
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Behavior', /** @lends Jii.base.Behavior.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {Jii.base.Component} the owner of this behavior
	 */
	owner: null,

	/**
	 * Declares event handlers for the [[owner]]'s events.
	 *
	 * Child classes may override this method to declare what callbacks should
	 * be attached to the events of the [[owner]] component.
	 *
	 * The callbacks will be attached to the [[owner]]'s events when the behavior is
	 * attached to the owner; and they will be detached from the events when
	 * the behavior is detached from the component.
	 *
	 * The callbacks can be any of the followings:
	 *
	 * - method in this behavior: `'handleClick'`
	 * - anonymous function: `function (event) { ... }`
	 * - method with context: `{callback: function (event) { ... }, context: this}`
	 *
	 * The following is an example:
	 *
	 * ~~~
	 * {
	 *     beforeValidate: 'myBeforeValidate',
	 *     afterValidate: {
	 *         callback: function() {},
	 *         context: this
	 *     }
	 * }
	 * ~~~
	 *
	 * @return {object} events (array keys) and the corresponding event handler methods (array values).
	 */
	events: function () {
		return {};
	},

	/**
	 * Attaches the behavior object to the component.
	 * The default implementation will set the [[owner]] property
	 * and attach event handlers as declared in [[events]].
	 * Make sure you call the parent implementation if you override this method.
	 * @param {Jii.base.Component} owner the component that this behavior is to be attached to.
	 */
	attach: function (owner) {
		this.owner = owner;

		Jii._.each(this.events(), Jii._.bind(function(handler, event) {
			handler = Jii.base.Event.normalizeHandler(handler, this);
			this.owner.on(event, handler);
		}, this));
	},

	/**
	 * Detaches the behavior object from the component.
	 * The default implementation will unset the [[owner]] property
	 * and detach event handlers declared in [[events]].
	 * Make sure you call the parent implementation if you override this method.
	 */
	detach: function () {
		if (!this.owner) {
			return;
		}

		Jii._.each(this.events(), Jii._.bind(function(handler, event) {
			handler = Jii.base.Event.normalizeHandler(handler, this);
			this.owner.off(event, handler);
		}, this));
		this.owner = null;
	}

});

},{"../Jii":125,"./Object":138}],131:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Component
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Component', /** @lends Jii.base.Component.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {object} the attached event handlers (event name: handlers)
	 */
	_events: null,

	/**
	 * @var {object} the attached behaviors (behavior name: behavior)
	 */
	_behaviors: null,

	/**
	 * @constructor
	 */
	constructor: function () {
		// Proxy behaviour methods
		this.proxyBehaviors();

		this.__super.apply(this, arguments);
	},

	/**
	 * Returns a list of behaviors that this component should behave as.
	 *
	 * Child classes may override this method to specify the behaviors they want to behave as.
	 *
	 * The return value of this method should be an array of behavior objects or configurations
	 * indexed by behavior names. A behavior configuration can be either a string specifying
	 * the behavior class or an array of the following structure:
	 *
	 * ~~~
	 * behaviorName: {
	 *     class: 'BehaviorClass',
	 *     property1: 'value1',
	 *     property2: 'value2'
	 * }
	 * ~~~
	 *
	 * Note that a behavior class must extend from [[Jii.base.Behavior]]. Behavior names can be strings
	 * or integers. If the former, they uniquely identify the behaviors. If the latter, the corresponding
	 * behaviors are anonymous and their properties and methods will NOT be made available via the component
	 * (however, the behaviors can still respond to the component's events).
	 *
	 * Behaviors declared in this method will be attached to the component automatically (on demand).
	 *
	 * @return {object} the behavior configurations.
	 */
	behaviors: function () {
		return {};
	},

	/**
	 * Returns a value indicating whether there is any handler attached to the named event.
	 * @param {string} name the event name
	 * @return {boolean} whether there is any handler attached to the event.
	 */
	hasEventHandlers: function (name) {
		this.ensureBehaviors();

		return this._events && this._events[name] && this._events[name].length > 0 ? true : false;// @todo || Event::hasHandlers(this, name);
	},

	/**
	 * Attaches an event handler to an event.
	 *
	 * The event handler must be a valid PHP callback. The followings are
	 * some examples:
	 *
	 * ~~~
	 * function (event) { ... }         // anonymous function
	 * ~~~
	 *
	 * The event handler must be defined with the following signature,
	 *
	 * ~~~
	 * function (event)
	 * ~~~
	 *
	 * where `event` is an [[Jii.base.Event]] object which includes parameters associated with the event.
	 *
	 * @param {string|string[]} name the event name
	 * @param {function} handler the event handler
	 * @param {*} [data] the data to be passed to the event handler when the event is triggered.
	 * When the event handler is invoked, this data can be accessed via data.
	 * @param {boolean} [isAppend] whether to append new event handler to the end of the existing
	 * handler list. If false, the new handler will be inserted at the beginning of the existing
	 * handler list.
	 * @see off()
	 */
	on: function (name, handler, data, isAppend) {
		data = data || null;
		isAppend = Jii._.isUndefined(isAppend) ? true : isAppend;

        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        this.ensureBehaviors();
		if (isAppend || !this._events || !this._events[name]) {
			this._events = this._events || {};
			this._events[name] = this._events[name] || [];
			this._events[name].push([handler, data]);
		} else {
			this._events[name].unshift([handler, data]);
		}
	},

	/**
	 * Detaches an existing event handler from this component.
	 * This method is the opposite of [[on()]].
	 * @param {string|string[]} name event name
	 * @param {function} [handler] the event handler to be removed.
	 * If it is null, all handlers attached to the named event will be removed.
	 * @return boolean if a handler is found and detached
	 * @see on()
	 */
	off: function (name, handler) {
		handler = handler || null;

        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

		this.ensureBehaviors();
		if (!this._events || !this._events[name]) {
			return false;
		}

		if (handler === null) {
			delete this._events[name];
			return true;
		}

		var newEvents = [];
		var isRemoved = false;
		Jii._.each(this._events[name], function(event, i) {
            if (Jii._.isObject(handler) && Jii._.has(handler, 'context') && Jii._.isFunction(handler.callback)) {
                if (event.callback !== handler.callback || event.context !== handler.context) {
                    newEvents.push(event);
                } else {
                    isRemoved = true;
                }
            } else {
                if (event.callback !== handler.callback) {
                    newEvents.push(event);
                } else {
                    isRemoved = true;
                }
            }
        }.bind(this));
		this._events[name] = newEvents;

		return isRemoved;
	},

    _normalizeEventNames: function(names) {
        return Jii._.isString(names) ?
            names.split(/[ ,]+/) :
            names;
    },

	/**
	 * Triggers an event.
	 * This method represents the happening of an event. It invokes
	 * all attached handlers for the event including class-level handlers.
	 * @param {string} name the event name
	 * @param {Jii.base.Event} [event] the event parameter. If not set, a default [[Jii.base.Event]] object will be created.
	 */
	trigger: function (name, event) {
		this.ensureBehaviors();
		if (this._events && this._events[name]) {
			if (event === null) {
				event = new Jii.base.Event();
			}
			if (!(event instanceof Jii.base.Event)) {
				event = new Jii.base.Event({
					params: event
				});
			}

			if (event.sender === null) {
				event.sender = this;
			}

			event.handled = false;
			event.name = name;

			var isStopped = false;
			Jii._.each(this._events[name], function(handler) {
				if (isStopped) {
					return;
				}

				event.data = handler[1];
				handler[0] = Jii.base.Event.normalizeHandler(handler[0]);
				handler[0].callback.call(handler[0].context, event);

				// stop further handling if the event is handled
				if (event.handled) {
					isStopped = true;
				}
			});
		}

		// invoke class-level attached handlers
		Jii.base.Event.trigger(this, name, event);
	},

	/**
	 * Returns the named behavior object.
	 * @param {string} name the behavior name
	 * @return {Jii.base.Behavior} the behavior object, or null if the behavior does not exist
	 */
	getBehavior: function (name) {
		this.ensureBehaviors();

		return this._behaviors && this._behaviors[name] ? this._behaviors[name] : null;
	},

	/**
	 * Returns all behaviors attached to this component.
	 * @return {object} list of behaviors attached to this component
	 */
	getBehaviors: function () {
		this.ensureBehaviors();

		return this._behaviors;
	},

	/**
	 * Attaches a behavior to this component.
	 * This method will create the behavior object based on the given
	 * configuration. After that, the behavior object will be attached to
	 * this component by calling the attach method.
	 * @param {string} name the name of the behavior.
	 * @param {string|Jii.base.Behavior[]|Jii.base.Behavior} behavior the behavior configuration. This can be one of the following:
	 *
	 *  - a [[Jii.base.Behavior]] object
	 *  - a string specifying the behavior class
	 *  - an object configuration array that will be passed to [[Jii.createObject()]] to create the behavior object.
	 *
	 * @return {Jii.base.Behavior} the behavior object
	 * @see detachBehavior()
	 */
	attachBehavior: function (name, behavior) {
		this.ensureBehaviors();

		return this._attachBehaviorInternal(name, behavior);
	},

	/**
	 * Attaches a list of behaviors to the component.
	 * Each behavior is indexed by its name and should be a [[Jii.base.Behavior]] object,
	 * a string specifying the behavior class, or an configuration array for creating the behavior.
	 * @param {[]} behaviors list of behaviors to be attached to the component
	 * @see attachBehavior()
	 */
	attachBehaviors: function (behaviors) {
		this.ensureBehaviors();

		Jii._.each(behaviors, Jii._.bind(function(behavior, name) {
			this._attachBehaviorInternal(name, behavior);
		}, this));
	},

	/**
	 * Detaches a behavior from the component.
	 * The behavior's detach method will be invoked.
	 * @param {string} name the behavior's name.
	 * @return {Jii.base.Behavior} the detached behavior. Null if the behavior does not exist.
	 */
	detachBehavior: function (name) {
		this.ensureBehaviors();
		if (this._behaviors && this._behaviors[name]) {
			var behavior = this._behaviors[name];
			delete this._behaviors[name];
			behavior.detach();

			return behavior;
		}

		return null;
	},

	/**
	 * Detaches all behaviors from the component.
	 */
	detachBehaviors: function () {
		this.ensureBehaviors();

		Jii._.each(Jii._.keys(this._behaviors), Jii._.bind(this.detachBehavior, this));
	},

	/**
	 * Makes sure that the behaviors declared in [[behaviors()]] are attached to this component.
	 */
	ensureBehaviors: function () {
		if (this._behaviors !== null) {
			return;
		}

		this._behaviors = [];
		Jii._.each(this.behaviors(), Jii._.bind(function(behavior, name) {
			this._attachBehaviorInternal(name, behavior);
		}, this));
	},

	/**
	 *
	 */
	proxyBehaviors: function () {
		Jii._.each(this.behaviors(), Jii._.bind(function(behavior, name) {
			var className = Jii._.isString(behavior) ? behavior : behavior.className;
			this._proxyBehaviorInternal(name, className);
		}, this));
	},

	/**
	 * Attaches a behavior to this component.
	 * @param {string} name the name of the behavior.
	 * @param {string|Jii.base.Behavior[]|Jii.base.Behavior} behavior the behavior to be attached
	 * @return {Jii.base.Behavior} the attached behavior.
	 * @private
	 */
	_attachBehaviorInternal: function (name, behavior) {
		if (!(behavior instanceof Jii.base.Behavior)) {
			behavior = Jii.createObject(behavior);
		}

		if (this._behaviors[name]) {
			this._behaviors[name].detach();
		}
		behavior.attach(this);

		this._proxyBehaviorInternal(name, behavior.className());

		this._behaviors[name] = behavior;
		return behavior;
	},

	/**
	 *
	 */
	_proxyBehaviorInternal: function (behaviorName, className) {
		var behaviorClass = Jii.namespace(className);

		while (true) {
			if (!behaviorClass || !behaviorClass.prototype || className === 'Jii.base.Behavior') {
				break;
			}

			for (var name in behaviorClass.prototype) {
				if (!behaviorClass.prototype.hasOwnProperty(name)) {
					continue;
				}

				// Skip constructor and non-public methods
				if (name === 'constructor' || name.substr(0, 1) === '_') {
					continue;
				}

				// Skip properties
				if (!Jii._.isFunction(behaviorClass.prototype[name])) {
					continue;
				}

				this[name] = this._getProxyBehaviorMethod(behaviorName, name);
			}

			className = behaviorClass.parentClassName();
			behaviorClass = Jii.namespace(className);
		}
	},

	_getProxyBehaviorMethod: function(behaviorName, methodName) {
		var context = this;

		return function() {
			return context.getBehavior(behaviorName)[methodName].apply(context, arguments);
		};
	},

	hasProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		return this.canGetProperty(name, checkVars, checkBehaviors) || this.canSetProperty(name, false, checkBehaviors);
	},

	// @todo move get, set to Object
	set: function(name, value) {
        // Object format support
        if (Jii._.isObject(name)) {
            Jii._.each(name, function(value, name) {
                this.set(name, value);
            }.bind(this));
            return;
        }

		// Generate setter name
		var setter = 'set' + Jii._s.capitalize(name);

		if (Jii._.isFunction(this[setter])) {
			this[setter].call(this, value);
		} else if (this.hasOwnProperty(name)) {
			this[name] = value;
		} else if (name.substr(0, 3) === 'on ') {
            this.on(name.substr(3), value);
		} else if (name.substr(0, 3) === 'as ') {
            this.attachBehavior(name.substr(3), value instanceof Jii.base.Behavior ? value : Jii.createObject(value));
		} else {
			// @todo as, see Component Yii2

			throw new Jii.exceptions.UnknownPropertyException('Setting unknown property: ' + this.className() + '.' + name);
		}
	},

	canSetProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		var setter = 'set' + Jii._s.capitalize(name);
		if (Jii._.isFunction(this[setter]) || (checkVars && this.hasOwnProperty(name))) {
			return true;
		} else if (checkBehaviors) {

		}

		return false;
	},

	get: function(name) {
		// Generate getter name
		var setter = 'get' + Jii._s.capitalize(name);

		if (Jii._.isFunction(this[setter])) {
			return this[setter].call(this);
		} else if (this.hasOwnProperty(name)) {
			return this[name];
		} else {
			throw new Jii.exceptions.UnknownPropertyException('Getting unknown property: ' + this.className() + '.' + name);
		}
	},

	canGetProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		var getter = 'get' + Jii._s.capitalize(key);
		if (Jii._.isFunction(this[getter]) || (checkVars && this.hasOwnProperty(name))) {
			return true;
		} else if (checkBehaviors) {

		}

		return false;
	}

});

},{"../Jii":125,"./Object":138}],132:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Component');

/**
 * @class Jii.base.Context
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Context', /** @lends Jii.base.Context.prototype */{

	__extends: Jii.base.Component,

	/**
	 * Custom context parameters (name => value).
	 * @type {object}
	 */
	params: {},

	/**
	 * @type {object}
	 */
	_components: {},

	/**
	 * Checks whether the named component exists.
	 * @param {string} id component ID
	 * @return {boolean} whether the named component exists. Both loaded and unloaded components
	 * are considered.
	 */
	hasComponent: function (id) {
		return Jii._.has(this._components, id);
	},

	/**
	 * Retrieves the named component.
	 * @param {string} id component ID (case-sensitive)
	 * @return {Jii.base.Component|null} the component instance, null if the component does not exist.
	 */
	getComponent: function (id) {
		return this._components[id] || null;
	},

	/**
	 * Registers a component with this module.
	 * @param {string} id component ID
	 * @param {Jii.base.Component|array|null} component the component to be registered with the module. This can
	 * be one of the followings:
	 *
	 * - a [[Jii.base.Component]] object
	 * - a configuration array: when [[getComponent()]] is called initially for this component, the array
	 *   will be used to instantiate the component via [[Jii.createObject()]].
	 * - null: the named component will be removed from the module
	 */
	setComponent: function (id, component) {
		if (component === null) {
			delete this._components[id];
		} else {
			// Create component instance
			if (!(component instanceof Jii.base.Component)) {
				component = Jii.createObject(component);
			}

			// Add links
			this[id] = this._components[id] = component;
		}
	},

	/**
	 * Returns the registered components.
	 * @return {Jii.base.Component[]} the components (indexed by their IDs)
	 */
	getComponents: function () {
		return this._components;
	},

	/**
	 * Registers a set of components in this module.
	 *
	 * Each component should be specified as a name-value pair, where
	 * name refers to the ID of the component and value the component or a configuration
	 * array that can be used to create the component. In the latter case, [[Jii.createObject()]]
	 * will be used to create the component.
	 *
	 * If a new component has the same ID as an existing one, the existing one will be overwritten silently.
	 *
	 * The following is an example for setting two components:
	 *
	 * ~~~
	 * {
     *     db: {
     *         class: 'Jii.db.Connection',
     *         dsn: 'sqlite:path/to/file.db'
     *     },
     *     cache: {
     *         class: 'Jii.caching.DbCache',
     *         db: 'db'
     *     }
     * }
	 * ~~~
	 *
	 * @param {array} components components (id => component configuration or instance)
	 */
	setComponents: function (components) {
		Jii._.each(components, Jii._.bind(function (component, id) {
			// Extend default class name
			if (!(component instanceof Jii.base.Component) && this._components[id] && !component.className) {
				component.className = this._components[id].className;
			}

			this.setComponent(id, component);
		}, this));
	},

	/**
	 * Loads components that are declared in [[preload]].
	 * @throws {Jii.exceptions.InvalidConfigException} if a component or module to be preloaded is unknown
	 */
	preloadComponents: function () {
		Jii._.each(this.preload, Jii._.bind(function (id) {
			if (this.hasComponent(id)) {
				this.getComponent(id);
			} else if (this.hasModule(id)) {
				this.getModule(id);
			} else {
				throw new Jii.exceptions.InvalidConfigException("Unknown component or module: " + id);
			}
		}, this));
	}

});

},{"../Jii":125,"./Component":131}],133:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Controller
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Controller', /** @lends Jii.base.Controller.prototype */{

	__extends: Jii.base.Component,

    __static: /** @lends Jii.base.Controller */{

        /**
         * @event Jii.base.Module#beforeAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_BEFORE_ACTION: 'beforeAction',

        /**
         * @event Jii.base.Module#afterAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_AFTER_ACTION: 'afterAction'

    },

	/**
	 * @type {string} The ID of this controller.
	 */
	id: null,

	/**
	 * @type {Jii.base.Module} The module that this controller belongs to.
	 */
	module: null,

	/**
	 * @type {string} The ID of the action that is used when the action ID is not specified
	 * in the request. Defaults to 'index'.
	 */
	defaultAction: 'index',

	/**
	 * @type {string|boolean} the name of the layout to be applied to this controller's views.
	 * This property mainly affects the behavior of [[render()]].
	 * Defaults to null, meaning the actual layout value should inherit that from [[module]]'s layout value.
	 * If false, no layout will be applied.
	 */
	layout: null,

	/**
	 * The view object that can be used to render views or view files.
	 * @type {Jii.view.View}
	 */
	_view: null,

	/**
	 * @constructor
	 */
	constructor: function (id, moduleObject, config) {
		this.id = id;
		this.module = moduleObject;
		this.__super(config);
	},

	/**
	 * Declares external actions for the controller.
	 * This method is meant to be overwritten to declare external actions for the controller.
	 * It should return an array, with array keys being action IDs, and array values the corresponding
	 * action class names or action configuration arrays. For example,
	 *
	 * ~~~
	 * return {
     *     'action1': 'app.components.Action1',
     *     'action2': {
     *         'className': 'app.components.Action2',
     *         'property1': 'value1',
     *         'property2': 'value2'
     *     }
     * };
	 * ~~~
	 *
	 * [[Jii.createObject()]] will be used later to create the requested action
	 * using the configuration provided here.
	 * @returns {object}
	 */
	actions: function () {
		return {};
	},

	/**
	 * Runs a request specified in terms of a route.
	 * @param {string} route the route to be handled, e.g., 'view', 'comment/view', 'admin/comment/view'.
	 * @param {Jii.base.Context} context
	 * @return {Promise}
	 */
	run: function (route, context) {
		var slashIndex = route.indexOf('/');
		if (slashIndex === -1) {
			return this.runAction(route, context);
		} else if (slashIndex > 0) {
			return this.module.runAction(route, context);
		}

		route = Jii._s.ltrim(route, '/');
		return Jii.app.runAction(route, context);
	},

	/**
	 * Runs an action within this controller with the specified action ID and parameters.
	 * If the action ID is empty, the method will use [[defaultAction]].
	 * @param {string} id The ID of the action to be executed.
	 * @param {Jii.base.Context} context
	 * @return {Promise} The result of the action.
	 * @throws {Jii.exceptions.InvalidRouteException} if the requested action ID cannot be resolved into an action successfully.
	 */
	runAction: function (id, context) {
		var action = this.createAction(id);
		if (action === null) {
			throw new Jii.exceptions.InvalidRouteException(Jii.t('jii', 'Unable to resolve the request: ' + this.getUniqueId() + '/' + id));
		}

		return Promise.all([
				this.module.beforeAction(action, context),
				this.beforeAction(action, context)
			]).then(function (results) {
				if (results.indexOf(false) !== -1) {
					return Promise.reject();
				}

                return Promise.resolve().then(function() {
                    return action.runWithParams(context);
                }).then(function(data) {
                    if (!Jii._.isUndefined(data) && context.response instanceof Jii.base.Response) {
                        context.response.data = data;
                    }

                    return Promise.all([
                        this.module.afterAction(action, context),
                        this.afterAction(action, context)
                    ]).then(function() {
                        if (context.response instanceof Jii.base.Response) {
                            context.response.send();
                        }

                        return data;
                    })
                }.bind(this));
        }.bind(this)).catch(Jii.catchHandler);
	},

	/**
	 * Creates an action based on the given action ID.
	 * The method first checks if the action ID has been declared in [[actions()]]. If so,
	 * it will use the configuration declared there to create the action object.
	 * If not, it will look for a controller method whose name is in the format of `actionXyz`
	 * where `Xyz` stands for the action ID. If found, an [[InlineAction]] representing that
	 * method will be created and returned.
	 * @param {string} id the action ID.
	 * @return {Jii.base.Action} the newly created action instance. Null if the ID doesn't resolve into any action.
	 */
	createAction: function (id) {
		if (id === '') {
			id = this.defaultAction;
		}

		var actionMap = this.actions();
		if (Jii._.has(actionMap, id)) {
			return Jii.createObject(actionMap[id], id, this);
		} else if (/^[a-z0-9\\-_]+$/.test(id)) {
			var method = 'action' + ('-' + id).replace(/-([a-z])/g, function(m, v) { return v.toUpperCase(); })

			if (Jii._.isFunction(this[method])) {
				return new Jii.request.InlineAction(id, this, method);
			}
		}

		return null;
	},

	/**
	 *
	 * @param {string} id
	 * @return {boolean}
	 */
	hasAction: function(id) {
		if (id === '') {
			id = this.defaultAction;
		}

		var actionMap = this.actions();
		if (Jii._.has(actionMap, id)) {
			return true;
		} else if (/^[a-z0-9\\-_]+$/.test(id)) {
			var method = id.charAt(0).toUpperCase() + id.slice(1);
			method = 'action' + method.replace('-', ' ');

			return Jii._.isFunction(this[method]);
		}

		return false;
	},

	/**
	 * @return string the controller ID that is prefixed with the module ID (if any).
	 */
	getUniqueId: function () {
		return this.module instanceof Jii.base.Application ? this.id : this.module.getUniqueId() + '/' + this.id;
	},

	/**
	 * This method is invoked right before an action is to be executed (after all possible filters).
	 * @param {Jii.base.Action} action
     * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	beforeAction: function (action, context) {
        this.trigger(this.__static.EVENT_BEFORE_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
		return Promise.resolve(true);
	},

	/**
	 * This method is invoked right after an action is executed.
	 * @param {Jii.base.Action} action
	 * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	afterAction: function (action, context) {
        this.trigger(this.__static.EVENT_AFTER_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve();
	},

	/**
	 * Renders a view and applies layout if available.
	 *
	 * The view to be rendered can be specified in one of the following formats:
	 *
	 * - path alias (e.g. "@app/views/site/index");
	 * - absolute path within application (e.g. "//site/index"): the view name starts with double slashes.
	 *   The actual view file will be looked for under the [[Application::viewPath|view path]] of the application.
	 * - absolute path within module (e.g. "/site/index"): the view name starts with a single slash.
	 *   The actual view file will be looked for under the [[Module::viewPath|view path]] of [[module]].
	 * - relative path (e.g. "index"): the actual view file will be looked for under [[viewPath]].
	 *
	 * To determine which layout should be applied, the following two steps are conducted:
	 *
	 * 1. In the first step, it determines the layout name and the context module:
	 *
	 * - If [[layout]] is specified as a string, use it as the layout name and [[module]] as the context module;
	 * - If [[layout]] is null, search through all ancestor modules of this controller and find the first
	 *   module whose [[Module::layout|layout]] is not null. The layout and the corresponding module
	 *   are used as the layout name and the context module, respectively. If such a module is not found
	 *   or the corresponding layout is not a string, it will return false, meaning no applicable layout.
	 *
	 * 2. In the second step, it determines the actual layout file according to the previously found layout name
	 *    and context module. The layout name can be:
	 *
	 * - a path alias (e.g. "@app/views/layouts/main");
	 * - an absolute path (e.g. "/main"): the layout name starts with a slash. The actual layout file will be
	 *   looked for under the [[Application::layoutPath|layout path]] of the application;
	 * - a relative path (e.g. "main"): the actual layout layout file will be looked for under the
	 *   [[Module::layoutPath|layout path]] of the context module.
	 *
	 * If the layout name does not contain a file extension, it will use the default one `.php`.
	 *
	 * @param {string} view   the view name. Please refer to [[findViewFile()]] on how to specify a view name.
	 * @param {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * These parameters will not be available in the layout.
	 * @return {string} the rendering result.
	 */
	render: function (view, params) {
		params = params || {};

		var output = this.getView().render(view, params, this);
		if (this.getView() instanceof Jii.view.WebView) {
			var layoutFile = this._findLayoutFile(this.getView());
			if (layoutFile !== false) {
				params.content = output;
				return this.getView().renderLayout(layoutFile, {content: output}, this);
			}
		}

		return output;
	},

	/**
	 * Renders a view.
	 * This method differs from [[render()]] in that it does not apply any layout.
	 * @param  {string} view   the view name. Please refer to [[render()]] on how to specify a view name.
	 * @param  {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * @return {string} the rendering result.
	 */
	renderPartial: function (view, params) {
		params = params || {};

		return this.getView().render(view, params, this);
	},

	/**
	 * Renders a view file.
	 * @param  {string} file   the view file to be rendered. This can be either a file path or a path alias.
	 * @param  {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * @return {string} the rendering result.
	 */
	renderFile: function (file, params) {
		params = params || {};

		return this.getView().renderFile(file, params, this);
	},

	/**
	 * Returns the view object that can be used to render views or view files.
	 * The [[render()]], [[renderPartial()]] and [[renderFile()]] methods will use
	 * this view object to implement the actual view rendering.
	 * If not set, it will default to the "view" application component.
	 * @return {Jii.view.View} the view object that can be used to render views or view files.
	 */
	getView: function () {
		if (this._view === null) {
			this._view = Jii.app.view;
		}

		return this._view;
	},

	/**
	 * Sets the view object to be used by this controller.
	 * @param {Jii.view.View} view the view object that can be used to render views or view files.
	 */
	setView: function (view) {
		this._view = view;
	},

	/**
	 * Returns the directory containing view files for this controller.
	 * The default implementation returns the directory named as controller [[id]] under the [[module]]'s
	 * [[viewPath]] directory.
	 * @return {string} the directory containing the view files for this controller.
	 */
	getViewPath: function () {
		return this.module.getViewPath() + '/' + this.id;
	},

	/**
	 * Finds the view file based on the given view name.
	 * @param {string} view the view name or the path alias of the view file. Please refer to [[render()]]
	 * on how to specify this parameter.
	 * @return {string} the view file path. Note that the file may not exist.
	 */
	findViewFile: function (view) {
		return this.getViewPath() + '/' + view;
	},

	/**
	 * Finds the applicable layout file.
	 * @param {Jii.view.View} view the view object to render the layout file.
	 * @return {string|boolean} the layout file path, or false if layout is not needed.
	 * Please refer to [[render()]] on how to specify this parameter.
	 */
	_findLayoutFile: function (view) {
		var module = this.module;
		var layout = null;

		if (Jii._.isString(this.layout)) {
			layout = this.layout;
		} else if (this.layout === null) {
			while (module !== null && module.layout === null) {
				module = module.module;
			}
			if (module !== null && Jii._.isString(module.layout)) {
				layout = module.layout;
			}
		}

		if (!layout) {
			return false;
		}

		var file = null;
		if (layout.indexOf('@') === 0) {
			file = Jii.getAlias(layout);
		} else if (layout.indexOf('/') === 0) {
			file = Jii.app.getLayoutPath() + '/' + layout.substr(1);
		} else {
			file = module.getLayoutPath() + '/' + layout;
		}

		var ext = Jii.helpers.File.getFileExtension(file);
		if (ext !== '') {
			return file;
		}

		var path = file + '.' + view.defaultExtension;
		if (view.defaultExtension !== 'ejs' && ext === '') {
			path = file + '.ejs';
		}

		return path;
	}

});


},{"../Jii":125,"./Object":138}],134:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Event
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Event', /** @lends Jii.base.Event.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {string} the event name. This property is set by [[Jii.base.Component.trigger()]] and [[trigger()]].
	 * Event handlers may use this property to check what event it is handling.
	 */
	name: null,

	/**
	 * @var {object} the sender of this event. If not set, this property will be
	 * set as the object whose "trigger()" method is called.
	 * This property may also be a `null` when this event is a
	 * class-level event which is triggered in a static context.
	 */
	sender: null,

	/**
	 * @var {boolean} whether the event is handled. Defaults to false.
	 * When a handler sets this to be true, the event processing will stop and
	 * ignore the rest of the uninvoked event handlers.
	 */
	handled: false,

	/**
	 * @var {*} the data that is passed to [[Jii.base.Component.on()]] when attaching an event handler.
	 * Note that this varies according to which event handler is currently executing.
	 */
	data: null,

	params: {},

	__static: /** @lends Jii.base.Event */{

		/**
		 * Convert string/function/object to object handler with context and callback params
		 * @param {string|function|object|[]} handler
		 * @param {object} [context]
		 * @returns {*}
		 */
		normalizeHandler: function (handler, context) {
			context = context || null;

			if (Jii._.isObject(handler) && Jii._.has(handler, 'callback') && Jii._.has(handler, 'context')) {
				return handler;
			}

			if (Jii._.isArray(handler) && handler.length === 2) {
				if (Jii._.isFunction(handler[0]) && Jii._.isObject(handler[1])) {
					return {
						context: handler[1],
						callback: handler[0]
					};
				}

				if (Jii._.isString(handler[0])) {
					handler[0] = Jii.namespace(handler[0]);
				}
				return {
					context: handler[0],
					callback: handler[0][handler[1]]
				};
			}

			if (Jii._.isString(handler)) {
				return {
					context: context,
					callback: this[handler]
				};
			}

			if (Jii._.isFunction(handler)) {
				return {
					context: context,
					callback: handler
				};
			}

			throw new Jii.exceptions.ApplicationException('Wrong handler format:' + JSON.stringify(handler));
		},

		_events: {},

		/**
		 * Attaches an event handler to a class-level event.
		 *
		 * When a class-level event is triggered, event handlers attached
		 * to that class and all parent classes will be invoked.
		 *
		 * For example, the following code attaches an event handler to `ActiveRecord`'s
		 * `afterInsert` event:
		 *
		 * ~~~
		 * Jii.base.Event.on(ActiveRecord.className(), ActiveRecord.EVENT_AFTER_INSERT, function (event) {
		 *     console.log(event.sender.className() + ' is inserted.');
		 * });
		 * ~~~
		 *
		 * The handler will be invoked for EVERY successful ActiveRecord insertion.
		 *
		 * For more details about how to declare an event handler, please refer to [[Jii.base.Component.on()]].
		 *
		 * @param {string} className the fully qualified class name to which the event handler needs to attach.
		 * @param {string} name the event name.
		 * @param {string|function|object} handler the event handler.
		 * @param {*} [data] the data to be passed to the event handler when the event is triggered.
		 * When the event handler is invoked, this data can be accessed via [[Jii.base.Event.data]].
		 * @param {boolean} [isAppend] whether to append new event handler to the end of the existing
		 * handler list. If false, the new handler will be inserted at the beginning of the existing
		 * handler list.
		 * @see off()
		 */
		on: function (className, name, handler, data, isAppend) {
			data = data || null;
			isAppend = Jii._.isUndefined(isAppend) ? true : isAppend;

			if (isAppend || !this._events || !this._events[name] || !this._events[name][className]) {
				this._events = this._events || {};
				this._events[name] = this._events[name] || {};
				this._events[name][className] = this._events[name][className] || [];
				this._events[name][className].push([handler, data]);
			} else {
				this._events[name].unshift([handler, data]);
			}
		},

		/**
		 * Detaches an event handler from a class-level event.
		 *
		 * This method is the opposite of [[on()]].
		 *
		 * @param {string} className the fully qualified class name from which the event handler needs to be detached.
		 * @param {string} name the event name.
		 * @param {string|function|object} [handler] the event handler to be removed.
		 * If it is null, all handlers attached to the named event will be removed.
		 * @return boolean whether a handler is found and detached.
		 * @see on()
		 */
		off: function (className, name, handler) {
			handler = handler || null;

			if (!this._events || !this._events[name] || !this._events[name][className]) {
				return false;
			}

			if (handler === null) {
				delete this._events[name][className];
				return true;
			}

			var newEvents = [];
			var isRemoved = false;
			Jii._.each(this._events[name][className], Jii._.bind(function(event) {
				if (event[0] !== handler) {
					newEvents.push(event);
				} else {
					isRemoved = true;
				}
			}, this));
			if (newEvents.length === 0) {
				delete this._events[name][className];
			} else {
				this._events[name][className] = newEvents;
			}

			return isRemoved;
		},

		/**
		 * Returns a value indicating whether there is any handler attached to the specified class-level event.
		 * Note that this method will also check all parent classes to see if there is any handler attached
		 * to the named event.
		 * @param {string|object} className the object or the fully qualified class name specifying the class-level event.
		 * @param {string} name the event name.
		 * @return boolean whether there is any handler attached to the event.
		 */
		hasHandlers: function (className, name) {
			if (!this._events || !this._events[name]) {
				return false;
			}

			if (Jii._.isObject(className)) {
				className = className.className();
			}

			var currentClass = Jii._.isObject(className) ? className : Jii.namespace(className);
			while (true) {
				if (this._events[name][className]) {
					return true;
				}

				className = currentClass.parentClassName();
				currentClass = className ? Jii.namespace(className) : null;

				if (!currentClass) {
					break;
				}
			}

			return false;
		},

		/**
		 * Triggers a class-level event.
		 * This method will cause invocation of event handlers that are attached to the named event
		 * for the specified class and all its parent classes.
		 * @param {string|object} className the object or the fully qualified class name specifying the class-level event.
		 * @param {string} name the event name.
		 * @param {Jii.base.Event} [event] the event parameter. If not set, a default [[Event]] object will be created.
		 */
		trigger: function (className, name, event) {
			event = event || null;

			if (!this._events || !this._events[name]) {
				return;
			}

			if (event === null) {
				event = new this();
			}
			
			event.handled = false;
			event.name = name;

			if (Jii._.isObject(className)) {
				if (event.sender === null) {
					event.sender = className;
				}
				className = className.className();
			}

			var currentClass = Jii._.isObject(className) ? className : Jii.namespace(className);
			while (true) {
				if (this._events[name][className]) {
					for (var handler, i = 0, l = this._events[name][className].length; i < l; i++) {
						handler = this._events[name][className][i];

						event.data = handler[1];
						handler[0] = this.normalizeHandler(handler[0]);
						handler[0].callback.call(handler[0].context, event);

						if (event.handled) {
							return;
						}
					}
				}

				className = currentClass.parentClassName();
				currentClass = className ? Jii.namespace(className) : null;

				if (!currentClass) {
					break;
				}
			}
		}
	}

});

},{"../Jii":125,"./Object":138}],135:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Request');

/**
 * @class Jii.base.HttpRequest
 * @extends Jii.base.Request
 */
Jii.defineClass('Jii.base.HttpRequest', /** @lends Jii.base.HttpRequest.prototype */{

	__extends: Jii.base.Request,

	/**
	 *
	 * @returns {string}
	 */
	getMethod: function () {
		return 'GET';
	},

	/**
	 * Returns whether this is a GET request.
	 * @return {boolean}
	 */
	isGet: function () {
		return this.getMethod() === 'GET';
	},

	/**
	 * Returns whether this is a OPTIONS request.
	 * @return {boolean}
	 */
	isOptions: function () {
		return this.getMethod() === 'OPTIONS';
	},

	/**
	 * Returns whether this is a HEAD request.
	 * @return {boolean}
	 */
	isHead: function () {
		return this.getMethod() === 'HEAD';
	},

	/**
	 * Returns whether this is a POST request.
	 * @return {boolean}
	 */
	isPost: function () {
		return this.getMethod() === 'POST';
	},

	/**
	 * Returns whether this is a DELETE request.
	 * @return {boolean}
	 */
	isDelete: function () {
		return this.getMethod() === 'DELETE';
	},

	/**
	 * Returns whether this is a PUT request.
	 * @return {boolean}
	 */
	isPut: function () {
		return this.getMethod() === 'PUT';
	},

	/**
	 * Returns whether this is a PATCH request.
	 * @return {boolean}
	 */
	isPatch: function () {
		return this.getMethod() === 'PATCH';
	},

	/**
	 * Returns whether this is an AJAX (XMLHttpRequest) request.
	 * @return boolean whether this is an AJAX (XMLHttpRequest) request.
	 */
	isAjax: function () {
		return false;
	},

	/**
	 * Returns whether this is an Adobe Flash or Flex request.
	 * @return boolean whether this is an Adobe Flash or Adobe Flex request.
	 */
	isFlash: function () {
		return false;
	},

	/**
	 * Returns the named request body parameter value.
	 * @param {string} name the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} the parameter value
	 */
	getBodyParam: function (name, defaultValue) {
		defaultValue = defaultValue || null;

		var bodyParams = this.getBodyParams();
		return Jii._.has(bodyParams, name) ? bodyParams[name] : defaultValue;
	},

	/**
	 * Returns POST parameter with a given name. If name isn't specified, returns an array of all POST parameters.
	 * @param {string} [name] the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} The POST parameter value
	 */
	post: function (name, defaultValue) {
		name = name || null;
		defaultValue = defaultValue || null;

		return name === null ? this.getBodyParams() : this.getBodyParam(name, defaultValue);
	},

	_queryParams: null,

	/**
	 * Returns the request parameters given in the [[queryString]].
	 * @return {object} the request GET parameter values.
	 */
	getQueryParams: function () {
		if (this._queryParams === null) {
			this._queryParams = this._parseQueryParams();
		}
		return this._queryParams;
	},

	/**
	 * Sets the request [[queryString]] parameters.
	 * @param {object} values the request query parameters (name-value pairs)
	 */
	setQueryParams: function (values) {
		this._queryParams = values;
	},

	_parseQueryParams: function () {
	},

	/**
	 * Returns the named GET parameter value.
	 * @param {string} name the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} the parameter value
	 */
	getQueryParam: function (name, defaultValue) {
		defaultValue = defaultValue || null;

		var queryParams = this.getQueryParams();
		return Jii._.has(queryParams, name) ? queryParams[name] : defaultValue;
	},

	/**
	 * Returns the named GET parameter value.
	 * If the GET parameter does not exist, the second parameter to this method will be returned.
	 * @param {string} [name] the GET parameter name. If not specified, whole all get params is returned.
	 * @param {*} [defaultValue] the default parameter value if the GET parameter does not exist.
	 * @return {*} the GET parameter value
	 */
	get: function (name, defaultValue) {
		name = name || null;
		defaultValue = defaultValue || null;

		return name === null ? this.getQueryParams() : this.getQueryParam(name, defaultValue);
	},

	_pathInfo: null,

	/**
	 * Returns the path info of the currently requested URL.
	 * A path info refers to the part that is after the entry script and before the question mark (query string).
	 * The starting and ending slashes are both removed.
	 * @return {string} Part of the request URL that is after the entry script and before the question mark.
	 * Note, the returned path info is already URL-decoded.
	 */
	getPathInfo: function () {
		if (this._pathInfo === null) {
			this._pathInfo = this._parsePathInfo();
		}
		return this._pathInfo;
	},

	/**
	 * Sets the path info of the current request.
	 * This method is mainly provided for testing purpose.
	 * @param {string} value The path info of the current request
	 */
	setPathInfo: function (value) {
		this._pathInfo = Jii._s.ltrim(value, '/');
	},

	_parsePathInfo: function () {
	},

	_hostInfo: null,

	/**
	 * Returns the schema and host part of the current request URL.
	 * The returned URL does not have an ending slash.
	 * By default this is determined based on the user request information.
	 * You may explicitly specify it by setting the setHostInfo().
	 * @return {string} Schema and hostname part (with port number if needed) of the request URL
	 */
	getHostInfo: function () {
		if (this._hostInfo === null) {
			this._hostInfo = this._parseHostInfo();
		}
		return this._hostInfo;
	},

	/**
	 * Sets the schema and host part of the application URL.
	 * This setter is provided in case the schema and hostname cannot be determined
	 * on certain Web servers.
	 * @param {string} value The schema and host part of the application URL. The trailing slashes will be removed.
	 */
	setHostInfo: function (value) {
		this._hostInfo = Jii._s.rtrim(value, '/');
		return this._hostInfo;
	},

	_parseHostInfo: function () {
	}

});


},{"../Jii":125,"./Request":139}],136:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Event');

/**
 * @class Jii.base.ModelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.base.ModelEvent', /** @lends Jii.base.ModelEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * A model is in valid status if it passes validations or certain checks.
	 * @type {boolean} Whether the model is in valid status. Defaults to true.
	 */
	isValid: true

});

},{"../Jii":125,"./Event":134}],137:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Context');

/**
 * @class Jii.base.Module
 * @extends Jii.base.Context
 */
Jii.defineClass('Jii.base.Module', /** @lends Jii.base.Module.prototype */{

	__extends: Jii.base.Context,

    __static: /** @lends Jii.base.Module */{

        /**
         * @event Jii.base.Module#beforeAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_BEFORE_ACTION: 'beforeAction',

        /**
         * @event Jii.base.Module#afterAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_AFTER_ACTION: 'afterAction'

    },

	/**
	 * @type {string}
	 */
	id: null,

	/**
	 * The parent module of this module. Null if this module does not have a parent.
	 * @type {Jii.base.Module}
	 */
	module: null,

    /**
     * @type {{string: function}}
     */
    inlineActions: {},

	/**
	 * Mapping from controller ID to controller configurations.
	 * Each name-value pair specifies the configuration of a single controller.
	 * A controller configuration can be either a string or an array.
	 * If the former, the string should be the fully qualified class name of the controller.
	 * If the latter, the array must contain a 'class' element which specifies
	 * the controller's fully qualified class name, and the rest of the name-value pairs
	 * in the array are used to initialize the corresponding controller properties. For example,
	 *
	 * ~~~
	 * {
     *   account: 'app.controllers.UserController',
     *   article: {
     *      className: 'app.controllers.PostController',
     *      pageTitle: 'something new'
     *   }
     * }
	 * ~~~
	 * @type {object}
	 */
	controllerMap: {},

	/**
	 * String the namespace that controller classes are in. If not set,
	 * it will use the "controllers" sub-namespace under the namespace of this module.
	 * For example, if the namespace of this module is "foo\bar", then the default
	 * controller namespace would be "foo\bar\controllers".
	 * @type {string}
	 */
	controllerNamespace: null,

	/**
	 * The default route of this module. Defaults to 'default'.
	 * The route may consist of child module ID, controller ID, and/or action ID.
	 * For example, `help`, `post/create`, `admin/post/create`.
	 * If action ID is not given, it will take the default value as specified in defaultAction.
	 * @type {string}
	 */
	defaultRoute: 'default',

	/**
	 * The layout that should be applied for views within this module. This refers to a view name
	 * relative to [[layoutPath]]. If this is not set, it means the layout value of the [[module|parent module]]
	 * will be taken. If this is false, layout will be disabled within this module.
	 * @type {string|boolean}
	 */
	layout: null,

	/**
	 * @type {object}
	 */
	_modules: null,

	/**
     * Stored controller instances
	 * @type {object}
	 */
    _controllers: {},

	/**
	 */
	constructor: function (id, moduleObject, config) {
		this.id = id;
		this.module = moduleObject;
		this._modules = {};

		this.__super(config);
	},

	init: function () {
		if (this.controllerNamespace === null) {
			var index = Jii._.lastIndexOf(this.className(), '.');
			this.controllerNamespace = this.className().substr(0, index);
		}
	},

    /**
     *
     * @returns {Promise}
     */
    start: function() {
        var promises = [];
        Jii._.each(this._components, function(component) {
            if (Jii._.isFunction(component.start)) {
                promises.push(component.start());
            }
        });
        return Promise.all(promises);
    },

    /**
     *
     * @returns {Promise}
     */
    stop: function() {
        var promises = [];
        Jii._.each(this._components, function(component) {
            if (Jii._.isFunction(component.stop)) {
                promises.push(component.stop());
            }
        });
        return Promise.all(promises);
    },

	getUniqueId: function () {
		if (this.module) {
			var id = this.module.getUniqueId() + '/' + this.id;
			return Jii._s.ltrim(id, '/');
		}
		return this.id;
	},

	/**
	 * The root directory of the module.
	 * @type {string}
	 */
	_basePath: null,

	/**
	 * Returns the root directory of the module.
	 * It defaults to the directory containing the module class file.
	 * @return {string} the root directory of the module.
	 */
	getBasePath: function () {
		if (this._basePath === null) {
			this._basePath = Jii.getAlias('@' + this.className().replace(/\.[^.]+$/, ''))
		}

		return this._basePath;
	},

	/**
	 * Sets the root directory of the module.
	 * This method can only be invoked at the beginning of the constructor.
	 * @param  {string} path the root directory of the module. This can be either a directory name or a path alias.
	 */
	setBasePath: function (path) {
		this._basePath = Jii.getAlias(path);
	},

	/**
	 * Returns the directory that contains the controller classes according to [[controllerNamespace]].
	 * Note that in order for this method to return a value, you must define
	 * an alias for the root namespace of [[controllerNamespace]].
	 * @return {string} the directory that contains the controller classes.
	 */
	getControllerPath: function () {
		return Jii.getAlias('@' + this.controllerNamespace.replace('.', '/'));
	},

	/**
	 * The root directory that contains view files for this module
	 * @type {string}
	 */
	_viewPath: null,

	/**
	 * Returns the directory that contains the view files for this module.
	 * @return {string} the root directory of view files. Defaults to "[[basePath]]/view".
	 */
	getViewPath: function () {
		if (this._viewPath === null) {
			this._viewPath = this.getBasePath() + '/views';
		}
		return this._viewPath;
	},

	/**
	 * Sets the directory that contains the view files.
	 * @param {string} path the root directory of view files.
	 */
	setViewPath: function (path) {
		this._viewPath = Jii.getAlias(path);
	},

	/**
	 * The root directory that contains layout view files for this module.
	 * @type {string}
	 */
	_layoutPath: null,

	/**
	 * Returns the directory that contains layout view files for this module.
	 * @return {string} the root directory of layout files. Defaults to "[[viewPath]]/layouts".
	 */
	getLayoutPath: function () {
		if (this._layoutPath === null) {
			this._layoutPath = this.getViewPath() + '/layouts';
		}
		return this._layoutPath;
	},

	/**
	 * Sets the directory that contains the layout files.
	 * @param  {string} path the root directory of layout files.
	 */
	setLayoutPath: function (path) {
		this._layoutPath = Jii.getAlias(path);
	},

	/**
	 * Checks whether the child module of the specified ID exists.
	 * This method supports checking the existence of both child and grand child modules.
	 * @param {string} id module ID. For grand child modules, use ID path relative to this module (e.g. `admin/content`).
	 * @return {boolean} whether the named module exists. Both loaded and unloaded modules
	 * are considered.
	 */
	hasModule: function (id) {
		var index = Jii._.indexOf(id, '.');
		if (index !== -1) {
			var moduleId = id.substr(0, index);
			var childModuleId = id.substr(index + 1);

			// Check sub-module
			var moduleObject = this.getModule(moduleId);
			return moduleObject !== null ? moduleObject.hasModule(childModuleId) : false;
		}

		return Jii._.has(this._modules[id]);
	},

	/**
	 * Retrieves the child module of the specified ID.
	 * This method supports retrieving both child modules and grand child modules.
	 * @param {string} id module ID (case-sensitive). To retrieve grand child modules,
	 * use ID path relative to this module (e.g. `admin/content`).
	 * @return {Jii.base.Module} the module instance, null if the module does not exist.
	 */
	getModule: function (id) {
		// Get sub-module
		var index = Jii._.indexOf(id, '.');
		if (index !== -1) {
			var moduleId = id.substr(0, index);
			var childModuleId = id.substr(index + 1);

			var moduleObject = this.getModule(moduleId);
			return moduleObject !== null ? moduleObject.getModule(childModuleId) : null;
		}

		return this._modules[id] || null;
	},

	/**
	 * Adds a sub-module to this module.
	 * @param {string} id module ID
	 * @param {Jii.base.Module|array|null} moduleObject the sub-module to be added to this module. This can
	 * be one of the followings:
	 *
	 * - a [[Jii.base.Module]] object
	 * - a configuration array: when [[getModule()]] is called initially, the array
	 *   will be used to instantiate the sub-module
	 * - null: the named sub-module will be removed from this module
	 */
	setModule: function (id, moduleObject) {
		if (moduleObject === null) {
			delete this._modules[id];
        } else {
			// Create module instance
            if (!(moduleObject instanceof Jii.base.Module)) {
                moduleObject = Jii.createObject(moduleObject, id, this);
            }

			// Add link
			this._modules[id] = moduleObject;
		}
	},

	/**
	 * Returns the sub-modules in this module.
	 * @return {Jii.base.Module[]} the modules (indexed by their IDs)
	 */
	getModules: function () {
		return this._modules;
	},

	/**
	 * Registers sub-modules in the current module.
	 *
	 * Each sub-module should be specified as a name-value pair, where
	 * name refers to the ID of the module and value the module or a configuration
	 * array that can be used to create the module. In the latter case, [[Jii.createObject()]]
	 * will be used to create the module.
	 *
	 * If a new sub-module has the same ID as an existing one, the existing one will be overwritten silently.
	 *
	 * The following is an example for registering two sub-modules:
	 *
	 * ~~~
	 * [
	 *     'comment' => [
	 *         'class' => 'app\modules\comment\CommentModule',
	 *         'db' => 'db',
	 *     ],
	 *     'booking' => ['class' => 'app\modules\booking\BookingModule'],
	 * ]
	 * ~~~
	 *
	 * @param {object} modules modules (id => module configuration or instances)
	 */
	setModules: function (modules) {
		Jii._.each(modules, Jii._.bind(function (moduleObject, id) {
			this.setModule(id, moduleObject);
		}, this));
	},

	/**
	 * Runs a controller action specified by a route.
	 * This method parses the specified route and creates the corresponding child module(s), controller and action
	 * instances. It then calls [[Jii.base.Controller::runAction()]] to run the action with the given parameters.
	 * If the route is empty, the method will use [[defaultRoute]].
	 * @param {string} route the route that specifies the action.
	 * @param {Jii.base.Context} context
	 * @return {Promise} the result of the action.
	 * @throws {Jii.exceptions.InvalidRouteException} if the requested route cannot be resolved into an action successfully
	 */
	runAction: function (route, context) {
        var routeParams = this._parseRoute(route);

        var fullRoute = routeParams.id + '/' + (routeParams.route || 'index');
        if (Jii._.has(this.inlineActions, fullRoute)) {
            var action = this.inlineActions[fullRoute] instanceof Jii.base.Action ?
                this.inlineActions[fullRoute] :
                new Jii.request.AnonymousAction(fullRoute, this, this.inlineActions[fullRoute]);

            return this.beforeAction(action, context).then(function (result) {
                if (result === false) {
                    return Promise.reject();
                }

                return Promise.resolve().then(function() {
                    return action.runWithParams(context);
                }).then(function(data) {
                    if (!Jii._.isUndefined(data) && context.response instanceof Jii.base.Response) {
                        context.response.data = data;
                        context.response.send();
                    }

                    return this.beforeAction(action, context).then(function() {
                        return data;
                    });
                }.bind(this));
            }.bind(this)).catch(Jii.catchHandler);
        }

		var parts = this.createController(route);
		if (parts !== null) {
			/** @type {Jii.base.Controller} */
			var controller = parts[0];
			var actionId = parts[1];

			return controller.runAction(actionId, context);
		}

		var id = this.getUniqueId();
		var requestName = id ? id + '/' + route : route;
		//throw new Jii.exceptions.InvalidRouteException('Unable to resolve the request `' + requestName + '`.');
		Jii.info('Unable to resolve the request `' + requestName + '`.');
	},

	/**
	 *
	 * @param {string} route
	 * @return {boolean}
	 */
	existsRoute: function(route) {
        var routeParams = this._parseRoute(route);
        var id = routeParams.id;
        route = routeParams.route;

        if (Jii._.has(this.inlineActions, id + '/' + (route || 'index'))) {
            return true;
        }

		if (Jii._.has(this.controllerMap, id)) {
			return true;
		}

		var moduleObject = this.getModule(id);
		if (moduleObject !== null) {
			return moduleObject.existsRoute(route);
		}

		if (/^[a-z0-9\\-_]+$/.test(id)) {
			var className = id.charAt(0).toUpperCase() + id.slice(1);
			className = className.replace('-', '') + 'Controller';
			className = this.controllerNamespace + '.' + className;

			var controllerClass = Jii.namespace(className);
			if (Jii._.isFunction(controllerClass)) {
				var controller = new controllerClass(id, this);
				return controller.hasAction(route);
			}
		}

		return false;
	},

	/**
	 * Creates a controller instance based on the controller ID.
	 *
	 * The controller is created within this module. The method first attempts to
	 * create the controller based on the [[controllerMap]] of the module.
	 *
	 * @param {string} route the route consisting of module, controller and action IDs.
	 * @return {[]|null} If the controller is created successfully, it will be returned together
	 * with the requested action ID. Otherwise false will be returned.
	 * @throws {Jii.exceptions.InvalidConfigException} if the controller class and its file do not match.
	 */
	createController: function (route) {
        var routeParams = this._parseRoute(route);
        var id = routeParams.id;
        route = routeParams.route;

		var controller = null;
		if (Jii._.has(this.controllerMap, id)) {
			controller = Jii.createObject(this.controllerMap[id], id, this);
			return controller !== null ? [controller, route] : null;
		}

		var moduleObject = this.getModule(id);
		if (moduleObject !== null) {
			return moduleObject.createController(route);
		}

		if (/^[a-z0-9\\-_]+$/.test(id)) {

			var className = id.charAt(0).toUpperCase() + id.slice(1);
			className = className.replace('-', '') + 'Controller';
			className = this.controllerNamespace + '.' + className;

            // Cache controller instances
            if (!this._controllers[className]) {

                var controllerClass = Jii.namespace(className);
                if (Jii._.isFunction(controllerClass)) {
                    this._controllers[className] = new controllerClass(id, this);

                    if (!(this._controllers[className] instanceof Jii.base.Controller)) {
                        throw new Jii.exceptions.InvalidConfigException("Controller class must extend from Jii.base.Controller.");
                    }
                }
			}
            controller = this._controllers[className] || null;
		}

		return controller !== null ? [controller, route] : null;
	},

    _parseRoute: function(route) {
        if (route === '') {
            route = this.defaultRoute;
        }

        route = Jii._s.trim(route, '/');

        var index = route.indexOf('/');
        if (index !== -1) {
            return {
                id: route.substr(0, index),
                route: route.substr(index + 1)
            };
        }
        return {
            id: route,
            route: ''
        }
    },

	/**
	 * This method is invoked right before an action of this module is to be executed (after all possible filters.)
	 * You may override this method to do last-minute preparation for the action.
	 * Make sure you call the parent implementation so that the relevant event is triggered.
	 * @param {Jii.base.Action} action the action to be executed.
	 * @param {Jii.base.Context} context
	 * @return {Promise}
	 */
	beforeAction: function (action, context) {
        this.trigger(this.__static.EVENT_BEFORE_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve(true);
	},

	/**
	 * This method is invoked right after an action of this module has been executed.
	 * You may override this method to do some postprocessing for the action.
	 * Make sure you call the parent implementation so that the relevant event is triggered.
	 * @param {Jii.base.Action} action the action just executed.
     * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	afterAction: function (action, context) {
        this.trigger(this.__static.EVENT_AFTER_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve();
	}

});

},{"../Jii":125,"./Context":132}],138:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 *
 * @class Jii.base.Object
 */
Jii.defineClass('Jii.base.Object', /** @lends Jii.base.Object.prototype */{

	__static: /** @lends Jii.base.Object */{

		/**
		 * Return full class name with namespace
		 * @returns {string}
		 */
		className: function () {
			return this.__className;
		},

		/**
		 * Return extended class name with namespace
		 * @returns {string}
		 */
		parentClassName: function () {
			return this.__parentClassName;
		}

	},

	/**
	 * @param {object} [config]
	 * @constructor
	 */
	constructor: function (config) {
		this.__super.apply(this, arguments);

		// Apply configuration to instance
		if (Jii._.isObject(config)) {
			Jii.configure(this, config);
		}

		// Run custom init method
		this.init();
	},

	/**
	 * Customized initialize method
	 */
	init: function () {
	},

	/**
	 * Method defined jsdoc for hide errors in IDE
	 * @param {...*} [params]
	 * @protected
	 */
	__super: function (params) {
	},

	/**
	 * Return full class name with namespace
	 * @returns {string}
	 */
	className: function () {
		return this.__className;
	},

	/**
	 * Return extended class name with namespace
	 * @returns {string}
	 */
	parentClassName: function () {
		return this.__parentClassName;
	}

});

},{"../Jii":125}],139:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.base.Request
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Request', /** @lends Jii.base.Request.prototype */{

	__extends: Jii.base.Component,

	/**
	 *
	 * @returns {string|null}
	 */
	getMethod: function () {
		return null;
	},

	/**
	 * Resolves the current request into a route and the associated parameters.
	 * @returns {array|null} the first element is the route, and the second is the associated parameters.
	 */
	resolve: function () {
		return null;
	},

	_pathInfo: null,

	/**
	 * Returns the path info of the currently requested URL.
	 * A path info refers to the part that is after the entry script and before the question mark (query string).
	 * The starting and ending slashes are both removed.
	 * @returns {string} Part of the request URL that is after the entry script and before the question mark.
	 * Note, the returned path info is already URL-decoded.
	 */
	getPathInfo: function () {
		if (this._pathInfo === null) {
			this._pathInfo = this._parsePathInfo();
		}
		return this._pathInfo;
	},

	/**
	 * Sets the path info of the current request.
	 * This method is mainly provided for testing purpose.
	 * @param {string} value The path info of the current request
	 */
	setPathInfo: function (value) {
		this._pathInfo = Jii._s.ltrim(value, '/');
	},

	_parsePathInfo: function () {
		return '';
	},

	_hostInfo: null,

	/**
	 * Returns the schema and host part of the current request URL.
	 * The returned URL does not have an ending slash.
	 * By default this is determined based on the user request information.
	 * You may explicitly specify it by setting the setHostInfo().
	 * @return {string} Schema and hostname part (with port number if needed) of the request URL
	 */
	getHostInfo: function () {
		if (this._hostInfo === null) {
			this._hostInfo = this._parseHostInfo();
		}
		return this._hostInfo;
	},

	/**
	 * Sets the schema and host part of the application URL.
	 * This setter is provided in case the schema and hostname cannot be determined
	 * on certain Web servers.
	 * @param {string} value The schema and host part of the application URL. The trailing slashes will be removed.
	 */
	setHostInfo: function (value) {
		this._hostInfo = Jii._s.rtrim(value, '/');
		return this._hostInfo;
	},

	_parseHostInfo: function () {
		return '';
	}

});

},{"../Jii":125}],140:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.base.Response
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Response', {

	__extends: Jii.base.Component,

	/**
	 * @var {boolean} whether the response has been sent. If this is true, calling [[send()]] will do nothing.
	 */
	isSent: false,

    /**
     * The original response data
     * @type {*}
     */
    data: null,

	/**
	 * Sends the response to client.
	 */
	send: function () {
	}

});

},{"../Jii":125}],141:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.exceptions.ApplicationException
 * @extends Error
 */
Jii.defineClass('Jii.exceptions.ApplicationException', /** @lends Jii.exceptions.ApplicationException.prototype */ {

	__extends: Error,

	constructor: function (message) {
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, this.__static);
		}
		this.name = this.__className;
		this.message = message || '';
	}
});

},{"../Jii":125}],142:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidCallException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidCallException', /** @lends Jii.exceptions.InvalidCallException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],143:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidConfigException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidConfigException', /** @lends Jii.exceptions.InvalidConfigException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],144:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidParamException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidParamException', /** @lends Jii.exceptions.InvalidParamException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],145:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidRouteException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidRouteException', /** @lends Jii.exceptions.InvalidRouteException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],146:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.NotSupportedException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.NotSupportedException', /** @lends Jii.exceptions.NotSupportedException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],147:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.UnknownPropertyException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.UnknownPropertyException', /** @lends Jii.exceptions.UnknownPropertyException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],148:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 * BaseFileHelper provides concrete implementation for [[FileHelper]].
 *
 * Do not use BaseFileHelper. Use [[FileHelper]] instead.
 *
 * @class Jii.helpers.File
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.File', /** @lends Jii.helpers.File.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.File */{

		PATTERN_NODIR: 1,
		PATTERN_ENDSWITH: 4,
		PATTERN_MUSTBEDIR: 8,
		PATTERN_NEGATIVE: 16,
		PATTERN_CASE_INSENSITIVE: 32,

		/**
		 * @type {string} the path (or alias) of a PHP file containing MIME type information.
		 */
		mimeMagicFile: '@jii/helpers/mimeTypes.php',

		getFileDirectory: function(path) {
			return path.replace(/\/?[^\/]+$/, '');
		},

		getFileName: function(path) {
			return path.replace(/(.*\/)?([^\/]+)$/, '$2');
		},

		getFileExtension: function(path) {
			var matches = /\.([a-z]+)$/.exec(path);
			return matches !== null ? matches[1] : '';
		},

		isFile: function(path) {
			return path.match(/[^\/]+\.[^\/]+$/) !== null;
		},

		/**
		 * Normalizes a file/directory path.
		 * The normalization does the following work:
		 *
		 * - Convert all directory separators into `DIRECTORY_SEPARATOR` (e.g. "\a/b\c" becomes "/a/b/c")
		 * - Remove trailing directory separators (e.g. "/a/b/c/" becomes "/a/b/c")
		 * - Turn multiple consecutive slashes into a single one (e.g. "/a///b/c" becomes "/a/b/c")
		 * - Remove ".." and "." based on their meanings (e.g. "/a/./b/../c" becomes "/a/c")
		 *
		 * @param {string} path the file/directory path to be normalized
		 * @param {string} [ds] the directory separator to be used in the normalized result. Defaults to `DIRECTORY_SEPARATOR`.
		 * @returns {string} the normalized file/directory path
		 */
		normalizePath: function (path, ds) {
			ds = ds || '/';

			path = Jii._s.rtrim(path.replace(/\/\\/g, ds + ds), ds);
			if ((ds + path).indexOf(ds + '.') === -1 && path.indexOf(ds + ds) === -1) {
				return path;
			}

			// the path may contain ".", ".." or double slashes, need to clean them up
			var parts = [];
			Jii._.each(path.split(ds), function(part) {
				if (part === '..' && parts.length > 0 && parts[parts.length - 1] !== '..') {
					parts.pop();
				}
				if (part === '.' || (part === '' && parts.length > 0)) {
					return;
				}

				parts.push(part);
			});

			path = parts.join(ds);
			return path === '' ? '.' : path;
		}
	}

});
},{"../Jii":125,"../base/Object":138}],149:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 * BaseFileHelper provides concrete implementation for [[FileHelper]].
 *
 * Do not use BaseFileHelper. Use [[FileHelper]] instead.
 *
 * @class Jii.helpers.String
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.String', /** @lends Jii.helpers.String.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.String */{

		/**
		 * Generate unique hash for string. http://jsperf.com/hashcodelordvlad
		 * @param {String} str
		 * @returns {String}
		 */
		hashCode: function(str){
			return str.split("").reduce(function (a, b) {
				a = ((a << 5) - a) + b.charCodeAt(0);
				return a & a;
			}, 0).toString().replace(/-/g, '1');
		},

		generateUid: function () {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random()*16|0;
				var v = c == 'x' ? r : (r&0x3|0x8);

				return v.toString(16);
			});
		}

	}

});
},{"../Jii":125,"../base/Object":138}],150:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 *
 * @class Jii.helpers.Url
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.Url', /** @lends Jii.helpers.Url.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.Url */{

		/**
		 * Returns a value indicating whether a URL is relative.
		 * A relative URL does not have host info part.
		 * @param {string} url the URL to be checked
		 * @returns {boolean} whether the URL is relative
		 */
		isRelative: function (url) {
			return url.indexOf('//') !== 0 && url.indexOf('://') === -1;
		}
	}

});
},{"../Jii":125,"../base/Object":138}],151:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Action');

/**
 * @class Jii.request.AnonymousAction
 * @extends Jii.base.Action
 */
Jii.defineClass('Jii.request.AnonymousAction', /** @lends Jii.request.AnonymousAction.prototype */{

	__extends: Jii.base.Action,

	/**
	 * @type {string} the controller method that  this inline action is associated with
	 */
	route: null,

    /**
     * @type {function}
     */
    handler: null,

    /**
     * @type {Jii.base.Module}
     */
    module: null,

	constructor: function (route, module, handler, config) {
		this.route = route;
		this.handler = handler;
		this.module = module;

        var id = route.split('/').pop();
		this.__super(id, null, config);
	},

    /**
     * Returns the unique ID of this action among the whole application.
     * @returns {string} the unique ID of this action among the whole application.
     */
    getUniqueId: function () {
        return this.route;
    },

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {*} the result of the action
	 */
	runWithParams: function (context) {
        return Promise.resolve().then(function() {
            return this.handler.call(this.module, context);
        }.bind(this));
	}
});

},{"../Jii":125,"../base/Action":127}],152:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * HeaderCollection is used by [[Jii.base.Response]] to maintain the currently registered HTTP headers.
 *
 * @class Jii.request.HeaderCollection
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.request.HeaderCollection', /** @lends Jii.request.HeaderCollection */{

	__extends: Jii.base.Object,

    _headers: null,

    init: function() {
        this._headers = {};
    },

    /**
     * Returns the named header(s).
     * @param {string} name the name of the header to return
     * @param {*} [defaultValue] the value to return in case the named header does not exist
     * @param {boolean} [isFirst] whether to only return the first header of the specified name.
     * If false, all headers of the specified name will be returned.
     * @return [string|array] the named header(s). If `first` is true, a string will be returned;
     * If `first` is false, an array will be returned.
     */
    get: function(name, defaultValue, isFirst) {
        defaultValue = defaultValue || null;
        if (Jii._.isUndefined(isFirst)) {
            isFirst = true;
        }

        name = name.toLowerCase();
        if (Jii._.has(this._headers, name)) {
            return isFirst ? Jii._.first(this._headers[name]) : this._headers[name];
        }

        return defaultValue;
    },

    /**
     * Adds a new header.
     * If there is already a header with the same name, it will be replaced.
     * @param {string} name the name of the header
     * @param {string} [value] the value of the header
     * @return {static} the collection object itself
     */
    set: function(name, value) {
        value = value || '';

        name = name.toLowerCase();
        this._headers[name] = Jii._.isArray(value) ? value : [value];

        return this;
    },

    /**
     * Adds a new header.
     * If there is already a header with the same name, the new one will
     * be appended to it instead of replacing it.
     * @param {string} name the name of the header
     * @param {string} value the value of the header
     * @return {static} the collection object itself
     */
    add: function(name, value) {
        name = name.toLowerCase();
        if (Jii._.isArray(this._headers[name])) {
            this._headers[name] = this._headers[name].concat(value);
        } else {
            this.set(name, value);
        }

        return this;
    },

    /**
     * Sets a new header only if it does not exist yet.
     * If there is already a header with the same name, the new one will be ignored.
     * @param {string} name the name of the header
     * @param {string} [value] the value of the header
     * @return {static} the collection object itself
     */
    setDefault: function(name, value) {
        value = value || '';

        name = name.toLowerCase();
        if (!this.has(name)) {
            this.set(name, value);
        }

        return this;
    },

    /**
     * Returns a value indicating whether the named header exists.
     * @param {string} name the name of the header
     * @return {boolean} whether the named header exists
     */
    has: function(name) {
        name = name.toLowerCase();
        return Jii._.has(this._headers, name) && this._headers[name].length > 0;
    },

    /**
     * Removes a header.
     * @param {string} name the name of the header to be removed.
     * @return {string|null} the value of the removed header. Null is returned if the header does not exist.
     */
    remove: function(name) {
        name = name.toLowerCase();
        if (Jii._.has(this._headers, name)) {
            var value = this._headers[name];
            delete this._headers[name];

            return value;
        }
        return null;
    },

    /**
     * Removes all headers.
     */
    removeAll: function() {
        this._headers = {};
    },

    /**
     * Returns the collection as a key-value object.
     * @return {object}
     */
    toObject: function() {
        var headers = {};
        Jii._.each(this._headers, Jii._.bind(function(value, key) {
            headers[key] = Jii._.first(value);
        }, this));
        return headers;
    }

});

},{"../Jii":125}],153:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Action');

/**
 * @class Jii.request.InlineAction
 * @extends Jii.base.Action
 */
Jii.defineClass('Jii.request.InlineAction', /** @lends Jii.request.InlineAction */{

	__extends: Jii.base.Action,

	/**
	 * @type {string} the controller method that  this inline action is associated with
	 */
	actionMethod: null,

	constructor: function (id, controller, actionMethod, config) {
		this.actionMethod = actionMethod;
		this.__super(id, controller, config);
	},

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {*} the result of the action
	 */
	runWithParams: function (context) {
        return Promise.resolve().then(function() {
            return this.controller[this.actionMethod].call(this.controller, context);
        }.bind(this));
	}
});

},{"../Jii":125,"../base/Action":127}],154:[function(require,module,exports){
module.exports = require('./src/Neatness');
},{"./src/Neatness":157}],155:[function(require,module,exports){

module.exports = function(Neatness) {

	return Neatness.createClass('Neatness.Exception', /** @lends Neatness.Exception.prototype */{

		__extends: Error,

		/**
		 * Text message
		 * @type {string}
		 */
		message: null,

		/**
		 * Extra information dumps
		 * @type {Array}
		 */
		extra: null,

		/**
		 * Base class for implement exception. This class extend from native Error and support
		 * stack trace and message.
		 * @constructs
		 * @extends Error
		 */
		constructor: function (message) {
			if (Error.captureStackTrace) {
				Error.captureStackTrace(this, this.constructor || this);
			}

			this.name = this.constructor.name;
			this.message = message || '';

			if (arguments.length > 1) {
				this.extra = Array.prototype.slice.call(arguments, 1);
			}

			this.__super();
		},

		/**
		 *
		 * @returns {string}
		 */
		toString: function () {
			return this.message;
		}

	});

};
},{}],156:[function(require,module,exports){

module.exports = function(Neatness) {

	/**
	 * Base class. Extend all you base classes from this class for true navigation in IDE
	 * and support methods such as {@link Neatness.Object#className}
	 * @class Neatness.Object
	 */
	return Neatness.createClass('Neatness.Object', {

		/**
		 * Link to used class. If you access to this property in extends classes, then you give top-level class.
		 * @type {*}
		 */
		__static: null,

		/**
		 * Full current class name with namespace
		 * @example Returns value example
		 *  app.MyClass
		 * @type {string}
		 * @protected
		 */
		__className: null,

		/**
		 * Unique instance name
		 * @example Returns value example
		 *  app.MyClass50
		 * @type {string}
		 * @protected
		 */
		__instanceName: null,

		/**
		 * Full parent (extends) class name with namespace
		 * @example Returns value example
		 *  app.MyBaseClass
		 * @type {string}
		 * @protected
		 */
		__parentClassName: null,

		/**
		 * Returns full class name with namespace
		 * @example
		 *  app.MyClass
		 * @returns {string}
		 */
		className: function() {
			return this.__className;
		},

		/**
		 * Returns unique instance name
		 * @example
		 *  app.MyClass
		 * @returns {string}
		 */
		classInstanceName: function() {
			return this.__instanceName;
		},

		/**
		 * Returns full parent class name with namespace
		 * @example
		 *  app.MyBaseClass
		 * @returns {string}
		 */
		parentClassName: function() {
			return this.__parentClassName;
		},

		/**
		 * Call parent class methods through this method. This method support only synchronous nested calls.
		 * @param {...*}
		 * @protected
		 */
		__super: function () {
		}

	});

};

},{}],157:[function(require,module,exports){

var extendClass = require('./extendClass');
var formats = require('./formats');

// For .noConflict() implementation
var hasPreviousNeatness = typeof window !== 'undefined' && window.hasOwnProperty('Neatness');
var previousNeatness = hasPreviousNeatness ? window.Neatness : null;

/**
 * Neatness class
 * @function Neatness
 */
var Neatness = function() {

	/**
	 *
	 * @type {object}
	 */
	this._context = {};

	this._contextKeys = {};
};

/**
 * @function Neatness.prototype.newContext
 * @param {boolean} [removeGlobal] Set true for remove Neatness object from window (browser global object)
 * @returns {Neatness}
 */
Neatness.prototype.newContext = function(removeGlobal) {
	removeGlobal = removeGlobal || false;

	if (removeGlobal) {
		this.noConflict();
	}

	return new Neatness();
};

/**
 * @function Neatness.prototype.moveContext
 * @param {boolean} newContext New context object
 * @param {boolean} [removeFromOld] Set true for remove keys from old context
 * @returns {Neatness}
 */
Neatness.prototype.moveContext = function(newContext, removeFromOld) {
	removeFromOld = removeFromOld || false;

	for (var key in this._contextKeys) {
		if (this._contextKeys.hasOwnProperty(key)) {
			newContext[key] = this._context[key];
			if (removeFromOld) {
				delete this._context[key];
			}
		}
	}
	this._context = newContext;
};

/**
 * @function Neatness.prototype.noConflict
 * @returns {Neatness}
 */
Neatness.prototype.noConflict = function() {
	// Root namespace object
	var root = typeof window !== 'undefined' ? window : {};

	if (hasPreviousNeatness) {
		root.Neatness = previousNeatness;
	} else {
		delete root.Neatness;
	}

	return this;
};

/**
 * @function Neatness.prototype.namespace
 * @param {string} name Full namespace name
 * @returns {object}
 */
Neatness.prototype.namespace = function (name) {
	name = name || '';

	var nameParts = name.split('.');
	var currentScope = this._context;

	if (!name) {
		return currentScope;
	}

	// Find or create
	for (var i = 0; i < nameParts.length; i++) {
		var scopeName = nameParts[i];
		if (i === 0) {
			this._contextKeys[scopeName] = true;
		}

		if (!currentScope[scopeName]) {
			currentScope[scopeName] = {
				__className: nameParts.slice(0, i).join('.'),
				__parentClassName: null
			};
		}
		currentScope = currentScope[scopeName];
	}

	return currentScope;
};

/**
 * Method for define class
 * @function Neatness.prototype.createClass
 * @param {string} globalName
 * @param {(function|object|null)} optionsOrExtend
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.createClass = function (globalName, optionsOrExtend, prototypeProperties, staticProperties) {
	var params = formats.parseFormat(globalName, optionsOrExtend, prototypeProperties, staticProperties);

	// Support extends and mixins as strings class names
	if (typeof params[2] === 'string') {
		params[2] = this.namespace(params[2]);
	}
	var mixins = params[6];
	for (var i = 0, l = mixins.length; i < l; i++) {
		if (typeof mixins[i] === 'string') {
			mixins[i] = this.namespace(mixins[i]);
		}
	}

	// Show error if not defined extended class
	if (params[2] !== null && typeof params[2] !== 'function') {
		throw new Error('Not found extend class for `' + globalName + '`.');
	}

	var newClass = extendClass(params[0], params[1], params[2], params[6], params[3], params[4], params[7]);
	formats.applyClassConfig(newClass, params[5], params[0], params[1]);

	return newClass;
};

/**
 * Method for define class
 * @function Neatness.prototype.defineClass
 * @param {string} globalName
 * @param {(function|object|null)} optionsOrExtend
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.defineClass = function (globalName, optionsOrExtend, prototypeProperties, staticProperties) {
	var newClass = this.createClass.apply(this, arguments);
	var nameObject = formats.parseFullName(globalName);

	this.namespace(nameObject.namespace)[nameObject.name] = newClass;
	return newClass;
};

/**
 * Method for define enum
 * @function Neatness.prototype.defineClass
 * @param {string} globalName
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.defineEnum = function (globalName, staticProperties) {
	var newClass = this.createClass(globalName, null, {}, staticProperties);
	var nameObject = formats.parseFullName(globalName);

	this.namespace(nameObject.namespace)[nameObject.name] = newClass;
	return newClass;
};

var neatness = module.exports = new Neatness();

// Web browser export
if (typeof window !== 'undefined') {
	window.Neatness = neatness;
}

/**
 * @type {Neatness.prototype.Object}
 */
Neatness.prototype.Object = require('./Neatness.Object')(neatness);

/**
 * @type {Neatness.prototype.Exception}
 */
Neatness.prototype.Exception = require('./Neatness.Exception')(neatness);

/**
 * @type {string}
 */
Neatness.prototype.version = '%JOINTS_CURRENT_VERSION%';

},{"./Neatness.Exception":155,"./Neatness.Object":156,"./extendClass":158,"./formats":159}],158:[function(require,module,exports){
var isEvalEnable = true;
var instanceCounter = 0;

var _noop = function() {
};

var _createFunction = function(nameObject, constructor) {
	if (!isEvalEnable || !nameObject) {
		return function () { return constructor.apply(this, arguments); }
	}

	var nameRegExp = /[^a-z$_\.]/i;
	var name = nameObject.name || 'Function';
	var nameParts = nameObject.globalName.split('.');

	// Create root object
	var rootName = nameParts.shift();
	var cs;

	rootName = rootName.replace(nameRegExp, '');
	eval('var ' + rootName + ' = cs = {};');

	// Create fake namespace object
	for (var i = 0; i < nameParts.length; i++) {
		var scopeName = nameParts[i];
		if (!cs[scopeName]) {
			cs[scopeName] = {};
		}
		cs = cs[scopeName];
	}

	var func;
	var fullName = (nameObject.namespace ? nameObject.namespace + '.' : '') + name;

	fullName = fullName.replace(nameRegExp, '');
	eval('func = ' + fullName + ' = function () { return constructor.apply(this, arguments); }');

	return func;
};

var _isStrictObject = function (obj) {
	if (!obj || typeof obj !== 'object' || obj instanceof RegExp || obj instanceof Date) {
		return false;
	}

	var bool = true;
	for (var key in obj) {
		bool = bool && obj.hasOwnProperty(key);
	}
	return bool;
};

var _clone = function(obj) {
	if (!_isStrictObject(obj)) {
		return obj;
	}

	var copy = obj.constructor();
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			copy[key] = _clone(obj[key]);
		}
	}
	return copy;
};

var _cloneObjInProto = function(obj) {
	for (var key in obj) {
		if (typeof obj === "object") {
			obj[key] = _clone(obj[key]);
		}
	}
};

var _coverVirtual = function (childMethod, parentMethod, superName) {
	return function () {
		var currentSuper = this[superName];
		this[superName] = parentMethod;
		var r = childMethod.apply(this, arguments);
		this[superName] = currentSuper;
		return r;
	};
};

var _extendWithSuper = function (childClass, newProperties, superName) {
	if (!newProperties) {
		return;
	}

	// Extend and setup virtual methods
	for (var key in newProperties) {
		if (!newProperties.hasOwnProperty(key)) {
			continue;
		}

		var value = newProperties[key];
		if (typeof value == 'function' && typeof childClass[key] == 'function' && childClass[key] !== _noop) {
			childClass[key] = _coverVirtual(value, childClass[key], superName);
		} else {
			childClass[key] = _clone(value);
		}
	}

	// Default state
	if (!childClass[superName]) {
		childClass[superName] = _noop;
	}
};

/**
 * Extend class
 * @param {object} nameObject
 * @param {object} parentNameObject
 * @param {function} [parentClass]
 * @param {function} [mixins]
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @returns {function} New class
 */
module.exports = function (nameObject, parentNameObject, parentClass, mixins, prototypeProperties, staticProperties, superName) {
	parentClass = parentClass || _noop;
	mixins = mixins || [];

	// The constructor function for the new subclass is either defined by you
	// (the "constructor" property in your `extend` definition), or defaulted
	// by us to simply call the parent's constructor.
	var constructor = prototypeProperties && prototypeProperties.hasOwnProperty('constructor') ?
		_coverVirtual(prototypeProperties.constructor, parentClass, superName) :
		parentClass;
	var childClass = _createFunction(nameObject, function() {
		if (!this.__instanceName) {
			_cloneObjInProto(this);
			this.__instanceName  = nameObject.globalName + instanceCounter++;
		}
		constructor.apply(this, arguments);
	});

	// Add static properties to the constructor function, if supplied.
	for (var prop in parentClass) {
		childClass[prop] = parentClass[prop];
	}
	_extendWithSuper(childClass, staticProperties, superName);

	// Set the prototype chain to inherit from `parent`, without calling
	// `parent`'s constructor function.
	var Surrogate = _createFunction(parentNameObject, _noop);
	Surrogate.prototype = parentClass.prototype;

	childClass.prototype = new Surrogate();

	// Copy objects from child prototype
	for (var prop2 in parentClass.prototype) {
		if (parentClass.prototype.hasOwnProperty(prop2) && prop2 !== 'constructor') {
			childClass.prototype[prop2] = _clone(parentClass.prototype[prop2]);
		}
	}

	// Add prototype properties (instance properties) to the subclass,
	// if supplied.
	if (prototypeProperties) {
		_extendWithSuper(childClass.prototype, prototypeProperties, superName);
	}

	// Add prototype properties and methods from mixins
	for (var i = 0, l = mixins.length; i < l; i++) {
		for (var mixinProp in mixins[i].prototype) {
			// Skip private
			if (mixinProp.substr(0, 2) === '__') {
				continue;
			}

			// Check for exists property or method. Mixin can only add properties, but no replace it
			if (typeof childClass.prototype[mixinProp] === 'function' || childClass.prototype.hasOwnProperty(mixinProp)) {
				throw new Error('Try to replace prototype property `' + mixinProp + '` in class `' + childClass.__className + '` by mixin `' + mixins[i].__className + '`');
			}
			childClass.prototype[mixinProp] = mixins[i].prototype[mixinProp];
		}
	}
	// Add static properties and methods from mixins
	for (var i = 0, l = mixins.length; i < l; i++) {
		for (var mixinProp in mixins[i]) {
			// Skip private
			if (mixinProp.substr(0, 2) === '__') {
				continue;
			}

			// Check for exists property or method. Mixin can only add properties, but no replace it
			if (typeof childClass[mixinProp] === 'function' || childClass.hasOwnProperty(mixinProp)) {
				throw new Error('Try to replace static property `' + mixinProp + '` in class `' + childClass.__className + '` by mixin `' + mixins[i].__className + '`');
			}
			childClass[mixinProp] = mixins[i][mixinProp];
		}
	}

	return childClass;
};

},{}],159:[function(require,module,exports){
var FORMAT_JOINTS_V02 = 'neatness_v02';
var FORMAT_JOINTS_V10 = 'neatness_v10';

module.exports = {

	/**
	 * Detect format and return class params
	 * @param {string} globalName
	 * @param {(function|object|null)} optionsOrExtend
	 * @param {object} [protoProps]
	 * @param {object} [staticProps]
	 * @returns {object}
	 */
	parseFormat: function (globalName, optionsOrExtend, protoProps, staticProps) {
		var nameObject = this.parseFullName(globalName);
		var parentNameObject = null;
		var parentClass = null;
		var prototypeProperties = null;
		var staticProperties = null;
		var format = null;
		var mixins = [];

		// Neatness v0.2 (old) format
		if (optionsOrExtend === null || typeof optionsOrExtend === 'function') {
			parentClass = optionsOrExtend;
			prototypeProperties = protoProps;
			staticProperties = staticProps;
			format = FORMAT_JOINTS_V02;

			if (parentClass && typeof parentClass.debugClassName === 'string') {
				parentNameObject = this.parseFullName(parentClass.debugClassName);
			}

			// Neatness v1.0 format
		} else if (typeof optionsOrExtend === 'object') {
			if (optionsOrExtend.hasOwnProperty('__extends')) {
				parentClass = optionsOrExtend.__extends;
				delete optionsOrExtend.__extends;
			}

			if (optionsOrExtend.hasOwnProperty('__static')) {
				staticProperties = optionsOrExtend.__static;
				delete optionsOrExtend.__static;
			}

			if (optionsOrExtend.hasOwnProperty('__mixins')) {
				mixins = mixins.concat(optionsOrExtend.__mixins);
				delete optionsOrExtend.__mixins;
			}
			if (optionsOrExtend.hasOwnProperty('__mixin')) {
				mixins = mixins.concat(optionsOrExtend.__mixin);
				delete optionsOrExtend.__mixin;
			}

			format = FORMAT_JOINTS_V10;
			prototypeProperties = optionsOrExtend;

			if (parentClass && typeof parentClass.__className === 'string') {
				parentNameObject = this.parseFullName(parentClass.__className);
			}
		}

		return [
			nameObject,
			parentNameObject,
			parentClass,
			prototypeProperties,
			staticProperties,
			format,
			mixins,
			format === FORMAT_JOINTS_V02 ? '_super' : '__super'
		];
	},

	applyClassConfig: function(newClass, format, nameObject, parentNameObject) {
		// Set __className for all formats
		newClass.__className = newClass.prototype.__className = nameObject.globalName;

		var classNameKey = format === FORMAT_JOINTS_V02 ? 'debugClassName' : '__className';
		var parentClassNameKey = format === FORMAT_JOINTS_V02 ? '' : '__parentClassName';
		var staticNameKey = format === FORMAT_JOINTS_V02 ? '_static' : '__static';

		newClass[classNameKey] = newClass.prototype[classNameKey] = nameObject.globalName;
		if (parentClassNameKey) {
			newClass[parentClassNameKey] = newClass.prototype[parentClassNameKey] = parentNameObject ? (parentNameObject.globalName || null) : null;
		}
		newClass[staticNameKey] = newClass.prototype[staticNameKey] = newClass;

		return newClass;
	},

	parseFullName: function(globalName) {
		// Split namespace
		var pos = globalName.lastIndexOf('.');

		return {
			globalName: globalName,
			name: pos !== -1 ? globalName.substr(pos + 1) : globalName,
			namespace: pos !== -1 ? globalName.substr(0, pos) : ''
		};
	}

};

},{}],160:[function(require,module,exports){
//  Underscore.string
//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
//  Underscore.string is freely distributable under the terms of the MIT license.
//  Documentation: https://github.com/epeli/underscore.string
//  Some code is borrowed from MooTools and Alexandru Marasteanu.
//  Version '2.4.0'

!function(root, String){
  'use strict';

  // Defining helper functions.

  var nativeTrim = String.prototype.trim;
  var nativeTrimRight = String.prototype.trimRight;
  var nativeTrimLeft = String.prototype.trimLeft;

  var parseNumber = function(source) { return source * 1 || 0; };

  var strRepeat = function(str, qty){
    if (qty < 1) return '';
    var result = '';
    while (qty > 0) {
      if (qty & 1) result += str;
      qty >>= 1, str += str;
    }
    return result;
  };

  var slice = [].slice;

  var defaultToWhiteSpace = function(characters) {
    if (characters == null)
      return '\\s';
    else if (characters.source)
      return characters.source;
    else
      return '[' + _s.escapeRegExp(characters) + ']';
  };

  // Helper for toBoolean
  function boolMatch(s, matchers) {
    var i, matcher, down = s.toLowerCase();
    matchers = [].concat(matchers);
    for (i = 0; i < matchers.length; i += 1) {
      matcher = matchers[i];
      if (!matcher) continue;
      if (matcher.test && matcher.test(s)) return true;
      if (matcher.toLowerCase() === down) return true;
    }
  }

  var escapeChars = {
    lt: '<',
    gt: '>',
    quot: '"',
    amp: '&',
    apos: "'"
  };

  var reversedEscapeChars = {};
  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;
  reversedEscapeChars["'"] = '#39';

  // sprintf() for JavaScript 0.7-beta1
  // http://www.diveintojavascript.com/projects/javascript-sprintf
  //
  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
  // All rights reserved.

  var sprintf = (function() {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }

    var str_repeat = strRepeat;

    var str_format = function() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
      for (i = 0; i < tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === 'string') {
          output.push(parse_tree[i]);
        }
        else if (node_type === 'array') {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) { // keyword argument
            arg = argv[cursor];
            for (k = 0; k < match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          } else if (match[1]) { // positional argument (explicit)
            arg = argv[match[1]];
          }
          else { // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
          }
          switch (match[8]) {
            case 'b': arg = arg.toString(2); break;
            case 'c': arg = String.fromCharCode(arg); break;
            case 'd': arg = parseInt(arg, 10); break;
            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
            case 'o': arg = arg.toString(8); break;
            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
            case 'u': arg = Math.abs(arg); break;
            case 'x': arg = arg.toString(16); break;
            case 'X': arg = arg.toString(16).toUpperCase(); break;
          }
          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        }
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push('%');
        }
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else {
                  throw new Error('[_.sprintf] huh?');
                }
              }
            }
            else {
              throw new Error('[_.sprintf] huh?');
            }
            match[2] = field_list;
          }
          else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
          }
          parse_tree.push(match);
        }
        else {
          throw new Error('[_.sprintf] huh?');
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();



  // Defining underscore.string

  var _s = {

    VERSION: '2.4.0',

    isBlank: function(str){
      if (str == null) str = '';
      return (/^\s*$/).test(str);
    },

    stripTags: function(str){
      if (str == null) return '';
      return String(str).replace(/<\/?[^>]+>/g, '');
    },

    capitalize : function(str){
      str = str == null ? '' : String(str);
      return str.charAt(0).toUpperCase() + str.slice(1);
    },

    chop: function(str, step){
      if (str == null) return [];
      str = String(str);
      step = ~~step;
      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
    },

    clean: function(str){
      return _s.strip(str).replace(/\s+/g, ' ');
    },

    count: function(str, substr){
      if (str == null || substr == null) return 0;

      str = String(str);
      substr = String(substr);

      var count = 0,
        pos = 0,
        length = substr.length;

      while (true) {
        pos = str.indexOf(substr, pos);
        if (pos === -1) break;
        count++;
        pos += length;
      }

      return count;
    },

    chars: function(str) {
      if (str == null) return [];
      return String(str).split('');
    },

    swapCase: function(str) {
      if (str == null) return '';
      return String(str).replace(/\S/g, function(c){
        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
      });
    },

    escapeHTML: function(str) {
      if (str == null) return '';
      return String(str).replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });
    },

    unescapeHTML: function(str) {
      if (str == null) return '';
      return String(str).replace(/\&([^;]+);/g, function(entity, entityCode){
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      });
    },

    escapeRegExp: function(str){
      if (str == null) return '';
      return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    },

    splice: function(str, i, howmany, substr){
      var arr = _s.chars(str);
      arr.splice(~~i, ~~howmany, substr);
      return arr.join('');
    },

    insert: function(str, i, substr){
      return _s.splice(str, i, 0, substr);
    },

    include: function(str, needle){
      if (needle === '') return true;
      if (str == null) return false;
      return String(str).indexOf(needle) !== -1;
    },

    join: function() {
      var args = slice.call(arguments),
        separator = args.shift();

      if (separator == null) separator = '';

      return args.join(separator);
    },

    lines: function(str) {
      if (str == null) return [];
      return String(str).split("\n");
    },

    reverse: function(str){
      return _s.chars(str).reverse().join('');
    },

    startsWith: function(str, starts){
      if (starts === '') return true;
      if (str == null || starts == null) return false;
      str = String(str); starts = String(starts);
      return str.length >= starts.length && str.slice(0, starts.length) === starts;
    },

    endsWith: function(str, ends){
      if (ends === '') return true;
      if (str == null || ends == null) return false;
      str = String(str); ends = String(ends);
      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
    },

    succ: function(str){
      if (str == null) return '';
      str = String(str);
      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);
    },

    titleize: function(str){
      if (str == null) return '';
      str  = String(str).toLowerCase();
      return str.replace(/(?:^|\s|-)\S/g, function(c){ return c.toUpperCase(); });
    },

    camelize: function(str){
      return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : ""; });
    },

    underscored: function(str){
      return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
    },

    dasherize: function(str){
      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
    },

    classify: function(str){
      return _s.capitalize(_s.camelize(String(str).replace(/[\W_]/g, ' ')).replace(/\s/g, ''));
    },

    humanize: function(str){
      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));
    },

    trim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrim) return nativeTrim.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
    },

    ltrim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp('^' + characters + '+'), '');
    },

    rtrim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp(characters + '+$'), '');
    },

    truncate: function(str, length, truncateStr){
      if (str == null) return '';
      str = String(str); truncateStr = truncateStr || '...';
      length = ~~length;
      return str.length > length ? str.slice(0, length) + truncateStr : str;
    },

    /**
     * _s.prune: a more elegant version of truncate
     * prune extra chars, never leaving a half-chopped word.
     * @author github.com/rwz
     */
    prune: function(str, length, pruneStr){
      if (str == null) return '';

      str = String(str); length = ~~length;
      pruneStr = pruneStr != null ? String(pruneStr) : '...';

      if (str.length <= length) return str;

      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

      if (template.slice(template.length-2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, '');
      else
        template = _s.rtrim(template.slice(0, template.length-1));

      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;
    },

    words: function(str, delimiter) {
      if (_s.isBlank(str)) return [];
      return _s.trim(str, delimiter).split(delimiter || /\s+/);
    },

    pad: function(str, length, padStr, type) {
      str = str == null ? '' : String(str);
      length = ~~length;

      var padlen  = 0;

      if (!padStr)
        padStr = ' ';
      else if (padStr.length > 1)
        padStr = padStr.charAt(0);

      switch(type) {
        case 'right':
          padlen = length - str.length;
          return str + strRepeat(padStr, padlen);
        case 'both':
          padlen = length - str.length;
          return strRepeat(padStr, Math.ceil(padlen/2)) + str
                  + strRepeat(padStr, Math.floor(padlen/2));
        default: // 'left'
          padlen = length - str.length;
          return strRepeat(padStr, padlen) + str;
        }
    },

    lpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr);
    },

    rpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, 'right');
    },

    lrpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, 'both');
    },

    sprintf: sprintf,

    vsprintf: function(fmt, argv){
      argv.unshift(fmt);
      return sprintf.apply(null, argv);
    },

    toNumber: function(str, decimals) {
      if (!str) return 0;
      str = _s.trim(str);
      if (!str.match(/^-?\d+(?:\.\d+)?$/)) return NaN;
      return parseNumber(parseNumber(str).toFixed(~~decimals));
    },

    numberFormat : function(number, dec, dsep, tsep) {
      if (isNaN(number) || number == null) return '';

      number = number.toFixed(~~dec);
      tsep = typeof tsep == 'string' ? tsep : ',';

      var parts = number.split('.'), fnums = parts[0],
        decimals = parts[1] ? (dsep || '.') + parts[1] : '';

      return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
    },

    strRight: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strRightBack: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.lastIndexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strLeft: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    strLeftBack: function(str, sep){
      if (str == null) return '';
      str += ''; sep = sep != null ? ''+sep : sep;
      var pos = str.lastIndexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    toSentence: function(array, separator, lastSeparator, serial) {
      separator = separator || ', ';
      lastSeparator = lastSeparator || ' and ';
      var a = array.slice(), lastMember = a.pop();

      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;

      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
    },

    toSentenceSerial: function() {
      var args = slice.call(arguments);
      args[3] = true;
      return _s.toSentence.apply(_s, args);
    },

    slugify: function(str) {
      if (str == null) return '';

      var from  = "Ä…Ã Ã¡Ã¤Ã¢Ã£Ã¥Ã¦ÄƒÄ‡Ä™Ã¨Ã©Ã«ÃªÃ¬Ã­Ã¯Ã®Å‚Å„Ã²Ã³Ã¶Ã´ÃµÃ¸Å›È™È›Ã¹ÃºÃ¼Ã»Ã±Ã§Å¼Åº",
          to    = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz",
          regex = new RegExp(defaultToWhiteSpace(from), 'g');

      str = String(str).toLowerCase().replace(regex, function(c){
        var index = from.indexOf(c);
        return to.charAt(index) || '-';
      });

      return _s.dasherize(str.replace(/[^\w\s-]/g, ''));
    },

    surround: function(str, wrapper) {
      return [wrapper, str, wrapper].join('');
    },

    quote: function(str, quoteChar) {
      return _s.surround(str, quoteChar || '"');
    },

    unquote: function(str, quoteChar) {
      quoteChar = quoteChar || '"';
      if (str[0] === quoteChar && str[str.length-1] === quoteChar)
        return str.slice(1,str.length-1);
      else return str;
    },

    exports: function() {
      var result = {};

      for (var prop in this) {
        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
        result[prop] = this[prop];
      }

      return result;
    },

    repeat: function(str, qty, separator){
      if (str == null) return '';

      qty = ~~qty;

      // using faster implementation if separator is not needed;
      if (separator == null) return strRepeat(String(str), qty);

      // this one is about 300x slower in Google Chrome
      for (var repeat = []; qty > 0; repeat[--qty] = str) {}
      return repeat.join(separator);
    },

    naturalCmp: function(str1, str2){
      if (str1 == str2) return 0;
      if (!str1) return -1;
      if (!str2) return 1;

      var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g,
        tokens1 = String(str1).toLowerCase().match(cmpRegex),
        tokens2 = String(str2).toLowerCase().match(cmpRegex),
        count = Math.min(tokens1.length, tokens2.length);

      for(var i = 0; i < count; i++) {
        var a = tokens1[i], b = tokens2[i];

        if (a !== b){
          var num1 = parseInt(a, 10);
          if (!isNaN(num1)){
            var num2 = parseInt(b, 10);
            if (!isNaN(num2) && num1 - num2)
              return num1 - num2;
          }
          return a < b ? -1 : 1;
        }
      }

      if (tokens1.length === tokens2.length)
        return tokens1.length - tokens2.length;

      return str1 < str2 ? -1 : 1;
    },

    levenshtein: function(str1, str2) {
      if (str1 == null && str2 == null) return 0;
      if (str1 == null) return String(str2).length;
      if (str2 == null) return String(str1).length;

      str1 = String(str1); str2 = String(str2);

      var current = [], prev, value;

      for (var i = 0; i <= str2.length; i++)
        for (var j = 0; j <= str1.length; j++) {
          if (i && j)
            if (str1.charAt(j - 1) === str2.charAt(i - 1))
              value = prev;
            else
              value = Math.min(current[j], current[j - 1], prev) + 1;
          else
            value = i + j;

          prev = current[j];
          current[j] = value;
        }

      return current.pop();
    },

    toBoolean: function(str, trueValues, falseValues) {
      if (typeof str === "number") str = "" + str;
      if (typeof str !== "string") return !!str;
      str = _s.trim(str);
      if (boolMatch(str, trueValues || ["true", "1"])) return true;
      if (boolMatch(str, falseValues || ["false", "0"])) return false;
    }
  };

  // Aliases

  _s.strip    = _s.trim;
  _s.lstrip   = _s.ltrim;
  _s.rstrip   = _s.rtrim;
  _s.center   = _s.lrpad;
  _s.rjust    = _s.lpad;
  _s.ljust    = _s.rpad;
  _s.contains = _s.include;
  _s.q        = _s.quote;
  _s.toBool   = _s.toBoolean;

  // Exporting

  // CommonJS module is defined
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      module.exports = _s;

    exports._s = _s;
  }

  // Register as a named module with AMD.
  if (typeof define === 'function' && define.amd)
    define('underscore.string', [], function(){ return _s; });


  // Integrate with Underscore.js if defined
  // or create our own underscore object.
  root._ = root._ || {};
  root._.string = root._.str = _s;
}(this, String);

},{}],161:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],162:[function(require,module,exports){
module.exports={
  "name": "jii",
  "version": "0.7.1",
  "description": "Jii - Full-Stack JavaScript Framework",
  "main": "index.js",
  "browser": "index-client.js",
  "author": "Vladimir Kozhin <affka@affka.ru>",
  "scripts": {
    "test": "nodeunit tests/unit"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jiisoft/jii"
  },
  "keywords": [
    "yii",
    "php",
    "framework",
    "javascript"
  ],
  "license": "MIT",
  "homepage": "https://github.com/jiisoft/jii",
  "bugs": {
    "url": "https://github.com/jiisoft/jii/issues"
  },
  "dependencies": {
    "neatness": "^1.1.10",
    "require-all": "0.0.8",
    "underscore": "^1.8.3",
    "underscore.string": "^2.4.0"
  },
  "devDependencies": {
    "nodeunit": "*"
  }
}

},{}]},{},[94]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJhcHAtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbndpbmRvdy5fID0gd2luZG93Ll8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxucmVxdWlyZSgnLi9saWIvY2xpZW50QmFzZUJyb3dzZXJpZnknKTtcclxucmVxdWlyZSgnLi9saWIvT2JqZWN0Jyk7XHJcbnJlcXVpcmUoJy4vbGliL0V4Y2VwdGlvbicpO1xyXG5yZXF1aXJlKCcuL2xpYi9OZWF0Q29tZXRDbGllbnQnKTtcclxucmVxdWlyZSgnLi9saWIvcm91dGVyL0Nvbm5lY3Rpb25DbGllbnQnKTtcclxucmVxdWlyZSgnLi9saWIvcm91dGVyL09wZW5lZFByb2ZpbGVDbGllbnQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gd2luZG93Lk5lYXRDb21ldDtcbn0se1wiLi9saWIvRXhjZXB0aW9uXCI6MyxcIi4vbGliL05lYXRDb21ldENsaWVudFwiOjQsXCIuL2xpYi9PYmplY3RcIjo1LFwiLi9saWIvY2xpZW50QmFzZUJyb3dzZXJpZnlcIjo2LFwiLi9saWIvcm91dGVyL0Nvbm5lY3Rpb25DbGllbnRcIjo3LFwiLi9saWIvcm91dGVyL09wZW5lZFByb2ZpbGVDbGllbnRcIjo4LFwidW5kZXJzY29yZVwiOjF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LkV4Y2VwdGlvblxyXG4gKi9cclxuTmVhdENvbWV0LkV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1zZykge1xyXG5cclxuICAgIHRoaXMubXNnID0gbXNnO1xyXG59O1xyXG5cclxuTmVhdENvbWV0LkV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgbXNnOiBudWxsXHJcblxyXG59O1xyXG5cclxuTmVhdENvbWV0LkV4Y2VwdGlvbi53YXJuaW5nID0gZnVuY3Rpb24obXNnKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOZWF0Q29tZXQgd2FybmluZzogXCIgKyBtc2cpO1xyXG4gICAgfVxyXG59O1xyXG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBjYWxsYmFjayBOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50fmNyZWF0ZUNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHByb2ZpbGVJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ0lkXHJcbiAqIEBwYXJhbSB7Kn0gcHJvZmlsZXNEZWZpbml0aW9uXHJcbiAqIEBwYXJhbSB7TmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50fSBvcGVuZWRQcm9maWxlXHJcbiAqIEByZXR1cm5zIHtOZWF0Q29tZXQuYXBpLklDb2xsZWN0aW9uQ2xpZW50fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0Lk5lYXRDb21ldENsaWVudFxyXG4gKiBAZXh0ZW5kcyBOZWF0Q29tZXQuT2JqZWN0XHJcbiAqL1xyXG5OZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50ID0gTmVhdENvbWV0Lk9iamVjdC5leHRlbmQoLyoqIEBsZW5kcyBOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge05lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50fSAqL1xyXG4gICAgY29tZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50fmNyZWF0ZUNvbGxlY3Rpb259ICovXHJcbiAgICBjcmVhdGVDb2xsZWN0aW9uOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCAqPj59ICovXHJcbiAgICBwcm9maWxlc0RlZmluaXRpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXHJcbiAgICBfb3BlbmVkUHJvZmlsZVBhcmFtczogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdC48bnVtYmVyLCBOZWF0Q29tZXQucm91dGVyLk9wZW5lZFByb2ZpbGVDbGllbnQ+fSAqL1xyXG4gICAgX29wZW5lZFByb2ZpbGVzOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE5lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudFtdPn0gKi9cclxuICAgIF9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7TmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50fSAqL1xyXG4gICAgX2Nvbm5lY3Rpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBfbGFzdElkOiAwLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlUGFyYW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fb3BlbmVkUHJvZmlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkID0ge307XHJcblxyXG4gICAgICAgIC8vIFNldHVwIGNoYW5uZWxcclxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uID0gbmV3IE5lYXRDb21ldC5yb3V0ZXIuQ29ubmVjdGlvbkNsaWVudCh7XHJcbiAgICAgICAgICAgIGNvbWV0OiB0aGlzLmNvbWV0LFxyXG4gICAgICAgICAgICBvbkNvbm5lY3Rpb25SZXN0b3JlOiBfLmJpbmQodGhpcy5yZWZyZXNoLCB0aGlzKSxcclxuICAgICAgICAgICAgb25Jbml0OiBfLmJpbmQodGhpcy5fb25SZWZyZXNoUmVzcG9uc2UsIHRoaXMpLFxyXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IF8uYmluZCh0aGlzLl9vbkNoYW5uZWxNZXNzYWdlLCB0aGlzKVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICByZWZyZXNoOiBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgLy8gQ2FsbCBzZXJ2ZXJcclxuICAgICAgICBpZiAodGhpcy5fb3BlbmVkUHJvZmlsZVBhcmFtcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbi5zZW5kT3Blbih0aGlzLl9vcGVuZWRQcm9maWxlUGFyYW1zKTtcclxuICAgICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9maWxlSWRcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXVxyXG4gICAgICogQHJldHVybnMge05lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudH1cclxuICAgICAqL1xyXG4gICAgb3BlblByb2ZpbGU6IGZ1bmN0aW9uKHByb2ZpbGVJZCwgcGFyYW1zKSB7XHJcblxyXG4gICAgICAgIHZhciBvcGVuZWRQcm9maWxlSWQgPSArK3RoaXMuX2xhc3RJZDtcclxuXHJcbiAgICAgICAgdGhpcy5fb3BlbmVkUHJvZmlsZVBhcmFtcy5wdXNoKFtvcGVuZWRQcm9maWxlSWQsIHByb2ZpbGVJZCwgcGFyYW1zIHx8IHt9XSk7XHJcblxyXG4gICAgICAgIC8vIEluaXQgb3BlbmVkUHJvZmlsZVxyXG4gICAgICAgIHZhciBvcGVuZWRQcm9maWxlID0gbmV3IE5lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudCgpO1xyXG4gICAgICAgIG9wZW5lZFByb2ZpbGUuaWQgPSBvcGVuZWRQcm9maWxlSWQ7XHJcbiAgICAgICAgb3BlbmVkUHJvZmlsZS5wcm9maWxlSWQgPSBwcm9maWxlSWQ7XHJcbiAgICAgICAgb3BlbmVkUHJvZmlsZS5jcmVhdGVDb2xsZWN0aW9uID0gdGhpcy5jcmVhdGVDb2xsZWN0aW9uIHx8IC8qIGxlZ2FjeSAqLyB0aGlzLmdldENvbGxlY3Rpb247XHJcbiAgICAgICAgb3BlbmVkUHJvZmlsZS5wcm9maWxlRGVmaW5pdGlvbiA9IHRoaXMucHJvZmlsZXNEZWZpbml0aW9uW3Byb2ZpbGVJZF07XHJcbiAgICAgICAgb3BlbmVkUHJvZmlsZS5pbml0KCk7XHJcbiAgICAgICAgdGhpcy5fb3BlbmVkUHJvZmlsZXNbb3BlbmVkUHJvZmlsZUlkXSA9IG9wZW5lZFByb2ZpbGU7XHJcblxyXG4gICAgICAgIGlmICghdGhpcy5fb3BlbmVkUHJvZmlsZXNCeVByb2ZpbGVJZFtwcm9maWxlSWRdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29wZW5lZFByb2ZpbGVzQnlQcm9maWxlSWRbcHJvZmlsZUlkXSA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkW3Byb2ZpbGVJZF0ucHVzaChvcGVuZWRQcm9maWxlKTtcclxuXHJcbiAgICAgICAgLy8gQ29ubmVjdFxyXG4gICAgICAgIC8vIFRPRE86IG9wdGltaXplXHJcbiAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb24gJiYgdGhpcy5fY29ubmVjdGlvbi5pc1JlYWR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIG9wZW5lZFByb2ZpbGU7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIHByb2ZpbGVzXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2tcclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIG9wZW46IGZ1bmN0aW9uKHByb2ZpbGVzLCBjYWxsYmFjaykge1xyXG5cclxuICAgICAgICAvLyBNYXJrXHJcbiAgICAgICAgXy5lYWNoKHByb2ZpbGVzLCBmdW5jdGlvbihwYXJhbXMsIHByb2ZpbGVJZCkge1xyXG5cclxuICAgICAgICAgICAgdmFyIG9wZW5lZFByb2ZpbGUgPSB0aGlzLm9wZW5Qcm9maWxlKHByb2ZpbGVJZCwgcGFyYW1zKTtcclxuXHJcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2sob3BlbmVkUHJvZmlsZSwgb3BlbmVkUHJvZmlsZS5wcm9maWxlSWQsIG9wZW5lZFByb2ZpbGUuaWQpO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfb25SZWZyZXNoUmVzcG9uc2U6IGZ1bmN0aW9uKHByb2ZpbGVEYXRhKSB7XHJcblxyXG4gICAgICAgIC8vIFNldHVwIGVuYWJsZWQgYmluZGluZ3NcclxuICAgICAgICBfLmVhY2gocHJvZmlsZURhdGEsIGZ1bmN0aW9uKHByb2ZpbGVCaW5kaW5ncywgcHJvZmlsZUlkKSB7XHJcblxyXG4gICAgICAgICAgICBfLmVhY2gocHJvZmlsZUJpbmRpbmdzLCBmdW5jdGlvbihiaW5kaW5nSWRfZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgICAgIHZhciBiaW5kaW5nSWQgPSBiaW5kaW5nSWRfZGF0YVswXTtcclxuXHJcbiAgICAgICAgICAgICAgICBfLmVhY2godGhpcy5fb3BlbmVkUHJvZmlsZXNCeVByb2ZpbGVJZFtwcm9maWxlSWRdLCBmdW5jdGlvbihvcGVuZWRQcm9maWxlKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIEluaXQgY2FsbFxyXG4gICAgICAgICAgICAgICAgICAgIG9wZW5lZFByb2ZpbGUuZ2V0Q29sbGVjdGlvbihiaW5kaW5nSWQpLnJlc2V0KGJpbmRpbmdJZF9kYXRhWzFdKTtcclxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xyXG5cclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgIH0sIHRoaXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICBfb25DaGFubmVsTWVzc2FnZTogZnVuY3Rpb24oY2hhbm5lbCwgZGF0YSkge1xyXG5cclxuICAgICAgICB2YXIgcmVncyA9IGNoYW5uZWwubWF0Y2goL14oW146XSspOihbXjpdKykoOi4rKT8vKTtcclxuICAgICAgICB0aGlzLl9jYWxsQ29sbGVjdGlvbnMocmVnc1sxXSwgcmVnc1syXSwgZGF0YSk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9jYWxsQ29sbGVjdGlvbnM6IGZ1bmN0aW9uKHByb2ZpbGVSZWYsIGJpbmRpbmdJZCwgYXJncykge1xyXG5cclxuICAgICAgICB2YXIgY29tbWFuZCA9IGFyZ3NbMF07XHJcbiAgICAgICAgYXJncyA9IGFyZ3Muc2xpY2UoMSk7XHJcblxyXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxDb2xsZWN0aW9uKG9wZW5lZFByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBvcGVuZWRQcm9maWxlLmdldENvbGxlY3Rpb24oYmluZGluZ0lkKTtcclxuICAgICAgICAgICAgY29sbGVjdGlvbltjb21tYW5kXS5hcHBseShjb2xsZWN0aW9uLCBhcmdzKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChwcm9maWxlUmVmLnN1YnN0cigwLCAxKSA9PT0gJyEnKSB7XHJcbiAgICAgICAgICAgIGNhbGxDb2xsZWN0aW9uKHRoaXMuX29wZW5lZFByb2ZpbGVzW3Byb2ZpbGVSZWYuc3Vic3RyKDEpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5fb3BlbmVkUHJvZmlsZXNCeVByb2ZpbGVJZFtwcm9maWxlUmVmXSwgY2FsbENvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn0pO1xyXG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IDIwMTQgPGEgaHJlZj1cImh0dHA6Ly93d3cuZXh0cG9pbnQuY29tXCI+RXh0UG9pbnQ8L2E+XHJcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly9rb3J5YWdpbi5jb21cIj5QYXZlbCBLb3J5YWdpbjwvYT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJhc2ljIGNsYXNzIHN1cHBvcnRzIHR3byB0eXBlcyBvZiBpbml0aWFsaXphdGlvblxyXG4gKlxyXG4gKiBJLiBTaW5nbGUgb3BlcmF0b3IgY2FsbC4gTm90ZTogaW5pdCgpIGlzIGJlaW5nIGNhbGxlZCBpbnRlcm5hbGx5XHJcbiAqIHZhciB4ID0gbmV3IFgoe1xyXG4gKiAgICAgYWJjOiAxMjNcclxuICogfSk7XHJcbiAqXHJcbiAqIElJLiBFeHBsaWNpdCBpbml0aWFsaXphdGlvblxyXG4gKiB2YXIgeCA9IG5ldyBYOyAvLyBEb24ndCBwYXNzIGFueSBwYXJhbWV0ZXIgaW4gY29uc3RydWN0b3IuIGluaXQoKSB3b24ndCBiZSBjYWxsZWQgaW1wbGljaXRseS5cclxuICogeC5hYmMgPSAxMjM7XHJcbiAqIHguaW5pdCgpO1xyXG4gKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0Lk9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gW2NvbmZpZ11cclxuICovXHJcbk5lYXRDb21ldC5PYmplY3QgPSBmdW5jdGlvbihjb25maWcpIHtcclxuXHJcbiAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgXy5hc3NpZ24odGhpcywgY29uZmlnKTtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5lYXRDb21ldC5PYmplY3QucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0byBkZWZpbmUgc3ViY2xhc3Nlc1xyXG4gKlxyXG4gKiBJdCBpcyBhIHBhcnQgb2YgQmFja2JvbmUuanMgMS4yLjMgaHR0cDovL2JhY2tib25lanMub3JnXHJcbiAqIChjKSAyMDEwLTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHNcclxuICogQHBhcmFtIHtPYmplY3R9IFtzdGF0aWNQcm9wc11cclxuICovXHJcbk5lYXRDb21ldC5PYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcclxuICAgIHZhciBjaGlsZDtcclxuXHJcbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XHJcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcclxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXHJcbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xyXG4gICAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXHJcbiAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcclxuICAgIC8vIGBwYXJlbnRgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCl7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfTtcclxuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcclxuXHJcbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcclxuICAgIC8vIGlmIHN1cHBsaWVkLlxyXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcblxyXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxyXG4gICAgLy8gbGF0ZXIuXHJcbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG5cclxuICAgIHJldHVybiBjaGlsZDtcclxufTtcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gRW5vdWdoIGpzZG9jIGlzIGluIHNlcnZlckJhc2UuanNcclxud2luZG93Lk5lYXRDb21ldCA9IHtcclxuICAgIGFkYXB0ZXJzOiB7fSxcclxuICAgIHJvdXRlcjoge31cclxufTtcclxuXG59LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50XHJcbiAqIEBleHRlbmRzIE5lYXRDb21ldC5PYmplY3RcclxuICovXHJcbk5lYXRDb21ldC5yb3V0ZXIuQ29ubmVjdGlvbkNsaWVudCA9IE5lYXRDb21ldC5PYmplY3QuZXh0ZW5kKC8qKiBAbGVuZHMgTmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge05lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50fSAqL1xyXG4gICAgY29tZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cclxuICAgIG9uQ29ubmVjdGlvblJlc3RvcmU6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cclxuICAgIG9uSW5pdDogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xyXG4gICAgb25NZXNzYWdlOiBudWxsLFxyXG5cclxuICAgIGlzUmVhZHk6IGZhbHNlLFxyXG5cclxuICAgIF9sYXN0SW5pdElkOiAwLFxyXG4gICAgX3dhaXRpbmdGb3I6IDEsIC8vIExvY2sgaW5pdGlhbGx5LiBOdWxsID0gbm90IHdhaXRpbmdcclxuICAgIF9tZXNzYWdlUXVldWU6IFtdLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBJbnN0YWxsIGNvbWV0IGxpc3RlbmVyc1xyXG4gICAgICAgIHRoaXMuY29tZXQuYmluZEV2ZW50cyh7XHJcbiAgICAgICAgICAgIG9uQ29ubmVjdGlvblJlc3RvcmU6IF8uYmluZCh0aGlzLl9vbkNvbWV0Q29ubmVjdGlvblJlc3RvcmUsIHRoaXMpLFxyXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IF8uYmluZCh0aGlzLl9vbkNvbWV0TWVzc2FnZSwgdGhpcylcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX29uQ29tZXRDb25uZWN0aW9uUmVzdG9yZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25SZXN0b3JlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNvbWV0TWVzc2FnZTogZnVuY3Rpb24oY2hhbm5lbCwgZGF0YSkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fd2FpdGluZ0Zvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlUXVldWUucHVzaChbY2hhbm5lbCwgZGF0YV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoY2hhbm5lbCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZW5kT3BlbjogZnVuY3Rpb24ocGFyYW1zKSB7XHJcblxyXG4gICAgICAgIC8vIEZvcmNlIGluaXRpYWxpemF0aW9uLXRpbWUgbWVzc2FnZXMgdG8gcnVuIGFmdGVyIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9ICsrdGhpcy5fbGFzdEluaXRJZDtcclxuICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gcmVxdWVzdElkO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmNvbWV0LnNlbmRPcGVuKHBhcmFtcywgXy5iaW5kKGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERyb3AgdGhlIHJlc3VsdCBvZiBhIHdyb25nIGNhbGxcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmdGb3IgIT0gcmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3Agd2FpdGluZ1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIEVmZmVjdGl2ZSBpbml0XHJcbiAgICAgICAgICAgIHRoaXMub25Jbml0KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmx1c2ggcGVuZGluZyBtZXNzYWdlc1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5fbWVzc2FnZVF1ZXVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZS5hcHBseSh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50XHJcbiAqIEBleHRlbmRzIE5lYXRDb21ldC5PYmplY3RcclxuICovXHJcbk5lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudCA9IE5lYXRDb21ldC5PYmplY3QuZXh0ZW5kKC8qKiBAbGVuZHMgTmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlU2VydmVyLnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cclxuICAgIGlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xyXG4gICAgcHJvZmlsZUlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7TmVhdENvbWV0Lk5lYXRDb21ldENsaWVudH5jcmVhdGVDb2xsZWN0aW9ufSAqL1xyXG4gICAgY3JlYXRlQ29sbGVjdGlvbjogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3QuPHN0cmluZywgKj4+fSAqL1xyXG4gICAgcHJvZmlsZURlZmluaXRpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgTmVhdENvbWV0LmFwaS5JQ29sbGVjdGlvbkNsaWVudD59ICovXHJcbiAgICBjb2xsZWN0aW9uczogbnVsbCxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25zID0ge307XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbGxlY3Rpb246IGZ1bmN0aW9uKGJpbmRpbmdJZCkge1xyXG5cclxuICAgICAgICAvLyBMYXp5IGluaXRcclxuICAgICAgICBpZiAoIV8uaGFzKHRoaXMuY29sbGVjdGlvbnMsIGJpbmRpbmdJZCkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghXy5oYXModGhpcy5wcm9maWxlRGVmaW5pdGlvbiwgYmluZGluZ0lkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5lYXRDb21ldC5FeGNlcHRpb24oJ1dyb25nIGJpbmRpbmdJZCAnICsgYmluZGluZ0lkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc1tiaW5kaW5nSWRdID0gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9maWxlSWQsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nSWQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2ZpbGVEZWZpbml0aW9uW2JpbmRpbmdJZF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uc1tiaW5kaW5nSWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgcG9wdWxhdGVOYW1lc3BhY2U6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cclxuICAgICAgICBfLmVhY2godGhpcy5wcm9maWxlRGVmaW5pdGlvbiwgZnVuY3Rpb24gKHBhcmFtcywgYmluZGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtiaW5kaW5nSWRdID0gdGhpcy5nZXRDb2xsZWN0aW9uKGJpbmRpbmdJZCkuZ2V0TmF0aXZlKCk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnamlpJyk7XG5yZXF1aXJlKCdqaWktbW9kZWwnKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL0FjdGl2ZVJlY29yZCcpO1xucmVxdWlyZSgnLi9saWIvRXhwcmVzc2lvbicpO1xucmVxdWlyZSgnLi9saWIvQWZ0ZXJTYXZlRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL3JlbW90ZS9Db21tYW5kJyk7XG5yZXF1aXJlKCcuL2xpYi9yZW1vdGUvQ29ubmVjdGlvbicpO1xucmVxdWlyZSgnLi9saWIvcmVtb3RlL1NjaGVtYScpO1xucmVxdWlyZSgnLi9saWIvcmVtb3RlL1RyYW5zcG9ydEludGVyZmFjZScpO1xufSx7XCIuL2xpYi9BY3RpdmVSZWNvcmRcIjoxMCxcIi4vbGliL0FmdGVyU2F2ZUV2ZW50XCI6MTEsXCIuL2xpYi9FeHByZXNzaW9uXCI6MTIsXCIuL2xpYi9yZW1vdGUvQ29tbWFuZFwiOjEzLFwiLi9saWIvcmVtb3RlL0Nvbm5lY3Rpb25cIjoxNCxcIi4vbGliL3JlbW90ZS9TY2hlbWFcIjoxNSxcIi4vbGliL3JlbW90ZS9UcmFuc3BvcnRJbnRlcmZhY2VcIjoxNixcImppaVwiOjEyNCxcImppaS1tb2RlbFwiOjk2fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBKaWkuc3FsLkFjdGl2ZVJlY29yZFxuICogQGV4dGVuZHMgSmlpLmJhc2UuQWN0aXZlUmVjb3JkXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnNxbC5BY3RpdmVSZWNvcmQnLCAvKiogQGxlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkFjdGl2ZVJlY29yZCxcblx0XG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkICove1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB1c2VkIGJ5IHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQnkgZGVmYXVsdCwgdGhlIFwiZGJcIiBhcHBsaWNhdGlvbiBjb21wb25lbnQgaXMgdXNlZCBhcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbi5cblx0XHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBkYXRhYmFzZSBjb25uZWN0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtKaWkuc3FsLkNvbm5lY3Rpb259IHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHVzZWQgYnkgdGhpcyBBUiBjbGFzcy5cblx0XHQgKi9cblx0XHRnZXREYjogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEppaS5hcHAuZ2V0Q29tcG9uZW50KCdkYicpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIFtbQWN0aXZlUXVlcnldXSBpbnN0YW5jZSB3aXRoIGEgZ2l2ZW4gU1FMIHN0YXRlbWVudC5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBiZWNhdXNlIHRoZSBTUUwgc3RhdGVtZW50IGlzIGFscmVhZHkgc3BlY2lmaWVkLCBjYWxsaW5nIGFkZGl0aW9uYWxcblx0XHQgKiBxdWVyeSBtb2RpZmljYXRpb24gbWV0aG9kcyAoc3VjaCBhcyBgd2hlcmUoKWAsIGBvcmRlcigpYCkgb24gdGhlIGNyZWF0ZWQgW1tBY3RpdmVRdWVyeV1dXG5cdFx0ICogaW5zdGFuY2Ugd2lsbCBoYXZlIG5vIGVmZmVjdC4gSG93ZXZlciwgY2FsbGluZyBgd2l0aCgpYCwgYGFzQXJyYXkoKWAgb3IgYGluZGV4QnkoKWAgaXNcblx0XHQgKiBzdGlsbCBmaW5lLlxuXHRcdCAqXG5cdFx0ICogQmVsb3cgaXMgYW4gZXhhbXBsZTpcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIGN1c3RvbWVycyA9IEN1c3RvbWVyLmZpbmRCeVNxbCgnU0VMRUNUICogRlJPTSBjdXN0b21lcicpLmFsbCgpO1xuXHRcdCAqIH5+flxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHNxbCB0aGUgU1FMIHN0YXRlbWVudCB0byBiZSBleGVjdXRlZFxuXHRcdCAqIEBwYXJhbSB7W119IHBhcmFtcyBwYXJhbWV0ZXJzIHRvIGJlIGJvdW5kIHRvIHRoZSBTUUwgc3RhdGVtZW50IGR1cmluZyBleGVjdXRpb24uXG5cdFx0ICogQHJldHVybnMge0ppaS5zcWwuQWN0aXZlUXVlcnl9IHRoZSBuZXdseSBjcmVhdGVkIFtbQWN0aXZlUXVlcnldXSBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGZpbmRCeVNxbDogZnVuY3Rpb24gKHNxbCwgcGFyYW1zKSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cblx0XHRcdHZhciBxdWVyeSA9IHRoaXMuZmluZCgpO1xuXHRcdFx0cXVlcnkuc2V0U3FsKHNxbCk7XG5cblx0XHRcdHJldHVybiBxdWVyeS5wYXJhbXMocGFyYW1zKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgd2hvbGUgdGFibGUgdXNpbmcgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSB2YWx1ZXMgYW5kIGNvbmRpdGlvbnMuXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGNoYW5nZSB0aGUgc3RhdHVzIHRvIGJlIDEgZm9yIGFsbCBjdXN0b21lcnMgd2hvc2Ugc3RhdHVzIGlzIDI6XG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci51cGRhdGVBbGwoe3N0YXR1czogMX0sICdzdGF0dXMgPSAyJyk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHNhdmVkIGludG8gdGhlIHRhYmxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSB0aGUgcGFyYW1ldGVycyAobmFtZSA9PiB2YWx1ZSkgdG8gYmUgYm91bmQgdG8gdGhlIHF1ZXJ5LlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZFxuXHRcdCAqL1xuXHRcdHVwZGF0ZUFsbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLnVwZGF0ZSh0aGlzLnRhYmxlTmFtZSgpLCBhdHRyaWJ1dGVzLCBjb25kaXRpb24sIHBhcmFtcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIHdob2xlIHRhYmxlIHVzaW5nIHRoZSBwcm92aWRlZCBjb3VudGVyIGNoYW5nZXMgYW5kIGNvbmRpdGlvbnMuXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGluY3JlbWVudCBhbGwgY3VzdG9tZXJzJyBhZ2UgYnkgMSxcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIEN1c3RvbWVyLnVwZGF0ZUFsbENvdW50ZXJzKHthZ2U6IDF9KTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7W119IGNvdW50ZXJzIHRoZSBjb3VudGVycyB0byBiZSB1cGRhdGVkIChhdHRyaWJ1dGUgbmFtZSA9PiBpbmNyZW1lbnQgdmFsdWUpLlxuXHRcdCAqIFVzZSBuZWdhdGl2ZSB2YWx1ZXMgaWYgeW91IHdhbnQgdG8gZGVjcmVtZW50IHRoZSBjb3VudGVycy5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xbXX0gW2NvbmRpdGlvbl0gdGhlIGNvbmRpdGlvbnMgdGhhdCB3aWxsIGJlIHB1dCBpbiB0aGUgV0hFUkUgcGFydCBvZiB0aGUgVVBEQVRFIFNRTC5cblx0XHQgKiBQbGVhc2UgcmVmZXIgdG8gW1tRdWVyeS53aGVyZSgpXV0gb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIChuYW1lID0+IHZhbHVlKSB0byBiZSBib3VuZCB0byB0aGUgcXVlcnkuXG5cdFx0ICogRG8gbm90IG5hbWUgdGhlIHBhcmFtZXRlcnMgYXMgYDpicDBgLCBgOmJwMWAsIGV0Yy4sIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoaXMgbWV0aG9kLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlQWxsQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycywgY29uZGl0aW9uLCBwYXJhbXMpIHtcblx0XHRcdGNvbmRpdGlvbiA9IGNvbmRpdGlvbiB8fCAnJztcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuXHRcdFx0dmFyIG4gPSAwO1xuXHRcdFx0SmlpLl8uZWFjaChjb3VudGVycywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHR2YXIgcGFyYW1zID0ge307XG5cdFx0XHRcdHBhcmFtc1snOmJweycgKyBuICsgJ30nXSA9IHZhbHVlO1xuXHRcdFx0XHRjb3VudGVyc1tuYW1lXSA9IG5ldyBKaWkuc3FsLkV4cHJlc3Npb24oJ1tbJyArIG5hbWUgKyAnXV0rOmJweycgKyBuICsgJ30nLCBwYXJhbXMpO1xuXHRcdFx0XHRuKys7XG5cdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLnVwZGF0ZSh0aGlzLnRhYmxlTmFtZSgpLCBjb3VudGVycywgY29uZGl0aW9uLCBwYXJhbXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWxldGVzIHJvd3MgaW4gdGhlIHRhYmxlIHVzaW5nIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLlxuXHRcdCAqIFdBUk5JTkc6IElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbnkgY29uZGl0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGRlbGV0ZSBBTEwgcm93cyBpbiB0aGUgdGFibGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgdG8gZGVsZXRlIGFsbCBjdXN0b21lcnMgd2hvc2Ugc3RhdHVzIGlzIDM6XG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci5kZWxldGVBbGwoJ3N0YXR1cyA9IDMnKTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfFtdfSBbY29uZGl0aW9uXSB0aGUgY29uZGl0aW9ucyB0aGF0IHdpbGwgYmUgcHV0IGluIHRoZSBXSEVSRSBwYXJ0IG9mIHRoZSBERUxFVEUgU1FMLlxuXHRcdCAqIFBsZWFzZSByZWZlciB0byBbW1F1ZXJ5LndoZXJlKCldXSBvbiBob3cgdG8gc3BlY2lmeSB0aGlzIHBhcmFtZXRlci5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgKG5hbWUgPT4gdmFsdWUpIHRvIGJlIGJvdW5kIHRvIHRoZSBxdWVyeS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIHJvd3MgZGVsZXRlZFxuXHRcdCAqL1xuXHRcdGRlbGV0ZUFsbDogZnVuY3Rpb24gKGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmRlbGV0ZSh0aGlzLnRhYmxlTmFtZSgpLCBjb25kaXRpb24sIHBhcmFtcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBpbmhlcml0ZG9jXG5cdFx0ICovXG5cdFx0ZmluZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWNsYXJlcyB0aGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQnkgZGVmYXVsdCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjbGFzcyBuYW1lIGFzIHRoZSB0YWJsZSBuYW1lIGJ5IGNhbGxpbmcgW1tJbmZsZWN0b3IuY2FtZWwyaWQoKV1dXG5cdFx0ICogd2l0aCBwcmVmaXggW1tDb25uZWN0aW9uLnRhYmxlUHJlZml4XV0uIEZvciBleGFtcGxlIGlmIFtbQ29ubmVjdGlvbi50YWJsZVByZWZpeF1dIGlzICd0YmxfJyxcblx0XHQgKiAnQ3VzdG9tZXInIGJlY29tZXMgJ3RibF9jdXN0b21lcicsIGFuZCAnT3JkZXJJdGVtJyBiZWNvbWVzICd0Ymxfb3JkZXJfaXRlbScuIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Rcblx0XHQgKiBpZiB0aGUgdGFibGUgaXMgbm90IG5hbWVkIGFmdGVyIHRoaXMgY29udmVudGlvbi5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGFibGUgbmFtZVxuXHRcdCAqL1xuXHRcdHRhYmxlTmFtZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lKCk7XG5cdFx0XHR2YXIgbmFtZSA9IGNsYXNzTmFtZS5zdWJzdHIoY2xhc3NOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcblxuXHRcdFx0cmV0dXJuICd7eyUnICsgSmlpLl9zLnVuZGVyc2NvcmVkKG5hbWUpICsgJ319Jztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc2NoZW1hIGluZm9ybWF0aW9uIG9mIHRoZSBEQiB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUiBjbGFzcy5cblx0XHQgKiBAcmV0dXJucyB7SmlpLnNxbC5UYWJsZVNjaGVtYX0gdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBvZiB0aGUgREIgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbn0gaWYgdGhlIHRhYmxlIGZvciB0aGUgQVIgY2xhc3MgZG9lcyBub3QgZXhpc3QuXG5cdFx0ICovXG5cdFx0Z2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzY2hlbWEgPSB0aGlzLmdldERiKCkuZ2V0VGFibGVTY2hlbWEodGhpcy50YWJsZU5hbWUoKSk7XG5cdFx0XHRpZiAoc2NoZW1hID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKFwiVGhlIHRhYmxlIGRvZXMgbm90IGV4aXN0OiBcIiArIHRoaXMudGFibGVOYW1lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2NoZW1hO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGtleSBuYW1lKHMpIGZvciB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgcmV0dXJuIHRoZSBwcmltYXJ5IGtleShzKSBhcyBkZWNsYXJlZFxuXHRcdCAqIGluIHRoZSBEQiB0YWJsZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqXG5cdFx0ICogSWYgdGhlIERCIHRhYmxlIGRvZXMgbm90IGRlY2xhcmUgYW55IHByaW1hcnkga2V5LCB5b3Ugc2hvdWxkIG92ZXJyaWRlXG5cdFx0ICogdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRoZSBhdHRyaWJ1dGVzIHRoYXQgeW91IHdhbnQgdG8gdXNlIGFzIHByaW1hcnkga2V5c1xuXHRcdCAqIGZvciB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGFuIGFycmF5IHNob3VsZCBiZSByZXR1cm5lZCBldmVuIGZvciBhIHRhYmxlIHdpdGggc2luZ2xlIHByaW1hcnkga2V5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgcHJpbWFyeSBrZXlzIG9mIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHRcdCAqL1xuXHRcdHByaW1hcnlLZXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFRhYmxlU2NoZW1hKCkucHJpbWFyeUtleTtcblx0XHR9LFxuXG5cdFx0cG9wdWxhdGVSZWNvcmQ6IGZ1bmN0aW9uIChyZWNvcmQsIHJvdykge1xuXG5cdFx0XHR2YXIgY29sdW1ucyA9IHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKS5jb2x1bW5zO1xuXHRcdFx0SmlpLl8uZWFjaChyb3csIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdGlmIChKaWkuXy5oYXMoY29sdW1ucywgbmFtZSkpIHtcblx0XHRcdFx0XHRyb3dbbmFtZV0gPSBjb2x1bW5zW25hbWVdLnR5cGVjYXN0KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX19zdXBlcihyZWNvcmQsIHJvdyk7XG5cdFx0fVxuXG5cdH0sXG5cblxuXHQvKipcblx0ICogTG9hZHMgZGVmYXVsdCB2YWx1ZXMgZnJvbSBkYXRhYmFzZSB0YWJsZSBzY2hlbWFcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbc2tpcElmU2V0XSBpZiBleGlzdGluZyB2YWx1ZSBzaG91bGQgYmUgcHJlc2VydmVkXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBtb2RlbCBpbnN0YW5jZVxuXHQgKi9cblx0bG9hZERlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uIChza2lwSWZTZXQpIHtcblx0XHRza2lwSWZTZXQgPSBza2lwSWZTZXQgIT09IGZhbHNlO1xuXG5cdFx0SmlpLl8uZWFjaCh0aGlzLl9fc3RhdGljLmdldFRhYmxlU2NoZW1hKCkuY29sdW1ucywgZnVuY3Rpb24oY29sdW1uKSB7XG5cdFx0XHRpZiAoY29sdW1uLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiAoIXNraXBJZlNldCB8fCB0aGlzLmdldChjb2x1bW4ubmFtZSkgPT09IG51bGwpKSB7XG5cdFx0XHRcdHRoaXMuc2V0KGNvbHVtbi5uYW1lLCBjb2x1bW4uZGVmYXVsdFZhbHVlKTtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBhdHRyaWJ1dGUgbmFtZXMgb2YgdGhlIG1vZGVsLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHJldHVybiBhbGwgY29sdW1uIG5hbWVzIG9mIHRoZSB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUiBjbGFzcy5cblx0ICogQHJldHVybnMge1tdfSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcy5cblx0ICovXG5cdGF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gSmlpLl8ua2V5cyh0aGlzLl9fc3RhdGljLmdldFRhYmxlU2NoZW1hKCkuY29sdW1ucyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluc2VydHMgYSByb3cgaW50byB0aGUgYXNzb2NpYXRlZCBkYXRhYmFzZSB0YWJsZSB1c2luZyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGlzIHJlY29yZC5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgcGVyZm9ybXMgdGhlIGZvbGxvd2luZyBzdGVwcyBpbiBvcmRlcjpcblx0ICpcblx0ICogMS4gY2FsbCBbW2JlZm9yZVZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLiBJZiB2YWxpZGF0aW9uXG5cdCAqICAgIGZhaWxzLCBpdCB3aWxsIHNraXAgdGhlIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBjYWxsIFtbYWZ0ZXJWYWxpZGF0ZSgpXV0gd2hlbiBgcnVuVmFsaWRhdGlvbmAgaXMgdHJ1ZS5cblx0ICogMy4gY2FsbCBbW2JlZm9yZVNhdmUoKV1dLiBJZiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UsIGl0IHdpbGwgc2tpcCB0aGVcblx0ICogICAgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDQuIGluc2VydCB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfSU5TRVJUXV0sIFtbRVZFTlRfQUZURVJfSU5TRVJUXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIGluc2VydGVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIElmIHRoZSB0YWJsZSdzIHByaW1hcnkga2V5IGlzIGF1dG8taW5jcmVtZW50YWwgYW5kIGlzIG51bGwgZHVyaW5nIGluc2VydGlvbixcblx0ICogaXQgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgYWN0dWFsIHZhbHVlIGFmdGVyIGluc2VydGlvbi5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRvIGluc2VydCBhIGN1c3RvbWVyIHJlY29yZDpcblx0ICpcblx0ICogfn5+XG5cdCAqIGN1c3RvbWVyID0gbmV3IEN1c3RvbWVyKCk7XG5cdCAqIGN1c3RvbWVyLm5hbWUgPSBuYW1lO1xuXHQgKiBjdXN0b21lci5lbWFpbCA9IGVtYWlsO1xuXHQgKiBjdXN0b21lci5pbnNlcnQoKTtcblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcnVuVmFsaWRhdGlvbiB3aGV0aGVyIHRvIHBlcmZvcm0gdmFsaWRhdGlvbiBiZWZvcmUgc2F2aW5nIHRoZSByZWNvcmQuXG5cdCAqIElmIHRoZSB2YWxpZGF0aW9uIGZhaWxzLCB0aGUgcmVjb3JkIHdpbGwgbm90IGJlIGluc2VydGVkIGludG8gdGhlIGRhdGFiYXNlLlxuXHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZXMgYXJlIHZhbGlkIGFuZCB0aGUgcmVjb3JkIGlzIGluc2VydGVkIHN1Y2Nlc3NmdWxseS5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGluc2VydCBmYWlsZWQuXG5cdCAqL1xuXHRpbnNlcnQ6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVzKSB7XG5cdFx0cnVuVmFsaWRhdGlvbiA9IHJ1blZhbGlkYXRpb24gIT09IGZhbHNlO1xuXHRcdGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IG51bGw7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGlmIChydW5WYWxpZGF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbGlkYXRlKGF0dHJpYnV0ZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24oaXNWYWxpZGF0ZSkge1xuXHRcdFx0aWYgKCFpc1ZhbGlkYXRlKSB7XG5cdFx0XHRcdEppaS5pbmZvKCdNb2RlbCBub3QgaW5zZXJ0ZWQgZHVlIHRvIHZhbGlkYXRpb24gZXJyb3IuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Lyp2YXIgZGIgPSB0aGlzLl9fc3RhdGljLmdldERiKCk7XG5cdFx0XHQgaWYgKHRoaXMuaXNUcmFuc2FjdGlvbmFsKHNlbGYuT1BfSU5TRVJUKSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uID0gZGIuYmVnaW5UcmFuc2FjdGlvbigpO1xuXHRcdFx0IHRyeSB7XG5cdFx0XHQgcmVzdWx0ID0gdGhpcy5pbnNlcnRJbnRlcm5hbChhdHRyaWJ1dGVzKTtcblx0XHRcdCBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHQgfSBlbHNlIHtcblx0XHRcdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcblx0XHRcdCB9XG5cdFx0XHQgfSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHQgdGhyb3cgZTtcblx0XHRcdCB9XG5cdFx0XHQgfSBlbHNlIHsqL1xuXHRcdFx0cmV0dXJuIHRoaXMuX2luc2VydEludGVybmFsKGF0dHJpYnV0ZXMpO1xuXHRcdFx0Ly99XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogSW5zZXJ0cyBhbiBBY3RpdmVSZWNvcmQgaW50byBEQiB3aXRob3V0IGNvbnNpZGVyaW5nIHRyYW5zYWN0aW9uLlxuXHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBpcyBpbnNlcnRlZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRfaW5zZXJ0SW50ZXJuYWw6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cdFx0YXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLmJlZm9yZVNhdmUodHJ1ZSkudGhlbihmdW5jdGlvbihib29sKSB7XG5cdFx0XHRpZiAoIWJvb2wpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXREaXJ0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG5cdFx0XHRpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG5cdFx0XHRcdEppaS5fLmVhY2godGhpcy5nZXRQcmltYXJ5S2V5KHRydWUpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0dmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmluc2VydE1vZGVsKHRoaXMsIHZhbHVlcykudGhlbihmdW5jdGlvbihpbnNlcnRJbmZvKSB7XG5cdFx0XHRcdGlmICghaW5zZXJ0SW5mbykge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0YWJsZSA9IHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKTtcblx0XHRcdFx0aWYgKHRhYmxlLnNlcXVlbmNlTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGFibGUucHJpbWFyeUtleS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gdGFibGUucHJpbWFyeUtleVtpXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaWQgPSB0YWJsZS5jb2x1bW5zW25hbWVdLnR5cGVjYXN0KGluc2VydEluZm8uaW5zZXJ0SWQpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpZCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tuYW1lXSA9IGlkO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgIEppaS5fLmVhY2godmFsdWVzLCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1trZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0dGhpcy5zZXRPbGRBdHRyaWJ1dGVzKHZhbHVlcyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyU2F2ZSh0cnVlLCBjaGFuZ2VkQXR0cmlidXRlcykudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNhdmVzIHRoZSBjaGFuZ2VzIHRvIHRoaXMgYWN0aXZlIHJlY29yZCBpbnRvIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlVmFsaWRhdGUoKV1dIHdoZW4gYHJ1blZhbGlkYXRpb25gIGlzIHRydWUuIElmIHZhbGlkYXRpb25cblx0ICogICAgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDIuIGNhbGwgW1thZnRlclZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLlxuXHQgKiAzLiBjYWxsIFtbYmVmb3JlU2F2ZSgpXV0uIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBza2lwIHRoZVxuXHQgKiAgICByZXN0IG9mIHRoZSBzdGVwcztcblx0ICogNC4gc2F2ZSB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfVVBEQVRFXV0sIFtbRVZFTlRfQUZURVJfVVBEQVRFXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byB1cGRhdGUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IEN1c3RvbWVyLmZpbmRPbmUoaWQpO1xuXHQgKiBjdXN0b21lci5uYW1lID0gbmFtZTtcblx0ICogY3VzdG9tZXIuZW1haWwgPSBlbWFpbDtcblx0ICogY3VzdG9tZXIudXBkYXRlKCk7XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIHVwZGF0ZSBkb2VzIG5vdCBhZmZlY3QgYW55IHJvdyBpbiB0aGUgdGFibGUuXG5cdCAqIEluIHRoaXMgY2FzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gMC4gRm9yIHRoaXMgcmVhc29uLCB5b3Ugc2hvdWxkIHVzZSB0aGUgZm9sbG93aW5nXG5cdCAqIGNvZGUgdG8gY2hlY2sgaWYgdXBkYXRlKCkgaXMgc3VjY2Vzc2Z1bCBvciBub3Q6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBpZiAodGhpcy51cGRhdGUoKSAhPT0gZmFsc2UpIHtcbiAgICAgKiAgICAgLy8gdXBkYXRlIHN1Y2Nlc3NmdWxcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgICAvLyB1cGRhdGUgZmFpbGVkXG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBydW5WYWxpZGF0aW9uIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgaW5zZXJ0ZWQgaW50byB0aGUgZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7W119IGF0dHJpYnV0ZU5hbWVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge251bWJlcnxib29sZWFufSB0aGUgbnVtYmVyIG9mIHJvd3MgYWZmZWN0ZWQsIG9yIGZhbHNlIGlmIHZhbGlkYXRpb24gZmFpbHNcblx0ICogb3IgW1tiZWZvcmVTYXZlKCldXSBzdG9wcyB0aGUgdXBkYXRpbmcgcHJvY2Vzcy5cblx0ICogQHRocm93cyBTdGFsZU9iamVjdEV4Y2VwdGlvbiBpZiBbW29wdGltaXN0aWNMb2NrfG9wdGltaXN0aWMgbG9ja2luZ11dIGlzIGVuYWJsZWQgYW5kIHRoZSBkYXRhXG5cdCAqIGJlaW5nIHVwZGF0ZWQgaXMgb3V0ZGF0ZWQuXG5cdCAqIEB0aHJvd3MgXFxFeGNlcHRpb24gaW4gY2FzZSB1cGRhdGUgZmFpbGVkLlxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpIHtcblx0XHRydW5WYWxpZGF0aW9uID0gcnVuVmFsaWRhdGlvbiAhPT0gZmFsc2U7XG5cdFx0YXR0cmlidXRlTmFtZXMgPSBhdHRyaWJ1dGVOYW1lcyB8fCBudWxsO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocnVuVmFsaWRhdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbihpc1ZhbGlkYXRlKSB7XG5cdFx0XHRpZiAoIWlzVmFsaWRhdGUpIHtcblx0XHRcdFx0SmlpLmluZm8oJ01vZGVsIG5vdCB1cGRhdGVkIGR1ZSB0byB2YWxpZGF0aW9uIGVycm9yLicpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qZGIgPSBzdGF0aWMuZ2V0RGIoKTtcblx0XHRcdGlmICh0aGlzLmlzVHJhbnNhY3Rpb25hbChzZWxmLk9QX1VQREFURSkpIHtcblx0XHRcdFx0dHJhbnNhY3Rpb24gPSBkYi5iZWdpblRyYW5zYWN0aW9uKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdGhpcy51cGRhdGVJbnRlcm5hbChhdHRyaWJ1dGVOYW1lcyk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0XHRcdHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHsqL1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdXBkYXRlSW50ZXJuYWwoYXR0cmlidXRlTmFtZXMpO1xuXHRcdFx0Ly99XG5cblx0XHR9LmJpbmQodGhpcykpO1xuXG5cblx0fSxcblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGUgdGFibGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3RpdmUgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlRGVsZXRlKCldXS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIGZhbHNlLCBpdCB3aWxsIHNraXAgdGhlXG5cdCAqICAgIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBkZWxldGUgdGhlIHJlY29yZCBmcm9tIHRoZSBkYXRhYmFzZTtcblx0ICogMy4gY2FsbCBbW2FmdGVyRGVsZXRlKCldXS5cblx0ICpcblx0ICogSW4gdGhlIGFib3ZlIHN0ZXAgMSBhbmQgMywgZXZlbnRzIG5hbWVkIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGFuZCBbW0VWRU5UX0FGVEVSX0RFTEVURV1dXG5cdCAqIHdpbGwgYmUgcmFpc2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8Ym9vbGVhbn0gdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQsIG9yIGZhbHNlIGlmIHRoZSBkZWxldGlvbiBpcyB1bnN1Y2Nlc3NmdWwgZm9yIHNvbWUgcmVhc29uLlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQgaXMgMCwgZXZlbiB0aG91Z2ggdGhlIGRlbGV0aW9uIGV4ZWN1dGlvbiBpcyBzdWNjZXNzZnVsLlxuXHQgKiBAdGhyb3dzIFN0YWxlT2JqZWN0RXhjZXB0aW9uIGlmIFtbb3B0aW1pc3RpY0xvY2t8b3B0aW1pc3RpYyBsb2NraW5nXV0gaXMgZW5hYmxlZCBhbmQgdGhlIGRhdGFcblx0ICogYmVpbmcgZGVsZXRlZCBpcyBvdXRkYXRlZC5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGRlbGV0ZSBmYWlsZWQuXG5cdCAqL1xuXHRkZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvKmRiID0gc3RhdGljLmdldERiKCk7XG5cdFx0aWYgKHRoaXMuaXNUcmFuc2FjdGlvbmFsKHNlbGYuT1BfREVMRVRFKSkge1xuXHRcdFx0dHJhbnNhY3Rpb24gPSBkYi5iZWdpblRyYW5zYWN0aW9uKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLmRlbGV0ZUludGVybmFsKCk7XG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dHJhbnNhY3Rpb24ucm9sbEJhY2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2FjdGlvbi5jb21taXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0XHR0cmFuc2FjdGlvbi5yb2xsQmFjaygpO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7Ki9cblx0XHRcdHJldHVybiB0aGlzLl9kZWxldGVJbnRlcm5hbCgpO1xuXHRcdC8vfVxuXG5cdFx0Ly9yZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGFuIEFjdGl2ZVJlY29yZCB3aXRob3V0IGNvbnNpZGVyaW5nIHRyYW5zYWN0aW9uLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfGJvb2xlYW59IHRoZSBudW1iZXIgb2Ygcm93cyBkZWxldGVkLCBvciBmYWxzZSBpZiB0aGUgZGVsZXRpb24gaXMgdW5zdWNjZXNzZnVsIGZvciBzb21lIHJlYXNvbi5cblx0ICogTm90ZSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRoZSBudW1iZXIgb2Ygcm93cyBkZWxldGVkIGlzIDAsIGV2ZW4gdGhvdWdoIHRoZSBkZWxldGlvbiBleGVjdXRpb24gaXMgc3VjY2Vzc2Z1bC5cblx0ICogQHRocm93cyBTdGFsZU9iamVjdEV4Y2VwdGlvblxuXHQgKi9cblx0X2RlbGV0ZUludGVybmFsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iZWZvcmVEZWxldGUoKS50aGVuKGZ1bmN0aW9uKGJvb2wpIHtcblx0XHRcdGlmICghYm9vbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmRlbGV0ZU1vZGVsKHRoaXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdC8qaWYgKGxvY2sgIT09IG51bGwgJiYgIXJlc3VsdCkge1xuXHRcdFx0XHQgdGhyb3cgbmV3IFN0YWxlT2JqZWN0RXhjZXB0aW9uKCdUaGUgb2JqZWN0IGJlaW5nIGRlbGV0ZWQgaXMgb3V0ZGF0ZWQuJyk7XG5cdFx0XHRcdCB9Ki9cblx0XHRcdFx0dGhpcy5zZXRPbGRBdHRyaWJ1dGVzKG51bGwpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRGVsZXRlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gYWN0aXZlIHJlY29yZCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmUuXG5cdCAqIFRoZSBjb21wYXJpc29uIGlzIG1hZGUgYnkgY29tcGFyaW5nIHRoZSB0YWJsZSBuYW1lcyBhbmQgdGhlIHByaW1hcnkga2V5IHZhbHVlcyBvZiB0aGUgdHdvIGFjdGl2ZSByZWNvcmRzLlxuXHQgKiBJZiBvbmUgb2YgdGhlIHJlY29yZHMgW1tpc05ld1JlY29yZHxpcyBuZXddXSB0aGV5IGFyZSBhbHNvIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuXHQgKiBAcGFyYW0ge0ppaS5zcWwuQWN0aXZlUmVjb3JkfSByZWNvcmQgcmVjb3JkIHRvIGNvbXBhcmUgdG9cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHR3byBhY3RpdmUgcmVjb3JkcyByZWZlciB0byB0aGUgc2FtZSByb3cgaW4gdGhlIHNhbWUgZGF0YWJhc2UgdGFibGUuXG5cdCAqL1xuXHRlcXVhbHM6IGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IHJlY29yZC5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMudGFibGVOYW1lKCkgPT09IHJlY29yZC5fX3N0YXRpYy50YWJsZU5hbWUoKSAmJiB0aGlzLmdldFByaW1hcnlLZXkoKSA9PT0gcmVjb3JkLmdldFByaW1hcnlLZXkoKTtcblx0fVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwuQWZ0ZXJTYXZlRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk1vZGVsRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50JywgLyoqIEBsZW5kcyBKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk1vZGVsRXZlbnQsXG5cblx0LyoqXG5cdCAqIFRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgaGFkIGNoYW5nZWQgYW5kIHdlcmUgc2F2ZWQuXG5cdCAqIEB0eXBlIHtzdHJpbmdbXX1cblx0ICovXG5cdGNoYW5nZWRBdHRyaWJ1dGVzOiBudWxsXG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICpcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogRXhwcmVzc2lvbiByZXByZXNlbnRzIGEgREIgZXhwcmVzc2lvbiB0aGF0IGRvZXMgbm90IG5lZWQgZXNjYXBpbmcgb3IgcXVvdGluZy5cbiAqIFdoZW4gYW4gRXhwcmVzc2lvbiBvYmplY3QgaXMgZW1iZWRkZWQgd2l0aGluIGEgU1FMIHN0YXRlbWVudCBvciBmcmFnbWVudCxcbiAqIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgW1tleHByZXNzaW9uXV0gcHJvcGVydHkgdmFsdWUgd2l0aG91dCBhbnlcbiAqIERCIGVzY2FwaW5nIG9yIHF1b3RpbmcuIEZvciBleGFtcGxlLFxuICpcbiAqIH5+flxuICogZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKCdOT1coKScpO1xuICogc3FsID0gJ1NFTEVDVCAnIC4gZXhwcmVzc2lvbjsgIC8vIFNFTEVDVCBOT1coKVxuICogfn5+XG4gKlxuICogQW4gZXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBib3VuZCB3aXRoIHBhcmFtZXRlcnMgc3BlY2lmaWVkIHZpYSBbW3BhcmFtc11dLlxuICpcbiAqIEBjbGFzcyBKaWkuc3FsLkV4cHJlc3Npb25cbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwuRXhwcmVzc2lvbicsIC8qKiBAbGVuZHMgSmlpLnNxbC5FeHByZXNzaW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIERCIGV4cHJlc3Npb25cblx0ICovXG5cdGV4cHJlc3Npb246IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtvYmplY3R9IGxpc3Qgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBib3VuZCBmb3IgdGhpcyBleHByZXNzaW9uLlxuXHQgKiBUaGUga2V5cyBhcmUgcGxhY2Vob2xkZXJzIGFwcGVhcmluZyBpbiBbW2V4cHJlc3Npb25dXSBhbmQgdGhlIHZhbHVlc1xuXHQgKiBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICovXG5cdHBhcmFtczogbnVsbCxcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIHRoZSBEQiBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge1tdfSBjb25maWcgbmFtZS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplIHRoZSBvYmplY3QgcHJvcGVydGllc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgcGFyYW1zLCBjb25maWcpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IFtdO1xuXG5cdFx0dGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0XHR0aGlzLl9fc3VwZXIoY29uZmlnKTtcblx0fSxcblxuXHQvKipcblx0ICogU3RyaW5nIG1hZ2ljIG1ldGhvZFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgREIgZXhwcmVzc2lvblxuXHQgKi9cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmV4cHJlc3Npb247XG5cdH1cblxufSk7XG59LHtcImppaVwiOjEyNH1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwucmVtb3RlLkNvbW1hbmRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLkNvbW1hbmQnLCAvKiogQGxlbmRzIEppaS5zcWwucmVtb3RlLkNvbW1hbmQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG4gICAgX19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuQ29tbWFuZCAqL3tcblxuICAgICAgICBNRVRIT0RfSU5TRVJUOiAnaW5zZXJ0JyxcbiAgICAgICAgTUVUSE9EX1VQREFURTogJ3VwZGF0ZScsXG4gICAgICAgIE1FVEhPRF9ERUxFVEU6ICdkZWxldGUnXG5cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLnNxbC5CYXNlQ29ubmVjdGlvbn0gdGhlIERCIGNvbm5lY3Rpb24gdGhhdCB0aGlzIGNvbW1hbmQgaXMgYXNzb2NpYXRlZCB3aXRoXG5cdCAqL1xuXHRkYjogbnVsbCxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdhbGwnKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeU9uZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdvbmUnKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeVNjYWxhcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdzY2FsYXInKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeUNvbHVtbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdjb2x1bW4nKTtcblx0fSxcblxuXHQvKipcblx0ICogUGVyZm9ybXMgdGhlIGFjdHVhbCBEQiBxdWVyeSBvZiBhIFNRTCBzdGF0ZW1lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2Rcblx0ICogQHJldHVybnMge1Byb21pc2V9IHRoZSBtZXRob2QgZXhlY3V0aW9uIHJlc3VsdFxuXHQgKiBAdGhyb3dzIEV4Y2VwdGlvbiBpZiB0aGUgcXVlcnkgY2F1c2VzIGFueSBwcm9ibGVtXG5cdCAqL1xuXHRfcXVlcnlJbnRlcm5hbDogZnVuY3Rpb24gKG1ldGhvZCkge1xuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ppaS5zcWwuQWN0aXZlUmVjb3JkfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBpbnNlcnRNb2RlbDogZnVuY3Rpb24obW9kZWwsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYi5leGVjKHRoaXMuX19zdGF0aWMuTUVUSE9EX0lOU0VSVCwgbW9kZWwuY2xhc3NOYW1lKCksIHtcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkocmVzdWx0LmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRFcnJvcnMocmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKHJlc3VsdC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRJZDogbW9kZWwuZ2V0UHJpbWFyeUtleSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZXhlYyh0aGlzLl9fc3RhdGljLk1FVEhPRF9VUERBVEUsIG1vZGVsLmNsYXNzTmFtZSgpLCB7XG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBtb2RlbC5nZXRPbGRQcmltYXJ5S2V5KHRydWUpLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXNcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghSmlpLl8uaXNFbXB0eShyZXN1bHQuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNldEVycm9ycyhyZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IG1vZGVsXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZGVsZXRlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmV4ZWModGhpcy5fX3N0YXRpYy5NRVRIT0RfREVMRVRFLCBtb2RlbC5jbGFzc05hbWUoKSwge1xuICAgICAgICAgICAgcHJpbWFyeUtleTogbW9kZWwuZ2V0UHJpbWFyeUtleSh0cnVlKVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQuc3VjY2VzcyA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAY2xhc3MgSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvblxyXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcclxuICovXHJcbkppaS5kZWZpbmVDbGFzcygnSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvbicsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvbi5wcm90b3R5cGUgKi97XHJcblxyXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5zcWwucmVtb3RlLlNjaGVtYX0gdGhlIGRhdGFiYXNlIHNjaGVtYVxyXG4gICAgICovXHJcbiAgICBzY2hlbWE6IHtcclxuICAgICAgICBjbGFzc05hbWU6ICdKaWkuc3FsLnJlbW90ZS5TY2hlbWEnXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZX1cclxuICAgICAqL1xyXG4gICAgdHJhbnNwb3J0OiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgcm91dGU6ICdhcGkvYXInLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gSmlpLmNyZWF0ZU9iamVjdCh0aGlzLnNjaGVtYSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRyYW5zcG9ydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gSmlpLmFwcC5nZXQoJ2NvbWV0Jyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghKHRoaXMudHJhbnNwb3J0IGluc3RhbmNlb2YgSmlpLmJhc2UuQ29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IEppaS5jcmVhdGVPYmplY3QodGhpcy50cmFuc3BvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbW1hbmQgZm9yIGV4ZWN1dGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtKaWkuc3FsLnJlbW90ZS5Db21tYW5kfSB0aGUgREIgY29tbWFuZFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDb21tYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKaWkuc3FsLnJlbW90ZS5Db21tYW5kKHtcclxuICAgICAgICAgICAgZGI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsQ2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc11cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAgICovXHJcbiAgICBleGVjOiBmdW5jdGlvbihtZXRob2QsIG1vZGVsQ2xhc3NOYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XHJcbiAgICAgICAgcGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICBwYXJhbXMubW9kZWxDbGFzc05hbWUgPSBtb2RlbENsYXNzTmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNwb3J0KCkucmVxdWVzdCh0aGlzLnJvdXRlLCBwYXJhbXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRhdGFiYXNlIG9wZW5lZCBieSB0aGlzIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7SmlpLnNxbC5yZW1vdGUuU2NoZW1hfSB0aGUgc2NoZW1hIGluZm9ybWF0aW9uIGZvciB0aGUgZGF0YWJhc2Ugb3BlbmVkIGJ5IHRoaXMgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0U2NoZW1hOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBmb3IgdGhlIG5hbWVkIHRhYmxlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGFibGUgbmFtZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSB0YWJsZSBzY2hlbWEgaW5mb3JtYXRpb24uIE51bGwgaWYgdGhlIG5hbWVkIHRhYmxlIGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRUYWJsZVNjaGVtYTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY2hlbWEoKS5nZXRUYWJsZVNjaGVtYShuYW1lKTtcclxuICAgIH1cclxuXHJcbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuc3FsLnJlbW90ZS5TY2hlbWFcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLlNjaGVtYScsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuU2NoZW1hLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXG4gICAgdGFibGVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuTW9kZWxTY2hlbWF9XG4gICAgICovXG4gICAgZ2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdCh0aGlzLnRhYmxlc1tuYW1lXSkgJiYgISh0aGlzLnRhYmxlc1tuYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsU2NoZW1hKSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZXNbbmFtZV0gPSBKaWkuYmFzZS5Nb2RlbFNjaGVtYS5jcmVhdGVGcm9tT2JqZWN0KHRoaXMudGFibGVzW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRhYmxlc1tuYW1lXSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRUYWJsZU5hbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5rZXlzKHRoaXMudGFibGVzKTtcbiAgICB9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZVxuICogQGludGVyZmFjZSBKaWkuc3FsLnJlbW90ZS5UcmFuc3BvcnRJbnRlcmZhY2VcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZScsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuVHJhbnNwb3J0SW50ZXJmYWNlLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgcmVxdWVzdCB0byBiYWNrZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbXMpIHtcblx0fVxuXG59KTtcbn0se1wiamlpXCI6MTI0fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdqaWknKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL2NsaWVudC9wbHVnaW4vQXV0b1JlY29ubmVjdCcpO1xucmVxdWlyZSgnLi9saWIvY2xpZW50L3BsdWdpbi9QbHVnaW5JbnRlcmZhY2UnKTtcbnJlcXVpcmUoJy4vbGliL2NsaWVudC90cmFuc3BvcnQvVHJhbnNwb3J0SW50ZXJmYWNlJyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvQ2xpZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvTG9nTWVzc2FnZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvTWVzc2FnZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvUmVxdWVzdEV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9DaGFubmVsRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL0xvZ0V2ZW50Jyk7XG5cbn0se1wiLi9saWIvQ2hhbm5lbEV2ZW50XCI6MTgsXCIuL2xpYi9Mb2dFdmVudFwiOjE5LFwiLi9saWIvY2xpZW50L0NsaWVudFwiOjIwLFwiLi9saWIvY2xpZW50L0xvZ01lc3NhZ2VFdmVudFwiOjIxLFwiLi9saWIvY2xpZW50L01lc3NhZ2VFdmVudFwiOjIyLFwiLi9saWIvY2xpZW50L1JlcXVlc3RFdmVudFwiOjI0LFwiLi9saWIvY2xpZW50L3BsdWdpbi9BdXRvUmVjb25uZWN0XCI6MjUsXCIuL2xpYi9jbGllbnQvcGx1Z2luL1BsdWdpbkludGVyZmFjZVwiOjI2LFwiLi9saWIvY2xpZW50L3RyYW5zcG9ydC9UcmFuc3BvcnRJbnRlcmZhY2VcIjoyOCxcImppaVwiOjEyNH1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LkNoYW5uZWxFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuQ2hhbm5lbEV2ZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuQ2hhbm5lbEV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Y2hhbm5lbDogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdG1lc3NhZ2U6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuTG9nRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmNvbWV0LkxvZ0V2ZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuTG9nRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqIExldmVsOiBkZWJ1Zy9pbmZvL3dhcm5pbmcvZXJyb3Jcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGxldmVsOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBMb2cgbWVzc2FnZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0bWVzc2FnZTogbnVsbFxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogUmVhZC1vbmx5IGZyb20gYXBpIHN0YXRpb25VaWRcbiAqIEB0eXBlIHtudWxsfVxuICovXG52YXIgc3RhdGlvblVpZCA9IG51bGw7XG5cbi8qKlxuICogQGNsYXNzIEppaS5jb21ldC5jbGllbnQuQ2xpZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqIEBpbXBsZW1lbnRzIEppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQuQ2xpZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LkNsaWVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQgKi97XG5cblx0XHQvKipcblx0XHQgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQjb3BlblxuXHRcdCAqIEBwcm9wZXJ0eSB7SmlpLmJhc2UuRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfT1BFTjogJ29wZW4nLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2Nsb3NlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9DTE9TRTogJ2Nsb3NlJyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNiZWZvcmVTZW5kXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9CRUZPUkVfU0VORDogJ2JlZm9yZVNlbmQnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2NoYW5uZWxcblx0XHQgKiBAcHJvcGVydHkge0ppaS5jb21ldC5DaGFubmVsRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfQ0hBTk5FTDogJ2NoYW5uZWwnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2NoYW5uZWw6XG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuQ2hhbm5lbEV2ZW50fSBldmVudFxuXHRcdCAqL1xuXHRcdEVWRU5UX0NIQU5ORUxfTkFNRTogJ2NoYW5uZWw6JyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNtZXNzYWdlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9NRVNTQUdFOiAnbWVzc2FnZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNiZWZvcmVSZXF1ZXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9CRUZPUkVfUkVRVUVTVDogJ2JlZm9yZVJlcXVlc3QnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQjcmVxdWVzdFxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5jb21ldC5jbGllbnQuUmVxdWVzdEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfUkVRVUVTVDogJ3JlcXVlc3QnXG5cblx0fSxcblxuXHQvKipcblx0ICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZX1cblx0ICovXG5cdHRyYW5zcG9ydDoge1xuXHRcdGNsYXNzTmFtZTogJ0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlNvY2tqcydcblx0fSxcblxuXHRwbHVnaW5zOiB7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7SmlpLmNvbWV0LmNsaWVudC5wbHVnaW4uQXV0b1JlY29ubmVjdH1cblx0XHQgKi9cblx0XHRhdXRvUmVjb25uZWN0OiB7XG5cdFx0XHRjbGFzc05hbWU6ICdKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5BdXRvUmVjb25uZWN0J1xuXHRcdH1cblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYXggY29tZXQgd29ya2VycyBudW1iZXIuIFVzZWQgZm9yIGF1dG8gZ2VuZXJhdGUgZGlmZmVyZW50IHNlcnZlciB1cmxzIChiYWxhbmNlcikuXG5cdCAqL1xuXHR3b3JrZXJzQ291bnQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0YXV0b09wZW46IHRydWUsXG5cblx0LyoqXG5cdCAqIFVybCB0byBjb21ldCBzZXJ2ZXJcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdF9zZXJ2ZXJVcmw6ICcnLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdF9pc09wZW5lZDogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0X2ZvcmNlQ2xvc2VkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgX3JlcXVlc3RzSW5Qcm9jZXNzOiB7fSxcblxuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0c3RhdGlvblVpZCA9IEppaS5oZWxwZXJzLlN0cmluZy5nZW5lcmF0ZVVpZCgpO1xuXG5cdFx0Ly8gSW5pdCB0cmFuc3BvcnRcblx0XHR0aGlzLnRyYW5zcG9ydCA9IEppaS5jcmVhdGVPYmplY3QodGhpcy50cmFuc3BvcnQpO1xuXHRcdHRoaXMudHJhbnNwb3J0Lm9uKEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5FVkVOVF9PUEVOLCB0aGlzLl9vbk9wZW4uYmluZCh0aGlzKSk7XG5cdFx0dGhpcy50cmFuc3BvcnQub24oSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlLkVWRU5UX0NMT1NFLCB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcykpO1xuXHRcdHRoaXMudHJhbnNwb3J0Lm9uKEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5FVkVOVF9NRVNTQUdFLCB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG5cblx0XHQvLyBJbml0IHBsdWdpbnNcblx0XHRKaWkuXy5lYWNoKHRoaXMucGx1Z2lucywgZnVuY3Rpb24oY29uZmlnLCBuYW1lKSB7XG5cdFx0XHRjb25maWcuY29tZXQgPSB0aGlzO1xuXHRcdFx0dGhpcy5wbHVnaW5zW25hbWVdID0gSmlpLmNyZWF0ZU9iamVjdChjb25maWcpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHQvLyBBdXRvIG9wZW5cblx0XHRpZiAodGhpcy5hdXRvT3Blbikge1xuXHRcdFx0dGhpcy5vcGVuKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdXJsIHRvIGNvbWV0IHNlcnZlclxuXHQgKiBEZXRlY3Qgc2VydmVyIHVybCBieSBwYXR0ZXJuLCBpZiBzZXQuIFVzZWQgZm9yIGJhbGFuY2VyIHNlcnZlciBieSBjbGllbnRzIHJhbmRvbSgpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICovXG5cdHNldFNlcnZlclVybDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBOb3JtYWxpemVcblx0XHRpZiAodmFsdWUuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuXHRcdFx0dmFyIHNzbFN1ZmZpeCA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnID8gJ3MnIDogJydcblx0XHRcdHZhbHVlID0gJ2h0dHAnICsgc3NsU3VmZml4ICsgJzonICsgdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQmFsYW5jZXJcblx0XHRpZiAodmFsdWUuaW5kZXhPZigne3dvcmtlckluZGV4fScpICE9PSAtMSkge1xuXHRcdFx0dmFyIG1pbiA9IDA7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgodGhpcy53b3JrZXJzQ291bnQgfHwgMCwgMSkgLSAxO1xuXHRcdFx0dmFyIHdvcmtlckluZGV4ID0gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgne3dvcmtlckluZGV4fScsIFN0cmluZyh3b3JrZXJJbmRleCkpO1xuXHRcdH1cblxuXHRcdC8vIFN3aXRjaCBzZXJ2ZXIgVVJMIHByb3RvY29sIHRvIEhUVFAgaW5zdGVhZCBvZiBIVFRQUyBpZiBicm93c2VyIGlzIElFOSBvciBsZXNzZXJcblx0XHR2YXIgaXNJRSA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgKC9NU0lFLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvb3BlcmEvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcblx0XHRpZiAoaXNJRSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpIHtcblx0XHRcdHZhciBpc1NzbCA9IC9eKGh0dHB8d3Mpcy8udGVzdCh2YWx1ZSk7XG5cdFx0XHRpZiAoaXNTc2wgPT09IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihodHRwfHdzKXMvLCAnJDEnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXJ2ZXJVcmwgPSB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIGNvbWV0IHNlcnZlciB1cmxcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldFNlcnZlclVybDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlcnZlclVybDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIHN0YXRpb24gVUlEIC0gdW5pcXVlIGlkIG9mIGN1cnJlbnQgamF2YXNjcmlwdCBlbnZpcm9ubWVudCAoYnJvd3NlciB0YWIpXG5cdCAqIEByZXR1cm5zIHtudWxsfVxuXHQgKi9cblx0Z2V0U3RhdGlvblVpZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHN0YXRpb25VaWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlLCBpZiBjb25uZWN0aW9uIGlzIG9wZW5lZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzT3BlbmVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNPcGVuZWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlLCBpZiBjb25uZWN0aW9uIGNsb3NlZCBieSBjbGllbnQgKG1hbnVhbGx5KVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRm9yY2VDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9mb3JjZUNsb3NlZDtcblx0fSxcblxuXHQvKipcblx0ICogT3BlbiBjb25uZWN0aW9uXG5cdCAqL1xuXHRvcGVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9mb3JjZUNsb3NlZCA9IGZhbHNlO1xuXHRcdGlmICghdGhpcy5faXNPcGVuZWQpIHtcblx0XHRcdHRoaXMudHJhbnNwb3J0Lm9wZW4odGhpcy5fc2VydmVyVXJsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENsb3NlIGNvbm5lY3Rpb25cblx0ICovXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9mb3JjZUNsb3NlZCA9IHRydWU7XG5cdFx0aWYgKHRoaXMuX2lzT3BlbmVkKSB7XG5cdFx0XHR0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0ICovXG5cdHNlbmQ6IGZ1bmN0aW9uKGNoYW5uZWwsIGRhdGEpIHtcblx0XHR0aGlzLl9zZW5kSW50ZXJuYWwoJ2NoYW5uZWwgJyArIGNoYW5uZWwgKyAnICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YV1cbiAgICAgKi9cbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAocm91dGUsIGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIGRhdGEucmVxdWVzdFVpZCA9IEppaS5oZWxwZXJzLlN0cmluZy5nZW5lcmF0ZVVpZCgpO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgZm9yIGFwcGVuZCBkYXRhXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBKaWkuY29tZXQuY2xpZW50LlJlcXVlc3RFdmVudCh7XG4gICAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgICBwYXJhbXM6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0JFRk9SRV9SRVFVRVNULCBldmVudCk7XG4gICAgICAgIGRhdGEgPSBldmVudC5wYXJhbXM7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcHJvbWlzZSBmb3Igd2FpdCByZXNwb25zZVxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzSW5Qcm9jZXNzW2RhdGEucmVxdWVzdFVpZF0gPSB7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gU2VuZCByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3NlbmRJbnRlcm5hbCgnYWN0aW9uICcgKyByb3V0ZSArICcgJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NlbmRJbnRlcm5hbDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8vIFRyaWdnZXIgZXZlbnQgYmVmb3JlIHNlbmQgbWVzc2FnZVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgSmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnQoe1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfU0VORCwgZXZlbnQpO1xuICAgICAgICBtZXNzYWdlID0gZXZlbnQubWVzc2FnZTtcblxuXHRcdGlmICh0aGlzLl9pc09wZW5lZCkge1xuXHRcdFx0dGhpcy50cmFuc3BvcnQuc2VuZChtZXNzYWdlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BlbjogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLl9pc09wZW5lZCkge1xuXHRcdFx0dGhpcy5faXNPcGVuZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfT1BFTiwgZXZlbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfb25DbG9zZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX2lzT3BlbmVkKSB7XG5cdFx0XHR0aGlzLl9pc09wZW5lZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQ0xPU0UsIGV2ZW50KTtcblx0XHR9XG5cdH0sXG5cbiAgICBfb25NZXNzYWdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UuaW5kZXhPZignYWN0aW9uICcpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGV2ZW50Lm1lc3NhZ2Uuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXF1ZXN0VWlkICYmIHRoaXMuX3JlcXVlc3RzSW5Qcm9jZXNzW3Jlc3BvbnNlLnJlcXVlc3RVaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF0ucmVzb2x2ZShyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3QgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9SRVFVRVNULCBuZXcgSmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF0ucm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRcdGlmIChldmVudC5tZXNzYWdlLmluZGV4T2YoJ2NoYW5uZWwgJykgPT09IDApIHtcblx0XHRcdHZhciBtZXNzYWdlID0gZXZlbnQubWVzc2FnZS5zdWJzdHIoOCk7XG5cdFx0XHR2YXIgaSA9IG1lc3NhZ2UuaW5kZXhPZignICcpO1xuXHRcdFx0dmFyIGNoYW5uZWxFdmVudCA9IG5ldyBKaWkuY29tZXQuQ2hhbm5lbEV2ZW50KHtcblx0XHRcdFx0Y2hhbm5lbDogbWVzc2FnZS5zdWJzdHIoMCwgaSksXG5cdFx0XHRcdHBhcmFtczogSlNPTi5wYXJzZShtZXNzYWdlLnN1YnN0cihpICsgMSkpXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVHJpZ2dlciBjaGFubmVsIGFuZCBjaGFubmVsOiogZXZlbnRzXG5cdFx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOTkVMX05BTUUgKyBjaGFubmVsRXZlbnQuY2hhbm5lbCwgY2hhbm5lbEV2ZW50KTtcblx0XHRcdHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5ORUwsIGNoYW5uZWxFdmVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciBtZXNzYWdlIGV2ZW50XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfTUVTU0FHRSwgbmV3IEppaS5jb21ldC5jbGllbnQuTWVzc2FnZUV2ZW50KHtcblx0XHRcdG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2Vcblx0XHR9KSk7XG5cdH1cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50LkxvZ01lc3NhZ2VFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LkxvZ01lc3NhZ2VFdmVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5Mb2dNZXNzYWdlRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqICBMZXZlbDogZGVidWcvaW5mby93YXJuaW5nL2Vycm9yXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRsZXZlbDogbnVsbCxcblxuXHQvKipcblx0ICogTG9nIG1lc3NhZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdG1lc3NhZ2U6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRtZXNzYWdlOiBudWxsXG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIEppaVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XHJcblxyXG52YXIgTmVhdENvbWV0ID0gcmVxdWlyZSgnbmVhdGNvbWV0Jyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnRcclxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50XHJcbiAqIEBpbXBsZW1lbnRzIE5lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50XHJcbiAqL1xyXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQuTmVhdENsaWVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5OZWF0Q2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICBfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcclxuXHJcbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnQgKi97XHJcblxyXG4gICAgICAgIFJPVVRFX1BSRUZJWDogJ3Byb2ZpbGVzOidcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQuQ2xpZW50fVxyXG4gICAgICovXHJcbiAgICBjb21ldDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGJpbmRpbmdzOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge05lYXRDb21ldC5OZWF0Q29tZXRDbGllbnR9XHJcbiAgICAgKi9cclxuICAgIGVuZ2luZToge1xyXG4gICAgICAgIGNsYXNzTmFtZTogJ05lYXRDb21ldC5OZWF0Q29tZXRDbGllbnQnXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb21ldCA9IHRoaXMuY29tZXQgPT09IG51bGwgP1xyXG4gICAgICAgICAgICBKaWkuYXBwLmdldCgnY29tZXQnKSA6XHJcbiAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tZXQgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db21wb25lbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tZXQgOlxyXG4gICAgICAgICAgICAgICAgICAgIEppaS5jcmVhdGVPYmplY3QodGhpcy5jb21ldClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTW92ZSBOZWF0Q29tZXQgdG8gSmlpIG5hbWVzcGFjZVxyXG4gICAgICAgIEppaS5fLmV4dGVuZChKaWkubmFtZXNwYWNlKCdOZWF0Q29tZXQnKSwgTmVhdENvbWV0KTtcclxuXHJcbiAgICAgICAgdGhpcy5lbmdpbmUuY29tZXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLnByb2ZpbGVzRGVmaW5pdGlvbiA9IHRoaXMuYmluZGluZ3M7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUuY3JlYXRlQ29sbGVjdGlvbiA9IHRoaXMuZW5naW5lLmNyZWF0ZUNvbGxlY3Rpb24gfHwgdGhpcy5fY3JlYXRlQ29sbGVjdGlvbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lID0gSmlpLmNyZWF0ZU9iamVjdCh0aGlzLmVuZ2luZSk7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwcm9maWxlSWRcclxuICAgICAqIEBwYXJhbSBwYXJhbXNcclxuICAgICAqIEByZXR1cm5zIHtOZWF0Q29tZXQucm91dGVyLk9wZW5lZFByb2ZpbGVDbGllbnR9XHJcbiAgICAgKi9cclxuICAgIG9wZW5Qcm9maWxlOiBmdW5jdGlvbihwcm9maWxlSWQsIHBhcmFtcykge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVuZ2luZS5vcGVuUHJvZmlsZShwcm9maWxlSWQsIHBhcmFtcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbGxlY3Rpb246IGZ1bmN0aW9uKHByb2ZpbGVJZCwgYmluZGluZ0lkKSB7XHJcblxyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbG93ZWQgdG8gZXhwZWN0IHRoYXQgaXQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBJQ29tZXRTZXJ2ZXIgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TmVhdENvbWV0LmFwaS5JQ29tZXRDbGllbnRFdmVudHN9IGV2ZW50c0hhbmRsZXJcclxuICAgICAqL1xyXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oZXZlbnRzSGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuY29tZXQub24oSmlpLmNvbWV0LmNsaWVudC5DbGllbnQuRVZFTlRfQ0hBTk5FTCwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmNoYW5uZWwuaW5kZXhPZih0aGlzLl9fc3RhdGljLlJPVVRFX1BSRUZJWCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50c0hhbmRsZXIub25NZXNzYWdlKGV2ZW50LmNoYW5uZWwuc3Vic3RyKHRoaXMuX19zdGF0aWMuUk9VVEVfUFJFRklYLmxlbmd0aCksIGV2ZW50LnBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbWV0Lm9uKCdvcGVuJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV2ZW50c0hhbmRsZXIub25Db25uZWN0aW9uUmVzdG9yZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcclxuICAgICAqIEBwYXJhbSB7TmVhdENvbWV0LmFwaS5JQ29tZXRDbGllbnR+b3BlblN1Y2Nlc3N9IHN1Y2Nlc3NDYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBzZW5kT3BlbjogZnVuY3Rpb24ocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNvbWV0LnJlcXVlc3QoJ25lYXQvb3BlbicsIHsgbmVhdDogcGFyYW1zIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhaW4gd2l0aCBOZWF0Q29tZXQgaGFuZGxlclxyXG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soZGF0YS5uZWF0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpZHNcclxuICAgICAqL1xyXG4gICAgc2VuZENsb3NlOiBmdW5jdGlvbihpZHMpIHtcclxuICAgICAgICB0aGlzLmNvbWV0LnJlcXVlc3QoJ25lYXQvY2xvc2UnLCB7IG5lYXQ6IGlkcyB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZUNvbGxlY3Rpb246IGZ1bmN0aW9uKHByb2ZpbGVJZCwgYmluZGluZ0lkLCBkZWZpbml0aW9uLCBvcGVuZWRQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsQ2xhc3NOYW1lID0gZGVmaW5pdGlvbi5jbGllbnRNb2RlbCB8fCBkZWZpbml0aW9uLnNlcnZlck1vZGVsIHx8IEppaS5iYXNlLkFjdGl2ZVJlY29yZDtcclxuICAgICAgICByZXR1cm4gbmV3IEppaS5iYXNlLkNvbGxlY3Rpb24oW10sIHtcclxuICAgICAgICAgICAgbW9kZWxDbGFzczogSmlpLm5hbWVzcGFjZShtb2RlbENsYXNzTmFtZSlcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cbn0se1wiamlpXCI6MTI0LFwibmVhdGNvbWV0XCI6Mn1dLDI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnQnLCAvKiogQGxlbmRzIEppaS5jb21ldC5jbGllbnQuUmVxdWVzdEV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cbiAgICByb3V0ZTogbnVsbFxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vUGx1Z2luSW50ZXJmYWNlJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5jb21ldC5jbGllbnQucGx1Z2luLkF1dG9SZWNvbm5lY3RcbiAqIEBleHRlbmRzIEppaS5jb21ldC5jbGllbnQucGx1Z2luLlBsdWdpbkludGVyZmFjZVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQucGx1Z2luLkF1dG9SZWNvbm5lY3QnLCAvKiogQGxlbmRzIEppaS5jb21ldC5jbGllbnQucGx1Z2luLkF1dG9SZWNvbm5lY3QucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmNvbWV0LmNsaWVudC5wbHVnaW4uUGx1Z2luSW50ZXJmYWNlLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdGVuYWJsZTogdHJ1ZSxcblxuXHQvKipcblx0ICogTWluaW1hbCByZXRyeSBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdG1pblJldHJ5SW50ZXJ2YWw6IDIwMDAsXG5cblx0LyoqXG5cdCAqIE1heGltYWwgcmV0cnkgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRtYXhSZXRyeUludGVydmFsOiAyMDAwMCxcblxuXHQvKipcblx0ICogQHR5cGUge251bWJlcn1cblx0ICovXG5cdF90cnlSZWNvbm5lY3ROdW1iZXI6IDAsXG5cblx0aW5pdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jb21ldC5vbihKaWkuY29tZXQuY2xpZW50LkNsaWVudC5FVkVOVF9PUEVOLCB0aGlzLl9vbk9wZW4uYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5jb21ldC50cmFuc3BvcnQub24oSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlLkVWRU5UX0NMT1NFLCB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcykpO1xuXHR9LFxuXG5cdF9vbk9wZW46IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3RyeVJlY29ubmVjdE51bWJlciA9IDA7XG5cdH0sXG5cblx0X29uQ2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLmVuYWJsZSAmJiAhdGhpcy5jb21ldC5pc0ZvcmNlQ2xvc2VkKCkpIHtcblx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX3RyeVJlY29ubmVjdE51bWJlcisrO1xuXHRcdFx0XHR0aGlzLmNvbWV0Lm9wZW4oKTtcblx0XHRcdH0uYmluZCh0aGlzKSwgdGhpcy5fdHJ5UmVjb25uZWN0TnVtYmVyID4gMTAgPyB0aGlzLm1heFJldHJ5SW50ZXJ2YWwgOiB0aGlzLm1pblJldHJ5SW50ZXJ2YWwpO1xuXHRcdH1cblx0fVxuXG59KTtcbn0se1wiLi9QbHVnaW5JbnRlcmZhY2VcIjoyNixcImppaVwiOjEyNH1dLDI2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LmNsaWVudC5wbHVnaW4uUGx1Z2luSW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5QbHVnaW5JbnRlcmZhY2UnLCAvKiogQGxlbmRzIEppaS5jb21ldC5jbGllbnQucGx1Z2luLlBsdWdpbkludGVyZmFjZS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtKaWkuY29tZXQuY2xpZW50LkNsaWVudH1cblx0ICovXG5cdGNvbWV0OiBudWxsXG5cbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vLyBzb2NranMgZ2xvYmFsIGZpeDogc29ja2pzIGV4cGVjdCB0aGF0IGdsb2JhbCBvYmplY3QgaXMgZXF1YWwgd2luZG93LCBidXQgaXQgaXMgbm90IGFsd2F5cywgZm9yIGV4YW1wbGUgaW4gbm9kZS13ZWJraXRcbmlmICh0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwgIT09IHdpbmRvdykge1xuICAgIHZhciB1c2VkV2luZG93S2V5cyA9IFsnZG9jdW1lbnQnLCAnbG9jYXRpb24nLCAnWE1MSHR0cFJlcXVlc3QnLCAnRXZlbnRTb3VyY2UnLCAnV2ViU29ja2V0JywgJ01veldlYlNvY2tldCcsXG4gICAgICAgICdYRG9tYWluUmVxdWVzdCcsICdjcnlwdG8nLCAnbmF2aWdhdG9yJywgJ2Nocm9tZScsICdhZGRFdmVudExpc3RlbmVyJywgJ2F0dGFjaEV2ZW50JyxcbiAgICAgICAgJ3JlbW92ZUV2ZW50TGlzdGVuZXInLCAnZGV0YWNoRXZlbnQnLCAncGFyZW50JywgJ3Bvc3RNZXNzYWdlJywgJ2NvbnNvbGUnXTtcbiAgICBKaWkuXy5lYWNoKHVzZWRXaW5kb3dLZXlzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgZ2xvYmFsW2tleV0gPSB3aW5kb3dba2V5XTtcbiAgICB9KTtcbn1cbi8vIEB0b2RvIGpzb25wIGNhbGxiYWNrc1xuXG52YXIgU29ja0pTID0gcmVxdWlyZSgnc29ja2pzLWNsaWVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5Tb2NranNcbiAqIEBleHRlbmRzIEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlNvY2tqcycsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuU29ja2pzLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZSxcblxuICAgIC8qKlxuICAgICAqIEF2YWlsYWJsZTpcbiAgICAgKiAtIHdlYnNvY2tldFxuICAgICAqIC0geGRyLXBvbGxpbmdcbiAgICAgKiAtIHhkci1zdHJlYW1pbmdcbiAgICAgKiAtIHhoci1wb2xsaW5nXG4gICAgICogLSB4aHItc3RyZWFtaW5nXG4gICAgICogLSBldmVudHNvdXJjZVxuICAgICAqIC0gaHRtbGZpbGVcbiAgICAgKiAtIGlmcmFtZVxuICAgICAqIC0ganNvbnAtcG9sbGluZ1xuICAgICAqL1xuICAgIHRyYW5zcG9ydHM6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtTb2NrSlN9XG5cdCAqL1xuXHRfd2Vic29ja2V0OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBPcGVuIGNvbm5lY3Rpb25cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHQgKi9cblx0b3BlbjogZnVuY3Rpb24odXJsKSB7XG5cdFx0dGhpcy5fd2Vic29ja2V0ID0gbmV3IFNvY2tKUyh1cmwsIG51bGwsIHtcblx0XHRcdC8vZGVidWc6IEhlbHBPbkNsaWNrLmRlYnVnLFxuICAgICAgICAgICAgdHJhbnNwb3J0czogdGhpcy50cmFuc3BvcnRzXG5cdFx0fSk7XG5cblx0XHR0aGlzLl93ZWJzb2NrZXQub25vcGVuID0gdGhpcy5fb25PcGVuLmJpbmQodGhpcyk7XG5cdFx0dGhpcy5fd2Vic29ja2V0Lm9ubWVzc2FnZSA9IHRoaXMuX29uTWVzc2FnZS5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX3dlYnNvY2tldC5vbmNsb3NlID0gdGhpcy5fb25DbG9zZS5iaW5kKHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDbG9zZSBjb25uZWN0aW9uXG5cdCAqL1xuXHRjbG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3dlYnNvY2tldCkge1xuXHRcdFx0dGhpcy5fd2Vic29ja2V0LmNsb3NlKCk7XG5cdFx0XHR0aGlzLl93ZWJzb2NrZXQgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2VuZCBtZXNzYWdlIHRvIHNlcnZlclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKi9cblx0c2VuZDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdGlmICh0aGlzLl93ZWJzb2NrZXQpIHtcblx0XHRcdHRoaXMuX3dlYnNvY2tldC5zZW5kKG1lc3NhZ2UpO1xuXHRcdH1cblx0fSxcblxuXHRfb25PcGVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9PUEVOLCBuZXcgSmlpLmJhc2UuRXZlbnQoKSk7XG5cdH0sXG5cblx0X29uQ2xvc2U6IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DTE9TRSwgbmV3IEppaS5iYXNlLkV2ZW50KCkpO1xuXHR9LFxuXG5cdF9vbk1lc3NhZ2U6IGZ1bmN0aW9uIChldmVudCkge1xuXHRcdGlmIChldmVudC50eXBlID09PSAnbWVzc2FnZScpIHtcblx0XHRcdHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX01FU1NBR0UsIG5ldyBKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudCh7XG5cdFx0XHRcdG1lc3NhZ2U6IGV2ZW50LmRhdGFcblx0XHRcdH0pKTtcblx0XHR9XG5cdH1cblxufSk7XG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiamlpXCI6MTI0LFwic29ja2pzLWNsaWVudFwiOjMxfV0sMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2VcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZScsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2UgKi97XG5cblx0XHQvKipcblx0XHQgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlI29wZW5cblx0XHQgKiBAcHJvcGVydHkge0ppaS5iYXNlLkV2ZW50fSBldmVudFxuXHRcdCAqL1xuXHRcdEVWRU5UX09QRU46ICdvcGVuJyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2UjY2xvc2Vcblx0XHQgKiBAcHJvcGVydHkge0ppaS5iYXNlLkV2ZW50fSBldmVudFxuXHRcdCAqL1xuXHRcdEVWRU5UX0NMT1NFOiAnY2xvc2UnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZSNtZXNzYWdlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9NRVNTQUdFOiAnbWVzc2FnZScsXG5cblx0XHQvKipcblx0XHQgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlI2xvZ1xuXHRcdCAqIEBwcm9wZXJ0eSB7SmlpLmNvbWV0LmNsaWVudC5Mb2dNZXNzYWdlRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfTE9HOiAnbG9nJ1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIE9wZW4gY29ubmVjdGlvblxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG5cdCAqL1xuXHRvcGVuOiBmdW5jdGlvbih1cmwpIHtcblx0fSxcblxuXHQvKipcblx0ICogQ2xvc2UgY29ubmVjdGlvblxuXHQgKi9cblx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZW5kIG1lc3NhZ2UgdG8gc2VydmVyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG5cdCAqL1xuXHRzZW5kOiBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdH1cblxufSk7XG59LHtcImppaVwiOjEyNH1dLDI5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4vaW5kZXgtY2xpZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvTmVhdENsaWVudCcpO1xufSx7XCIuL2luZGV4LWNsaWVudFwiOjE3LFwiLi9saWIvY2xpZW50L05lYXRDbGllbnRcIjoyM31dLDMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxuXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG59LHt9XSwzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB0cmFuc3BvcnRMaXN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQtbGlzdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbWFpbicpKHRyYW5zcG9ydExpc3QpO1xuXG4vLyBUT0RPIGNhbid0IGdldCByaWQgb2YgdGhpcyB1bnRpbCBhbGwgc2VydmVycyBkb1xuaWYgKCdfc29ja2pzX29ubG9hZCcgaW4gZ2xvYmFsKSB7XG4gIHNldFRpbWVvdXQoZ2xvYmFsLl9zb2NranNfb25sb2FkLCAxKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vbWFpblwiOjQ0LFwiLi90cmFuc3BvcnQtbGlzdFwiOjQ2fV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBDbG9zZUV2ZW50KCkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnY2xvc2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLndhc0NsZWFuID0gZmFsc2U7XG4gIHRoaXMuY29kZSA9IDA7XG4gIHRoaXMucmVhc29uID0gJyc7XG59XG5cbmluaGVyaXRzKENsb3NlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbG9zZUV2ZW50O1xuXG59LHtcIi4vZXZlbnRcIjozNCxcImluaGVyaXRzXCI6ODd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnR0YXJnZXQnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcbn1cblxuaW5oZXJpdHMoRXZlbnRFbWl0dGVyLCBFdmVudFRhcmdldCk7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodHlwZSkge1xuICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHNlbGYucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMub24odHlwZSwgZyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdHlwZV07XG4gIGlmICghbGlzdGVuZXJzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxufSx7XCIuL2V2ZW50dGFyZ2V0XCI6MzUsXCJpbmhlcml0c1wiOjg3fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBFdmVudChldmVudFR5cGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xufVxuXG5FdmVudC5wcm90b3R5cGUuaW5pdEV2ZW50ID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBjYW5CdWJibGUsIGNhbmNlbGFibGUpIHtcbiAgdGhpcy50eXBlID0gZXZlbnRUeXBlO1xuICB0aGlzLmJ1YmJsZXMgPSBjYW5CdWJibGU7XG4gIHRoaXMuY2FuY2VsYWJsZSA9IGNhbmNlbGFibGU7XG4gIHRoaXMudGltZVN0YW1wID0gK25ldyBEYXRlKCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbiA9IGZ1bmN0aW9uKCkge307XG5FdmVudC5wcm90b3R5cGUucHJldmVudERlZmF1bHQgID0gZnVuY3Rpb24oKSB7fTtcblxuRXZlbnQuQ0FQVFVSSU5HX1BIQVNFID0gMTtcbkV2ZW50LkFUX1RBUkdFVCAgICAgICA9IDI7XG5FdmVudC5CVUJCTElOR19QSEFTRSAgPSAzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuXG59LHt9XSwzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG5cbmZ1bmN0aW9uIEV2ZW50VGFyZ2V0KCkge1xuICB0aGlzLl9saXN0ZW5lcnMgPSB7fTtcbn1cblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgfVxuICB2YXIgYXJyID0gdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV07XG4gIC8vICM0XG4gIGlmIChhcnIuaW5kZXhPZihsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgIGFyciA9IGFyci5jb25jYXQoW2xpc3RlbmVyXSk7XG4gIH1cbiAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnI7XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICBpZiAoIWFycikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgaWR4ID0gYXJyLmluZGV4T2YobGlzdGVuZXIpO1xuICBpZiAoaWR4ICE9PSAtMSkge1xuICAgIGlmIChhcnIubGVuZ3RoID4gMSkge1xuICAgICAgLy8gTWFrZSBhIGNvcHkgc28gYXMgbm90IHRvIGludGVyZmVyZSB3aXRoIGEgY3VycmVudCBkaXNwYXRjaEV2ZW50LlxuICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoYXJyLnNsaWNlKGlkeCArIDEpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbn07XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgdmFyIHQgPSBldmVudC50eXBlO1xuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIC8vIFRPRE86IFRoaXMgZG9lc24ndCBtYXRjaCB0aGUgcmVhbCBiZWhhdmlvcjsgcGVyIHNwZWMsIG9uZm9vIGdldFxuICAvLyB0aGVpciBwbGFjZSBpbiBsaW5lIGZyb20gdGhlIC9maXJzdC8gdGltZSB0aGV5J3JlIHNldCBmcm9tXG4gIC8vIG5vbi1udWxsLiBBbHRob3VnaCBXZWJLaXQgYnVtcHMgaXQgdG8gdGhlIGVuZCBldmVyeSB0aW1lIGl0J3NcbiAgLy8gc2V0LlxuICBpZiAodGhpc1snb24nICsgdF0pIHtcbiAgICB0aGlzWydvbicgKyB0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBpZiAodCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAvLyBHcmFiIGEgcmVmZXJlbmNlIHRvIHRoZSBsaXN0ZW5lcnMgbGlzdC4gcmVtb3ZlRXZlbnRMaXN0ZW5lciBtYXkgYWx0ZXIgdGhlIGxpc3QuXG4gICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVyc1t0XTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFRhcmdldDtcblxufSx7fV0sMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgO1xuXG5mdW5jdGlvbiBUcmFuc3BvcnRNZXNzYWdlRXZlbnQoZGF0YSkge1xuICBFdmVudC5jYWxsKHRoaXMpO1xuICB0aGlzLmluaXRFdmVudCgnbWVzc2FnZScsIGZhbHNlLCBmYWxzZSk7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG59XG5cbmluaGVyaXRzKFRyYW5zcG9ydE1lc3NhZ2VFdmVudCwgRXZlbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zcG9ydE1lc3NhZ2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6MzQsXCJpbmhlcml0c1wiOjg3fV0sMzc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gIDtcblxuZnVuY3Rpb24gRmFjYWRlSlModHJhbnNwb3J0KSB7XG4gIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgdHJhbnNwb3J0Lm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgdHJhbnNwb3J0Lm9uKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xufVxuXG5GYWNhZGVKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCdjJywgSlNPTjMuc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB0aGlzLl90cmFuc3BvcnQuc2VuZChkYXRhKTtcbn07XG5GYWNhZGVKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX3RyYW5zcG9ydC5jbG9zZSgpO1xuICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZhY2FkZUpTO1xuXG59LHtcIi4vdXRpbHMvaWZyYW1lXCI6NzcsXCJqc29uM1wiOjg4fV0sMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBGYWNhZGVKUyA9IHJlcXVpcmUoJy4vZmFjYWRlJylcbiAgLCBJbmZvSWZyYW1lUmVjZWl2ZXIgPSByZXF1aXJlKCcuL2luZm8taWZyYW1lLXJlY2VpdmVyJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvaWZyYW1lJylcbiAgLCBsb2MgPSByZXF1aXJlKCcuL2xvY2F0aW9uJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmlmcmFtZS1ib290c3RyYXAnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihTb2NrSlMsIGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdmFyIHRyYW5zcG9ydE1hcCA9IHt9O1xuICBhdmFpbGFibGVUcmFuc3BvcnRzLmZvckVhY2goZnVuY3Rpb24oYXQpIHtcbiAgICBpZiAoYXQuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICB0cmFuc3BvcnRNYXBbYXQuZmFjYWRlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWVdID0gYXQuZmFjYWRlVHJhbnNwb3J0O1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gaGFyZC1jb2RlZCBmb3IgdGhlIGluZm8gaWZyYW1lXG4gIC8vIFRPRE8gc2VlIGlmIHdlIGNhbiBtYWtlIHRoaXMgbW9yZSBkeW5hbWljXG4gIHRyYW5zcG9ydE1hcFtJbmZvSWZyYW1lUmVjZWl2ZXIudHJhbnNwb3J0TmFtZV0gPSBJbmZvSWZyYW1lUmVjZWl2ZXI7XG4gIHZhciBwYXJlbnRPcmlnaW47XG5cbiAgLyogZXNsaW50LWRpc2FibGUgY2FtZWxjYXNlICovXG4gIFNvY2tKUy5ib290c3RyYXBfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBjYW1lbGNhc2UgKi9cbiAgICB2YXIgZmFjYWRlO1xuICAgIGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCA9IGxvYy5oYXNoLnNsaWNlKDEpO1xuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICBpZiAoZS5zb3VyY2UgIT09IHBhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIHBhcmVudE9yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcGFyZW50T3JpZ2luID0gZS5vcmlnaW47XG4gICAgICB9XG4gICAgICBpZiAoZS5vcmlnaW4gIT09IHBhcmVudE9yaWdpbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBpZnJhbWVNZXNzYWdlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgIGRlYnVnKCdiYWQganNvbicsIGUuZGF0YSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGlmcmFtZU1lc3NhZ2Uud2luZG93SWQgIT09IGlmcmFtZVV0aWxzLmN1cnJlbnRXaW5kb3dJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGlmcmFtZU1lc3NhZ2UudHlwZSkge1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIHZhciBwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHAgPSBKU09OMy5wYXJzZShpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgIHZhciB0cmFuc3BvcnQgPSBwWzFdO1xuICAgICAgICB2YXIgdHJhbnNVcmwgPSBwWzJdO1xuICAgICAgICB2YXIgYmFzZVVybCA9IHBbM107XG4gICAgICAgIGRlYnVnKHZlcnNpb24sIHRyYW5zcG9ydCwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICAgICAgICAvLyBjaGFuZ2UgdGhpcyB0byBzZW12ZXIgbG9naWNcbiAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbmNvbXBhdGliaWxlIFNvY2tKUyEgTWFpbiBzaXRlIHVzZXM6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgdmVyc2lvbiArICdcIiwgdGhlIGlmcmFtZTonICtcbiAgICAgICAgICAgICAgICAgICAgJyBcIicgKyBTb2NrSlMudmVyc2lvbiArICdcIi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0cmFuc1VybCwgbG9jLmhyZWYpIHx8XG4gICAgICAgICAgICAhdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChiYXNlVXJsLCBsb2MuaHJlZikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhblxcJ3QgY29ubmVjdCB0byBkaWZmZXJlbnQgZG9tYWluIGZyb20gd2l0aGluIGFuICcgK1xuICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLiAoJyArIGxvYy5ocmVmICsgJywgJyArIHRyYW5zVXJsICsgJywgJyArIGJhc2VVcmwgKyAnKScpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUyhuZXcgdHJhbnNwb3J0TWFwW3RyYW5zcG9ydF0odHJhbnNVcmwsIGJhc2VVcmwpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtJzpcbiAgICAgICAgZmFjYWRlLl9zZW5kKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYyc6XG4gICAgICAgIGlmIChmYWNhZGUpIHtcbiAgICAgICAgICBmYWNhZGUuX2Nsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ21lc3NhZ2UnLCBvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgncycpO1xuICB9O1xufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4vZmFjYWRlXCI6MzcsXCIuL2luZm8taWZyYW1lLXJlY2VpdmVyXCI6NDAsXCIuL2xvY2F0aW9uXCI6NDMsXCIuL3V0aWxzL2V2ZW50XCI6NzYsXCIuL3V0aWxzL2lmcmFtZVwiOjc3LFwiLi91dGlscy91cmxcIjo4MixcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwianNvbjNcIjo4OH1dLDM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmluZm8tYWpheCcpO1xufVxuXG5mdW5jdGlvbiBJbmZvQWpheCh1cmwsIEFqYXhPYmplY3QpIHtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgdDAgPSArbmV3IERhdGUoKTtcbiAgdGhpcy54byA9IG5ldyBBamF4T2JqZWN0KCdHRVQnLCB1cmwpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgdmFyIGluZm8sIHJ0dDtcbiAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgIHJ0dCA9ICgrbmV3IERhdGUoKSkgLSB0MDtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaW5mbyA9IEpTT04zLnBhcnNlKHRleHQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgZGVidWcoJ2JhZCBqc29uJywgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKCFvYmplY3RVdGlscy5pc09iamVjdChpbmZvKSkge1xuICAgICAgICBpbmZvID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb0FqYXgsIEV2ZW50RW1pdHRlcik7XG5cbkluZm9BamF4LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnhvLmNsb3NlKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9BamF4O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi91dGlscy9vYmplY3RcIjo3OSxcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3LFwianNvbjNcIjo4OH1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxuZnVuY3Rpb24gSW5mb1JlY2VpdmVySWZyYW1lKHRyYW5zVXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy5pciA9IG5ldyBJbmZvQWpheCh0cmFuc1VybCwgWEhSTG9jYWxPYmplY3QpO1xuICB0aGlzLmlyLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgIHNlbGYuaXIgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIEpTT04zLnN0cmluZ2lmeShbaW5mbywgcnR0XSkpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoSW5mb1JlY2VpdmVySWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtaW5mby1yZWNlaXZlcic7XG5cbkluZm9SZWNlaXZlcklmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaXIpIHtcbiAgICB0aGlzLmlyLmNsb3NlKCk7XG4gICAgdGhpcy5pciA9IG51bGw7XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVySWZyYW1lO1xuXG59LHtcIi4vaW5mby1hamF4XCI6MzksXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6NjcsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODcsXCJqc29uM1wiOjg4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L2lmcmFtZScpXG4gICwgSW5mb1JlY2VpdmVySWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJbmZvSWZyYW1lKGJhc2VVcmwsIHVybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBpZnIgPSBzZWxmLmlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUsIHVybCwgYmFzZVVybCk7XG5cbiAgICBpZnIub25jZSgnbWVzc2FnZScsIGZ1bmN0aW9uKG1zZykge1xuICAgICAgaWYgKG1zZykge1xuICAgICAgICB2YXIgZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBkID0gSlNPTjMucGFyc2UobXNnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIG1zZyk7XG4gICAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICBzZWxmLmNsb3NlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICB9XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG5cbiAgICBpZnIub25jZSgnY2xvc2UnLCBmdW5jdGlvbigpIHtcbiAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICBzZWxmLmNsb3NlKCk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gVE9ETyB0aGlzIHNlZW1zIHRoZSBzYW1lIGFzIHRoZSAnbmVlZEJvZHknIGZyb20gdHJhbnNwb3J0c1xuICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5KSB7XG4gICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gIH0gZWxzZSB7XG4gICAgZ28oKTtcbiAgfVxufVxuXG5pbmhlcml0cyhJbmZvSWZyYW1lLCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvSWZyYW1lLmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5JbmZvSWZyYW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5pZnIpIHtcbiAgICB0aGlzLmlmci5jbG9zZSgpO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMuaWZyID0gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb0lmcmFtZTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjQwLFwiLi90cmFuc3BvcnQvaWZyYW1lXCI6NTIsXCIuL3V0aWxzL2V2ZW50XCI6NzYsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4NyxcImpzb24zXCI6ODh9XSw0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgWERSID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hkcicpXG4gICwgWEhSQ29ycyA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItY29ycycpXG4gICwgWEhSTG9jYWwgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBYSFJGYWtlID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlJylcbiAgLCBJbmZvSWZyYW1lID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZScpXG4gICwgSW5mb0FqYXggPSByZXF1aXJlKCcuL2luZm8tYWpheCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIGRlYnVnKGJhc2VVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5kb1hocihiYXNlVXJsLCB1cmxJbmZvKTtcbiAgfSwgMCk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuLy8gVE9ETyB0aGlzIGlzIGN1cnJlbnRseSBpZ25vcmluZyB0aGUgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBhbmQgdGhlIHdoaXRlbGlzdFxuXG5JbmZvUmVjZWl2ZXIuX2dldFJlY2VpdmVyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsLCB1cmxJbmZvKSB7XG4gIC8vIGRldGVybWluZSBtZXRob2Qgb2YgQ09SUyBzdXBwb3J0IChpZiBuZWVkZWQpXG4gIGlmICh1cmxJbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSTG9jYWwpO1xuICB9XG4gIGlmIChYSFJDb3JzLmVuYWJsZWQpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSQ29ycyk7XG4gIH1cbiAgaWYgKFhEUi5lbmFibGVkICYmIHVybEluZm8uc2FtZVNjaGVtZSkge1xuICAgIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYRFIpO1xuICB9XG4gIGlmIChJbmZvSWZyYW1lLmVuYWJsZWQoKSkge1xuICAgIHJldHVybiBuZXcgSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpO1xuICB9XG4gIHJldHVybiBuZXcgSW5mb0FqYXgodXJsLCBYSFJGYWtlKTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUuZG9YaHIgPSBmdW5jdGlvbihiYXNlVXJsLCB1cmxJbmZvKSB7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2luZm8nKVxuICAgIDtcbiAgZGVidWcoJ2RvWGhyJywgdXJsKTtcblxuICB0aGlzLnhvID0gSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlcihiYXNlVXJsLCB1cmwsIHVybEluZm8pO1xuXG4gIHRoaXMudGltZW91dFJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICB9LCBJbmZvUmVjZWl2ZXIudGltZW91dCk7XG5cbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgfSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24od2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRSZWYpO1xuICB0aGlzLnRpbWVvdXRSZWYgPSBudWxsO1xuICBpZiAoIXdhc0NsZWFuICYmIHRoaXMueG8pIHtcbiAgICB0aGlzLnhvLmNsb3NlKCk7XG4gIH1cbiAgdGhpcy54byA9IG51bGw7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cbkluZm9SZWNlaXZlci50aW1lb3V0ID0gODAwMDtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuL2luZm8tYWpheFwiOjM5LFwiLi9pbmZvLWlmcmFtZVwiOjQxLFwiLi90cmFuc3BvcnQvc2VuZGVyL3hkclwiOjY0LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1jb3JzXCI6NjUsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWZha2VcIjo2NixcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWxcIjo2NyxcIi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwubG9jYXRpb24gfHwge1xuICBvcmlnaW46ICdodHRwOi8vbG9jYWxob3N0OjgwJ1xuLCBwcm90b2NvbDogJ2h0dHAnXG4sIGhvc3Q6ICdsb2NhbGhvc3QnXG4sIHBvcnQ6IDgwXG4sIGhyZWY6ICdodHRwOi8vbG9jYWxob3N0LydcbiwgaGFzaDogJydcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnJlcXVpcmUoJy4vc2hpbXMnKTtcblxudmFyIFVSTCA9IHJlcXVpcmUoJ3VybC1wYXJzZScpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi91dGlscy9yYW5kb20nKVxuICAsIGVzY2FwZSA9IHJlcXVpcmUoJy4vdXRpbHMvZXNjYXBlJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgdHJhbnNwb3J0ID0gcmVxdWlyZSgnLi91dGlscy90cmFuc3BvcnQnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9vYmplY3QnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL3V0aWxzL2Jyb3dzZXInKVxuICAsIGxvZyA9IHJlcXVpcmUoJy4vdXRpbHMvbG9nJylcbiAgLCBFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnQnKVxuICAsIEV2ZW50VGFyZ2V0ID0gcmVxdWlyZSgnLi9ldmVudC9ldmVudHRhcmdldCcpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gICwgQ2xvc2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvY2xvc2UnKVxuICAsIFRyYW5zcG9ydE1lc3NhZ2VFdmVudCA9IHJlcXVpcmUoJy4vZXZlbnQvdHJhbnMtbWVzc2FnZScpXG4gICwgSW5mb1JlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgLy8gTWFrZSBkZWJ1ZyBtb2R1bGUgYXZhaWxhYmxlIGdsb2JhbGx5IHNvIHlvdSBjYW4gZW5hYmxlIHZpYSB0aGUgY29uc29sZSBlYXNpbHlcbiAgZ2xvYmFsLmRiZyA9IHJlcXVpcmUoJ2RlYnVnJyk7XG4gIGRlYnVnID0gZ2xvYmFsLmRiZygnc29ja2pzLWNsaWVudDptYWluJyk7XG59XG5cbnZhciB0cmFuc3BvcnRzO1xuXG4vLyBmb2xsb3cgY29uc3RydWN0b3Igc3RlcHMgZGVmaW5lZCBhdCBodHRwOi8vZGV2LnczLm9yZy9odG1sNS93ZWJzb2NrZXRzLyN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuZnVuY3Rpb24gU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTb2NrSlMpKSB7XG4gICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICB9XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGYWlsZWQgdG8gY29uc3RydWN0ICdTb2NrSlM6IDEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudFwiKTtcbiAgfVxuICBFdmVudFRhcmdldC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICB0aGlzLmV4dGVuc2lvbnMgPSAnJztcbiAgdGhpcy5wcm90b2NvbCA9ICcnO1xuXG4gIC8vIG5vbi1zdGFuZGFyZCBleHRlbnNpb25cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmIChvcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QpIHtcbiAgICBsb2cud2FybihcIidwcm90b2NvbHNfd2hpdGVsaXN0JyBpcyBERVBSRUNBVEVELiBVc2UgJ3RyYW5zcG9ydHMnIGluc3RlYWQuXCIpO1xuICB9XG4gIHRoaXMuX3RyYW5zcG9ydHNXaGl0ZWxpc3QgPSBvcHRpb25zLnRyYW5zcG9ydHM7XG5cbiAgdmFyIHNlc3Npb25JZCA9IG9wdGlvbnMuc2Vzc2lvbklkIHx8IDg7XG4gIGlmICh0eXBlb2Ygc2Vzc2lvbklkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ251bWJlcicpIHtcbiAgICB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJhbmRvbS5zdHJpbmcoc2Vzc2lvbklkKTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJZiBzZXNzaW9uSWQgaXMgdXNlZCBpbiB0aGUgb3B0aW9ucywgaXQgbmVlZHMgdG8gYmUgYSBudW1iZXIgb3IgYSBmdW5jdGlvbi5cIik7XG4gIH1cblxuICB0aGlzLl9zZXJ2ZXIgPSBvcHRpb25zLnNlcnZlciB8fCByYW5kb20ubnVtYmVyU3RyaW5nKDEwMDApO1xuXG4gIC8vIFN0ZXAgMSBvZiBXUyBzcGVjIC0gcGFyc2UgYW5kIHZhbGlkYXRlIHRoZSB1cmwuIElzc3VlICM4XG4gIHZhciBwYXJzZWRVcmwgPSBuZXcgVVJMKHVybCk7XG4gIGlmICghcGFyc2VkVXJsLmhvc3QgfHwgIXBhcnNlZFVybC5wcm90b2NvbCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBVUkwgJ1wiICsgdXJsICsgXCInIGlzIGludmFsaWRcIik7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgbXVzdCBub3QgY29udGFpbiBhIGZyYWdtZW50Jyk7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnaHR0cDonICYmIHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3Mgc2NoZW1lIG11c3QgYmUgZWl0aGVyICdodHRwOicgb3IgJ2h0dHBzOicuICdcIiArIHBhcnNlZFVybC5wcm90b2NvbCArIFwiJyBpcyBub3QgYWxsb3dlZC5cIik7XG4gIH1cblxuICB2YXIgc2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnaHR0cHM6JztcbiAgLy8gU3RlcCAyIC0gZG9uJ3QgYWxsb3cgc2VjdXJlIG9yaWdpbiB3aXRoIGFuIGluc2VjdXJlIHByb3RvY29sXG4gIGlmIChsb2MucHJvdG9jb2wgPT09ICdodHRwcycgJiYgIXNlY3VyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2VjdXJpdHlFcnJvcjogQW4gaW5zZWN1cmUgU29ja0pTIGNvbm5lY3Rpb24gbWF5IG5vdCBiZSBpbml0aWF0ZWQgZnJvbSBhIHBhZ2UgbG9hZGVkIG92ZXIgSFRUUFMnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMyAtIGNoZWNrIHBvcnQgYWNjZXNzIC0gbm8gbmVlZCBoZXJlXG4gIC8vIFN0ZXAgNCAtIHBhcnNlIHByb3RvY29scyBhcmd1bWVudFxuICBpZiAoIXByb3RvY29scykge1xuICAgIHByb3RvY29scyA9IFtdO1xuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICBwcm90b2NvbHMgPSBbcHJvdG9jb2xzXTtcbiAgfVxuXG4gIC8vIFN0ZXAgNSAtIGNoZWNrIHByb3RvY29scyBhcmd1bWVudFxuICB2YXIgc29ydGVkUHJvdG9jb2xzID0gcHJvdG9jb2xzLnNvcnQoKTtcbiAgc29ydGVkUHJvdG9jb2xzLmZvckVhY2goZnVuY3Rpb24ocHJvdG8sIGkpIHtcbiAgICBpZiAoIXByb3RvKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGludmFsaWQuXCIpO1xuICAgIH1cbiAgICBpZiAoaSA8IChzb3J0ZWRQcm90b2NvbHMubGVuZ3RoIC0gMSkgJiYgcHJvdG8gPT09IHNvcnRlZFByb3RvY29sc1tpICsgMV0pIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcIlRoZSBwcm90b2NvbHMgZW50cnkgJ1wiICsgcHJvdG8gKyBcIicgaXMgZHVwbGljYXRlZC5cIik7XG4gICAgfVxuICB9KTtcblxuICAvLyBTdGVwIDYgLSBjb252ZXJ0IG9yaWdpblxuICB2YXIgbyA9IHVybFV0aWxzLmdldE9yaWdpbihsb2MuaHJlZik7XG4gIHRoaXMuX29yaWdpbiA9IG8gPyBvLnRvTG93ZXJDYXNlKCkgOiBudWxsO1xuXG4gIC8vIHJlbW92ZSB0aGUgdHJhaWxpbmcgc2xhc2hcbiAgcGFyc2VkVXJsLnNldCgncGF0aG5hbWUnLCBwYXJzZWRVcmwucGF0aG5hbWUucmVwbGFjZSgvXFwvKyQvLCAnJykpO1xuXG4gIC8vIHN0b3JlIHRoZSBzYW5pdGl6ZWQgdXJsXG4gIHRoaXMudXJsID0gcGFyc2VkVXJsLmhyZWY7XG4gIGRlYnVnKCd1c2luZyB1cmwnLCB0aGlzLnVybCk7XG5cbiAgLy8gU3RlcCA3IC0gc3RhcnQgY29ubmVjdGlvbiBpbiBiYWNrZ3JvdW5kXG4gIC8vIG9idGFpbiBzZXJ2ZXIgaW5mb1xuICAvLyBodHRwOi8vc29ja2pzLmdpdGh1Yi5pby9zb2NranMtcHJvdG9jb2wvc29ja2pzLXByb3RvY29sLTAuMy4zLmh0bWwjc2VjdGlvbi0yNlxuICB0aGlzLl91cmxJbmZvID0ge1xuICAgIG51bGxPcmlnaW46ICFicm93c2VyLmhhc0RvbWFpbigpXG4gICwgc2FtZU9yaWdpbjogdXJsVXRpbHMuaXNPcmlnaW5FcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gICwgc2FtZVNjaGVtZTogdXJsVXRpbHMuaXNTY2hlbWVFcXVhbCh0aGlzLnVybCwgbG9jLmhyZWYpXG4gIH07XG5cbiAgdGhpcy5faXIgPSBuZXcgSW5mb1JlY2VpdmVyKHRoaXMudXJsLCB0aGlzLl91cmxJbmZvKTtcbiAgdGhpcy5faXIub25jZSgnZmluaXNoJywgdGhpcy5fcmVjZWl2ZUluZm8uYmluZCh0aGlzKSk7XG59XG5cbmluaGVyaXRzKFNvY2tKUywgRXZlbnRUYXJnZXQpO1xuXG5mdW5jdGlvbiB1c2VyU2V0Q29kZShjb2RlKSB7XG4gIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn1cblxuU29ja0pTLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAvLyBTdGVwIDFcbiAgaWYgKGNvZGUgJiYgIXVzZXJTZXRDb2RlKGNvZGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkQWNjZXNzRXJyb3I6IEludmFsaWQgY29kZScpO1xuICB9XG4gIC8vIFN0ZXAgMi40IHN0YXRlcyB0aGUgbWF4IGlzIDEyMyBieXRlcywgYnV0IHdlIGFyZSBqdXN0IGNoZWNraW5nIGxlbmd0aFxuICBpZiAocmVhc29uICYmIHJlYXNvbi5sZW5ndGggPiAxMjMpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ3JlYXNvbiBhcmd1bWVudCBoYXMgYW4gaW52YWxpZCBsZW5ndGgnKTtcbiAgfVxuXG4gIC8vIFN0ZXAgMy4xXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TSU5HIHx8IHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNMT1NFRCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE8gbG9vayBhdCBkb2NzIHRvIGRldGVybWluZSBob3cgdG8gc2V0IHRoaXNcbiAgdmFyIHdhc0NsZWFuID0gdHJ1ZTtcbiAgdGhpcy5fY2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgJ05vcm1hbCBjbG9zdXJlJywgd2FzQ2xlYW4pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAvLyAjMTMgLSBjb252ZXJ0IGFueXRoaW5nIG5vbi1zdHJpbmcgdG8gc3RyaW5nXG4gIC8vIFRPRE8gdGhpcyBjdXJyZW50bHkgdHVybnMgb2JqZWN0cyBpbnRvIFtvYmplY3QgT2JqZWN0XVxuICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZFN0YXRlRXJyb3I6IFRoZSBjb25uZWN0aW9uIGhhcyBub3QgYmVlbiBlc3RhYmxpc2hlZCB5ZXQnKTtcbiAgfVxuICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnQuc2VuZChlc2NhcGUucXVvdGUoZGF0YSkpO1xufTtcblxuU29ja0pTLnZlcnNpb24gPSByZXF1aXJlKCcuL3ZlcnNpb24nKTtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX3JlY2VpdmVJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gIGRlYnVnKCdfcmVjZWl2ZUluZm8nLCBydHQpO1xuICB0aGlzLl9pciA9IG51bGw7XG4gIGlmICghaW5mbykge1xuICAgIHRoaXMuX2Nsb3NlKDEwMDIsICdDYW5ub3QgY29ubmVjdCB0byBzZXJ2ZXInKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBlc3RhYmxpc2ggYSByb3VuZC10cmlwIHRpbWVvdXQgKFJUTykgYmFzZWQgb24gdGhlXG4gIC8vIHJvdW5kLXRyaXAgdGltZSAoUlRUKVxuICB0aGlzLl9ydG8gPSB0aGlzLmNvdW50UlRPKHJ0dCk7XG4gIC8vIGFsbG93IHNlcnZlciB0byBvdmVycmlkZSB1cmwgdXNlZCBmb3IgdGhlIGFjdHVhbCB0cmFuc3BvcnRcbiAgdGhpcy5fdHJhbnNVcmwgPSBpbmZvLmJhc2VfdXJsID8gaW5mby5iYXNlX3VybCA6IHRoaXMudXJsO1xuICBpbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKGluZm8sIHRoaXMuX3VybEluZm8pO1xuICBkZWJ1ZygnaW5mbycsIGluZm8pO1xuICAvLyBkZXRlcm1pbmUgbGlzdCBvZiBkZXNpcmVkIGFuZCBzdXBwb3J0ZWQgdHJhbnNwb3J0c1xuICB2YXIgZW5hYmxlZFRyYW5zcG9ydHMgPSB0cmFuc3BvcnRzLmZpbHRlclRvRW5hYmxlZCh0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0LCBpbmZvKTtcbiAgdGhpcy5fdHJhbnNwb3J0cyA9IGVuYWJsZWRUcmFuc3BvcnRzLm1haW47XG4gIGRlYnVnKHRoaXMuX3RyYW5zcG9ydHMubGVuZ3RoICsgJyBlbmFibGVkIHRyYW5zcG9ydHMnKTtcblxuICB0aGlzLl9jb25uZWN0KCk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG4gIGZvciAodmFyIFRyYW5zcG9ydCA9IHRoaXMuX3RyYW5zcG9ydHMuc2hpZnQoKTsgVHJhbnNwb3J0OyBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCkpIHtcbiAgICBkZWJ1ZygnYXR0ZW1wdCcsIFRyYW5zcG9ydC50cmFuc3BvcnROYW1lKTtcbiAgICBpZiAoVHJhbnNwb3J0Lm5lZWRCb2R5KSB7XG4gICAgICBpZiAoIWdsb2JhbC5kb2N1bWVudC5ib2R5IHx8XG4gICAgICAgICAgKHR5cGVvZiBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgICAgIGdsb2JhbC5kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAnY29tcGxldGUnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgICAgZGVidWcoJ3dhaXRpbmcgZm9yIGJvZHknKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0cy51bnNoaWZ0KFRyYW5zcG9ydCk7XG4gICAgICAgIGV2ZW50VXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCB0aGlzLl9jb25uZWN0LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2FsY3VsYXRlIHRpbWVvdXQgYmFzZWQgb24gUlRPIGFuZCByb3VuZCB0cmlwcy4gRGVmYXVsdCB0byA1c1xuICAgIHZhciB0aW1lb3V0TXMgPSAodGhpcy5fcnRvICogVHJhbnNwb3J0LnJvdW5kVHJpcHMpIHx8IDUwMDA7XG4gICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gc2V0VGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0LmJpbmQodGhpcyksIHRpbWVvdXRNcyk7XG4gICAgZGVidWcoJ3VzaW5nIHRpbWVvdXQnLCB0aW1lb3V0TXMpO1xuXG4gICAgdmFyIHRyYW5zcG9ydFVybCA9IHVybFV0aWxzLmFkZFBhdGgodGhpcy5fdHJhbnNVcmwsICcvJyArIHRoaXMuX3NlcnZlciArICcvJyArIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkKCkpO1xuICAgIGRlYnVnKCd0cmFuc3BvcnQgdXJsJywgdHJhbnNwb3J0VXJsKTtcbiAgICB2YXIgdHJhbnNwb3J0T2JqID0gbmV3IFRyYW5zcG9ydCh0cmFuc3BvcnRVcmwsIHRoaXMuX3RyYW5zVXJsKTtcbiAgICB0cmFuc3BvcnRPYmoub24oJ21lc3NhZ2UnLCB0aGlzLl90cmFuc3BvcnRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai5vbmNlKCdjbG9zZScsIHRoaXMuX3RyYW5zcG9ydENsb3NlLmJpbmQodGhpcykpO1xuICAgIHRyYW5zcG9ydE9iai50cmFuc3BvcnROYW1lID0gVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0T2JqO1xuXG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMuX2Nsb3NlKDIwMDAsICdBbGwgdHJhbnNwb3J0cyBmYWlsZWQnLCBmYWxzZSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0VGltZW91dCcpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX3RyYW5zcG9ydENsb3NlKDIwMDcsICdUcmFuc3BvcnQgdGltZWQgb3V0Jyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcbiAgZGVidWcoJ190cmFuc3BvcnRNZXNzYWdlJywgbXNnKTtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gICAgLCB0eXBlID0gbXNnLnNsaWNlKDAsIDEpXG4gICAgLCBjb250ZW50ID0gbXNnLnNsaWNlKDEpXG4gICAgLCBwYXlsb2FkXG4gICAgO1xuXG4gIC8vIGZpcnN0IGNoZWNrIGZvciBtZXNzYWdlcyB0aGF0IGRvbid0IG5lZWQgYSBwYXlsb2FkXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgdGhpcy5fb3BlbigpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaGVhcnRiZWF0JykpO1xuICAgICAgZGVidWcoJ2hlYXJ0YmVhdCcsIHRoaXMudHJhbnNwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChjb250ZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHBheWxvYWQgPSBKU09OMy5wYXJzZShjb250ZW50KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGVidWcoJ2VtcHR5IHBheWxvYWQnLCBjb250ZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdhJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpKSB7XG4gICAgICAgIHBheWxvYWQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgZGVidWcoJ21lc3NhZ2UnLCBzZWxmLnRyYW5zcG9ydCwgcCk7XG4gICAgICAgICAgc2VsZi5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgZGVidWcoJ21lc3NhZ2UnLCB0aGlzLnRyYW5zcG9ydCwgcGF5bG9hZCk7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IFRyYW5zcG9ydE1lc3NhZ2VFdmVudChwYXlsb2FkKSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0sIHRydWUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX3RyYW5zcG9ydENsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0Q2xvc2UnLCB0aGlzLnRyYW5zcG9ydCwgY29kZSwgcmVhc29uKTtcbiAgaWYgKHRoaXMuX3RyYW5zcG9ydCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdXNlclNldENvZGUoY29kZSkgJiYgY29kZSAhPT0gMjAwMCAmJiB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgdGhpcy5fY29ubmVjdCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuX2Nsb3NlKGNvZGUsIHJlYXNvbik7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9vcGVuID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfb3BlbicsIHRoaXMuX3RyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0aGlzLnJlYWR5U3RhdGUpO1xuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIGlmICh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90cmFuc3BvcnRUaW1lb3V0SWQpO1xuICAgICAgdGhpcy5fdHJhbnNwb3J0VGltZW91dElkID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZTtcbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdvcGVuJykpO1xuICAgIGRlYnVnKCdjb25uZWN0ZWQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAvLyBjb25uZWN0aW9uLlxuICAgIHRoaXMuX2Nsb3NlKDEwMDYsICdTZXJ2ZXIgbG9zdCBzZXNzaW9uJyk7XG4gIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uLCB3YXNDbGVhbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4sIHRoaXMucmVhZHlTdGF0ZSk7XG4gIHZhciBmb3JjZUZhaWwgPSBmYWxzZTtcblxuICBpZiAodGhpcy5faXIpIHtcbiAgICBmb3JjZUZhaWwgPSB0cnVlO1xuICAgIHRoaXMuX2lyLmNsb3NlKCk7XG4gICAgdGhpcy5faXIgPSBudWxsO1xuICB9XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBTb2NrSlMgaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQnKTtcbiAgfVxuXG4gIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TSU5HO1xuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5DTE9TRUQ7XG5cbiAgICBpZiAoZm9yY2VGYWlsKSB7XG4gICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdlcnJvcicpKTtcbiAgICB9XG5cbiAgICB2YXIgZSA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScpO1xuICAgIGUud2FzQ2xlYW4gPSB3YXNDbGVhbiB8fCBmYWxzZTtcbiAgICBlLmNvZGUgPSBjb2RlIHx8IDEwMDA7XG4gICAgZS5yZWFzb24gPSByZWFzb247XG5cbiAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgdGhpcy5vbm1lc3NhZ2UgPSB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgIGRlYnVnKCdkaXNjb25uZWN0ZWQnKTtcbiAgfS5iaW5kKHRoaXMpLCAwKTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cblNvY2tKUy5wcm90b3R5cGUuY291bnRSVE8gPSBmdW5jdGlvbihydHQpIHtcbiAgLy8gSW4gYSBsb2NhbCBlbnZpcm9ubWVudCwgd2hlbiB1c2luZyBJRTgvOSBhbmQgdGhlIGBqc29ucC1wb2xsaW5nYFxuICAvLyB0cmFuc3BvcnQgdGhlIHRpbWUgbmVlZGVkIHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gKHRoZSB0aW1lIHRoYXQgcGFzc1xuICAvLyBmcm9tIHRoZSBvcGVuaW5nIG9mIHRoZSB0cmFuc3BvcnQgdG8gdGhlIGNhbGwgb2YgYF9kaXNwYXRjaE9wZW5gKSBpc1xuICAvLyBhcm91bmQgMjAwbXNlYyAodGhlIGxvd2VyIGJvdW5kIHVzZWQgaW4gdGhlIGFydGljbGUgYWJvdmUpIGFuZCB0aGlzXG4gIC8vIGNhdXNlcyBzcHVyaW91cyB0aW1lb3V0cy4gRm9yIHRoaXMgcmVhc29uIHdlIGNhbGN1bGF0ZSBhIHZhbHVlIHNsaWdodGx5XG4gIC8vIGxhcmdlciB0aGFuIHRoYXQgdXNlZCBpbiB0aGUgYXJ0aWNsZS5cbiAgaWYgKHJ0dCA+IDEwMCkge1xuICAgIHJldHVybiA0ICogcnR0OyAvLyBydG8gPiA0MDBtc2VjXG4gIH1cbiAgcmV0dXJuIDMwMCArIHJ0dDsgLy8gMzAwbXNlYyA8IHJ0byA8PSA0MDBtc2VjXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgdHJhbnNwb3J0cyA9IHRyYW5zcG9ydChhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmVxdWlyZSgnLi9pZnJhbWUtYm9vdHN0cmFwJykoU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKTtcbiAgcmV0dXJuIFNvY2tKUztcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vZXZlbnQvY2xvc2VcIjozMixcIi4vZXZlbnQvZXZlbnRcIjozNCxcIi4vZXZlbnQvZXZlbnR0YXJnZXRcIjozNSxcIi4vZXZlbnQvdHJhbnMtbWVzc2FnZVwiOjM2LFwiLi9pZnJhbWUtYm9vdHN0cmFwXCI6MzgsXCIuL2luZm8tcmVjZWl2ZXJcIjo0MixcIi4vbG9jYXRpb25cIjo0MyxcIi4vc2hpbXNcIjo0NSxcIi4vdXRpbHMvYnJvd3NlclwiOjc0LFwiLi91dGlscy9lc2NhcGVcIjo3NSxcIi4vdXRpbHMvZXZlbnRcIjo3NixcIi4vdXRpbHMvbG9nXCI6NzgsXCIuL3V0aWxzL29iamVjdFwiOjc5LFwiLi91dGlscy9yYW5kb21cIjo4MCxcIi4vdXRpbHMvdHJhbnNwb3J0XCI6ODEsXCIuL3V0aWxzL3VybFwiOjgyLFwiLi92ZXJzaW9uXCI6ODMsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImluaGVyaXRzXCI6ODcsXCJqc29uM1wiOjg4LFwidXJsLXBhcnNlXCI6ODl9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoganNjczogZGlzYWJsZSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBwdWxsZWQgc3BlY2lmaWMgc2hpbXMgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vZXMtc2hpbXMvZXM1LXNoaW1cblxudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgU3RyaW5nUHJvdG90eXBlID0gU3RyaW5nLnByb3RvdHlwZTtcbnZhciBhcnJheV9zbGljZSA9IEFycmF5UHJvdG90eXBlLnNsaWNlO1xuXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nO1xudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsKSB7XG4gICAgcmV0dXJuIE9iamVjdFByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xudmFyIGlzQXJyYXkgPSBmdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbnZhciBpc1N0cmluZyA9IGZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICAgIHJldHVybiBfdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBTdHJpbmddJztcbn07XG5cbnZhciBzdXBwb3J0c0Rlc2NyaXB0b3JzID0gT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmIChmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHt9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZSkgeyAvKiB0aGlzIGlzIEVTMyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufSgpKTtcblxuLy8gRGVmaW5lIGNvbmZpZ3VyYWJsZSwgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlIHByb3BzXG4vLyBpZiB0aGV5IGRvbid0IGV4aXN0LlxudmFyIGRlZmluZVByb3BlcnR5O1xuaWYgKHN1cHBvcnRzRGVzY3JpcHRvcnMpIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCB7XG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IG1ldGhvZFxuICAgICAgICB9KTtcbiAgICB9O1xufSBlbHNlIHtcbiAgICBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWUsIG1ldGhvZCwgZm9yY2VBc3NpZ24pIHtcbiAgICAgICAgaWYgKCFmb3JjZUFzc2lnbiAmJiAobmFtZSBpbiBvYmplY3QpKSB7IHJldHVybjsgfVxuICAgICAgICBvYmplY3RbbmFtZV0gPSBtZXRob2Q7XG4gICAgfTtcbn1cbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG9iamVjdCwgbWFwLCBmb3JjZUFzc2lnbikge1xuICAgIGZvciAodmFyIG5hbWUgaW4gbWFwKSB7XG4gICAgICAgIGlmIChPYmplY3RQcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIG5hbWUpKSB7XG4gICAgICAgICAgZGVmaW5lUHJvcGVydHkob2JqZWN0LCBuYW1lLCBtYXBbbmFtZV0sIGZvcmNlQXNzaWduKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbnZhciB0b09iamVjdCA9IGZ1bmN0aW9uIChvKSB7XG4gICAgaWYgKG8gPT0gbnVsbCkgeyAvLyB0aGlzIG1hdGNoZXMgYm90aCBudWxsIGFuZCB1bmRlZmluZWRcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcImNhbid0IGNvbnZlcnQgXCIgKyBvICsgJyB0byBvYmplY3QnKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdChvKTtcbn07XG5cbi8vXG4vLyBVdGlsXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSA5LjRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDkuNFxuLy8gaHR0cDovL2pzcGVyZi5jb20vdG8taW50ZWdlclxuXG5mdW5jdGlvbiB0b0ludGVnZXIobnVtKSB7XG4gICAgdmFyIG4gPSArbnVtO1xuICAgIGlmIChuICE9PSBuKSB7IC8vIGlzTmFOXG4gICAgICAgIG4gPSAwO1xuICAgIH0gZWxzZSBpZiAobiAhPT0gMCAmJiBuICE9PSAoMSAvIDApICYmIG4gIT09IC0oMSAvIDApKSB7XG4gICAgICAgIG4gPSAobiA+IDAgfHwgLTEpICogTWF0aC5mbG9vcihNYXRoLmFicyhuKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBUb1VpbnQzMih4KSB7XG4gICAgcmV0dXJuIHggPj4+IDA7XG59XG5cbi8vXG4vLyBGdW5jdGlvblxuLy8gPT09PT09PT1cbi8vXG5cbi8vIEVTLTUgMTUuMy40LjVcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjMuNC41XG5cbmZ1bmN0aW9uIEVtcHR5KCkge31cblxuZGVmaW5lUHJvcGVydGllcyhGdW5jdGlvblByb3RvdHlwZSwge1xuICAgIGJpbmQ6IGZ1bmN0aW9uIGJpbmQodGhhdCkgeyAvLyAubGVuZ3RoIGlzIDFcbiAgICAgICAgLy8gMS4gTGV0IFRhcmdldCBiZSB0aGUgdGhpcyB2YWx1ZS5cbiAgICAgICAgdmFyIHRhcmdldCA9IHRoaXM7XG4gICAgICAgIC8vIDIuIElmIElzQ2FsbGFibGUoVGFyZ2V0KSBpcyBmYWxzZSwgdGhyb3cgYSBUeXBlRXJyb3IgZXhjZXB0aW9uLlxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgY2FsbGVkIG9uIGluY29tcGF0aWJsZSAnICsgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyAzLiBMZXQgQSBiZSBhIG5ldyAocG9zc2libHkgZW1wdHkpIGludGVybmFsIGxpc3Qgb2YgYWxsIG9mIHRoZVxuICAgICAgICAvLyAgIGFyZ3VtZW50IHZhbHVlcyBwcm92aWRlZCBhZnRlciB0aGlzQXJnIChhcmcxLCBhcmcyIGV0YyksIGluIG9yZGVyLlxuICAgICAgICAvLyBYWFggc2xpY2VkQXJncyB3aWxsIHN0YW5kIGluIGZvciBcIkFcIiBpZiB1c2VkXG4gICAgICAgIHZhciBhcmdzID0gYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyAvLyBmb3Igbm9ybWFsIGNhbGxcbiAgICAgICAgLy8gNC4gTGV0IEYgYmUgYSBuZXcgbmF0aXZlIEVDTUFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAvLyAxMS4gU2V0IHRoZSBbW1Byb3RvdHlwZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdGhlIHN0YW5kYXJkXG4gICAgICAgIC8vICAgYnVpbHQtaW4gRnVuY3Rpb24gcHJvdG90eXBlIG9iamVjdCBhcyBzcGVjaWZpZWQgaW4gMTUuMy4zLjEuXG4gICAgICAgIC8vIDEyLiBTZXQgdGhlIFtbQ2FsbF1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgYXMgZGVzY3JpYmVkIGluXG4gICAgICAgIC8vICAgMTUuMy40LjUuMS5cbiAgICAgICAgLy8gMTMuIFNldCB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjIuXG4gICAgICAgIC8vIDE0LiBTZXQgdGhlIFtbSGFzSW5zdGFuY2VdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjMuXG4gICAgICAgIHZhciBiaW5kZXIgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgIGlmICh0aGlzIGluc3RhbmNlb2YgYm91bmQpIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4yIFtbQ29uc3RydWN0XV1cbiAgICAgICAgICAgICAgICAvLyBXaGVuIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCxcbiAgICAgICAgICAgICAgICAvLyBGIHRoYXQgd2FzIGNyZWF0ZWQgdXNpbmcgdGhlIGJpbmQgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggYVxuICAgICAgICAgICAgICAgIC8vIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IHRhcmdldCBiZSB0aGUgdmFsdWUgb2YgRidzIFtbVGFyZ2V0RnVuY3Rpb25dXVxuICAgICAgICAgICAgICAgIC8vICAgaW50ZXJuYWwgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gSWYgdGFyZ2V0IGhhcyBubyBbW0NvbnN0cnVjdF1dIGludGVybmFsIG1ldGhvZCwgYVxuICAgICAgICAgICAgICAgIC8vICAgVHlwZUVycm9yIGV4Y2VwdGlvbiBpcyB0aHJvd24uXG4gICAgICAgICAgICAgICAgLy8gMy4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NvbnN0cnVjdF1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBtZXRob2Qgb2YgdGFyZ2V0IHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGFyZ2V0LmFwcGx5KFxuICAgICAgICAgICAgICAgICAgICB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChhcnJheV9zbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0KHJlc3VsdCkgPT09IHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyAxNS4zLjQuNS4xIFtbQ2FsbF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kIG9mIGEgZnVuY3Rpb24gb2JqZWN0LCBGLFxuICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyB0aGlzIHZhbHVlIGFuZCBhIGxpc3Qgb2YgYXJndW1lbnRzIEV4dHJhQXJncywgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgICAgIC8vIHN0ZXBzIGFyZSB0YWtlbjpcbiAgICAgICAgICAgICAgICAvLyAxLiBMZXQgYm91bmRBcmdzIGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tCb3VuZEFyZ3NdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgcHJvcGVydHkuXG4gICAgICAgICAgICAgICAgLy8gMi4gTGV0IGJvdW5kVGhpcyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRUaGlzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDQuIExldCBhcmdzIGJlIGEgbmV3IGxpc3QgY29udGFpbmluZyB0aGUgc2FtZSB2YWx1ZXMgYXMgdGhlXG4gICAgICAgICAgICAgICAgLy8gICBsaXN0IGJvdW5kQXJncyBpbiB0aGUgc2FtZSBvcmRlciBmb2xsb3dlZCBieSB0aGUgc2FtZVxuICAgICAgICAgICAgICAgIC8vICAgdmFsdWVzIGFzIHRoZSBsaXN0IEV4dHJhQXJncyBpbiB0aGUgc2FtZSBvcmRlci5cbiAgICAgICAgICAgICAgICAvLyA1LiBSZXR1cm4gdGhlIHJlc3VsdCBvZiBjYWxsaW5nIHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBtZXRob2RcbiAgICAgICAgICAgICAgICAvLyAgIG9mIHRhcmdldCBwcm92aWRpbmcgYm91bmRUaGlzIGFzIHRoZSB0aGlzIHZhbHVlIGFuZFxuICAgICAgICAgICAgICAgIC8vICAgcHJvdmlkaW5nIGFyZ3MgYXMgdGhlIGFyZ3VtZW50cy5cblxuICAgICAgICAgICAgICAgIC8vIGVxdWl2OiB0YXJnZXQuY2FsbCh0aGlzLCAuLi5ib3VuZEFyZ3MsIC4uLmFyZ3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhhdCxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIDE1LiBJZiB0aGUgW1tDbGFzc11dIGludGVybmFsIHByb3BlcnR5IG9mIFRhcmdldCBpcyBcIkZ1bmN0aW9uXCIsIHRoZW5cbiAgICAgICAgLy8gICAgIGEuIExldCBMIGJlIHRoZSBsZW5ndGggcHJvcGVydHkgb2YgVGFyZ2V0IG1pbnVzIHRoZSBsZW5ndGggb2YgQS5cbiAgICAgICAgLy8gICAgIGIuIFNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIGVpdGhlciAwIG9yIEwsIHdoaWNoZXZlciBpc1xuICAgICAgICAvLyAgICAgICBsYXJnZXIuXG4gICAgICAgIC8vIDE2LiBFbHNlIHNldCB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIDAuXG5cbiAgICAgICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcblxuICAgICAgICAvLyAxNy4gU2V0IHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSBsZW5ndGggb3duIHByb3BlcnR5IG9mIEYgdG8gdGhlIHZhbHVlc1xuICAgICAgICAvLyAgIHNwZWNpZmllZCBpbiAxNS4zLjUuMS5cbiAgICAgICAgdmFyIGJvdW5kQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gWFhYIEJ1aWxkIGEgZHluYW1pYyBmdW5jdGlvbiB3aXRoIGRlc2lyZWQgYW1vdW50IG9mIGFyZ3VtZW50cyBpcyB0aGUgb25seVxuICAgICAgICAvLyB3YXkgdG8gc2V0IHRoZSBsZW5ndGggcHJvcGVydHkgb2YgYSBmdW5jdGlvbi5cbiAgICAgICAgLy8gSW4gZW52aXJvbm1lbnRzIHdoZXJlIENvbnRlbnQgU2VjdXJpdHkgUG9saWNpZXMgZW5hYmxlZCAoQ2hyb21lIGV4dGVuc2lvbnMsXG4gICAgICAgIC8vIGZvciBleC4pIGFsbCB1c2Ugb2YgZXZhbCBvciBGdW5jdGlvbiBjb3N0cnVjdG9yIHRocm93cyBhbiBleGNlcHRpb24uXG4gICAgICAgIC8vIEhvd2V2ZXIgaW4gYWxsIG9mIHRoZXNlIGVudmlyb25tZW50cyBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBleGlzdHNcbiAgICAgICAgLy8gYW5kIHNvIHRoaXMgY29kZSB3aWxsIG5ldmVyIGJlIGV4ZWN1dGVkLlxuICAgICAgICB2YXIgYm91bmQgPSBGdW5jdGlvbignYmluZGVyJywgJ3JldHVybiBmdW5jdGlvbiAoJyArIGJvdW5kQXJncy5qb2luKCcsJykgKyAnKXsgcmV0dXJuIGJpbmRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcblxuICAgICAgICBpZiAodGFyZ2V0LnByb3RvdHlwZSkge1xuICAgICAgICAgICAgRW1wdHkucHJvdG90eXBlID0gdGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgIGJvdW5kLnByb3RvdHlwZSA9IG5ldyBFbXB0eSgpO1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgZGFuZ2xpbmcgcmVmZXJlbmNlcy5cbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE4LiBTZXQgdGhlIFtbRXh0ZW5zaWJsZV1dIGludGVybmFsIHByb3BlcnR5IG9mIEYgdG8gdHJ1ZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIDE5LiBMZXQgdGhyb3dlciBiZSB0aGUgW1tUaHJvd1R5cGVFcnJvcl1dIGZ1bmN0aW9uIE9iamVjdCAoMTMuMi4zKS5cbiAgICAgICAgLy8gMjAuIENhbGwgdGhlIFtbRGVmaW5lT3duUHJvcGVydHldXSBpbnRlcm5hbCBtZXRob2Qgb2YgRiB3aXRoXG4gICAgICAgIC8vICAgYXJndW1lbnRzIFwiY2FsbGVyXCIsIFByb3BlcnR5RGVzY3JpcHRvciB7W1tHZXRdXTogdGhyb3dlciwgW1tTZXRdXTpcbiAgICAgICAgLy8gICB0aHJvd2VyLCBbW0VudW1lcmFibGVdXTogZmFsc2UsIFtbQ29uZmlndXJhYmxlXV06IGZhbHNlfSwgYW5kXG4gICAgICAgIC8vICAgZmFsc2UuXG4gICAgICAgIC8vIDIxLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImFyZ3VtZW50c1wiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsXG4gICAgICAgIC8vICAgW1tTZXRdXTogdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sXG4gICAgICAgIC8vICAgYW5kIGZhbHNlLlxuXG4gICAgICAgIC8vIFRPRE9cbiAgICAgICAgLy8gTk9URSBGdW5jdGlvbiBvYmplY3RzIGNyZWF0ZWQgdXNpbmcgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZG8gbm90XG4gICAgICAgIC8vIGhhdmUgYSBwcm90b3R5cGUgcHJvcGVydHkgb3IgdGhlIFtbQ29kZV1dLCBbW0Zvcm1hbFBhcmFtZXRlcnNdXSwgYW5kXG4gICAgICAgIC8vIFtbU2NvcGVdXSBpbnRlcm5hbCBwcm9wZXJ0aWVzLlxuICAgICAgICAvLyBYWFggY2FuJ3QgZGVsZXRlIHByb3RvdHlwZSBpbiBwdXJlLWpzLlxuXG4gICAgICAgIC8vIDIyLiBSZXR1cm4gRi5cbiAgICAgICAgcmV0dXJuIGJvdW5kO1xuICAgIH1cbn0pO1xuXG4vL1xuLy8gQXJyYXlcbi8vID09PT09XG4vL1xuXG4vLyBFUzUgMTUuNC4zLjJcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjQuMy4yXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pc0FycmF5XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5LCB7IGlzQXJyYXk6IGlzQXJyYXkgfSk7XG5cblxudmFyIGJveGVkU3RyaW5nID0gT2JqZWN0KCdhJyk7XG52YXIgc3BsaXRTdHJpbmcgPSBib3hlZFN0cmluZ1swXSAhPT0gJ2EnIHx8ICEoMCBpbiBib3hlZFN0cmluZyk7XG5cbnZhciBwcm9wZXJseUJveGVzQ29udGV4dCA9IGZ1bmN0aW9uIHByb3Blcmx5Qm94ZWQobWV0aG9kKSB7XG4gICAgLy8gQ2hlY2sgbm9kZSAwLjYuMjEgYnVnIHdoZXJlIHRoaXJkIHBhcmFtZXRlciBpcyBub3QgYm94ZWRcbiAgICB2YXIgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IHRydWU7XG4gICAgdmFyIHByb3Blcmx5Qm94ZXNTdHJpY3QgPSB0cnVlO1xuICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgbWV0aG9kLmNhbGwoJ2ZvbycsIGZ1bmN0aW9uIChfLCBfXywgY29udGV4dCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZXh0ICE9PSAnb2JqZWN0JykgeyBwcm9wZXJseUJveGVzTm9uU3RyaWN0ID0gZmFsc2U7IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWV0aG9kLmNhbGwoWzFdLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAndXNlIHN0cmljdCc7XG4gICAgICAgICAgICBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHlwZW9mIHRoaXMgPT09ICdzdHJpbmcnO1xuICAgICAgICB9LCAneCcpO1xuICAgIH1cbiAgICByZXR1cm4gISFtZXRob2QgJiYgcHJvcGVybHlCb3hlc05vblN0cmljdCAmJiBwcm9wZXJseUJveGVzU3RyaWN0O1xufTtcblxuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goZnVuIC8qLCB0aGlzcCovKSB7XG4gICAgICAgIHZhciBvYmplY3QgPSB0b09iamVjdCh0aGlzKSxcbiAgICAgICAgICAgIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogb2JqZWN0LFxuICAgICAgICAgICAgdGhpc3AgPSBhcmd1bWVudHNbMV0sXG4gICAgICAgICAgICBpID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAvLyBJZiBubyBjYWxsYmFjayBmdW5jdGlvbiBvciBpZiBjYWxsYmFjayBpcyBub3QgYSBjYWxsYWJsZSBmdW5jdGlvblxuICAgICAgICBpZiAoIWlzRnVuY3Rpb24oZnVuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpOyAvLyBUT0RPIG1lc3NhZ2VcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgrK2kgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYpIHtcbiAgICAgICAgICAgICAgICAvLyBJbnZva2UgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHdpdGggY2FsbCwgcGFzc2luZyBhcmd1bWVudHM6XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dCwgcHJvcGVydHkgdmFsdWUsIHByb3BlcnR5IGtleSwgdGhpc0FyZyBvYmplY3RcbiAgICAgICAgICAgICAgICAvLyBjb250ZXh0XG4gICAgICAgICAgICAgICAgZnVuLmNhbGwodGhpc3AsIHNlbGZbaV0sIGksIG9iamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59LCAhcHJvcGVybHlCb3hlc0NvbnRleHQoQXJyYXlQcm90b3R5cGUuZm9yRWFjaCkpO1xuXG4vLyBFUzUgMTUuNC40LjE0XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjQuMTRcbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0FycmF5L2luZGV4T2ZcbnZhciBoYXNGaXJlZm94MkluZGV4T2ZCdWcgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiAmJiBbMCwgMV0uaW5kZXhPZigxLCAyKSAhPT0gLTE7XG5kZWZpbmVQcm9wZXJ0aWVzKEFycmF5UHJvdG90eXBlLCB7XG4gICAgaW5kZXhPZjogZnVuY3Rpb24gaW5kZXhPZihzb3VnaHQgLyosIGZyb21JbmRleCAqLyApIHtcbiAgICAgICAgdmFyIHNlbGYgPSBzcGxpdFN0cmluZyAmJiBpc1N0cmluZyh0aGlzKSA/IHRoaXMuc3BsaXQoJycpIDogdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBsZW5ndGggPSBzZWxmLmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGkgPSB0b0ludGVnZXIoYXJndW1lbnRzWzFdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGhhbmRsZSBuZWdhdGl2ZSBpbmRpY2VzXG4gICAgICAgIGkgPSBpID49IDAgPyBpIDogTWF0aC5tYXgoMCwgbGVuZ3RoICsgaSk7XG4gICAgICAgIGZvciAoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIGluIHNlbGYgJiYgc2VsZltpXSA9PT0gc291Z2h0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbn0sIGhhc0ZpcmVmb3gySW5kZXhPZkJ1Zyk7XG5cbi8vXG4vLyBTdHJpbmdcbi8vID09PT09PVxuLy9cblxuLy8gRVM1IDE1LjUuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNS40LjE0XG5cbi8vIFtidWdmaXgsIElFIGx0IDksIGZpcmVmb3ggNCwgS29ucXVlcm9yLCBPcGVyYSwgb2JzY3VyZSBicm93c2Vyc11cbi8vIE1hbnkgYnJvd3NlcnMgZG8gbm90IHNwbGl0IHByb3Blcmx5IHdpdGggcmVndWxhciBleHByZXNzaW9ucyBvciB0aGV5XG4vLyBkbyBub3QgcGVyZm9ybSB0aGUgc3BsaXQgY29ycmVjdGx5IHVuZGVyIG9ic2N1cmUgY29uZGl0aW9ucy5cbi8vIFNlZSBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvY3Jvc3MtYnJvd3Nlci1zcGxpdFxuLy8gSSd2ZSB0ZXN0ZWQgaW4gbWFueSBicm93c2VycyBhbmQgdGhpcyBzZWVtcyB0byBjb3ZlciB0aGUgZGV2aWFudCBvbmVzOlxuLy8gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pIHNob3VsZCBiZSBbXCJcIiwgXCJcIl0sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKC4/KSguPykvKSBzaG91bGQgYmUgW1wiXCIsIFwiLlwiLCBcIlwiLCBcIlwiXSwgbm90IFtcIlwiLCBcIlwiXVxuLy8gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pIHNob3VsZCBiZSBbXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIFwic1wiLCBcInRcIl0sIG5vdFxuLy8gICAgICAgW3VuZGVmaW5lZCwgXCJ0XCIsIHVuZGVmaW5lZCwgXCJlXCIsIC4uLl1cbi8vICAgICcnLnNwbGl0KC8uPy8pIHNob3VsZCBiZSBbXSwgbm90IFtcIlwiXVxuLy8gICAgJy4nLnNwbGl0KC8oKSgpLykgc2hvdWxkIGJlIFtcIi5cIl0sIG5vdCBbXCJcIiwgXCJcIiwgXCIuXCJdXG5cbnZhciBzdHJpbmdfc3BsaXQgPSBTdHJpbmdQcm90b3R5cGUuc3BsaXQ7XG5pZiAoXG4gICAgJ2FiJy5zcGxpdCgvKD86YWIpKi8pLmxlbmd0aCAhPT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT09IDQgfHxcbiAgICAndGVzc3QnLnNwbGl0KC8ocykqLylbMV0gPT09ICd0JyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT09IDQgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGggfHxcbiAgICAnLicuc3BsaXQoLygpKCkvKS5sZW5ndGggPiAxXG4pIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcGxpYW50RXhlY05wY2cgPSAvKCk/Py8uZXhlYygnJylbMV0gPT09IHZvaWQgMDsgLy8gTlBDRzogbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBcblxuICAgICAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICAgICAgdmFyIHN0cmluZyA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICAgICAgICBpZiAoX3RvU3RyaW5nLmNhbGwoc2VwYXJhdG9yKSAhPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nX3NwbGl0LmNhbGwodGhpcywgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXSxcbiAgICAgICAgICAgICAgICBmbGFncyA9IChzZXBhcmF0b3IuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAoc2VwYXJhdG9yLm11bHRpbGluZSAgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5leHRlbmRlZCAgID8gJ3gnIDogJycpICsgLy8gUHJvcG9zZWQgZm9yIEVTNlxuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5zdGlja3kgICAgID8gJ3knIDogJycpLCAvLyBGaXJlZm94IDMrXG4gICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IDAsXG4gICAgICAgICAgICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyLCBtYXRjaCwgbGFzdEluZGV4LCBsYXN0TGVuZ3RoO1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJyc7IC8vIFR5cGUtY29udmVydFxuICAgICAgICAgICAgaWYgKCFjb21wbGlhbnRFeGVjTnBjZykge1xuICAgICAgICAgICAgICAgIC8vIERvZXNuJ3QgbmVlZCBmbGFncyBneSwgYnV0IHRoZXkgZG9uJ3QgaHVydFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvcjIgPSBuZXcgUmVnRXhwKCdeJyArIHNlcGFyYXRvci5zb3VyY2UgKyAnJCg/IVxcXFxzKScsIGZsYWdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIFZhbHVlcyBmb3IgYGxpbWl0YCwgcGVyIHRoZSBzcGVjOlxuICAgICAgICAgICAgICogSWYgdW5kZWZpbmVkOiA0Mjk0OTY3Mjk1IC8vIE1hdGgucG93KDIsIDMyKSAtIDFcbiAgICAgICAgICAgICAqIElmIDAsIEluZmluaXR5LCBvciBOYU46IDBcbiAgICAgICAgICAgICAqIElmIHBvc2l0aXZlIG51bWJlcjogbGltaXQgPSBNYXRoLmZsb29yKGxpbWl0KTsgaWYgKGxpbWl0ID4gNDI5NDk2NzI5NSkgbGltaXQgLT0gNDI5NDk2NzI5NjtcbiAgICAgICAgICAgICAqIElmIG5lZ2F0aXZlIG51bWJlcjogNDI5NDk2NzI5NiAtIE1hdGguZmxvb3IoTWF0aC5hYnMobGltaXQpKVxuICAgICAgICAgICAgICogSWYgb3RoZXI6IFR5cGUtY29udmVydCwgdGhlbiB1c2UgdGhlIGFib3ZlIHJ1bGVzXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxpbWl0ID0gbGltaXQgPT09IHZvaWQgMCA/XG4gICAgICAgICAgICAgICAgLTEgPj4+IDAgOiAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgICAgVG9VaW50MzIobGltaXQpO1xuICAgICAgICAgICAgd2hpbGUgKG1hdGNoID0gc2VwYXJhdG9yLmV4ZWMoc3RyaW5nKSkge1xuICAgICAgICAgICAgICAgIC8vIGBzZXBhcmF0b3IubGFzdEluZGV4YCBpcyBub3QgcmVsaWFibGUgY3Jvc3MtYnJvd3NlclxuICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPiBsYXN0TGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYCBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gbm9ucGFydGljaXBhdGluZyBjYXB0dXJpbmcgZ3JvdXBzXG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cgJiYgbWF0Y2gubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbMF0ucmVwbGFjZShzZXBhcmF0b3IyLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoIC0gMjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hbaV0gPSB2b2lkIDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID4gMSAmJiBtYXRjaC5pbmRleCA8IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIEFycmF5UHJvdG90eXBlLnB1c2guYXBwbHkob3V0cHV0LCBtYXRjaC5zbGljZSgxKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFzdExlbmd0aCA9IG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG91dHB1dC5sZW5ndGggPj0gbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXBhcmF0b3IubGFzdEluZGV4ID09PSBtYXRjaC5pbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXBhcmF0b3IubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGFzdExhc3RJbmRleCA9PT0gc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3IudGVzdCgnJykpIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltaXQgPyBvdXRwdXQuc2xpY2UoMCwgbGltaXQpIDogb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbi8vIFtidWdmaXgsIGNocm9tZV1cbi8vIElmIHNlcGFyYXRvciBpcyB1bmRlZmluZWQsIHRoZW4gdGhlIHJlc3VsdCBhcnJheSBjb250YWlucyBqdXN0IG9uZSBTdHJpbmcsXG4vLyB3aGljaCBpcyB0aGUgdGhpcyB2YWx1ZSAoY29udmVydGVkIHRvIGEgU3RyaW5nKS4gSWYgbGltaXQgaXMgbm90IHVuZGVmaW5lZCxcbi8vIHRoZW4gdGhlIG91dHB1dCBhcnJheSBpcyB0cnVuY2F0ZWQgc28gdGhhdCBpdCBjb250YWlucyBubyBtb3JlIHRoYW4gbGltaXRcbi8vIGVsZW1lbnRzLlxuLy8gXCIwXCIuc3BsaXQodW5kZWZpbmVkLCAwKSAtPiBbXVxufSBlbHNlIGlmICgnMCcuc3BsaXQodm9pZCAwLCAwKS5sZW5ndGgpIHtcbiAgICBTdHJpbmdQcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICAgIGlmIChzZXBhcmF0b3IgPT09IHZvaWQgMCAmJiBsaW1pdCA9PT0gMCkgeyByZXR1cm4gW107IH1cbiAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG59XG5cbi8vIEVTNSAxNS41LjQuMjBcbi8vIHdoaXRlc3BhY2UgZnJvbTogaHR0cDovL2VzNS5naXRodWIuaW8vI3gxNS41LjQuMjBcbnZhciB3cyA9ICdcXHgwOVxceDBBXFx4MEJcXHgwQ1xceDBEXFx4MjBcXHhBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwMycgK1xuICAgICdcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBBXFx1MjAyRlxcdTIwNUZcXHUzMDAwXFx1MjAyOCcgK1xuICAgICdcXHUyMDI5XFx1RkVGRic7XG52YXIgemVyb1dpZHRoID0gJ1xcdTIwMGInO1xudmFyIHdzUmVnZXhDaGFycyA9ICdbJyArIHdzICsgJ10nO1xudmFyIHRyaW1CZWdpblJlZ2V4cCA9IG5ldyBSZWdFeHAoJ14nICsgd3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyonKTtcbnZhciB0cmltRW5kUmVnZXhwID0gbmV3IFJlZ0V4cCh3c1JlZ2V4Q2hhcnMgKyB3c1JlZ2V4Q2hhcnMgKyAnKiQnKTtcbnZhciBoYXNUcmltV2hpdGVzcGFjZUJ1ZyA9IFN0cmluZ1Byb3RvdHlwZS50cmltICYmICh3cy50cmltKCkgfHwgIXplcm9XaWR0aC50cmltKCkpO1xuZGVmaW5lUHJvcGVydGllcyhTdHJpbmdQcm90b3R5cGUsIHtcbiAgICAvLyBodHRwOi8vYmxvZy5zdGV2ZW5sZXZpdGhhbi5jb20vYXJjaGl2ZXMvZmFzdGVyLXRyaW0tamF2YXNjcmlwdFxuICAgIC8vIGh0dHA6Ly9wZXJmZWN0aW9ua2lsbHMuY29tL3doaXRlc3BhY2UtZGV2aWF0aW9ucy9cbiAgICB0cmltOiBmdW5jdGlvbiB0cmltKCkge1xuICAgICAgICBpZiAodGhpcyA9PT0gdm9pZCAwIHx8IHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgdGhpcyArICcgdG8gb2JqZWN0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzKS5yZXBsYWNlKHRyaW1CZWdpblJlZ2V4cCwgJycpLnJlcGxhY2UodHJpbUVuZFJlZ2V4cCwgJycpO1xuICAgIH1cbn0sIGhhc1RyaW1XaGl0ZXNwYWNlQnVnKTtcblxuLy8gRUNNQS0yNjIsIDNyZCBCLjIuM1xuLy8gTm90IGFuIEVDTUFTY3JpcHQgc3RhbmRhcmQsIGFsdGhvdWdoIEVDTUFTY3JpcHQgM3JkIEVkaXRpb24gaGFzIGFcbi8vIG5vbi1ub3JtYXRpdmUgc2VjdGlvbiBzdWdnZXN0aW5nIHVuaWZvcm0gc2VtYW50aWNzIGFuZCBpdCBzaG91bGQgYmVcbi8vIG5vcm1hbGl6ZWQgYWNyb3NzIGFsbCBicm93c2Vyc1xuLy8gW2J1Z2ZpeCwgSUUgbHQgOV0gSUUgPCA5IHN1YnN0cigpIHdpdGggbmVnYXRpdmUgdmFsdWUgbm90IHdvcmtpbmcgaW4gSUVcbnZhciBzdHJpbmdfc3Vic3RyID0gU3RyaW5nUHJvdG90eXBlLnN1YnN0cjtcbnZhciBoYXNOZWdhdGl2ZVN1YnN0ckJ1ZyA9ICcnLnN1YnN0ciAmJiAnMGInLnN1YnN0cigtMSkgIT09ICdiJztcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgc3Vic3RyOiBmdW5jdGlvbiBzdWJzdHIoc3RhcnQsIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nX3N1YnN0ci5jYWxsKFxuICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgIHN0YXJ0IDwgMCA/ICgoc3RhcnQgPSB0aGlzLmxlbmd0aCArIHN0YXJ0KSA8IDAgPyAwIDogc3RhcnQpIDogc3RhcnQsXG4gICAgICAgICAgICBsZW5ndGhcbiAgICAgICAgKTtcbiAgICB9XG59LCBoYXNOZWdhdGl2ZVN1YnN0ckJ1Zyk7XG5cbn0se31dLDQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gIC8vIHN0cmVhbWluZyB0cmFuc3BvcnRzXG4gIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3dlYnNvY2tldCcpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1zdHJlYW1pbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9ldmVudHNvdXJjZScpKVxuXG4gIC8vIHBvbGxpbmcgdHJhbnNwb3J0c1xuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2xpYi9pZnJhbWUtd3JhcCcpKHJlcXVpcmUoJy4vdHJhbnNwb3J0L2h0bWxmaWxlJykpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hoci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXBvbGxpbmcnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nJylcbl07XG5cbn0se1wiLi90cmFuc3BvcnQvZXZlbnRzb3VyY2VcIjo1MCxcIi4vdHJhbnNwb3J0L2h0bWxmaWxlXCI6NTEsXCIuL3RyYW5zcG9ydC9qc29ucC1wb2xsaW5nXCI6NTMsXCIuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXBcIjo1NixcIi4vdHJhbnNwb3J0L3dlYnNvY2tldFwiOjY4LFwiLi90cmFuc3BvcnQveGRyLXBvbGxpbmdcIjo2OSxcIi4vdHJhbnNwb3J0L3hkci1zdHJlYW1pbmdcIjo3MCxcIi4vdHJhbnNwb3J0L3hoci1wb2xsaW5nXCI6NzEsXCIuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nXCI6NzJ9XSw0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvZXZlbnQnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBYSFIgPSBnbG9iYWwuWE1MSHR0cFJlcXVlc3RcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmJyb3dzZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIEFic3RyYWN0WEhST2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIGRlYnVnKG1ldGhvZCwgdXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhBYnN0cmFjdFhIUk9iamVjdCwgRXZlbnRFbWl0dGVyKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0cnkge1xuICAgIHRoaXMueGhyID0gbmV3IFhIUigpO1xuICB9IGNhdGNoICh4KSB7fVxuXG4gIGlmICghdGhpcy54aHIpIHtcbiAgICBkZWJ1Zygnbm8geGhyJyk7XG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnbm8geGhyIHN1cHBvcnQnKTtcbiAgICB0aGlzLl9jbGVhbnVwKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gc2V2ZXJhbCBicm93c2VycyBjYWNoZSBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgLy8gdGFiIGdldHMgY2xvc2VkOiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC81MjgwXG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQgY2xlYW51cCcpO1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIHRoaXMueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIGlmICh0aGlzLnRpbWVvdXQgJiYgJ3RpbWVvdXQnIGluIHRoaXMueGhyKSB7XG4gICAgICB0aGlzLnhoci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgICAgdGhpcy54aHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRlYnVnKCd4aHIgdGltZW91dCcpO1xuICAgICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGRlYnVnKCdleGNlcHRpb24nLCBlKTtcbiAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCghb3B0cyB8fCAhb3B0cy5ub0NyZWRlbnRpYWxzKSAmJiBBYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMpIHtcbiAgICBkZWJ1Zygnd2l0aENyZWRlbnRpYWxzJyk7XG4gICAgLy8gTW96aWxsYSBkb2NzIHNheXMgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vWE1MSHR0cFJlcXVlc3QgOlxuICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuXG4gICAgdGhpcy54aHIud2l0aENyZWRlbnRpYWxzID0gJ3RydWUnO1xuICB9XG4gIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgIGZvciAodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgIHRoaXMueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICB2YXIgeCA9IHNlbGYueGhyO1xuICAgICAgdmFyIHRleHQsIHN0YXR1cztcbiAgICAgIGRlYnVnKCdyZWFkeVN0YXRlJywgeC5yZWFkeVN0YXRlKTtcbiAgICAgIHN3aXRjaCAoeC5yZWFkeVN0YXRlKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICBkZWJ1Zygnc3RhdHVzJywgc3RhdHVzKTtcbiAgICAgICAgLy8gSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTBcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIyMykge1xuICAgICAgICAgIHN0YXR1cyA9IDIwNDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDIwMCAmJiB0ZXh0ICYmIHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGRlYnVnKCdjaHVuaycpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICBzdGF0dXMgPSB4LnN0YXR1cztcbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSUUgcmV0dXJucyB0aGlzIGZvciBhIGJhZCBwb3J0XG4gICAgICAgIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS93aW5kb3dzL2Rlc2t0b3AvYWEzODM3NzAodj12cy44NSkuYXNweFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjAwNSB8fCBzdGF0dXMgPT09IDEyMDI5KSB7XG4gICAgICAgICAgc3RhdHVzID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBzdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB0cnkge1xuICAgIHNlbGYueGhyLnNlbmQocGF5bG9hZCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfVxufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgaWYgKCF0aGlzLnhocikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuXG4gIC8vIElFIG5lZWRzIHRoaXMgZmllbGQgdG8gYmUgYSBmdW5jdGlvblxuICB0aGlzLnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHt9O1xuICBpZiAodGhpcy54aHIub250aW1lb3V0KSB7XG4gICAgdGhpcy54aHIub250aW1lb3V0ID0gbnVsbDtcbiAgfVxuXG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhoci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMuX2NsZWFudXAodHJ1ZSk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFYSFI7XG4vLyBvdmVycmlkZSBYTUxIdHRwUmVxdWVzdCBmb3IgSUU2Lzdcbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKCFBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkICYmIChheG8gaW4gZ2xvYmFsKSkge1xuICBkZWJ1Zygnb3ZlcnJpZGluZyB4bWxodHRwcmVxdWVzdCcpO1xuICBYSFIgPSBmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIG5ldyBnbG9iYWxbYXhvXSgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIEFic3RyYWN0WEhST2JqZWN0LmVuYWJsZWQgPSAhIW5ldyBYSFIoKTtcbn1cblxudmFyIGNvcnMgPSBmYWxzZTtcbnRyeSB7XG4gIGNvcnMgPSAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWEhSKCk7XG59IGNhdGNoIChpZ25vcmVkKSB7fVxuXG5BYnN0cmFjdFhIUk9iamVjdC5zdXBwb3J0c0NPUlMgPSBjb3JzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFic3RyYWN0WEhST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9ldmVudFwiOjc2LFwiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDQ4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLkV2ZW50U291cmNlO1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIEV2ZW50U291cmNlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2V2ZW50c291cmNlJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIEV2ZW50U291cmNlRHJpdmVyID0gcmVxdWlyZSgnZXZlbnRzb3VyY2UnKVxuICA7XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9ldmVudHNvdXJjZScsIEV2ZW50U291cmNlUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuRXZlbnRTb3VyY2VUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFFdmVudFNvdXJjZURyaXZlcjtcbn07XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnZXZlbnRzb3VyY2UnO1xuRXZlbnRTb3VyY2VUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjU0LFwiLi9yZWNlaXZlci9ldmVudHNvdXJjZVwiOjU5LFwiLi9zZW5kZXIveGhyLWNvcnNcIjo2NSxcImV2ZW50c291cmNlXCI6NDgsXCJpbmhlcml0c1wiOjg3fV0sNTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSHRtbGZpbGVSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvaHRtbGZpbGUnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgO1xuXG5mdW5jdGlvbiBIdG1sRmlsZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgWEhSTG9jYWxPYmplY3QpO1xufVxuXG5pbmhlcml0cyhIdG1sRmlsZVRyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuSHRtbEZpbGVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgcmV0dXJuIEh0bWxmaWxlUmVjZWl2ZXIuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW47XG59O1xuXG5IdG1sRmlsZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2h0bWxmaWxlJztcbkh0bWxGaWxlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxGaWxlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIvaHRtbGZpbGVcIjo2MCxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjY3LFwiaW5oZXJpdHNcIjo4N31dLDUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JrIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZnJvbSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycyBoYXZlIGNhcGFiaWxpdGllcyB0byBjb21tdW5pY2F0ZSB3aXRoXG4vLyBjcm9zcyBkb21haW4gaWZyYW1lIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCB2ZXJzaW9uID0gcmVxdWlyZSgnLi4vdmVyc2lvbicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvaWZyYW1lJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvZXZlbnQnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp0cmFuc3BvcnQ6aWZyYW1lJyk7XG59XG5cbmZ1bmN0aW9uIElmcmFtZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKSB7XG4gIGlmICghSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5vcmlnaW4gPSB1cmxVdGlscy5nZXRPcmlnaW4oYmFzZVVybCk7XG4gIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gIHRoaXMudHJhbnNVcmwgPSB0cmFuc1VybDtcbiAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRoaXMud2luZG93SWQgPSByYW5kb20uc3RyaW5nKDgpO1xuXG4gIHZhciBpZnJhbWVVcmwgPSB1cmxVdGlscy5hZGRQYXRoKGJhc2VVcmwsICcvaWZyYW1lLmh0bWwnKSArICcjJyArIHRoaXMud2luZG93SWQ7XG4gIGRlYnVnKHRyYW5zcG9ydCwgdHJhbnNVcmwsIGlmcmFtZVVybCk7XG5cbiAgdGhpcy5pZnJhbWVPYmogPSBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lVXJsLCBmdW5jdGlvbihyKSB7XG4gICAgZGVidWcoJ2VyciBjYWxsYmFjaycpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lICgnICsgciArICcpJyk7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcblxuICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5fbWVzc2FnZS5iaW5kKHRoaXMpO1xuICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayk7XG59XG5cbmluaGVyaXRzKElmcmFtZVRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgZXZlbnRVdGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xuICAgIHRyeSB7XG4gICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgdGhpcy5wb3N0TWVzc2FnZSgnYycpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrID0gdGhpcy5pZnJhbWVPYmogPSBudWxsO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLl9tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICBkZWJ1ZygnbWVzc2FnZScsIGUuZGF0YSk7XG4gIGlmICghdXJsVXRpbHMuaXNPcmlnaW5FcXVhbChlLm9yaWdpbiwgdGhpcy5vcmlnaW4pKSB7XG4gICAgZGVidWcoJ25vdCBzYW1lIG9yaWdpbicsIGUub3JpZ2luLCB0aGlzLm9yaWdpbik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGlmcmFtZU1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgaWZyYW1lTWVzc2FnZSA9IEpTT04zLnBhcnNlKGUuZGF0YSk7XG4gIH0gY2F0Y2ggKGlnbm9yZWQpIHtcbiAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSB0aGlzLndpbmRvd0lkKSB7XG4gICAgZGVidWcoJ21pc21hdGNoZWQgd2luZG93IGlkJywgaWZyYW1lTWVzc2FnZS53aW5kb3dJZCwgdGhpcy53aW5kb3dJZCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgY2FzZSAncyc6XG4gICAgdGhpcy5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgLy8gd2luZG93IGdsb2JhbCBkZXBlbmRlbmN5XG4gICAgdGhpcy5wb3N0TWVzc2FnZSgncycsIEpTT04zLnN0cmluZ2lmeShbXG4gICAgICB2ZXJzaW9uXG4gICAgLCB0aGlzLnRyYW5zcG9ydFxuICAgICwgdGhpcy50cmFuc1VybFxuICAgICwgdGhpcy5iYXNlVXJsXG4gICAgXSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0JzpcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgIGJyZWFrO1xuICBjYXNlICdjJzpcbiAgICB2YXIgY2RhdGE7XG4gICAgdHJ5IHtcbiAgICAgIGNkYXRhID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICBkZWJ1ZygnYmFkIGpzb24nLCBpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgY2RhdGFbMF0sIGNkYXRhWzFdKTtcbiAgICB0aGlzLmNsb3NlKCk7XG4gICAgYnJlYWs7XG4gIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gIGRlYnVnKCdwb3N0TWVzc2FnZScsIHR5cGUsIGRhdGEpO1xuICB0aGlzLmlmcmFtZU9iai5wb3N0KEpTT04zLnN0cmluZ2lmeSh7XG4gICAgd2luZG93SWQ6IHRoaXMud2luZG93SWRcbiAgLCB0eXBlOiB0eXBlXG4gICwgZGF0YTogZGF0YSB8fCAnJ1xuICB9KSwgdGhpcy5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICBkZWJ1Zygnc2VuZCcsIG1lc3NhZ2UpO1xuICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZSc7XG5JZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gSWZyYW1lVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo3NixcIi4uL3V0aWxzL2lmcmFtZVwiOjc3LFwiLi4vdXRpbHMvcmFuZG9tXCI6ODAsXCIuLi91dGlscy91cmxcIjo4MixcIi4uL3ZlcnNpb25cIjo4MyxcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3LFwianNvbjNcIjo4OH1dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtZXNzYWdlIGNvdWxkIHVzZSB1cCB0byBvbmUgaHR0cCByZXF1ZXN0LiBCdXQgYXQgbGVhc3QgaXQgd29ya3MgYWxtb3N0XG4vLyBldmVyeXdoZXJlLlxuLy8gS25vd24gbGltaXRhdGlvbnM6XG4vLyAgIG8geW91IHdpbGwgZ2V0IGEgc3Bpbm5pbmcgY3Vyc29yXG4vLyAgIG8gZm9yIEtvbnF1ZXJvciBhIGR1bWIgdGltZXIgaXMgbmVlZGVkIHRvIGRldGVjdCBlcnJvcnNcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyLXJlY2VpdmVyJylcbiAgLCBKc29ucFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9qc29ucCcpXG4gICwganNvbnBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlci9qc29ucCcpXG4gIDtcblxuZnVuY3Rpb24gSnNvblBUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFKc29uUFRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL2pzb25wJywganNvbnBTZW5kZXIsIEpzb25wUmVjZWl2ZXIpO1xufVxuXG5pbmhlcml0cyhKc29uUFRyYW5zcG9ydCwgU2VuZGVyUmVjZWl2ZXIpO1xuXG5Kc29uUFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiAhIWdsb2JhbC5kb2N1bWVudDtcbn07XG5cbkpzb25QVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAnanNvbnAtcG9sbGluZyc7XG5Kc29uUFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMTtcbkpzb25QVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29uUFRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vbGliL3NlbmRlci1yZWNlaXZlclwiOjU4LFwiLi9yZWNlaXZlci9qc29ucFwiOjYxLFwiLi9zZW5kZXIvanNvbnBcIjo2MyxcImluaGVyaXRzXCI6ODd9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIFNlbmRlclJlY2VpdmVyID0gcmVxdWlyZSgnLi9zZW5kZXItcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YWpheC1iYXNlZCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBamF4U2VuZGVyKEFqYXhPYmplY3QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnY3JlYXRlIGFqYXggc2VuZGVyJywgdXJsLCBwYXlsb2FkKTtcbiAgICB2YXIgb3B0ID0ge307XG4gICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0LmhlYWRlcnMgPSB7J0NvbnRlbnQtdHlwZSc6J3RleHQvcGxhaW4nfTtcbiAgICB9XG4gICAgdmFyIGFqYXhVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHVybCwgJy94aHJfc2VuZCcpO1xuICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgYWpheFVybCwgcGF5bG9hZCwgb3B0KTtcbiAgICB4by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICBpZiAoc3RhdHVzICE9PSAyMDAgJiYgc3RhdHVzICE9PSAyMDQpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignaHR0cCBzdGF0dXMgJyArIHN0YXR1cykpO1xuICAgICAgfVxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnYWJvcnQnKTtcbiAgICAgIHhvLmNsb3NlKCk7XG4gICAgICB4byA9IG51bGw7XG5cbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ0Fib3J0ZWQnKTtcbiAgICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gQWpheEJhc2VkVHJhbnNwb3J0KHRyYW5zVXJsLCB1cmxTdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIFNlbmRlclJlY2VpdmVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHVybFN1ZmZpeCwgY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSwgUmVjZWl2ZXIsIEFqYXhPYmplY3QpO1xufVxuXG5pbmhlcml0cyhBamF4QmFzZWRUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBBamF4QmFzZWRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuLi8uLi91dGlscy91cmxcIjo4MixcIi4vc2VuZGVyLXJlY2VpdmVyXCI6NTgsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImluaGVyaXRzXCI6ODd9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpidWZmZXJlZC1zZW5kZXInKTtcbn1cblxuZnVuY3Rpb24gQnVmZmVyZWRTZW5kZXIodXJsLCBzZW5kZXIpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgdGhpcy51cmwgPSB1cmw7XG59XG5cbmluaGVyaXRzKEJ1ZmZlcmVkU2VuZGVyLCBFdmVudEVtaXR0ZXIpO1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5zZW5kQnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gIGlmICghdGhpcy5zZW5kU3RvcCkge1xuICAgIHRoaXMuc2VuZFNjaGVkdWxlKCk7XG4gIH1cbn07XG5cbi8vIEZvciBwb2xsaW5nIHRyYW5zcG9ydHMgaW4gYSBzaXR1YXRpb24gd2hlbiBpbiB0aGUgbWVzc2FnZSBjYWxsYmFjayxcbi8vIG5ldyBtZXNzYWdlIGlzIGJlaW5nIHNlbmQuIElmIHRoZSBzZW5kaW5nIGNvbm5lY3Rpb24gd2FzIHN0YXJ0ZWRcbi8vIGJlZm9yZSByZWNlaXZpbmcgb25lLCBpdCBpcyBwb3NzaWJsZSB0byBzYXR1cmF0ZSB0aGUgbmV0d29yayBhbmRcbi8vIHRpbWVvdXQgZHVlIHRvIHRoZSBsYWNrIG9mIHJlY2VpdmluZyBzb2NrZXQuIFRvIGF2b2lkIHRoYXQgd2UgZGVsYXlcbi8vIHNlbmRpbmcgbWVzc2FnZXMgYnkgc29tZSBzbWFsbCB0aW1lLCBpbiBvcmRlciB0byBsZXQgcmVjZWl2aW5nXG4vLyBjb25uZWN0aW9uIGJlIHN0YXJ0ZWQgYmVmb3JlaGFuZC4gVGhpcyBpcyBvbmx5IGEgaGFsZm1lYXN1cmUgYW5kXG4vLyBkb2VzIG5vdCBmaXggdGhlIGJpZyBwcm9ibGVtLCBidXQgaXQgZG9lcyBtYWtlIHRoZSB0ZXN0cyBnbyBtb3JlXG4vLyBzdGFibGUgb24gc2xvdyBuZXR3b3Jrcy5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGVXYWl0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzZW5kU2NoZWR1bGVXYWl0Jyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHRyZWY7XG4gIHRoaXMuc2VuZFN0b3AgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnc2VuZFN0b3AnKTtcbiAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gIH07XG4gIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgc2VsZi5zZW5kU2NoZWR1bGUoKTtcbiAgfSwgMjUpO1xufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRTY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlJywgdGhpcy5zZW5kQnVmZmVyLmxlbmd0aCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGlzLnNlbmRCdWZmZXIuam9pbignLCcpICsgJ10nO1xuICAgIHRoaXMuc2VuZFN0b3AgPSB0aGlzLnNlbmRlcih0aGlzLnVybCwgcGF5bG9hZCwgZnVuY3Rpb24oZXJyKSB7XG4gICAgICBzZWxmLnNlbmRTdG9wID0gbnVsbDtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgZGVidWcoJ2Vycm9yJywgZXJyKTtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGVyci5jb2RlIHx8IDEwMDYsICdTZW5kaW5nIGVycm9yOiAnICsgZXJyKTtcbiAgICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5zZW5kU2NoZWR1bGVXYWl0KCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5zZW5kQnVmZmVyID0gW107XG4gIH1cbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdzdG9wJyk7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgaWYgKHRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTdG9wKCk7XG4gICAgdGhpcy5zZW5kU3RvcCA9IG51bGw7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQnVmZmVyZWRTZW5kZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIElmcmFtZVRyYW5zcG9ydCA9IHJlcXVpcmUoJy4uL2lmcmFtZScpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9vYmplY3QnKVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cbiAgZnVuY3Rpb24gSWZyYW1lV3JhcFRyYW5zcG9ydCh0cmFuc1VybCwgYmFzZVVybCkge1xuICAgIElmcmFtZVRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lLCB0cmFuc1VybCwgYmFzZVVybCk7XG4gIH1cblxuICBpbmhlcml0cyhJZnJhbWVXcmFwVHJhbnNwb3J0LCBJZnJhbWVUcmFuc3BvcnQpO1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKHVybCwgaW5mbykge1xuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGlmcmFtZUluZm8gPSBvYmplY3RVdGlscy5leHRlbmQoe30sIGluZm8pO1xuICAgIGlmcmFtZUluZm8uc2FtZU9yaWdpbiA9IHRydWU7XG4gICAgcmV0dXJuIHRyYW5zcG9ydC5lbmFibGVkKGlmcmFtZUluZm8pICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG4gIH07XG5cbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2lmcmFtZS0nICsgdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gIElmcmFtZVdyYXBUcmFuc3BvcnQubmVlZEJvZHkgPSB0cnVlO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSBJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyArIHRyYW5zcG9ydC5yb3VuZFRyaXBzIC0gMTsgLy8gaHRtbCwgamF2YXNjcmlwdCAoMikgKyB0cmFuc3BvcnQgLSBubyBDT1JTICgxKVxuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQuZmFjYWRlVHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gIHJldHVybiBJZnJhbWVXcmFwVHJhbnNwb3J0O1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL3V0aWxzL29iamVjdFwiOjc5LFwiLi4vaWZyYW1lXCI6NTIsXCJpbmhlcml0c1wiOjg3fV0sNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cG9sbGluZycpO1xufVxuXG5mdW5jdGlvbiBQb2xsaW5nKFJlY2VpdmVyLCByZWNlaXZlVXJsLCBBamF4T2JqZWN0KSB7XG4gIGRlYnVnKHJlY2VpdmVVcmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdGhpcy5SZWNlaXZlciA9IFJlY2VpdmVyO1xuICB0aGlzLnJlY2VpdmVVcmwgPSByZWNlaXZlVXJsO1xuICB0aGlzLkFqYXhPYmplY3QgPSBBamF4T2JqZWN0O1xuICB0aGlzLl9zY2hlZHVsZVJlY2VpdmVyKCk7XG59XG5cbmluaGVyaXRzKFBvbGxpbmcsIEV2ZW50RW1pdHRlcik7XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY2VpdmVyID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NoZWR1bGVSZWNlaXZlcicpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBwb2xsID0gdGhpcy5wb2xsID0gbmV3IHRoaXMuUmVjZWl2ZXIodGhpcy5yZWNlaXZlVXJsLCB0aGlzLkFqYXhPYmplY3QpO1xuXG4gIHBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG5cbiAgcG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdjbG9zZScsIGNvZGUsIHJlYXNvbiwgc2VsZi5wb2xsSXNDbG9zaW5nKTtcbiAgICBzZWxmLnBvbGwgPSBwb2xsID0gbnVsbDtcblxuICAgIGlmICghc2VsZi5wb2xsSXNDbG9zaW5nKSB7XG4gICAgICBpZiAocmVhc29uID09PSAnbmV0d29yaycpIHtcbiAgICAgICAgc2VsZi5fc2NoZWR1bGVSZWNlaXZlcigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUgfHwgMTAwNiwgcmVhc29uKTtcbiAgICAgICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIHRoaXMucG9sbElzQ2xvc2luZyA9IHRydWU7XG4gIGlmICh0aGlzLnBvbGwpIHtcbiAgICB0aGlzLnBvbGwuYWJvcnQoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBQb2xsaW5nO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw1ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEJ1ZmZlcmVkU2VuZGVyID0gcmVxdWlyZSgnLi9idWZmZXJlZC1zZW5kZXInKVxuICAsIFBvbGxpbmcgPSByZXF1aXJlKCcuL3BvbGxpbmcnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyLXJlY2VpdmVyJyk7XG59XG5cbmZ1bmN0aW9uIFNlbmRlclJlY2VpdmVyKHRyYW5zVXJsLCB1cmxTdWZmaXgsIHNlbmRlckZ1bmMsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gIHZhciBwb2xsVXJsID0gdXJsVXRpbHMuYWRkUGF0aCh0cmFuc1VybCwgdXJsU3VmZml4KTtcbiAgZGVidWcocG9sbFVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgQnVmZmVyZWRTZW5kZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgc2VuZGVyRnVuYyk7XG5cbiAgdGhpcy5wb2xsID0gbmV3IFBvbGxpbmcoUmVjZWl2ZXIsIHBvbGxVcmwsIEFqYXhPYmplY3QpO1xuICB0aGlzLnBvbGwub24oJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICBkZWJ1ZygncG9sbCBtZXNzYWdlJywgbXNnKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICB9KTtcbiAgdGhpcy5wb2xsLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgZGVidWcoJ3BvbGwgY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYucG9sbCA9IG51bGw7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGNvZGUsIHJlYXNvbik7XG4gICAgc2VsZi5jbG9zZSgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoU2VuZGVyUmVjZWl2ZXIsIEJ1ZmZlcmVkU2VuZGVyKTtcblxuU2VuZGVyUmVjZWl2ZXIucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gICAgdGhpcy5wb2xsID0gbnVsbDtcbiAgfVxuICB0aGlzLnN0b3AoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuLi8uLi91dGlscy91cmxcIjo4MixcIi4vYnVmZmVyZWQtc2VuZGVyXCI6NTUsXCIuL3BvbGxpbmdcIjo1NyxcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiaW5oZXJpdHNcIjo4N31dLDU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmV2ZW50c291cmNlJyk7XG59XG5cbmZ1bmN0aW9uIEV2ZW50U291cmNlUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIGVzID0gdGhpcy5lcyA9IG5ldyBFdmVudFNvdXJjZURyaXZlcih1cmwpO1xuICBlcy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRlY29kZVVSSShlLmRhdGEpKTtcbiAgfTtcbiAgZXMub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnZXJyb3InLCBlcy5yZWFkeVN0YXRlLCBlKTtcbiAgICAvLyBFUyBvbiByZWNvbm5lY3Rpb24gaGFzIHJlYWR5U3RhdGUgPSAwIG9yIDEuXG4gICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICB2YXIgcmVhc29uID0gKGVzLnJlYWR5U3RhdGUgIT09IDIgPyAnbmV0d29yaycgOiAncGVybWFuZW50Jyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKHJlYXNvbik7XG4gIH07XG59XG5cbmluaGVyaXRzKEV2ZW50U291cmNlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xlYW51cCcpO1xuICB2YXIgZXMgPSB0aGlzLmVzO1xuICBpZiAoZXMpIHtcbiAgICBlcy5vbm1lc3NhZ2UgPSBlcy5vbmVycm9yID0gbnVsbDtcbiAgICBlcy5jbG9zZSgpO1xuICAgIHRoaXMuZXMgPSBudWxsO1xuICB9XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xvc2UgPSBmdW5jdGlvbihyZWFzb24pIHtcbiAgZGVidWcoJ2Nsb3NlJywgcmVhc29uKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgICBzZWxmLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB9LCAyMDApO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudFNvdXJjZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImV2ZW50c291cmNlXCI6NDgsXCJpbmhlcml0c1wiOjg3fV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpodG1sZmlsZScpO1xufVxuXG5mdW5jdGlvbiBIdG1sZmlsZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZnJhbWVVdGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ2M9JyArIGRlY29kZVVSSUNvbXBvbmVudChpZnJhbWVVdGlscy5XUHJlZml4ICsgJy4nICsgdGhpcy5pZCkpO1xuXG4gIGRlYnVnKCd1c2luZyBodG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkKTtcbiAgdmFyIGNvbnN0cnVjdEZ1bmMgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA/XG4gICAgICBpZnJhbWVVdGlscy5jcmVhdGVIdG1sZmlsZSA6IGlmcmFtZVV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICBnbG9iYWxbaWZyYW1lVXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB7XG4gICAgc3RhcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3N0YXJ0Jyk7XG4gICAgICBzZWxmLmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICB9XG4gICwgbWVzc2FnZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGRhdGEpO1xuICAgIH1cbiAgLCBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdG9wJyk7XG4gICAgICBzZWxmLl9jbGVhbnVwKCk7XG4gICAgICBzZWxmLl9jbG9zZSgnbmV0d29yaycpO1xuICAgIH1cbiAgfTtcbiAgdGhpcy5pZnJhbWVPYmogPSBjb25zdHJ1Y3RGdW5jKHVybCwgZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2NhbGxiYWNrJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICAgIHNlbGYuX2Nsb3NlKCdwZXJtYW5lbnQnKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEh0bWxmaWxlUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIHRoaXMuX2Nsb3NlKCd1c2VyJyk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgaWYgKHRoaXMuaWZyYW1lT2JqKSB7XG4gICAgdGhpcy5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgIHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdfY2xvc2UnLCByZWFzb24pO1xuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgcmVhc29uKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIuaHRtbGZpbGVFbmFibGVkID0gZmFsc2U7XG5cbi8vIG9iZnVzY2F0ZSB0byBhdm9pZCBmaXJld2FsbHNcbnZhciBheG8gPSBbJ0FjdGl2ZSddLmNvbmNhdCgnT2JqZWN0Jykuam9pbignWCcpO1xuaWYgKGF4byBpbiBnbG9iYWwpIHtcbiAgdHJ5IHtcbiAgICBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9ICEhbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICB9IGNhdGNoICh4KSB7fVxufVxuXG5IdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgPSBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCB8fCBpZnJhbWVVdGlscy5pZnJhbWVFbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEh0bWxmaWxlUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjc3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6ODAsXCIuLi8uLi91dGlscy91cmxcIjo4MixcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3fV0sNjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2lmcmFtZScpXG4gICwgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6anNvbnAnKTtcbn1cblxuZnVuY3Rpb24gSnNvbnBSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgdGhpcy5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoNik7XG4gIHZhciB1cmxXaXRoSWQgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBlbmNvZGVVUklDb21wb25lbnQodXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0gPSB0aGlzLl9jYWxsYmFjay5iaW5kKHRoaXMpO1xuICB0aGlzLl9jcmVhdGVTY3JpcHQodXJsV2l0aElkKTtcblxuICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gIHRoaXMudGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KScpKTtcbiAgfSwgSnNvbnBSZWNlaXZlci50aW1lb3V0KTtcbn1cblxuaW5oZXJpdHMoSnNvbnBSZWNlaXZlciwgRXZlbnRFbWl0dGVyKTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmIChnbG9iYWxbdXRpbHMuV1ByZWZpeF1bdGhpcy5pZF0pIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdKU09OUCB1c2VyIGFib3J0ZWQgcmVhZCcpO1xuICAgIGVyci5jb2RlID0gMTAwMDtcbiAgICB0aGlzLl9hYm9ydChlcnIpO1xuICB9XG59O1xuXG5Kc29ucFJlY2VpdmVyLnRpbWVvdXQgPSAzNTAwMDtcbkpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0ID0gMTAwMDtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICBkZWJ1ZygnX2NhbGxiYWNrJywgZGF0YSk7XG4gIHRoaXMuX2NsZWFudXAoKTtcblxuICBpZiAodGhpcy5hYm9ydGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChkYXRhKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgfVxuICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ25ldHdvcmsnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9hYm9ydCA9IGZ1bmN0aW9uKGVycikge1xuICBkZWJ1ZygnX2Fib3J0JywgZXJyKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLmFib3J0aW5nID0gdHJ1ZTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIGVyci5jb2RlLCBlcnIubWVzc2FnZSk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX2NsZWFudXAnKTtcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZW91dElkKTtcbiAgaWYgKHRoaXMuc2NyaXB0Mikge1xuICAgIHRoaXMuc2NyaXB0Mi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuc2NyaXB0Mik7XG4gICAgdGhpcy5zY3JpcHQyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5zY3JpcHQpIHtcbiAgICB2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgeW91IGNhbid0IHJlYWxseSBhYm9ydCBzY3JpcHQgbG9hZGluZyBvZlxuICAgIC8vIHRoZSBzY3JpcHQuXG4gICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgIHRoaXMuc2NyaXB0ID0gbnVsbDtcbiAgfVxuICBkZWxldGUgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX3NjcmlwdEVycm9yID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfc2NyaXB0RXJyb3InKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBpZiAodGhpcy5lcnJvclRpbWVyKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpcy5lcnJvclRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBpZiAoIXNlbGYubG9hZGVkT2theSkge1xuICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9uZXJyb3IpJykpO1xuICAgIH1cbiAgfSwgSnNvbnBSZWNlaXZlci5zY3JpcHRFcnJvclRpbWVvdXQpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NyZWF0ZVNjcmlwdCA9IGZ1bmN0aW9uKHVybCkge1xuICBkZWJ1ZygnX2NyZWF0ZVNjcmlwdCcsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0ID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG5cbiAgc2NyaXB0LmlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgc2NyaXB0LnNyYyA9IHVybDtcbiAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgc2NyaXB0LmNoYXJzZXQgPSAnVVRGLTgnO1xuICBzY3JpcHQub25lcnJvciA9IHRoaXMuX3NjcmlwdEVycm9yLmJpbmQodGhpcyk7XG4gIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ubG9hZCknKSk7XG4gIH07XG5cbiAgLy8gSUU5IGZpcmVzICdlcnJvcicgZXZlbnQgYWZ0ZXIgb25yZWFkeXN0YXRlY2hhbmdlIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAvLyBVc2UgbG9hZGVkT2theSB0byBkZXRlcm1pbmUgaWYgYWN0dWFsbHkgZXJyb3JlZFxuICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ucmVhZHlzdGF0ZWNoYW5nZScsIHNjcmlwdC5yZWFkeVN0YXRlKTtcbiAgICBpZiAoL2xvYWRlZHxjbG9zZWQvLnRlc3Qoc2NyaXB0LnJlYWR5U3RhdGUpKSB7XG4gICAgICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5odG1sRm9yICYmIHNjcmlwdC5vbmNsaWNrKSB7XG4gICAgICAgIHNlbGYubG9hZGVkT2theSA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgfVxuICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25yZWFkeXN0YXRlY2hhbmdlKScpKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIC8vIElFOiBldmVudC9odG1sRm9yL29uY2xpY2sgdHJpY2suXG4gIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gIC8vIHNjcmlwdCBjb2RlIHdpbGwgYmUgaW5zdGFsbGVkIGFzICdvbmNsaWNrJyBoYW5kbGVyIGZvciB0aGVcbiAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gIC8vIHNldC4gRm9yIHJlZmVyZW5jZSBzZWU6XG4gIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gIC8vICAgaHR0cDovL3dpa2kud2hhdHdnLm9yZy93aWtpL0R5bmFtaWNfU2NyaXB0X0V4ZWN1dGlvbl9PcmRlclxuICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmRvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgLy8gQWNjb3JkaW5nIHRvIG1vemlsbGEgZG9jcywgaW4gcmVjZW50IGJyb3dzZXJzIHNjcmlwdC5hc3luYyBkZWZhdWx0c1xuICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgIGlmICghYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICB0cnkge1xuICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgc2NyaXB0LmV2ZW50ID0gJ29uY2xpY2snO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE9wZXJhLCBzZWNvbmQgc3luYyBzY3JpcHQgaGFja1xuICAgICAgc2NyaXB0MiA9IHRoaXMuc2NyaXB0MiA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHNjcmlwdDIudGV4dCA9IFwidHJ5e3ZhciBhID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ1wiICsgc2NyaXB0LmlkICsgXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgfVxuXG4gIHZhciBoZWFkID0gZ2xvYmFsLmRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdCwgaGVhZC5maXJzdENoaWxkKTtcbiAgaWYgKHNjcmlwdDIpIHtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQyLCBoZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEpzb25wUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL3V0aWxzL2Jyb3dzZXJcIjo3NCxcIi4uLy4uL3V0aWxzL2lmcmFtZVwiOjc3LFwiLi4vLi4vdXRpbHMvcmFuZG9tXCI6ODAsXCIuLi8uLi91dGlscy91cmxcIjo4MixcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3fV0sNjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6eGhyJyk7XG59XG5cbmZ1bmN0aW9uIFhoclJlY2VpdmVyKHVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIHRoaXMuYnVmZmVyUG9zaXRpb24gPSAwO1xuXG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gIHRoaXMueG8ub24oJ2NodW5rJywgdGhpcy5fY2h1bmtIYW5kbGVyLmJpbmQodGhpcykpO1xuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIGRlYnVnKCdmaW5pc2gnLCBzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYuX2NodW5rSGFuZGxlcihzdGF0dXMsIHRleHQpO1xuICAgIHNlbGYueG8gPSBudWxsO1xuICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9KTtcbn1cblxuaW5oZXJpdHMoWGhyUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5fY2h1bmtIYW5kbGVyID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gIGRlYnVnKCdfY2h1bmtIYW5kbGVyJywgc3RhdHVzKTtcbiAgaWYgKHN0YXR1cyAhPT0gMjAwIHx8ICF0ZXh0KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgZm9yICh2YXIgaWR4ID0gLTE7IDsgdGhpcy5idWZmZXJQb3NpdGlvbiArPSBpZHggKyAxKSB7XG4gICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UodGhpcy5idWZmZXJQb3NpdGlvbik7XG4gICAgaWR4ID0gYnVmLmluZGV4T2YoJ1xcbicpO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIG1zZyA9IGJ1Zi5zbGljZSgwLCBpZHgpO1xuICAgIGlmIChtc2cpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gICAgfVxuICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Fib3J0Jyk7XG4gIGlmICh0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICAgIGRlYnVnKCdjbG9zZScpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnLCBudWxsLCAndXNlcicpO1xuICAgIHRoaXMueG8gPSBudWxsO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gWGhyUmVjZWl2ZXI7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDYzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvcmFuZG9tJylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpzZW5kZXI6anNvbnAnKTtcbn1cblxudmFyIGZvcm0sIGFyZWE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUlmcmFtZShpZCkge1xuICBkZWJ1ZygnY3JlYXRlSWZyYW1lJywgaWQpO1xuICB0cnkge1xuICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgIHJldHVybiBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJyArIGlkICsgJ1wiPicpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIHJldHVybiBpZnJhbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9ybSgpIHtcbiAgZGVidWcoJ2NyZWF0ZUZvcm0nKTtcbiAgZm9ybSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gJ1VURi04JztcblxuICBhcmVhID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gIGFyZWEubmFtZSA9ICdkJztcbiAgZm9ybS5hcHBlbmRDaGlsZChhcmVhKTtcblxuICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gIGRlYnVnKHVybCwgcGF5bG9hZCk7XG4gIGlmICghZm9ybSkge1xuICAgIGNyZWF0ZUZvcm0oKTtcbiAgfVxuICB2YXIgaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDgpO1xuICBmb3JtLnRhcmdldCA9IGlkO1xuICBmb3JtLmFjdGlvbiA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybFV0aWxzLmFkZFBhdGgodXJsLCAnL2pzb25wX3NlbmQnKSwgJ2k9JyArIGlkKTtcblxuICB2YXIgaWZyYW1lID0gY3JlYXRlSWZyYW1lKGlkKTtcbiAgaWZyYW1lLmlkID0gaWQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgdHJ5IHtcbiAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIHNlcmlvdXNseSBicm9rZW4gYnJvd3NlcnMgZ2V0IGhlcmVcbiAgfVxuICBmb3JtLnN1Ym1pdCgpO1xuXG4gIHZhciBjb21wbGV0ZWQgPSBmdW5jdGlvbihlcnIpIHtcbiAgICBkZWJ1ZygnY29tcGxldGVkJywgaWQsIGVycik7XG4gICAgaWYgKCFpZnJhbWUub25lcnJvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAvLyBpbW1lZGlhdGVseSwgdGh1cyB0aGlzIHRpbWVvdXQuXG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbmluZyB1cCcsIGlkKTtcbiAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICBpZnJhbWUgPSBudWxsO1xuICAgIH0sIDUwMCk7XG4gICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgIC8vIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBkZXRlY3QgaWYgdGhlIGlmcmFtZSBzdWNjZWVkZWQgb3JcbiAgICAvLyBmYWlsZWQgdG8gc3VibWl0IG91ciBmb3JtLlxuICAgIGNhbGxiYWNrKGVycik7XG4gIH07XG4gIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBpZCk7XG4gICAgY29tcGxldGVkKCk7XG4gIH07XG4gIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1Zygnb25sb2FkJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBpZCwgaWZyYW1lLnJlYWR5U3RhdGUsIGUpO1xuICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgY29tcGxldGVkKCk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2Fib3J0ZWQnLCBpZCk7XG4gICAgY29tcGxldGVkKG5ldyBFcnJvcignQWJvcnRlZCcpKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjgwLFwiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NH1dLDY0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvYnJvd3NlcicpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOnhkcicpO1xufVxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG5cbmZ1bmN0aW9uIFhEUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLl9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhYRFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX3N0YXJ0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcoJ19zdGFydCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB4ZHIgPSBuZXcgZ2xvYmFsLlhEb21haW5SZXF1ZXN0KCk7XG4gIC8vIElFIGNhY2hlcyBldmVuIFBPU1RzXG4gIHVybCA9IHVybFV0aWxzLmFkZFF1ZXJ5KHVybCwgJ3Q9JyArICgrbmV3IERhdGUoKSkpO1xuXG4gIHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29uZXJyb3InKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29udGltZW91dCcpO1xuICAgIHNlbGYuX2Vycm9yKCk7XG4gIH07XG4gIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3Byb2dyZXNzJywgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gIH07XG4gIHhkci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygnbG9hZCcpO1xuICAgIHNlbGYuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICBzZWxmLl9jbGVhbnVwKGZhbHNlKTtcbiAgfTtcbiAgdGhpcy54ZHIgPSB4ZHI7XG4gIHRoaXMudW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgfSk7XG4gIHRyeSB7XG4gICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICB0aGlzLnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICBpZiAodGhpcy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnhkci50aW1lb3V0ID0gdGhpcy50aW1lb3V0O1xuICAgIH1cbiAgICB0aGlzLnhkci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoICh4KSB7XG4gICAgdGhpcy5fZXJyb3IoKTtcbiAgfVxufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJywgYWJvcnQpO1xuICBpZiAoIXRoaXMueGRyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGV2ZW50VXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICB0aGlzLnhkci5vbnRpbWVvdXQgPSB0aGlzLnhkci5vbmVycm9yID0gdGhpcy54ZHIub25wcm9ncmVzcyA9IHRoaXMueGRyLm9ubG9hZCA9IG51bGw7XG4gIGlmIChhYm9ydCkge1xuICAgIHRyeSB7XG4gICAgICB0aGlzLnhkci5hYm9ydCgpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH1cbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLnhkciA9IG51bGw7XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gSUUgOC85IGlmIHRoZSByZXF1ZXN0IHRhcmdldCB1c2VzIHRoZSBzYW1lIHNjaGVtZSAtICM3OVxuWERST2JqZWN0LmVuYWJsZWQgPSAhIShnbG9iYWwuWERvbWFpblJlcXVlc3QgJiYgYnJvd3Nlci5oYXNEb21haW4oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gWERST2JqZWN0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NzQsXCIuLi8uLi91dGlscy9ldmVudFwiOjc2LFwiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIFhockRyaXZlciA9IHJlcXVpcmUoJy4uL2RyaXZlci94aHInKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkNvcnNPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xufVxuXG5pbmhlcml0cyhYSFJDb3JzT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJDb3JzT2JqZWN0LmVuYWJsZWQgPSBYaHJEcml2ZXIuZW5hYmxlZCAmJiBYaHJEcml2ZXIuc3VwcG9ydHNDT1JTO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkNvcnNPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjQ3LFwiaW5oZXJpdHNcIjo4N31dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICA7XG5cbmZ1bmN0aW9uIFhIUkZha2UoLyogbWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMgKi8pIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB0aGlzLnRvID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgJ3t9Jyk7XG4gIH0sIFhIUkZha2UudGltZW91dCk7XG59XG5cbmluaGVyaXRzKFhIUkZha2UsIEV2ZW50RW1pdHRlcik7XG5cblhIUkZha2UucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRvKTtcbn07XG5cblhIUkZha2UudGltZW91dCA9IDIwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSRmFrZTtcblxufSx7XCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw2NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJMb2NhbE9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCAvKiwgb3B0cyAqLykge1xuICBYaHJEcml2ZXIuY2FsbCh0aGlzLCBtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgIG5vQ3JlZGVudGlhbHM6IHRydWVcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhIUkxvY2FsT2JqZWN0LCBYaHJEcml2ZXIpO1xuXG5YSFJMb2NhbE9iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQ7XG5cbm1vZHVsZS5leHBvcnRzID0gWEhSTG9jYWxPYmplY3Q7XG5cbn0se1wiLi4vZHJpdmVyL3hoclwiOjQ3LFwiaW5oZXJpdHNcIjo4N31dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL3VybCcpXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgV2Vic29ja2V0RHJpdmVyID0gcmVxdWlyZSgnLi9kcml2ZXIvd2Vic29ja2V0JylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OndlYnNvY2tldCcpO1xufVxuXG5mdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFXZWJTb2NrZXRUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbiAgZGVidWcoJ2NvbnN0cnVjdG9yJywgdHJhbnNVcmwpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsICcvd2Vic29ja2V0Jyk7XG4gIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICB1cmwgPSAnd3NzJyArIHVybC5zbGljZSg1KTtcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnd3MnICsgdXJsLnNsaWNlKDQpO1xuICB9XG4gIHRoaXMudXJsID0gdXJsO1xuXG4gIHRoaXMud3MgPSBuZXcgV2Vic29ja2V0RHJpdmVyKHRoaXMudXJsKTtcbiAgdGhpcy53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UgZXZlbnQnLCBlLmRhdGEpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIGUuZGF0YSk7XG4gIH07XG4gIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAvLyBjcmVhdGVkIGFmdGVyIG9udW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAvLyBuYXZpZ2F0ZXMgYXdheSBmcm9tIHRoZSBwYWdlLiBJbiBzdWNoIHNpdHVhdGlvbiBsZXQncyBsaWUgLVxuICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTYwODVcbiAgdGhpcy51bmxvYWRSZWYgPSB1dGlscy51bmxvYWRBZGQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3VubG9hZCcpO1xuICAgIHNlbGYud3MuY2xvc2UoKTtcbiAgfSk7XG4gIHRoaXMud3Mub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1ZygnY2xvc2UgZXZlbnQnLCBlLmNvZGUsIGUucmVhc29uKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xuICB0aGlzLndzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yIGV2ZW50JywgZSk7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIDEwMDYsICdXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW4nKTtcbiAgICBzZWxmLl9jbGVhbnVwKCk7XG4gIH07XG59XG5cbmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgRXZlbnRFbWl0dGVyKTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgbXNnID0gJ1snICsgZGF0YSArICddJztcbiAgZGVidWcoJ3NlbmQnLCBtc2cpO1xuICB0aGlzLndzLnNlbmQobXNnKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIGlmICh0aGlzLndzKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG4gIHRoaXMuX2NsZWFudXAoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHZhciB3cyA9IHRoaXMud3M7XG4gIGlmICh3cykge1xuICAgIHdzLm9ubWVzc2FnZSA9IHdzLm9uY2xvc2UgPSB3cy5vbmVycm9yID0gbnVsbDtcbiAgfVxuICB1dGlscy51bmxvYWREZWwodGhpcy51bmxvYWRSZWYpO1xuICB0aGlzLnVubG9hZFJlZiA9IHRoaXMud3MgPSBudWxsO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2VuYWJsZWQnKTtcbiAgcmV0dXJuICEhV2Vic29ja2V0RHJpdmVyO1xufTtcbldlYlNvY2tldFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3dlYnNvY2tldCc7XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuLi91dGlscy9ldmVudFwiOjc2LFwiLi4vdXRpbHMvdXJsXCI6ODIsXCIuL2RyaXZlci93ZWJzb2NrZXRcIjo0OSxcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3fV0sNjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi94ZHItc3RyZWFtaW5nJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbmZ1bmN0aW9uIFhkclBvbGxpbmdUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFYRFJPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhkclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItcG9sbGluZyc7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYZHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIveGhyXCI6NjIsXCIuL3NlbmRlci94ZHJcIjo2NCxcIi4veGRyLXN0cmVhbWluZ1wiOjcwLFwiaW5oZXJpdHNcIjo4N31dLDcwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhoclJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci94aHInKVxuICAsIFhEUk9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hkcicpXG4gIDtcblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuZnVuY3Rpb24gWGRyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIFhEUk9iamVjdCk7XG59XG5cbmluaGVyaXRzKFhkclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLmNvb2tpZV9uZWVkZWQgfHwgaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiBYRFJPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVTY2hlbWU7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4ZHItc3RyZWFtaW5nJztcblhkclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIveGhyXCI6NjIsXCIuL3NlbmRlci94ZHJcIjo2NCxcImluaGVyaXRzXCI6ODd9XSw3MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgO1xuXG5mdW5jdGlvbiBYaHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIFhIUkNvcnNPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYaHJQb2xsaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiBpbmZvLnNhbWVPcmlnaW4pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ3hoci1wb2xsaW5nJztcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclBvbGxpbmdUcmFuc3BvcnQ7XG5cbn0se1wiLi9saWIvYWpheC1iYXNlZFwiOjU0LFwiLi9yZWNlaXZlci94aHJcIjo2MixcIi4vc2VuZGVyL3hoci1jb3JzXCI6NjUsXCIuL3NlbmRlci94aHItbG9jYWxcIjo2NyxcImluaGVyaXRzXCI6ODd9XSw3MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYSFJDb3JzT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsT2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGhyLWxvY2FsJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi4vdXRpbHMvYnJvd3NlcicpXG4gIDtcblxuZnVuY3Rpb24gWGhyU3RyZWFtaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWEhSTG9jYWxPYmplY3QuZW5hYmxlZCAmJiAhWEhSQ29yc09iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyU3RyZWFtaW5nVHJhbnNwb3J0LCBBamF4QmFzZWRUcmFuc3BvcnQpO1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKGluZm8pIHtcbiAgaWYgKGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBPcGVyYSBkb2Vzbid0IHN1cHBvcnQgeGhyLXN0cmVhbWluZyAjNjBcbiAgLy8gQnV0IGl0IG1pZ2h0IGJlIGFibGUgdG8gIzkyXG4gIGlmIChicm93c2VyLmlzT3BlcmEoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBYSFJDb3JzT2JqZWN0LmVuYWJsZWQ7XG59O1xuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItc3RyZWFtaW5nJztcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbi8vIFNhZmFyaSBnZXRzIGNvbmZ1c2VkIHdoZW4gYSBzdHJlYW1pbmcgYWpheCByZXF1ZXN0IGlzIHN0YXJ0ZWRcbi8vIGJlZm9yZSBvbmxvYWQuIFRoaXMgY2F1c2VzIHRoZSBsb2FkIGluZGljYXRvciB0byBzcGluIGluZGVmaW5ldGVseS5cbi8vIE9ubHkgcmVxdWlyZSBib2R5IHdoZW4gdXNlZCBpbiBhIGJyb3dzZXJcblhoclN0cmVhbWluZ1RyYW5zcG9ydC5uZWVkQm9keSA9ICEhZ2xvYmFsLmRvY3VtZW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4uL3V0aWxzL2Jyb3dzZXJcIjo3NCxcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIveGhyXCI6NjIsXCIuL3NlbmRlci94aHItY29yc1wiOjY1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6NjcsXCJpbmhlcml0c1wiOjg3fV0sNzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5pZiAoZ2xvYmFsLmNyeXB0byAmJiBnbG9iYWwuY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnl0ZXMpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzLnJhbmRvbUJ5dGVzID0gZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIGJ5dGVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXNbaV0gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAyNTYpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPcGVyYTogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5uYXZpZ2F0b3IgJiZcbiAgICAgIC9vcGVyYS9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiwgaXNLb25xdWVyb3I6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAva29ucXVlcm9yL2kudGVzdChnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gIH1cblxuICAvLyAjMTg3IHdyYXAgZG9jdW1lbnQuZG9tYWluIGluIHRyeS9jYXRjaCBiZWNhdXNlIG9mIFdQOCBmcm9tIGZpbGU6Ly8vXG4sIGhhc0RvbWFpbjogZnVuY3Rpb24gKCkge1xuICAgIC8vIG5vbi1icm93c2VyIGNsaWVudCBhbHdheXMgaGFzIGEgZG9tYWluXG4gICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQuZG9tYWluO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpO1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxudmFyIGV4dHJhRXNjYXBhYmxlID0gL1tcXHgwMC1cXHgxZlxcdWQ4MDAtXFx1ZGZmZlxcdWZmZmVcXHVmZmZmXFx1MDMwMC1cXHUwMzMzXFx1MDMzZC1cXHUwMzQ2XFx1MDM0YS1cXHUwMzRjXFx1MDM1MC1cXHUwMzUyXFx1MDM1Ny1cXHUwMzU4XFx1MDM1Yy1cXHUwMzYyXFx1MDM3NFxcdTAzN2VcXHUwMzg3XFx1MDU5MS1cXHUwNWFmXFx1MDVjNFxcdTA2MTAtXFx1MDYxN1xcdTA2NTMtXFx1MDY1NFxcdTA2NTctXFx1MDY1YlxcdTA2NWQtXFx1MDY1ZVxcdTA2ZGYtXFx1MDZlMlxcdTA2ZWItXFx1MDZlY1xcdTA3MzBcXHUwNzMyLVxcdTA3MzNcXHUwNzM1LVxcdTA3MzZcXHUwNzNhXFx1MDczZFxcdTA3M2YtXFx1MDc0MVxcdTA3NDNcXHUwNzQ1XFx1MDc0N1xcdTA3ZWItXFx1MDdmMVxcdTA5NTFcXHUwOTU4LVxcdTA5NWZcXHUwOWRjLVxcdTA5ZGRcXHUwOWRmXFx1MGEzM1xcdTBhMzZcXHUwYTU5LVxcdTBhNWJcXHUwYTVlXFx1MGI1Yy1cXHUwYjVkXFx1MGUzOC1cXHUwZTM5XFx1MGY0M1xcdTBmNGRcXHUwZjUyXFx1MGY1N1xcdTBmNWNcXHUwZjY5XFx1MGY3Mi1cXHUwZjc2XFx1MGY3OFxcdTBmODAtXFx1MGY4M1xcdTBmOTNcXHUwZjlkXFx1MGZhMlxcdTBmYTdcXHUwZmFjXFx1MGZiOVxcdTE5MzktXFx1MTkzYVxcdTFhMTdcXHUxYjZiXFx1MWNkYS1cXHUxY2RiXFx1MWRjMC1cXHUxZGNmXFx1MWRmY1xcdTFkZmVcXHUxZjcxXFx1MWY3M1xcdTFmNzVcXHUxZjc3XFx1MWY3OVxcdTFmN2JcXHUxZjdkXFx1MWZiYlxcdTFmYmVcXHUxZmM5XFx1MWZjYlxcdTFmZDNcXHUxZmRiXFx1MWZlM1xcdTFmZWJcXHUxZmVlLVxcdTFmZWZcXHUxZmY5XFx1MWZmYlxcdTFmZmRcXHUyMDAwLVxcdTIwMDFcXHUyMGQwLVxcdTIwZDFcXHUyMGQ0LVxcdTIwZDdcXHUyMGU3LVxcdTIwZTlcXHUyMTI2XFx1MjEyYS1cXHUyMTJiXFx1MjMyOS1cXHUyMzJhXFx1MmFkY1xcdTMwMmItXFx1MzAyY1xcdWFhYjItXFx1YWFiM1xcdWY5MDAtXFx1ZmEwZFxcdWZhMTBcXHVmYTEyXFx1ZmExNS1cXHVmYTFlXFx1ZmEyMFxcdWZhMjJcXHVmYTI1LVxcdWZhMjZcXHVmYTJhLVxcdWZhMmRcXHVmYTMwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjFkXFx1ZmIxZlxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiNGVcXHVmZmYwLVxcdWZmZmZdL2dcbiAgLCBleHRyYUxvb2t1cDtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxMb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgdmFyIGk7XG4gIHZhciB1bnJvbGxlZCA9IHt9O1xuICB2YXIgYyA9IFtdO1xuICBmb3IgKGkgPSAwOyBpIDwgNjU1MzY7IGkrKykge1xuICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICB9XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgdW5yb2xsZWRbIGEgXSA9ICdcXFxcdScgKyAoJzAwMDAnICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgIHJldHVybiAnJztcbiAgfSk7XG4gIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgcXVvdGU6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OMy5zdHJpbmdpZnkoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYUVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmICghZXh0cmFFc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmICghZXh0cmFMb29rdXApIHtcbiAgICAgIGV4dHJhTG9va3VwID0gdW5yb2xsTG9va3VwKGV4dHJhRXNjYXBhYmxlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcXVvdGVkLnJlcGxhY2UoZXh0cmFFc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgIHJldHVybiBleHRyYUxvb2t1cFthXTtcbiAgICB9KTtcbiAgfVxufTtcblxufSx7XCJqc29uM1wiOjg4fV0sNzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmFuZG9tID0gcmVxdWlyZSgnLi9yYW5kb20nKTtcblxudmFyIG9uVW5sb2FkID0ge31cbiAgLCBhZnRlclVubG9hZCA9IGZhbHNlXG4gICAgLy8gZGV0ZWN0IGdvb2dsZSBjaHJvbWUgcGFja2FnZWQgYXBwcyBiZWNhdXNlIHRoZXkgZG9uJ3QgYWxsb3cgdGhlICd1bmxvYWQnIGV2ZW50XG4gICwgaXNDaHJvbWVQYWNrYWdlZEFwcCA9IGdsb2JhbC5jaHJvbWUgJiYgZ2xvYmFsLmNocm9tZS5hcHAgJiYgZ2xvYmFsLmNocm9tZS5hcHAucnVudGltZVxuICA7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBhdHRhY2hFdmVudDogZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLmRvY3VtZW50ICYmIGdsb2JhbC5hdHRhY2hFdmVudCkge1xuICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgLy8gQWNjb3JkaW5nIHRvOiBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG4gICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICBnbG9iYWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgZGV0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuZGV0YWNoRXZlbnQpIHtcbiAgICAgIGdsb2JhbC5kb2N1bWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgIGdsb2JhbC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cblxuLCB1bmxvYWRBZGQ6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgaWYgKGlzQ2hyb21lUGFja2FnZWRBcHApIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciByZWYgPSByYW5kb20uc3RyaW5nKDgpO1xuICAgIG9uVW5sb2FkW3JlZl0gPSBsaXN0ZW5lcjtcbiAgICBpZiAoYWZ0ZXJVbmxvYWQpIHtcbiAgICAgIHNldFRpbWVvdXQodGhpcy50cmlnZ2VyVW5sb2FkQ2FsbGJhY2tzLCAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbiAgfVxuXG4sIHVubG9hZERlbDogZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG5cbiwgdHJpZ2dlclVubG9hZENhbGxiYWNrczogZnVuY3Rpb24oKSB7XG4gICAgZm9yICh2YXIgcmVmIGluIG9uVW5sb2FkKSB7XG4gICAgICBvblVubG9hZFtyZWZdKCk7XG4gICAgICBkZWxldGUgb25VbmxvYWRbcmVmXTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB1bmxvYWRUcmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFmdGVyVW5sb2FkID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMudHJpZ2dlclVubG9hZENhbGxiYWNrcygpO1xufTtcblxuLy8gJ3VubG9hZCcgYWxvbmUgaXMgbm90IHJlbGlhYmxlIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUsIGJ1dCB3ZVxuLy8gY2FuJ3QgdXNlIGBiZWZvcmV1bmxvYWRgIGFzIElFIGZpcmVzIGl0IG9uIGphdmFzY3JpcHQ6IGxpbmtzLlxuaWYgKCFpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gIG1vZHVsZS5leHBvcnRzLmF0dGFjaEV2ZW50KCd1bmxvYWQnLCB1bmxvYWRUcmlnZ2VyZWQpO1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9yYW5kb21cIjo4MH1dLDc3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vZXZlbnQnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGJyb3dzZXIgPSByZXF1aXJlKCcuL2Jyb3dzZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6aWZyYW1lJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBXUHJlZml4OiAnX2pwJ1xuLCBjdXJyZW50V2luZG93SWQ6IG51bGxcblxuLCBwb2xsdXRlR2xvYmFsTmFtZXNwYWNlOiBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShtb2R1bGUuZXhwb3J0cy5XUHJlZml4IGluIGdsb2JhbCkpIHtcbiAgICAgIGdsb2JhbFttb2R1bGUuZXhwb3J0cy5XUHJlZml4XSA9IHt9O1xuICAgIH1cbiAgfVxuXG4sIHBvc3RNZXNzYWdlOiBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgaWYgKGdsb2JhbC5wYXJlbnQgIT09IGdsb2JhbCkge1xuICAgICAgZ2xvYmFsLnBhcmVudC5wb3N0TWVzc2FnZShKU09OMy5zdHJpbmdpZnkoe1xuICAgICAgICB3aW5kb3dJZDogbW9kdWxlLmV4cG9ydHMuY3VycmVudFdpbmRvd0lkXG4gICAgICAsIHR5cGU6IHR5cGVcbiAgICAgICwgZGF0YTogZGF0YSB8fCAnJ1xuICAgICAgfSksICcqJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnKCdDYW5ub3QgcG9zdE1lc3NhZ2UsIG5vIHBhcmVudCB3aW5kb3cuJywgdHlwZSwgZGF0YSk7XG4gICAgfVxuICB9XG5cbiwgY3JlYXRlSWZyYW1lOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygndW5hdHRhY2gnKTtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICB0cnkge1xuICAgICAgICBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgLy8gVGhpcyB0aW1lb3V0IG1ha2VzIGNocm9tZSBmaXJlIG9uYmVmb3JldW5sb2FkIGV2ZW50XG4gICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgZXZlbnRVdGlscy51bmxvYWREZWwodW5sb2FkUmVmKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIGVycik7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgZGVidWcoJ3Bvc3QnLCBtc2csIG9yaWdpbik7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmcmFtZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ29uZXJyb3InKTtcbiAgICB9O1xuICAgIGlmcmFtZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdvbmxvYWQnKTtcbiAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBvbmVycm9yKCdvbmxvYWQgdGltZW91dCcpO1xuICAgICAgfSwgMjAwMCk7XG4gICAgfTtcbiAgICBnbG9iYWwuZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcigndGltZW91dCcpO1xuICAgIH0sIDE1MDAwKTtcbiAgICB1bmxvYWRSZWYgPSBldmVudFV0aWxzLnVubG9hZEFkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zdDogcG9zdFxuICAgICwgY2xlYW51cDogY2xlYW51cFxuICAgICwgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG4gIH1cblxuLyoganNoaW50IHVuZGVmOiBmYWxzZSwgbmV3Y2FwOiBmYWxzZSAqL1xuLyogZXNsaW50IG5vLXVuZGVmOiAwLCBuZXctY2FwOiAwICovXG4sIGNyZWF0ZUh0bWxmaWxlOiBmdW5jdGlvbihpZnJhbWVVcmwsIGVycm9yQ2FsbGJhY2spIHtcbiAgICB2YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbiAgICB2YXIgZG9jID0gbmV3IGdsb2JhbFtheG9dKCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRSZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpICB7XG4gICAgICBkZWJ1Zygnb25lcnJvcicsIHIpO1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2socik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICB0cnkge1xuICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgfVxuICAgICAgICB9LCAwKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZ2xvYmFsLmRvY3VtZW50LmRvbWFpbiArICdcIjsnICtcbiAgICAgICAgICAgICAgJzwvcycgKyAnY3JpcHQ+PC9odG1sPicpO1xuICAgIGRvYy5jbG9zZSgpO1xuICAgIGRvYy5wYXJlbnRXaW5kb3dbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lVXJsO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gZmFsc2U7XG5pZiAoZ2xvYmFsLmRvY3VtZW50KSB7XG4gIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAvLyBodWdlIGRlbGF5LCBvciBub3QgYXQgYWxsLlxuICBtb2R1bGUuZXhwb3J0cy5pZnJhbWVFbmFibGVkID0gKHR5cGVvZiBnbG9iYWwucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICB0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFicm93c2VyLmlzS29ucXVlcm9yKCkpO1xufVxuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL2Jyb3dzZXJcIjo3NCxcIi4vZXZlbnRcIjo3NixcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwianNvbjNcIjo4OH1dLDc4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGxvZ09iamVjdCA9IHt9O1xuWydsb2cnLCAnZGVidWcnLCAnd2FybiddLmZvckVhY2goZnVuY3Rpb24gKGxldmVsKSB7XG4gIHZhciBsZXZlbEV4aXN0cyA9IGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlW2xldmVsXSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0uYXBwbHk7XG4gIGxvZ09iamVjdFtsZXZlbF0gPSBsZXZlbEV4aXN0cyA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5KGdsb2JhbC5jb25zb2xlLCBhcmd1bWVudHMpO1xuICB9IDogKGxldmVsID09PSAnbG9nJyA/IGZ1bmN0aW9uICgpIHt9IDogbG9nT2JqZWN0LmxvZyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2dPYmplY3Q7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sNzk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfVxuXG4sIGV4dGVuZDogZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCF0aGlzLmlzT2JqZWN0KG9iaikpIHtcbiAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHZhciBzb3VyY2UsIHByb3A7XG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgc291cmNlID0gYXJndW1lbnRzW2ldO1xuICAgICAgZm9yIChwcm9wIGluIHNvdXJjZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwgcHJvcCkpIHtcbiAgICAgICAgICBvYmpbcHJvcF0gPSBzb3VyY2VbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfVxufTtcblxufSx7fV0sODA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgY3J5cHRvOnRydWUgKi9cbnZhciBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuLy8gVGhpcyBzdHJpbmcgaGFzIGxlbmd0aCAzMiwgYSBwb3dlciBvZiAyLCBzbyB0aGUgbW9kdWx1cyBkb2Vzbid0IGludHJvZHVjZSBhXG4vLyBiaWFzLlxudmFyIF9yYW5kb21TdHJpbmdDaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NSc7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc3RyaW5nOiBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgbWF4ID0gX3JhbmRvbVN0cmluZ0NoYXJzLmxlbmd0aDtcbiAgICB2YXIgYnl0ZXMgPSBjcnlwdG8ucmFuZG9tQnl0ZXMobGVuZ3RoKTtcbiAgICB2YXIgcmV0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmV0LnB1c2goX3JhbmRvbVN0cmluZ0NoYXJzLnN1YnN0cihieXRlc1tpXSAlIG1heCwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xuICB9XG5cbiwgbnVtYmVyOiBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbiAgfVxuXG4sIG51bWJlclN0cmluZzogZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycgKyAobWF4IC0gMSkpLmxlbmd0aDtcbiAgICB2YXIgcCA9IG5ldyBBcnJheSh0ICsgMSkuam9pbignMCcpO1xuICAgIHJldHVybiAocCArIHRoaXMubnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbiAgfVxufTtcblxufSx7XCJjcnlwdG9cIjo3M31dLDgxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dHJhbnNwb3J0Jyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXZhaWxhYmxlVHJhbnNwb3J0cykge1xuICByZXR1cm4ge1xuICAgIGZpbHRlclRvRW5hYmxlZDogZnVuY3Rpb24odHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbykge1xuICAgICAgdmFyIHRyYW5zcG9ydHMgPSB7XG4gICAgICAgIG1haW46IFtdXG4gICAgICAsIGZhY2FkZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoIXRyYW5zcG9ydHNXaGl0ZWxpc3QpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFtdO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdHJhbnNwb3J0c1doaXRlbGlzdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdCA9IFt0cmFuc3BvcnRzV2hpdGVsaXN0XTtcbiAgICAgIH1cblxuICAgICAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKHRyYW5zKSB7XG4gICAgICAgIGlmICghdHJhbnMpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnMudHJhbnNwb3J0TmFtZSA9PT0gJ3dlYnNvY2tldCcgJiYgaW5mby53ZWJzb2NrZXQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZGVidWcoJ2Rpc2FibGVkIGZyb20gc2VydmVyJywgJ3dlYnNvY2tldCcpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFuc3BvcnRzV2hpdGVsaXN0Lmxlbmd0aCAmJlxuICAgICAgICAgICAgdHJhbnNwb3J0c1doaXRlbGlzdC5pbmRleE9mKHRyYW5zLnRyYW5zcG9ydE5hbWUpID09PSAtMSkge1xuICAgICAgICAgIGRlYnVnKCdub3QgaW4gd2hpdGVsaXN0JywgdHJhbnMudHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLmVuYWJsZWQoaW5mbykpIHtcbiAgICAgICAgICBkZWJ1ZygnZW5hYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHRyYW5zcG9ydHMubWFpbi5wdXNoKHRyYW5zKTtcbiAgICAgICAgICBpZiAodHJhbnMuZmFjYWRlVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICB0cmFuc3BvcnRzLmZhY2FkZS5wdXNoKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cmFuc3BvcnRzO1xuICAgIH1cbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NH1dLDgyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp1dGlsczp1cmwnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldE9yaWdpbjogZnVuY3Rpb24odXJsKSB7XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBwID0gbmV3IFVSTCh1cmwpO1xuICAgIGlmIChwLnByb3RvY29sID09PSAnZmlsZTonKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcG9ydCA9IHAucG9ydDtcbiAgICBpZiAoIXBvcnQpIHtcbiAgICAgIHBvcnQgPSAocC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpID8gJzQ0MycgOiAnODAnO1xuICAgIH1cblxuICAgIHJldHVybiBwLnByb3RvY29sICsgJy8vJyArIHAuaG9zdG5hbWUgKyAnOicgKyBwb3J0O1xuICB9XG5cbiwgaXNPcmlnaW5FcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciByZXMgPSB0aGlzLmdldE9yaWdpbihhKSA9PT0gdGhpcy5nZXRPcmlnaW4oYik7XG4gICAgZGVidWcoJ3NhbWUnLCBhLCBiLCByZXMpO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuLCBpc1NjaGVtZUVxdWFsOiBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIChhLnNwbGl0KCc6JylbMF0gPT09IGIuc3BsaXQoJzonKVswXSk7XG4gIH1cblxuLCBhZGRQYXRoOiBmdW5jdGlvbiAodXJsLCBwYXRoKSB7XG4gICAgdmFyIHFzID0gdXJsLnNwbGl0KCc/Jyk7XG4gICAgcmV0dXJuIHFzWzBdICsgcGF0aCArIChxc1sxXSA/ICc/JyArIHFzWzFdIDogJycpO1xuICB9XG5cbiwgYWRkUXVlcnk6IGZ1bmN0aW9uICh1cmwsIHEpIHtcbiAgICByZXR1cm4gdXJsICsgKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gKCc/JyArIHEpIDogKCcmJyArIHEpKTtcbiAgfVxufTtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwidXJsLXBhcnNlXCI6ODl9XSw4MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cyA9ICcxLjAuMyc7XG59LHt9XSw4NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XG5leHBvcnRzLmxvZyA9IGxvZztcbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxuICAgICAgICAgICAgICAgJiYgJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZS5zdG9yYWdlXG4gICAgICAgICAgICAgICAgICA/IGNocm9tZS5zdG9yYWdlLmxvY2FsXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcbiAgJ2xpZ2h0c2VhZ3JlZW4nLFxuICAnZm9yZXN0Z3JlZW4nLFxuICAnZ29sZGVucm9kJyxcbiAgJ2RvZGdlcmJsdWUnLFxuICAnZGFya29yY2hpZCcsXG4gICdjcmltc29uJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG4gIC8vIGlzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIHJldHVybiAoJ1dlYmtpdEFwcGVhcmFuY2UnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSkgfHxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG4gICAgKHdpbmRvdy5jb25zb2xlICYmIChjb25zb2xlLmZpcmVidWcgfHwgKGNvbnNvbGUuZXhjZXB0aW9uICYmIGNvbnNvbGUudGFibGUpKSkgfHxcbiAgICAvLyBpcyBmaXJlZm94ID49IHYzMT9cbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcbiAgICAobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpO1xufVxuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xufTtcblxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoKSB7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgdXNlQ29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG5cbiAgYXJnc1swXSA9ICh1c2VDb2xvcnMgPyAnJWMnIDogJycpXG4gICAgKyB0aGlzLm5hbWVzcGFjZVxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxuICAgICsgYXJnc1swXVxuICAgICsgKHVzZUNvbG9ycyA/ICclYyAnIDogJyAnKVxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdXNlQ29sb3JzKSByZXR1cm4gYXJncztcblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3MgPSBbYXJnc1swXSwgYywgJ2NvbG9yOiBpbmhlcml0J10uY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MsIDEpKTtcblxuICAvLyB0aGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEMgPSAwO1xuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16JV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICBpZiAoJyUlJyA9PT0gbWF0Y2gpIHJldHVybjtcbiAgICBpbmRleCsrO1xuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xuICAgICAgLy8gd2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG4gICAgICAvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuICAgICAgbGFzdEMgPSBpbmRleDtcbiAgICB9XG4gIH0pO1xuXG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbiAgcmV0dXJuIGFyZ3M7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gbG9nKCkge1xuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gJ29iamVjdCcgPT09IHR5cGVvZiBjb25zb2xlXG4gICAgJiYgY29uc29sZS5sb2dcbiAgICAmJiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlLmxvZywgY29uc29sZSwgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIHRyeSB7XG4gICAgaWYgKG51bGwgPT0gbmFtZXNwYWNlcykge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZyA9IG5hbWVzcGFjZXM7XG4gICAgfVxuICB9IGNhdGNoKGUpIHt9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgdmFyIHI7XG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5kZWJ1ZztcbiAgfSBjYXRjaChlKSB7fVxuICByZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBFbmFibGUgbmFtZXNwYWNlcyBsaXN0ZWQgaW4gYGxvY2FsU3RvcmFnZS5kZWJ1Z2AgaW5pdGlhbGx5LlxuICovXG5cbmV4cG9ydHMuZW5hYmxlKGxvYWQoKSk7XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCl7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbn0se1wiLi9kZWJ1Z1wiOjg1fV0sODU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKlxuICogRXhwb3NlIGBkZWJ1ZygpYCBhcyB0aGUgbW9kdWxlLlxuICovXG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IGRlYnVnO1xuZXhwb3J0cy5jb2VyY2UgPSBjb2VyY2U7XG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xuZXhwb3J0cy5lbmFibGUgPSBlbmFibGU7XG5leHBvcnRzLmVuYWJsZWQgPSBlbmFibGVkO1xuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cbi8qKlxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG4gKi9cblxuZXhwb3J0cy5uYW1lcyA9IFtdO1xuZXhwb3J0cy5za2lwcyA9IFtdO1xuXG4vKipcbiAqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cbiAqXG4gKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlcmNhc2VkIGxldHRlciwgaS5lLiBcIm5cIi5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdHRlcnMgPSB7fTtcblxuLyoqXG4gKiBQcmV2aW91c2x5IGFzc2lnbmVkIGNvbG9yLlxuICovXG5cbnZhciBwcmV2Q29sb3IgPSAwO1xuXG4vKipcbiAqIFByZXZpb3VzIGxvZyB0aW1lc3RhbXAuXG4gKi9cblxudmFyIHByZXZUaW1lO1xuXG4vKipcbiAqIFNlbGVjdCBhIGNvbG9yLlxuICpcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNlbGVjdENvbG9yKCkge1xuICByZXR1cm4gZXhwb3J0cy5jb2xvcnNbcHJldkNvbG9yKysgJSBleHBvcnRzLmNvbG9ycy5sZW5ndGhdO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWJ1ZyhuYW1lc3BhY2UpIHtcblxuICAvLyBkZWZpbmUgdGhlIGBkaXNhYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBkaXNhYmxlZCgpIHtcbiAgfVxuICBkaXNhYmxlZC5lbmFibGVkID0gZmFsc2U7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZW5hYmxlZGAgdmVyc2lvblxuICBmdW5jdGlvbiBlbmFibGVkKCkge1xuXG4gICAgdmFyIHNlbGYgPSBlbmFibGVkO1xuXG4gICAgLy8gc2V0IGBkaWZmYCB0aW1lc3RhbXBcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xuICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgc2VsZi5kaWZmID0gbXM7XG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XG4gICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICBwcmV2VGltZSA9IGN1cnI7XG5cbiAgICAvLyBhZGQgdGhlIGBjb2xvcmAgaWYgbm90IHNldFxuICAgIGlmIChudWxsID09IHNlbGYudXNlQ29sb3JzKSBzZWxmLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XG4gICAgaWYgKG51bGwgPT0gc2VsZi5jb2xvciAmJiBzZWxmLnVzZUNvbG9ycykgc2VsZi5jb2xvciA9IHNlbGVjdENvbG9yKCk7XG5cbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBhcmdzWzBdKSB7XG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlb1xuICAgICAgYXJncyA9IFsnJW8nXS5jb25jYXQoYXJncyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EteiVdKS9nLCBmdW5jdGlvbihtYXRjaCwgZm9ybWF0KSB7XG4gICAgICAvLyBpZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcbiAgICAgIGluZGV4Kys7XG4gICAgICB2YXIgZm9ybWF0dGVyID0gZXhwb3J0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xuICAgICAgICB2YXIgdmFsID0gYXJnc1tpbmRleF07XG4gICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuICAgICAgICAvLyBub3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG4gICAgICAgIGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgaW5kZXgtLTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcblxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgZXhwb3J0cy5mb3JtYXRBcmdzKSB7XG4gICAgICBhcmdzID0gZXhwb3J0cy5mb3JtYXRBcmdzLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIH1cbiAgICB2YXIgbG9nRm4gPSBlbmFibGVkLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xuICAgIGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG4gIGVuYWJsZWQuZW5hYmxlZCA9IHRydWU7XG5cbiAgdmFyIGZuID0gZXhwb3J0cy5lbmFibGVkKG5hbWVzcGFjZSkgPyBlbmFibGVkIDogZGlzYWJsZWQ7XG5cbiAgZm4ubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXG4gIHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gIGV4cG9ydHMuc2F2ZShuYW1lc3BhY2VzKTtcblxuICB2YXIgc3BsaXQgPSAobmFtZXNwYWNlcyB8fCAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgdmFyIGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgbmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG4gICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgZXhwb3J0cy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gIHZhciBpLCBsZW47XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAoZXhwb3J0cy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENvZXJjZSBgdmFsYC5cbiAqXG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqIEByZXR1cm4ge01peGVkfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG4gIHJldHVybiB2YWw7XG59XG5cbn0se1wibXNcIjo4Nn1dLDg2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpe1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgaWYgKCdzdHJpbmcnID09IHR5cGVvZiB2YWwpIHJldHVybiBwYXJzZSh2YWwpO1xuICByZXR1cm4gb3B0aW9ucy5sb25nXG4gICAgPyBsb25nKHZhbClcbiAgICA6IHNob3J0KHZhbCk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gJycgKyBzdHI7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwMDApIHJldHVybjtcbiAgdmFyIG1hdGNoID0gL14oKD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm47XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNob3J0KG1zKSB7XG4gIGlmIChtcyA+PSBkKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICBpZiAobXMgPj0gaCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgaWYgKG1zID49IG0pIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIGlmIChtcyA+PSBzKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9uZyhtcykge1xuICByZXR1cm4gcGx1cmFsKG1zLCBkLCAnZGF5JylcbiAgICB8fCBwbHVyYWwobXMsIGgsICdob3VyJylcbiAgICB8fCBwbHVyYWwobXMsIG0sICdtaW51dGUnKVxuICAgIHx8IHBsdXJhbChtcywgcywgJ3NlY29uZCcpXG4gICAgfHwgbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG4sIG5hbWUpIHtcbiAgaWYgKG1zIDwgbikgcmV0dXJuO1xuICBpZiAobXMgPCBuICogMS41KSByZXR1cm4gTWF0aC5mbG9vcihtcyAvIG4pICsgJyAnICsgbmFtZTtcbiAgcmV0dXJuIE1hdGguY2VpbChtcyAvIG4pICsgJyAnICsgbmFtZSArICdzJztcbn1cblxufSx7fV0sODc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG5cbn0se31dLDg4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbi8qISBKU09OIHYzLjMuMiB8IGh0dHA6Ly9iZXN0aWVqcy5naXRodWIuaW8vanNvbjMgfCBDb3B5cmlnaHQgMjAxMi0yMDE0LCBLaXQgQ2FtYnJpZGdlIHwgaHR0cDovL2tpdC5taXQtbGljZW5zZS5vcmcgKi9cbjsoZnVuY3Rpb24gKCkge1xuICAvLyBEZXRlY3QgdGhlIGBkZWZpbmVgIGZ1bmN0aW9uIGV4cG9zZWQgYnkgYXN5bmNocm9ub3VzIG1vZHVsZSBsb2FkZXJzLiBUaGVcbiAgLy8gc3RyaWN0IGBkZWZpbmVgIGNoZWNrIGlzIG5lY2Vzc2FyeSBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGByLmpzYC5cbiAgdmFyIGlzTG9hZGVyID0gdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQ7XG5cbiAgLy8gQSBzZXQgb2YgdHlwZXMgdXNlZCB0byBkaXN0aW5ndWlzaCBvYmplY3RzIGZyb20gcHJpbWl0aXZlcy5cbiAgdmFyIG9iamVjdFR5cGVzID0ge1xuICAgIFwiZnVuY3Rpb25cIjogdHJ1ZSxcbiAgICBcIm9iamVjdFwiOiB0cnVlXG4gIH07XG5cbiAgLy8gRGV0ZWN0IHRoZSBgZXhwb3J0c2Agb2JqZWN0IGV4cG9zZWQgYnkgQ29tbW9uSlMgaW1wbGVtZW50YXRpb25zLlxuICB2YXIgZnJlZUV4cG9ydHMgPSBvYmplY3RUeXBlc1t0eXBlb2YgZXhwb3J0c10gJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8vIFVzZSB0aGUgYGdsb2JhbGAgb2JqZWN0IGV4cG9zZWQgYnkgTm9kZSAoaW5jbHVkaW5nIEJyb3dzZXJpZnkgdmlhXG4gIC8vIGBpbnNlcnQtbW9kdWxlLWdsb2JhbHNgKSwgTmFyd2hhbCwgYW5kIFJpbmdvIGFzIHRoZSBkZWZhdWx0IGNvbnRleHQsXG4gIC8vIGFuZCB0aGUgYHdpbmRvd2Agb2JqZWN0IGluIGJyb3dzZXJzLiBSaGlubyBleHBvcnRzIGEgYGdsb2JhbGAgZnVuY3Rpb25cbiAgLy8gaW5zdGVhZC5cbiAgdmFyIHJvb3QgPSBvYmplY3RUeXBlc1t0eXBlb2Ygd2luZG93XSAmJiB3aW5kb3cgfHwgdGhpcyxcbiAgICAgIGZyZWVHbG9iYWwgPSBmcmVlRXhwb3J0cyAmJiBvYmplY3RUeXBlc1t0eXBlb2YgbW9kdWxlXSAmJiBtb2R1bGUgJiYgIW1vZHVsZS5ub2RlVHlwZSAmJiB0eXBlb2YgZ2xvYmFsID09IFwib2JqZWN0XCIgJiYgZ2xvYmFsO1xuXG4gIGlmIChmcmVlR2xvYmFsICYmIChmcmVlR2xvYmFsW1wiZ2xvYmFsXCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJ3aW5kb3dcIl0gPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbFtcInNlbGZcIl0gPT09IGZyZWVHbG9iYWwpKSB7XG4gICAgcm9vdCA9IGZyZWVHbG9iYWw7XG4gIH1cblxuICAvLyBQdWJsaWM6IEluaXRpYWxpemVzIEpTT04gMyB1c2luZyB0aGUgZ2l2ZW4gYGNvbnRleHRgIG9iamVjdCwgYXR0YWNoaW5nIHRoZVxuICAvLyBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBmdW5jdGlvbnMgdG8gdGhlIHNwZWNpZmllZCBgZXhwb3J0c2Agb2JqZWN0LlxuICBmdW5jdGlvbiBydW5JbkNvbnRleHQoY29udGV4dCwgZXhwb3J0cykge1xuICAgIGNvbnRleHQgfHwgKGNvbnRleHQgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuICAgIGV4cG9ydHMgfHwgKGV4cG9ydHMgPSByb290W1wiT2JqZWN0XCJdKCkpO1xuXG4gICAgLy8gTmF0aXZlIGNvbnN0cnVjdG9yIGFsaWFzZXMuXG4gICAgdmFyIE51bWJlciA9IGNvbnRleHRbXCJOdW1iZXJcIl0gfHwgcm9vdFtcIk51bWJlclwiXSxcbiAgICAgICAgU3RyaW5nID0gY29udGV4dFtcIlN0cmluZ1wiXSB8fCByb290W1wiU3RyaW5nXCJdLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0W1wiT2JqZWN0XCJdIHx8IHJvb3RbXCJPYmplY3RcIl0sXG4gICAgICAgIERhdGUgPSBjb250ZXh0W1wiRGF0ZVwiXSB8fCByb290W1wiRGF0ZVwiXSxcbiAgICAgICAgU3ludGF4RXJyb3IgPSBjb250ZXh0W1wiU3ludGF4RXJyb3JcIl0gfHwgcm9vdFtcIlN5bnRheEVycm9yXCJdLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0W1wiVHlwZUVycm9yXCJdIHx8IHJvb3RbXCJUeXBlRXJyb3JcIl0sXG4gICAgICAgIE1hdGggPSBjb250ZXh0W1wiTWF0aFwiXSB8fCByb290W1wiTWF0aFwiXSxcbiAgICAgICAgbmF0aXZlSlNPTiA9IGNvbnRleHRbXCJKU09OXCJdIHx8IHJvb3RbXCJKU09OXCJdO1xuXG4gICAgLy8gRGVsZWdhdGUgdG8gdGhlIG5hdGl2ZSBgc3RyaW5naWZ5YCBhbmQgYHBhcnNlYCBpbXBsZW1lbnRhdGlvbnMuXG4gICAgaWYgKHR5cGVvZiBuYXRpdmVKU09OID09IFwib2JqZWN0XCIgJiYgbmF0aXZlSlNPTikge1xuICAgICAgZXhwb3J0cy5zdHJpbmdpZnkgPSBuYXRpdmVKU09OLnN0cmluZ2lmeTtcbiAgICAgIGV4cG9ydHMucGFyc2UgPSBuYXRpdmVKU09OLnBhcnNlO1xuICAgIH1cblxuICAgIC8vIENvbnZlbmllbmNlIGFsaWFzZXMuXG4gICAgdmFyIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZSxcbiAgICAgICAgZ2V0Q2xhc3MgPSBvYmplY3RQcm90by50b1N0cmluZyxcbiAgICAgICAgaXNQcm9wZXJ0eSwgZm9yRWFjaCwgdW5kZWY7XG5cbiAgICAvLyBUZXN0IHRoZSBgRGF0ZSNnZXRVVEMqYCBtZXRob2RzLiBCYXNlZCBvbiB3b3JrIGJ5IEBZYWZmbGUuXG4gICAgdmFyIGlzRXh0ZW5kZWQgPSBuZXcgRGF0ZSgtMzUwOTgyNzMzNDU3MzI5Mik7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRoZSBgZ2V0VVRDRnVsbFllYXJgLCBgTW9udGhgLCBhbmQgYERhdGVgIG1ldGhvZHMgcmV0dXJuIG5vbnNlbnNpY2FsXG4gICAgICAvLyByZXN1bHRzIGZvciBjZXJ0YWluIGRhdGVzIGluIE9wZXJhID49IDEwLjUzLlxuICAgICAgaXNFeHRlbmRlZCA9IGlzRXh0ZW5kZWQuZ2V0VVRDRnVsbFllYXIoKSA9PSAtMTA5MjUyICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTW9udGgoKSA9PT0gMCAmJiBpc0V4dGVuZGVkLmdldFVUQ0RhdGUoKSA9PT0gMSAmJlxuICAgICAgICAvLyBTYWZhcmkgPCAyLjAuMiBzdG9yZXMgdGhlIGludGVybmFsIG1pbGxpc2Vjb25kIHRpbWUgdmFsdWUgY29ycmVjdGx5LFxuICAgICAgICAvLyBidXQgY2xpcHMgdGhlIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgZGF0ZSBtZXRob2RzIHRvIHRoZSByYW5nZSBvZlxuICAgICAgICAvLyBzaWduZWQgMzItYml0IGludGVnZXJzIChbLTIgKiogMzEsIDIgKiogMzEgLSAxXSkuXG4gICAgICAgIGlzRXh0ZW5kZWQuZ2V0VVRDSG91cnMoKSA9PSAxMCAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbnV0ZXMoKSA9PSAzNyAmJiBpc0V4dGVuZGVkLmdldFVUQ1NlY29uZHMoKSA9PSA2ICYmIGlzRXh0ZW5kZWQuZ2V0VVRDTWlsbGlzZWNvbmRzKCkgPT0gNzA4O1xuICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cblxuICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIG5hdGl2ZSBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgcGFyc2VgXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIGFyZSBzcGVjLWNvbXBsaWFudC4gQmFzZWQgb24gd29yayBieSBLZW4gU255ZGVyLlxuICAgIGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgICBpZiAoaGFzW25hbWVdICE9PSB1bmRlZikge1xuICAgICAgICAvLyBSZXR1cm4gY2FjaGVkIGZlYXR1cmUgdGVzdCByZXN1bHQuXG4gICAgICAgIHJldHVybiBoYXNbbmFtZV07XG4gICAgICB9XG4gICAgICB2YXIgaXNTdXBwb3J0ZWQ7XG4gICAgICBpZiAobmFtZSA9PSBcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKSB7XG4gICAgICAgIC8vIElFIDw9IDcgZG9lc24ndCBzdXBwb3J0IGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyB1c2luZyBzcXVhcmVcbiAgICAgICAgLy8gYnJhY2tldCBub3RhdGlvbi4gSUUgOCBvbmx5IHN1cHBvcnRzIHRoaXMgZm9yIHByaW1pdGl2ZXMuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gXCJhXCJbMF0gIT0gXCJhXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJqc29uXCIpIHtcbiAgICAgICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgYm90aCBgSlNPTi5zdHJpbmdpZnlgIGFuZCBgSlNPTi5wYXJzZWAgYXJlXG4gICAgICAgIC8vIHN1cHBvcnRlZC5cbiAgICAgICAgaXNTdXBwb3J0ZWQgPSBoYXMoXCJqc29uLXN0cmluZ2lmeVwiKSAmJiBoYXMoXCJqc29uLXBhcnNlXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZhbHVlLCBzZXJpYWxpemVkID0gJ3tcImFcIjpbMSx0cnVlLGZhbHNlLG51bGwsXCJcXFxcdTAwMDBcXFxcYlxcXFxuXFxcXGZcXFxcclxcXFx0XCJdfSc7XG4gICAgICAgIC8vIFRlc3QgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgaWYgKG5hbWUgPT0gXCJqc29uLXN0cmluZ2lmeVwiKSB7XG4gICAgICAgICAgdmFyIHN0cmluZ2lmeSA9IGV4cG9ydHMuc3RyaW5naWZ5LCBzdHJpbmdpZnlTdXBwb3J0ZWQgPSB0eXBlb2Ygc3RyaW5naWZ5ID09IFwiZnVuY3Rpb25cIiAmJiBpc0V4dGVuZGVkO1xuICAgICAgICAgIGlmIChzdHJpbmdpZnlTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgIC8vIEEgdGVzdCBmdW5jdGlvbiBvYmplY3Qgd2l0aCBhIGN1c3RvbSBgdG9KU09OYCBtZXRob2QuXG4gICAgICAgICAgICAodmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfSkudG9KU09OID0gdmFsdWU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPVxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggMy4xYjEgYW5kIGIyIHNlcmlhbGl6ZSBzdHJpbmcsIG51bWJlciwgYW5kIGJvb2xlYW5cbiAgICAgICAgICAgICAgICAvLyBwcmltaXRpdmVzIGFzIG9iamVjdCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoMCkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyLCBhbmQgSlNPTiAyIHNlcmlhbGl6ZSB3cmFwcGVkIHByaW1pdGl2ZXMgYXMgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBOdW1iZXIoKSkgPT09IFwiMFwiICYmXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBTdHJpbmcoKSkgPT0gJ1wiXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIHZhbHVlIGlzIGBudWxsYCwgYHVuZGVmaW5lZGAsIG9yXG4gICAgICAgICAgICAgICAgLy8gZG9lcyBub3QgZGVmaW5lIGEgY2Fub25pY2FsIEpTT04gcmVwcmVzZW50YXRpb24gKHRoaXMgYXBwbGllcyB0b1xuICAgICAgICAgICAgICAgIC8vIG9iamVjdHMgd2l0aCBgdG9KU09OYCBwcm9wZXJ0aWVzIGFzIHdlbGwsICp1bmxlc3MqIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIHdpdGhpbiBhbiBvYmplY3Qgb3IgYXJyYXkpLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShnZXRDbGFzcykgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gSUUgOCBzZXJpYWxpemVzIGB1bmRlZmluZWRgIGFzIGBcInVuZGVmaW5lZFwiYC4gU2FmYXJpIDw9IDUuMS43IGFuZFxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIzIHBhc3MgdGhpcyB0ZXN0LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh1bmRlZikgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS43IGFuZCBGRiAzLjFiMyB0aHJvdyBgRXJyb3JgcyBhbmQgYFR5cGVFcnJvcmBzLFxuICAgICAgICAgICAgICAgIC8vIHJlc3BlY3RpdmVseSwgaWYgdGhlIHZhbHVlIGlzIG9taXR0ZWQgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KCkgPT09IHVuZGVmICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgdGhyb3cgYW4gZXJyb3IgaWYgdGhlIGdpdmVuIHZhbHVlIGlzIG5vdCBhIG51bWJlcixcbiAgICAgICAgICAgICAgICAvLyBzdHJpbmcsIGFycmF5LCBvYmplY3QsIEJvb2xlYW4sIG9yIGBudWxsYCBsaXRlcmFsLiBUaGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMgYXMgd2VsbCwgdW5sZXNzIHRoZXkgYXJlIG5lc3RlZFxuICAgICAgICAgICAgICAgIC8vIGluc2lkZSBvYmplY3Qgb3IgYXJyYXkgbGl0ZXJhbHMuIFlVSSAzLjAuMGIxIGlnbm9yZXMgY3VzdG9tIGB0b0pTT05gXG4gICAgICAgICAgICAgICAgLy8gbWV0aG9kcyBlbnRpcmVseS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdmFsdWVdKSA9PSBcIlsxXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gUHJvdG90eXBlIDw9IDEuNi4xIHNlcmlhbGl6ZXMgYFt1bmRlZmluZWRdYCBhcyBgXCJbXVwiYCBpbnN0ZWFkIG9mXG4gICAgICAgICAgICAgICAgLy8gYFwiW251bGxdXCJgLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWZdKSA9PSBcIltudWxsXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gWVVJIDMuMC4wYjEgZmFpbHMgdG8gc2VyaWFsaXplIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCkgPT0gXCJudWxsXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSwgMiBoYWx0cyBzZXJpYWxpemF0aW9uIGlmIGFuIGFycmF5IGNvbnRhaW5zIGEgZnVuY3Rpb246XG4gICAgICAgICAgICAgICAgLy8gYFsxLCB0cnVlLCBnZXRDbGFzcywgMV1gIHNlcmlhbGl6ZXMgYXMgXCJbMSx0cnVlLF0sXCIuIEZGIDMuMWIzXG4gICAgICAgICAgICAgICAgLy8gZWxpZGVzIG5vbi1KU09OIHZhbHVlcyBmcm9tIG9iamVjdHMgYW5kIGFycmF5cywgdW5sZXNzIHRoZXlcbiAgICAgICAgICAgICAgICAvLyBkZWZpbmUgY3VzdG9tIGB0b0pTT05gIG1ldGhvZHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KFt1bmRlZiwgZ2V0Q2xhc3MsIG51bGxdKSA9PSBcIltudWxsLG51bGwsbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBzZXJpYWxpemF0aW9uIHRlc3QuIEZGIDMuMWIxIHVzZXMgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2VzXG4gICAgICAgICAgICAgICAgLy8gd2hlcmUgY2hhcmFjdGVyIGVzY2FwZSBjb2RlcyBhcmUgZXhwZWN0ZWQgKGUuZy4sIGBcXGJgID0+IGBcXHUwMDA4YCkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHsgXCJhXCI6IFt2YWx1ZSwgdHJ1ZSwgZmFsc2UsIG51bGwsIFwiXFx4MDBcXGJcXG5cXGZcXHJcXHRcIl0gfSkgPT0gc2VyaWFsaXplZCAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxIGFuZCBiMiBpZ25vcmUgdGhlIGBmaWx0ZXJgIGFuZCBgd2lkdGhgIGFyZ3VtZW50cy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobnVsbCwgdmFsdWUpID09PSBcIjFcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbMSwgMl0sIG51bGwsIDEpID09IFwiW1xcbiAxLFxcbiAyXFxuXVwiICYmXG4gICAgICAgICAgICAgICAgLy8gSlNPTiAyLCBQcm90b3R5cGUgPD0gMS43LCBhbmQgb2xkZXIgV2ViS2l0IGJ1aWxkcyBpbmNvcnJlY3RseVxuICAgICAgICAgICAgICAgIC8vIHNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycy5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTguNjRlMTUpKSA9PSAnXCItMjcxODIxLTA0LTIwVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBUaGUgbWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LCBidXQgcmVxdWlyZWQgaW4gNS4xLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSg4LjY0ZTE1KSkgPT0gJ1wiKzI3NTc2MC0wOS0xM1QwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gRmlyZWZveCA8PSAxMS4wIGluY29ycmVjdGx5IHNlcmlhbGl6ZXMgeWVhcnMgcHJpb3IgdG8gMCBhcyBuZWdhdGl2ZVxuICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgeWVhcnMgaW5zdGVhZCBvZiBzaXgtZGlnaXQgeWVhcnMuIENyZWRpdHM6IEBZYWZmbGUuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC02MjE5ODc1NTJlNSkpID09ICdcIi0wMDAwMDEtMDEtMDFUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNSBhbmQgT3BlcmEgPj0gMTAuNTMgaW5jb3JyZWN0bHkgc2VyaWFsaXplIG1pbGxpc2Vjb25kXG4gICAgICAgICAgICAgICAgLy8gdmFsdWVzIGxlc3MgdGhhbiAxMDAwLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtMSkpID09ICdcIjE5NjktMTItMzFUMjM6NTk6NTkuOTk5WlwiJztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBzdHJpbmdpZnlTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBzdHJpbmdpZnlTdXBwb3J0ZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGVzdCBgSlNPTi5wYXJzZWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1wYXJzZVwiKSB7XG4gICAgICAgICAgdmFyIHBhcnNlID0gZXhwb3J0cy5wYXJzZTtcbiAgICAgICAgICBpZiAodHlwZW9mIHBhcnNlID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIGIyIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGEgYmFyZSBsaXRlcmFsIGlzIHByb3ZpZGVkLlxuICAgICAgICAgICAgICAvLyBDb25mb3JtaW5nIGltcGxlbWVudGF0aW9ucyBzaG91bGQgYWxzbyBjb2VyY2UgdGhlIGluaXRpYWwgYXJndW1lbnQgdG9cbiAgICAgICAgICAgICAgLy8gYSBzdHJpbmcgcHJpb3IgdG8gcGFyc2luZy5cbiAgICAgICAgICAgICAgaWYgKHBhcnNlKFwiMFwiKSA9PT0gMCAmJiAhcGFyc2UoZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gU2ltcGxlIHBhcnNpbmcgdGVzdC5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHBhcnNlKHNlcmlhbGl6ZWQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJzZVN1cHBvcnRlZCA9IHZhbHVlW1wiYVwiXS5sZW5ndGggPT0gNSAmJiB2YWx1ZVtcImFcIl1bMF0gPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjIgYW5kIEZGIDMuMWIxIGFsbG93IHVuZXNjYXBlZCB0YWJzIGluIHN0cmluZ3MuXG4gICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gIXBhcnNlKCdcIlxcdFwiJyk7XG4gICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICBpZiAocGFyc2VTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBGRiA0LjAgYW5kIDQuMC4xIGFsbG93IGxlYWRpbmcgYCtgIHNpZ25zIGFuZCBsZWFkaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVjaW1hbCBwb2ludHMuIEZGIDQuMCwgNC4wLjEsIGFuZCBJRSA5LTEwIGFsc28gYWxsb3dcbiAgICAgICAgICAgICAgICAgICAgICAvLyBjZXJ0YWluIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgICAgIHBhcnNlU3VwcG9ydGVkID0gcGFyc2UoXCIwMVwiKSAhPT0gMTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wLCA0LjAuMSwgYW5kIFJoaW5vIDEuN1IzLVI0IGFsbG93IHRyYWlsaW5nIGRlY2ltYWxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBwb2ludHMuIFRoZXNlIGVudmlyb25tZW50cywgYWxvbmcgd2l0aCBGRiAzLjFiMSBhbmQgMixcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHNvIGFsbG93IHRyYWlsaW5nIGNvbW1hcyBpbiBKU09OIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMS5cIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge1xuICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpc1N1cHBvcnRlZCA9IHBhcnNlU3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzW25hbWVdID0gISFpc1N1cHBvcnRlZDtcbiAgICB9XG5cbiAgICBpZiAoIWhhcyhcImpzb25cIikpIHtcbiAgICAgIC8vIENvbW1vbiBgW1tDbGFzc11dYCBuYW1lIGFsaWFzZXMuXG4gICAgICB2YXIgZnVuY3Rpb25DbGFzcyA9IFwiW29iamVjdCBGdW5jdGlvbl1cIixcbiAgICAgICAgICBkYXRlQ2xhc3MgPSBcIltvYmplY3QgRGF0ZV1cIixcbiAgICAgICAgICBudW1iZXJDbGFzcyA9IFwiW29iamVjdCBOdW1iZXJdXCIsXG4gICAgICAgICAgc3RyaW5nQ2xhc3MgPSBcIltvYmplY3QgU3RyaW5nXVwiLFxuICAgICAgICAgIGFycmF5Q2xhc3MgPSBcIltvYmplY3QgQXJyYXldXCIsXG4gICAgICAgICAgYm9vbGVhbkNsYXNzID0gXCJbb2JqZWN0IEJvb2xlYW5dXCI7XG5cbiAgICAgIC8vIERldGVjdCBpbmNvbXBsZXRlIHN1cHBvcnQgZm9yIGFjY2Vzc2luZyBzdHJpbmcgY2hhcmFjdGVycyBieSBpbmRleC5cbiAgICAgIHZhciBjaGFySW5kZXhCdWdneSA9IGhhcyhcImJ1Zy1zdHJpbmctY2hhci1pbmRleFwiKTtcblxuICAgICAgLy8gRGVmaW5lIGFkZGl0aW9uYWwgdXRpbGl0eSBtZXRob2RzIGlmIHRoZSBgRGF0ZWAgbWV0aG9kcyBhcmUgYnVnZ3kuXG4gICAgICBpZiAoIWlzRXh0ZW5kZWQpIHtcbiAgICAgICAgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbiAgICAgICAgLy8gQSBtYXBwaW5nIGJldHdlZW4gdGhlIG1vbnRocyBvZiB0aGUgeWVhciBhbmQgdGhlIG51bWJlciBvZiBkYXlzIGJldHdlZW5cbiAgICAgICAgLy8gSmFudWFyeSAxc3QgYW5kIHRoZSBmaXJzdCBvZiB0aGUgcmVzcGVjdGl2ZSBtb250aC5cbiAgICAgICAgdmFyIE1vbnRocyA9IFswLCAzMSwgNTksIDkwLCAxMjAsIDE1MSwgMTgxLCAyMTIsIDI0MywgMjczLCAzMDQsIDMzNF07XG4gICAgICAgIC8vIEludGVybmFsOiBDYWxjdWxhdGVzIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuIHRoZSBVbml4IGVwb2NoIGFuZCB0aGVcbiAgICAgICAgLy8gZmlyc3QgZGF5IG9mIHRoZSBnaXZlbiBtb250aC5cbiAgICAgICAgdmFyIGdldERheSA9IGZ1bmN0aW9uICh5ZWFyLCBtb250aCkge1xuICAgICAgICAgIHJldHVybiBNb250aHNbbW9udGhdICsgMzY1ICogKHllYXIgLSAxOTcwKSArIGZsb29yKCh5ZWFyIC0gMTk2OSArIChtb250aCA9ICsobW9udGggPiAxKSkpIC8gNCkgLSBmbG9vcigoeWVhciAtIDE5MDEgKyBtb250aCkgLyAxMDApICsgZmxvb3IoKHllYXIgLSAxNjAxICsgbW9udGgpIC8gNDAwKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IERldGVybWluZXMgaWYgYSBwcm9wZXJ0eSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSBvZiB0aGUgZ2l2ZW5cbiAgICAgIC8vIG9iamVjdC4gRGVsZWdhdGVzIHRvIHRoZSBuYXRpdmUgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgbWV0aG9kLlxuICAgICAgaWYgKCEoaXNQcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5KSkge1xuICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgY29uc3RydWN0b3I7XG4gICAgICAgICAgaWYgKChtZW1iZXJzLl9fcHJvdG9fXyA9IG51bGwsIG1lbWJlcnMuX19wcm90b19fID0ge1xuICAgICAgICAgICAgLy8gVGhlICpwcm90byogcHJvcGVydHkgY2Fubm90IGJlIHNldCBtdWx0aXBsZSB0aW1lcyBpbiByZWNlbnRcbiAgICAgICAgICAgIC8vIHZlcnNpb25zIG9mIEZpcmVmb3ggYW5kIFNlYU1vbmtleS5cbiAgICAgICAgICAgIFwidG9TdHJpbmdcIjogMVxuICAgICAgICAgIH0sIG1lbWJlcnMpLnRvU3RyaW5nICE9IGdldENsYXNzKSB7XG4gICAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjMgZG9lc24ndCBpbXBsZW1lbnQgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAsIGJ1dFxuICAgICAgICAgICAgLy8gc3VwcG9ydHMgdGhlIG11dGFibGUgKnByb3RvKiBwcm9wZXJ0eS5cbiAgICAgICAgICAgIGlzUHJvcGVydHkgPSBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgLy8gQ2FwdHVyZSBhbmQgYnJlYWsgdGhlIG9iamVjdCdzIHByb3RvdHlwZSBjaGFpbiAoc2VlIHNlY3Rpb24gOC42LjJcbiAgICAgICAgICAgICAgLy8gb2YgdGhlIEVTIDUuMSBzcGVjKS4gVGhlIHBhcmVudGhlc2l6ZWQgZXhwcmVzc2lvbiBwcmV2ZW50cyBhblxuICAgICAgICAgICAgICAvLyB1bnNhZmUgdHJhbnNmb3JtYXRpb24gYnkgdGhlIENsb3N1cmUgQ29tcGlsZXIuXG4gICAgICAgICAgICAgIHZhciBvcmlnaW5hbCA9IHRoaXMuX19wcm90b19fLCByZXN1bHQgPSBwcm9wZXJ0eSBpbiAodGhpcy5fX3Byb3RvX18gPSBudWxsLCB0aGlzKTtcbiAgICAgICAgICAgICAgLy8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvdG90eXBlIGNoYWluLlxuICAgICAgICAgICAgICB0aGlzLl9fcHJvdG9fXyA9IG9yaWdpbmFsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2FwdHVyZSBhIHJlZmVyZW5jZSB0byB0aGUgdG9wLWxldmVsIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgICAgICAgICAgY29uc3RydWN0b3IgPSBtZW1iZXJzLmNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgLy8gVXNlIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IHRvIHNpbXVsYXRlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGluXG4gICAgICAgICAgICAvLyBvdGhlciBlbnZpcm9ubWVudHMuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIHZhciBwYXJlbnQgPSAodGhpcy5jb25zdHJ1Y3RvciB8fCBjb25zdHJ1Y3RvcikucHJvdG90eXBlO1xuICAgICAgICAgICAgICByZXR1cm4gcHJvcGVydHkgaW4gdGhpcyAmJiAhKHByb3BlcnR5IGluIHBhcmVudCAmJiB0aGlzW3Byb3BlcnR5XSA9PT0gcGFyZW50W3Byb3BlcnR5XSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBtZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gaXNQcm9wZXJ0eS5jYWxsKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gSW50ZXJuYWw6IE5vcm1hbGl6ZXMgdGhlIGBmb3IuLi5pbmAgaXRlcmF0aW9uIGFsZ29yaXRobSBhY3Jvc3NcbiAgICAgIC8vIGVudmlyb25tZW50cy4gRWFjaCBlbnVtZXJhdGVkIGtleSBpcyB5aWVsZGVkIHRvIGEgYGNhbGxiYWNrYCBmdW5jdGlvbi5cbiAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgc2l6ZSA9IDAsIFByb3BlcnRpZXMsIG1lbWJlcnMsIHByb3BlcnR5O1xuXG4gICAgICAgIC8vIFRlc3RzIGZvciBidWdzIGluIHRoZSBjdXJyZW50IGVudmlyb25tZW50J3MgYGZvci4uLmluYCBhbGdvcml0aG0uIFRoZVxuICAgICAgICAvLyBgdmFsdWVPZmAgcHJvcGVydHkgaW5oZXJpdHMgdGhlIG5vbi1lbnVtZXJhYmxlIGZsYWcgZnJvbVxuICAgICAgICAvLyBgT2JqZWN0LnByb3RvdHlwZWAgaW4gb2xkZXIgdmVyc2lvbnMgb2YgSUUsIE5ldHNjYXBlLCBhbmQgTW96aWxsYS5cbiAgICAgICAgKFByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGhpcy52YWx1ZU9mID0gMDtcbiAgICAgICAgfSkucHJvdG90eXBlLnZhbHVlT2YgPSAwO1xuXG4gICAgICAgIC8vIEl0ZXJhdGUgb3ZlciBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgYFByb3BlcnRpZXNgIGNsYXNzLlxuICAgICAgICBtZW1iZXJzID0gbmV3IFByb3BlcnRpZXMoKTtcbiAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBtZW1iZXJzKSB7XG4gICAgICAgICAgLy8gSWdub3JlIGFsbCBwcm9wZXJ0aWVzIGluaGVyaXRlZCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC5cbiAgICAgICAgICBpZiAoaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgc2l6ZSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBQcm9wZXJ0aWVzID0gbWVtYmVycyA9IG51bGw7XG5cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBpdGVyYXRpb24gYWxnb3JpdGhtLlxuICAgICAgICBpZiAoIXNpemUpIHtcbiAgICAgICAgICAvLyBBIGxpc3Qgb2Ygbm9uLWVudW1lcmFibGUgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgbWVtYmVycyA9IFtcInZhbHVlT2ZcIiwgXCJ0b1N0cmluZ1wiLCBcInRvTG9jYWxlU3RyaW5nXCIsIFwicHJvcGVydHlJc0VudW1lcmFibGVcIiwgXCJpc1Byb3RvdHlwZU9mXCIsIFwiaGFzT3duUHJvcGVydHlcIiwgXCJjb25zdHJ1Y3RvclwiXTtcbiAgICAgICAgICAvLyBJRSA8PSA4LCBNb3ppbGxhIDEuMCwgYW5kIE5ldHNjYXBlIDYuMiBpZ25vcmUgc2hhZG93ZWQgbm9uLWVudW1lcmFibGVcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGlzRnVuY3Rpb24gPSBnZXRDbGFzcy5jYWxsKG9iamVjdCkgPT0gZnVuY3Rpb25DbGFzcywgcHJvcGVydHksIGxlbmd0aDtcbiAgICAgICAgICAgIHZhciBoYXNQcm9wZXJ0eSA9ICFpc0Z1bmN0aW9uICYmIHR5cGVvZiBvYmplY3QuY29uc3RydWN0b3IgIT0gXCJmdW5jdGlvblwiICYmIG9iamVjdFR5cGVzW3R5cGVvZiBvYmplY3QuaGFzT3duUHJvcGVydHldICYmIG9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBpc1Byb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gR2Vja28gPD0gMS4wIGVudW1lcmF0ZXMgdGhlIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyB1bmRlclxuICAgICAgICAgICAgICAvLyBjZXJ0YWluIGNvbmRpdGlvbnM7IElFIGRvZXMgbm90LlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmIGhhc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIGVhY2ggbm9uLWVudW1lcmFibGUgcHJvcGVydHkuXG4gICAgICAgICAgICBmb3IgKGxlbmd0aCA9IG1lbWJlcnMubGVuZ3RoOyBwcm9wZXJ0eSA9IG1lbWJlcnNbLS1sZW5ndGhdOyBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmIGNhbGxiYWNrKHByb3BlcnR5KSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmIChzaXplID09IDIpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgPD0gMi4wLjQgZW51bWVyYXRlcyBzaGFkb3dlZCBwcm9wZXJ0aWVzIHR3aWNlLlxuICAgICAgICAgIGZvckVhY2ggPSBmdW5jdGlvbiAob2JqZWN0LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgc2V0IG9mIGl0ZXJhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IHt9LCBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5O1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgLy8gU3RvcmUgZWFjaCBwcm9wZXJ0eSBuYW1lIHRvIHByZXZlbnQgZG91YmxlIGVudW1lcmF0aW9uLiBUaGVcbiAgICAgICAgICAgICAgLy8gYHByb3RvdHlwZWAgcHJvcGVydHkgb2YgZnVuY3Rpb25zIGlzIG5vdCBlbnVtZXJhdGVkIGR1ZSB0byBjcm9zcy1cbiAgICAgICAgICAgICAgLy8gZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgICBpZiAoIShpc0Z1bmN0aW9uICYmIHByb3BlcnR5ID09IFwicHJvdG90eXBlXCIpICYmICFpc1Byb3BlcnR5LmNhbGwobWVtYmVycywgcHJvcGVydHkpICYmIChtZW1iZXJzW3Byb3BlcnR5XSA9IDEpICYmIGlzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gYnVncyBkZXRlY3RlZDsgdXNlIHRoZSBzdGFuZGFyZCBgZm9yLi4uaW5gIGFsZ29yaXRobS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBpc0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgZm9yIChwcm9wZXJ0eSBpbiBvYmplY3QpIHtcbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkgJiYgIShpc0NvbnN0cnVjdG9yID0gcHJvcGVydHkgPT09IFwiY29uc3RydWN0b3JcIikpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE1hbnVhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgZm9yIHRoZSBgY29uc3RydWN0b3JgIHByb3BlcnR5IGR1ZSB0b1xuICAgICAgICAgICAgLy8gY3Jvc3MtZW52aXJvbm1lbnQgaW5jb25zaXN0ZW5jaWVzLlxuICAgICAgICAgICAgaWYgKGlzQ29uc3RydWN0b3IgfHwgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgKHByb3BlcnR5ID0gXCJjb25zdHJ1Y3RvclwiKSkpIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZvckVhY2gob2JqZWN0LCBjYWxsYmFjayk7XG4gICAgICB9O1xuXG4gICAgICAvLyBQdWJsaWM6IFNlcmlhbGl6ZXMgYSBKYXZhU2NyaXB0IGB2YWx1ZWAgYXMgYSBKU09OIHN0cmluZy4gVGhlIG9wdGlvbmFsXG4gICAgICAvLyBgZmlsdGVyYCBhcmd1bWVudCBtYXkgc3BlY2lmeSBlaXRoZXIgYSBmdW5jdGlvbiB0aGF0IGFsdGVycyBob3cgb2JqZWN0IGFuZFxuICAgICAgLy8gYXJyYXkgbWVtYmVycyBhcmUgc2VyaWFsaXplZCwgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBhbmQgbnVtYmVycyB0aGF0XG4gICAgICAvLyBpbmRpY2F0ZXMgd2hpY2ggcHJvcGVydGllcyBzaG91bGQgYmUgc2VyaWFsaXplZC4gVGhlIG9wdGlvbmFsIGB3aWR0aGBcbiAgICAgIC8vIGFyZ3VtZW50IG1heSBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVtYmVyIHRoYXQgc3BlY2lmaWVzIHRoZSBpbmRlbnRhdGlvblxuICAgICAgLy8gbGV2ZWwgb2YgdGhlIG91dHB1dC5cbiAgICAgIGlmICghaGFzKFwianNvbi1zdHJpbmdpZnlcIikpIHtcbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGNvbnRyb2wgY2hhcmFjdGVycyBhbmQgdGhlaXIgZXNjYXBlZCBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIEVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFxcXFxcIixcbiAgICAgICAgICAzNDogJ1xcXFxcIicsXG4gICAgICAgICAgODogXCJcXFxcYlwiLFxuICAgICAgICAgIDEyOiBcIlxcXFxmXCIsXG4gICAgICAgICAgMTA6IFwiXFxcXG5cIixcbiAgICAgICAgICAxMzogXCJcXFxcclwiLFxuICAgICAgICAgIDk6IFwiXFxcXHRcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBDb252ZXJ0cyBgdmFsdWVgIGludG8gYSB6ZXJvLXBhZGRlZCBzdHJpbmcgc3VjaCB0aGF0IGl0c1xuICAgICAgICAvLyBsZW5ndGggaXMgYXQgbGVhc3QgZXF1YWwgdG8gYHdpZHRoYC4gVGhlIGB3aWR0aGAgbXVzdCBiZSA8PSA2LlxuICAgICAgICB2YXIgbGVhZGluZ1plcm9lcyA9IFwiMDAwMDAwXCI7XG4gICAgICAgIHZhciB0b1BhZGRlZFN0cmluZyA9IGZ1bmN0aW9uICh3aWR0aCwgdmFsdWUpIHtcbiAgICAgICAgICAvLyBUaGUgYHx8IDBgIGV4cHJlc3Npb24gaXMgbmVjZXNzYXJ5IHRvIHdvcmsgYXJvdW5kIGEgYnVnIGluXG4gICAgICAgICAgLy8gT3BlcmEgPD0gNy41NHUyIHdoZXJlIGAwID09IC0wYCwgYnV0IGBTdHJpbmcoLTApICE9PSBcIjBcImAuXG4gICAgICAgICAgcmV0dXJuIChsZWFkaW5nWmVyb2VzICsgKHZhbHVlIHx8IDApKS5zbGljZSgtd2lkdGgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBEb3VibGUtcXVvdGVzIGEgc3RyaW5nIGB2YWx1ZWAsIHJlcGxhY2luZyBhbGwgQVNDSUkgY29udHJvbFxuICAgICAgICAvLyBjaGFyYWN0ZXJzIChjaGFyYWN0ZXJzIHdpdGggY29kZSB1bml0IHZhbHVlcyBiZXR3ZWVuIDAgYW5kIDMxKSB3aXRoXG4gICAgICAgIC8vIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBRdW90ZSh2YWx1ZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIHZhciB1bmljb2RlUHJlZml4ID0gXCJcXFxcdTAwXCI7XG4gICAgICAgIHZhciBxdW90ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHZhciByZXN1bHQgPSAnXCInLCBpbmRleCA9IDAsIGxlbmd0aCA9IHZhbHVlLmxlbmd0aCwgdXNlQ2hhckluZGV4ID0gIWNoYXJJbmRleEJ1Z2d5IHx8IGxlbmd0aCA+IDEwO1xuICAgICAgICAgIHZhciBzeW1ib2xzID0gdXNlQ2hhckluZGV4ICYmIChjaGFySW5kZXhCdWdneSA/IHZhbHVlLnNwbGl0KFwiXCIpIDogdmFsdWUpO1xuICAgICAgICAgIGZvciAoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIGNoYXJDb2RlID0gdmFsdWUuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgY2hhcmFjdGVyIGlzIGEgY29udHJvbCBjaGFyYWN0ZXIsIGFwcGVuZCBpdHMgVW5pY29kZSBvclxuICAgICAgICAgICAgLy8gc2hvcnRoYW5kIGVzY2FwZSBzZXF1ZW5jZTsgb3RoZXJ3aXNlLCBhcHBlbmQgdGhlIGNoYXJhY3RlciBhcy1pcy5cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA4OiBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTI6IGNhc2UgMTM6IGNhc2UgMzQ6IGNhc2UgOTI6XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IEVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdW5pY29kZVByZWZpeCArIHRvUGFkZGVkU3RyaW5nKDIsIGNoYXJDb2RlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVzZUNoYXJJbmRleCA/IHN5bWJvbHNbaW5kZXhdIDogdmFsdWUuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdCArICdcIic7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZXMgYW4gb2JqZWN0LiBJbXBsZW1lbnRzIHRoZVxuICAgICAgICAvLyBgU3RyKGtleSwgaG9sZGVyKWAsIGBKTyh2YWx1ZSlgLCBhbmQgYEpBKHZhbHVlKWAgb3BlcmF0aW9ucy5cbiAgICAgICAgdmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSwgb2JqZWN0LCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlLCBjbGFzc05hbWUsIHllYXIsIG1vbnRoLCBkYXRlLCB0aW1lLCBob3VycywgbWludXRlcywgc2Vjb25kcywgbWlsbGlzZWNvbmRzLCByZXN1bHRzLCBlbGVtZW50LCBpbmRleCwgbGVuZ3RoLCBwcmVmaXgsIHJlc3VsdDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTmVjZXNzYXJ5IGZvciBob3N0IG9iamVjdCBzdXBwb3J0LlxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3RbcHJvcGVydHldO1xuICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgICAgaWYgKGNsYXNzTmFtZSA9PSBkYXRlQ2xhc3MgJiYgIWlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpIHtcbiAgICAgICAgICAgICAgaWYgKHZhbHVlID4gLTEgLyAwICYmIHZhbHVlIDwgMSAvIDApIHtcbiAgICAgICAgICAgICAgICAvLyBEYXRlcyBhcmUgc2VyaWFsaXplZCBhY2NvcmRpbmcgdG8gdGhlIGBEYXRlI3RvSlNPTmAgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjkuNS40NC4gU2VlIHNlY3Rpb24gMTUuOS4xLjE1XG4gICAgICAgICAgICAgICAgLy8gZm9yIHRoZSBJU08gODYwMSBkYXRlIHRpbWUgc3RyaW5nIGZvcm1hdC5cbiAgICAgICAgICAgICAgICBpZiAoZ2V0RGF5KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBjb21wdXRlIHRoZSB5ZWFyLCBtb250aCwgZGF0ZSwgaG91cnMsIG1pbnV0ZXMsXG4gICAgICAgICAgICAgICAgICAvLyBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGlmIHRoZSBgZ2V0VVRDKmAgbWV0aG9kcyBhcmVcbiAgICAgICAgICAgICAgICAgIC8vIGJ1Z2d5LiBBZGFwdGVkIGZyb20gQFlhZmZsZSdzIGBkYXRlLXNoaW1gIHByb2plY3QuXG4gICAgICAgICAgICAgICAgICBkYXRlID0gZmxvb3IodmFsdWUgLyA4NjRlNSk7XG4gICAgICAgICAgICAgICAgICBmb3IgKHllYXIgPSBmbG9vcihkYXRlIC8gMzY1LjI0MjUpICsgMTk3MCAtIDE7IGdldERheSh5ZWFyICsgMSwgMCkgPD0gZGF0ZTsgeWVhcisrKTtcbiAgICAgICAgICAgICAgICAgIGZvciAobW9udGggPSBmbG9vcigoZGF0ZSAtIGdldERheSh5ZWFyLCAwKSkgLyAzMC40Mik7IGdldERheSh5ZWFyLCBtb250aCArIDEpIDw9IGRhdGU7IG1vbnRoKyspO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IDEgKyBkYXRlIC0gZ2V0RGF5KHllYXIsIG1vbnRoKTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBgdGltZWAgdmFsdWUgc3BlY2lmaWVzIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5IChzZWUgRVNcbiAgICAgICAgICAgICAgICAgIC8vIDUuMSBzZWN0aW9uIDE1LjkuMS4yKS4gVGhlIGZvcm11bGEgYChBICUgQiArIEIpICUgQmAgaXMgdXNlZFxuICAgICAgICAgICAgICAgICAgLy8gdG8gY29tcHV0ZSBgQSBtb2R1bG8gQmAsIGFzIHRoZSBgJWAgb3BlcmF0b3IgZG9lcyBub3RcbiAgICAgICAgICAgICAgICAgIC8vIGNvcnJlc3BvbmQgdG8gdGhlIGBtb2R1bG9gIG9wZXJhdGlvbiBmb3IgbmVnYXRpdmUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICAgIHRpbWUgPSAodmFsdWUgJSA4NjRlNSArIDg2NGU1KSAlIDg2NGU1O1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGhvdXJzLCBtaW51dGVzLCBzZWNvbmRzLCBhbmQgbWlsbGlzZWNvbmRzIGFyZSBvYnRhaW5lZCBieVxuICAgICAgICAgICAgICAgICAgLy8gZGVjb21wb3NpbmcgdGhlIHRpbWUgd2l0aGluIHRoZSBkYXkuIFNlZSBzZWN0aW9uIDE1LjkuMS4xMC5cbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gZmxvb3IodGltZSAvIDM2ZTUpICUgMjQ7XG4gICAgICAgICAgICAgICAgICBtaW51dGVzID0gZmxvb3IodGltZSAvIDZlNCkgJSA2MDtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSBmbG9vcih0aW1lIC8gMWUzKSAlIDYwO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdGltZSAlIDFlMztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgeWVhciA9IHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCk7XG4gICAgICAgICAgICAgICAgICBtb250aCA9IHZhbHVlLmdldFVUQ01vbnRoKCk7XG4gICAgICAgICAgICAgICAgICBkYXRlID0gdmFsdWUuZ2V0VVRDRGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgaG91cnMgPSB2YWx1ZS5nZXRVVENIb3VycygpO1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IHZhbHVlLmdldFVUQ01pbnV0ZXMoKTtcbiAgICAgICAgICAgICAgICAgIHNlY29uZHMgPSB2YWx1ZS5nZXRVVENTZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgICBtaWxsaXNlY29uZHMgPSB2YWx1ZS5nZXRVVENNaWxsaXNlY29uZHMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2VyaWFsaXplIGV4dGVuZGVkIHllYXJzIGNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9ICh5ZWFyIDw9IDAgfHwgeWVhciA+PSAxZTQgPyAoeWVhciA8IDAgPyBcIi1cIiA6IFwiK1wiKSArIHRvUGFkZGVkU3RyaW5nKDYsIHllYXIgPCAwID8gLXllYXIgOiB5ZWFyKSA6IHRvUGFkZGVkU3RyaW5nKDQsIHllYXIpKSArXG4gICAgICAgICAgICAgICAgICBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1vbnRoICsgMSkgKyBcIi1cIiArIHRvUGFkZGVkU3RyaW5nKDIsIGRhdGUpICtcbiAgICAgICAgICAgICAgICAgIC8vIE1vbnRocywgZGF0ZXMsIGhvdXJzLCBtaW51dGVzLCBhbmQgc2Vjb25kcyBzaG91bGQgaGF2ZSB0d29cbiAgICAgICAgICAgICAgICAgIC8vIGRpZ2l0czsgbWlsbGlzZWNvbmRzIHNob3VsZCBoYXZlIHRocmVlLlxuICAgICAgICAgICAgICAgICAgXCJUXCIgKyB0b1BhZGRlZFN0cmluZygyLCBob3VycykgKyBcIjpcIiArIHRvUGFkZGVkU3RyaW5nKDIsIG1pbnV0ZXMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBzZWNvbmRzKSArXG4gICAgICAgICAgICAgICAgICAvLyBNaWxsaXNlY29uZHMgYXJlIG9wdGlvbmFsIGluIEVTIDUuMCwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICAgIFwiLlwiICsgdG9QYWRkZWRTdHJpbmcoMywgbWlsbGlzZWNvbmRzKSArIFwiWlwiO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUudG9KU09OID09IFwiZnVuY3Rpb25cIiAmJiAoKGNsYXNzTmFtZSAhPSBudW1iZXJDbGFzcyAmJiBjbGFzc05hbWUgIT0gc3RyaW5nQ2xhc3MgJiYgY2xhc3NOYW1lICE9IGFycmF5Q2xhc3MpIHx8IGlzUHJvcGVydHkuY2FsbCh2YWx1ZSwgXCJ0b0pTT05cIikpKSB7XG4gICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBhZGRzIG5vbi1zdGFuZGFyZCBgdG9KU09OYCBtZXRob2RzIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBgTnVtYmVyYCwgYFN0cmluZ2AsIGBEYXRlYCwgYW5kIGBBcnJheWAgcHJvdG90eXBlcy4gSlNPTiAzXG4gICAgICAgICAgICAgIC8vIGlnbm9yZXMgYWxsIGB0b0pTT05gIG1ldGhvZHMgb24gdGhlc2Ugb2JqZWN0cyB1bmxlc3MgdGhleSBhcmVcbiAgICAgICAgICAgICAgLy8gZGVmaW5lZCBkaXJlY3RseSBvbiBhbiBpbnN0YW5jZS5cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04ocHJvcGVydHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIElmIGEgcmVwbGFjZW1lbnQgZnVuY3Rpb24gd2FzIHByb3ZpZGVkLCBjYWxsIGl0IHRvIG9idGFpbiB0aGUgdmFsdWVcbiAgICAgICAgICAgIC8vIGZvciBzZXJpYWxpemF0aW9uLlxuICAgICAgICAgICAgdmFsdWUgPSBjYWxsYmFjay5jYWxsKG9iamVjdCwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpO1xuICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYm9vbGVhbkNsYXNzKSB7XG4gICAgICAgICAgICAvLyBCb29sZWFucyBhcmUgcmVwcmVzZW50ZWQgbGl0ZXJhbGx5LlxuICAgICAgICAgICAgcmV0dXJuIFwiXCIgKyB2YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykge1xuICAgICAgICAgICAgLy8gSlNPTiBudW1iZXJzIG11c3QgYmUgZmluaXRlLiBgSW5maW5pdHlgIGFuZCBgTmFOYCBhcmUgc2VyaWFsaXplZCBhc1xuICAgICAgICAgICAgLy8gYFwibnVsbFwiYC5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwID8gXCJcIiArIHZhbHVlIDogXCJudWxsXCI7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIFN0cmluZ3MgYXJlIGRvdWJsZS1xdW90ZWQgYW5kIGVzY2FwZWQuXG4gICAgICAgICAgICByZXR1cm4gcXVvdGUoXCJcIiArIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIG9iamVjdHMgYW5kIGFycmF5cy5cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBjeWNsaWMgc3RydWN0dXJlcy4gVGhpcyBpcyBhIGxpbmVhciBzZWFyY2g7IHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBzdGFjay5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICBpZiAoc3RhY2tbbGVuZ3RoXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBDeWNsaWMgc3RydWN0dXJlcyBjYW5ub3QgYmUgc2VyaWFsaXplZCBieSBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGhlIG9iamVjdCB0byB0aGUgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIFNhdmUgdGhlIGN1cnJlbnQgaW5kZW50YXRpb24gbGV2ZWwgYW5kIGluZGVudCBvbmUgYWRkaXRpb25hbCBsZXZlbC5cbiAgICAgICAgICAgIHByZWZpeCA9IGluZGVudGF0aW9uO1xuICAgICAgICAgICAgaW5kZW50YXRpb24gKz0gd2hpdGVzcGFjZTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgYXJyYXkgZWxlbWVudHMuXG4gICAgICAgICAgICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudCA9IHNlcmlhbGl6ZShpbmRleCwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChlbGVtZW50ID09PSB1bmRlZiA/IFwibnVsbFwiIDogZWxlbWVudCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwiW1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJdXCIgOiAoXCJbXCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJdXCIpKSA6IFwiW11cIjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3QgbWVtYmVycy4gTWVtYmVycyBhcmUgc2VsZWN0ZWQgZnJvbVxuICAgICAgICAgICAgICAvLyBlaXRoZXIgYSB1c2VyLXNwZWNpZmllZCBsaXN0IG9mIHByb3BlcnR5IG5hbWVzLCBvciB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgIC8vIGl0c2VsZi5cbiAgICAgICAgICAgICAgZm9yRWFjaChwcm9wZXJ0aWVzIHx8IHZhbHVlLCBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWxlbWVudCA9IHNlcmlhbGl6ZShwcm9wZXJ0eSwgdmFsdWUsIGNhbGxiYWNrLCBwcm9wZXJ0aWVzLCB3aGl0ZXNwYWNlLCBpbmRlbnRhdGlvbiwgc3RhY2spO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB1bmRlZikge1xuICAgICAgICAgICAgICAgICAgLy8gQWNjb3JkaW5nIHRvIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjM6IFwiSWYgYGdhcGAge3doaXRlc3BhY2V9XG4gICAgICAgICAgICAgICAgICAvLyBpcyBub3QgdGhlIGVtcHR5IHN0cmluZywgbGV0IGBtZW1iZXJgIHtxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIn1cbiAgICAgICAgICAgICAgICAgIC8vIGJlIHRoZSBjb25jYXRlbmF0aW9uIG9mIGBtZW1iZXJgIGFuZCB0aGUgYHNwYWNlYCBjaGFyYWN0ZXIuXCJcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBcImBzcGFjZWAgY2hhcmFjdGVyXCIgcmVmZXJzIHRvIHRoZSBsaXRlcmFsIHNwYWNlXG4gICAgICAgICAgICAgICAgICAvLyBjaGFyYWN0ZXIsIG5vdCB0aGUgYHNwYWNlYCB7d2lkdGh9IGFyZ3VtZW50IHByb3ZpZGVkIHRvXG4gICAgICAgICAgICAgICAgICAvLyBgSlNPTi5zdHJpbmdpZnlgLlxuICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHF1b3RlKHByb3BlcnR5KSArIFwiOlwiICsgKHdoaXRlc3BhY2UgPyBcIiBcIiA6IFwiXCIpICsgZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0cy5sZW5ndGggPyAod2hpdGVzcGFjZSA/IFwie1xcblwiICsgaW5kZW50YXRpb24gKyByZXN1bHRzLmpvaW4oXCIsXFxuXCIgKyBpbmRlbnRhdGlvbikgKyBcIlxcblwiICsgcHJlZml4ICsgXCJ9XCIgOiAoXCJ7XCIgKyByZXN1bHRzLmpvaW4oXCIsXCIpICsgXCJ9XCIpKSA6IFwie31cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgb2JqZWN0IGZyb20gdGhlIHRyYXZlcnNlZCBvYmplY3Qgc3RhY2suXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04uc3RyaW5naWZ5YC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjMuXG4gICAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKHNvdXJjZSwgZmlsdGVyLCB3aWR0aCkge1xuICAgICAgICAgIHZhciB3aGl0ZXNwYWNlLCBjYWxsYmFjaywgcHJvcGVydGllcywgY2xhc3NOYW1lO1xuICAgICAgICAgIGlmIChvYmplY3RUeXBlc1t0eXBlb2YgZmlsdGVyXSAmJiBmaWx0ZXIpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbChmaWx0ZXIpKSA9PSBmdW5jdGlvbkNsYXNzKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrID0gZmlsdGVyO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICAvLyBDb252ZXJ0IHRoZSBwcm9wZXJ0eSBuYW1lcyBhcnJheSBpbnRvIGEgbWFrZXNoaWZ0IHNldC5cbiAgICAgICAgICAgICAgcHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICBmb3IgKHZhciBpbmRleCA9IDAsIGxlbmd0aCA9IGZpbHRlci5sZW5ndGgsIHZhbHVlOyBpbmRleCA8IGxlbmd0aDsgdmFsdWUgPSBmaWx0ZXJbaW5kZXgrK10sICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkpLCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHwgY2xhc3NOYW1lID09IG51bWJlckNsYXNzKSAmJiAocHJvcGVydGllc1t2YWx1ZV0gPSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh3aWR0aCkge1xuICAgICAgICAgICAgaWYgKChjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHdpZHRoKSkgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgYHdpZHRoYCB0byBhbiBpbnRlZ2VyIGFuZCBjcmVhdGUgYSBzdHJpbmcgY29udGFpbmluZ1xuICAgICAgICAgICAgICAvLyBgd2lkdGhgIG51bWJlciBvZiBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICBpZiAoKHdpZHRoIC09IHdpZHRoICUgMSkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZm9yICh3aGl0ZXNwYWNlID0gXCJcIiwgd2lkdGggPiAxMCAmJiAod2lkdGggPSAxMCk7IHdoaXRlc3BhY2UubGVuZ3RoIDwgd2lkdGg7IHdoaXRlc3BhY2UgKz0gXCIgXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PSBzdHJpbmdDbGFzcykge1xuICAgICAgICAgICAgICB3aGl0ZXNwYWNlID0gd2lkdGgubGVuZ3RoIDw9IDEwID8gd2lkdGggOiB3aWR0aC5zbGljZSgwLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiBkaXNjYXJkcyB0aGUgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCBlbXB0eSBzdHJpbmcga2V5c1xuICAgICAgICAgIC8vIChgXCJcImApIG9ubHkgaWYgdGhleSBhcmUgdXNlZCBkaXJlY3RseSB3aXRoaW4gYW4gb2JqZWN0IG1lbWJlciBsaXN0XG4gICAgICAgICAgLy8gKGUuZy4sIGAhKFwiXCIgaW4geyBcIlwiOiAxfSlgKS5cbiAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKFwiXCIsICh2YWx1ZSA9IHt9LCB2YWx1ZVtcIlwiXSA9IHNvdXJjZSwgdmFsdWUpLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgXCJcIiwgW10pO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBQdWJsaWM6IFBhcnNlcyBhIEpTT04gc291cmNlIHN0cmluZy5cbiAgICAgIGlmICghaGFzKFwianNvbi1wYXJzZVwiKSkge1xuICAgICAgICB2YXIgZnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQSBtYXAgb2YgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIHVuZXNjYXBlZFxuICAgICAgICAvLyBlcXVpdmFsZW50cy5cbiAgICAgICAgdmFyIFVuZXNjYXBlcyA9IHtcbiAgICAgICAgICA5MjogXCJcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcIicsXG4gICAgICAgICAgNDc6IFwiL1wiLFxuICAgICAgICAgIDk4OiBcIlxcYlwiLFxuICAgICAgICAgIDExNjogXCJcXHRcIixcbiAgICAgICAgICAxMTA6IFwiXFxuXCIsXG4gICAgICAgICAgMTAyOiBcIlxcZlwiLFxuICAgICAgICAgIDExNDogXCJcXHJcIlxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBTdG9yZXMgdGhlIHBhcnNlciBzdGF0ZS5cbiAgICAgICAgdmFyIEluZGV4LCBTb3VyY2U7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlc2V0cyB0aGUgcGFyc2VyIHN0YXRlIGFuZCB0aHJvd3MgYSBgU3ludGF4RXJyb3JgLlxuICAgICAgICB2YXIgYWJvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHRocm93IFN5bnRheEVycm9yKCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJldHVybnMgdGhlIG5leHQgdG9rZW4sIG9yIGBcIiRcImAgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZFxuICAgICAgICAvLyB0aGUgZW5kIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLiBBIHRva2VuIG1heSBiZSBhIHN0cmluZywgbnVtYmVyLCBgbnVsbGBcbiAgICAgICAgLy8gbGl0ZXJhbCwgb3IgQm9vbGVhbiBsaXRlcmFsLlxuICAgICAgICB2YXIgbGV4ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHZhciBzb3VyY2UgPSBTb3VyY2UsIGxlbmd0aCA9IHNvdXJjZS5sZW5ndGgsIHZhbHVlLCBiZWdpbiwgcG9zaXRpb24sIGlzU2lnbmVkLCBjaGFyQ29kZTtcbiAgICAgICAgICB3aGlsZSAoSW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgc3dpdGNoIChjaGFyQ29kZSkge1xuICAgICAgICAgICAgICBjYXNlIDk6IGNhc2UgMTA6IGNhc2UgMTM6IGNhc2UgMzI6XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB3aGl0ZXNwYWNlIHRva2VucywgaW5jbHVkaW5nIHRhYnMsIGNhcnJpYWdlIHJldHVybnMsIGxpbmVcbiAgICAgICAgICAgICAgICAvLyBmZWVkcywgYW5kIHNwYWNlIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSAxMjM6IGNhc2UgMTI1OiBjYXNlIDkxOiBjYXNlIDkzOiBjYXNlIDU4OiBjYXNlIDQ0OlxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGEgcHVuY3R1YXRvciB0b2tlbiAoYHtgLCBgfWAsIGBbYCwgYF1gLCBgOmAsIG9yIGAsYCkgYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBwb3NpdGlvbi5cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNoYXJJbmRleEJ1Z2d5ID8gc291cmNlLmNoYXJBdChJbmRleCkgOiBzb3VyY2VbSW5kZXhdO1xuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICBjYXNlIDM0OlxuICAgICAgICAgICAgICAgIC8vIGBcImAgZGVsaW1pdHMgYSBKU09OIHN0cmluZzsgYWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kXG4gICAgICAgICAgICAgICAgLy8gYmVnaW4gcGFyc2luZyB0aGUgc3RyaW5nLiBTdHJpbmcgdG9rZW5zIGFyZSBwcmVmaXhlZCB3aXRoIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIgdG8gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHB1bmN0dWF0b3JzIGFuZFxuICAgICAgICAgICAgICAgIC8vIGVuZC1vZi1zdHJpbmcgdG9rZW5zLlxuICAgICAgICAgICAgICAgIGZvciAodmFsdWUgPSBcIkBcIiwgSW5kZXgrKzsgSW5kZXggPCBsZW5ndGg7KSB7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA8IDMyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVuZXNjYXBlZCBBU0NJSSBjb250cm9sIGNoYXJhY3RlcnMgKHRob3NlIHdpdGggYSBjb2RlIHVuaXRcbiAgICAgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGFuIHRoZSBzcGFjZSBjaGFyYWN0ZXIpIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGFyQ29kZSA9PSA5Mikge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIHJldmVyc2Ugc29saWR1cyAoYFxcYCkgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhbiBlc2NhcGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnRyb2wgY2hhcmFjdGVyIChpbmNsdWRpbmcgYFwiYCwgYFxcYCwgYW5kIGAvYCkgb3IgVW5pY29kZVxuICAgICAgICAgICAgICAgICAgICAvLyBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDkyOiBjYXNlIDM0OiBjYXNlIDQ3OiBjYXNlIDk4OiBjYXNlIDExNjogY2FzZSAxMTA6IGNhc2UgMTAyOiBjYXNlIDExNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSBlc2NhcGVkIGNvbnRyb2wgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IFVuZXNjYXBlc1tjaGFyQ29kZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTc6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgXFx1YCBtYXJrcyB0aGUgYmVnaW5uaW5nIG9mIGEgVW5pY29kZSBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIHZhbGlkYXRlIHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm91ci1kaWdpdCBjb2RlIHBvaW50LlxuICAgICAgICAgICAgICAgICAgICAgICAgYmVnaW4gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4ICsgNDsgSW5kZXggPCBwb3NpdGlvbjsgSW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQSB2YWxpZCBzZXF1ZW5jZSBjb21wcmlzZXMgZm91ciBoZXhkaWdpdHMgKGNhc2UtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluc2Vuc2l0aXZlKSB0aGF0IGZvcm0gYSBzaW5nbGUgaGV4YWRlY2ltYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3IHx8IGNoYXJDb2RlID49IDk3ICYmIGNoYXJDb2RlIDw9IDEwMiB8fCBjaGFyQ29kZSA+PSA2NSAmJiBjaGFyQ29kZSA8PSA3MCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJldml2ZSB0aGUgZXNjYXBlZCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBmcm9tQ2hhckNvZGUoXCIweFwiICsgc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludmFsaWQgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQW4gdW5lc2NhcGVkIGRvdWJsZS1xdW90ZSBjaGFyYWN0ZXIgbWFya3MgdGhlIGVuZCBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luID0gSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltaXplIGZvciB0aGUgY29tbW9uIGNhc2Ugd2hlcmUgYSBzdHJpbmcgaXMgdmFsaWQuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjaGFyQ29kZSA+PSAzMiAmJiBjaGFyQ29kZSAhPSA5MiAmJiBjaGFyQ29kZSAhPSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBzdHJpbmcgYXMtaXMuXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDM0KSB7XG4gICAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHRvIHRoZSBuZXh0IGNoYXJhY3RlciBhbmQgcmV0dXJuIHRoZSByZXZpdmVkIHN0cmluZy5cbiAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVudGVybWluYXRlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBudW1iZXJzIGFuZCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgIC8vIEFkdmFuY2UgcGFzdCB0aGUgbmVnYXRpdmUgc2lnbiwgaWYgb25lIGlzIHNwZWNpZmllZC5cbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBhcnNlIGFuIGludGVnZXIgb3IgZmxvYXRpbmctcG9pbnQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KSB7XG4gICAgICAgICAgICAgICAgICAvLyBMZWFkaW5nIHplcm9lcyBhcmUgaW50ZXJwcmV0ZWQgYXMgb2N0YWwgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4ICsgMSkpLCBjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NykpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBvY3RhbCBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaXNTaWduZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBpbnRlZ2VyIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgIGZvciAoOyBJbmRleCA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBJbmRleCsrKTtcbiAgICAgICAgICAgICAgICAgIC8vIEZsb2F0cyBjYW5ub3QgY29udGFpbiBhIGxlYWRpbmcgZGVjaW1hbCBwb2ludDsgaG93ZXZlciwgdGhpc1xuICAgICAgICAgICAgICAgICAgLy8gY2FzZSBpcyBhbHJlYWR5IGFjY291bnRlZCBmb3IgYnkgdGhlIHBhcnNlci5cbiAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChJbmRleCkgPT0gNDYpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb24gPSArK0luZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgZGVjaW1hbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCB0cmFpbGluZyBkZWNpbWFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgSW5kZXggPSBwb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIGV4cG9uZW50cy4gVGhlIGBlYCBkZW5vdGluZyB0aGUgZXhwb25lbnQgaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UtaW5zZW5zaXRpdmUuXG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAxMDEgfHwgY2hhckNvZGUgPT0gNjkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdCgrK0luZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBwYXN0IHRoZSBzaWduIGZvbGxvd2luZyB0aGUgZXhwb25lbnQsIGlmIG9uZSBpc1xuICAgICAgICAgICAgICAgICAgICAvLyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSA0MyB8fCBjaGFyQ29kZSA9PSA0NSkge1xuICAgICAgICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGV4cG9uZW50aWFsIGNvbXBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChwb3NpdGlvbiA9IEluZGV4OyBwb3NpdGlvbiA8IGxlbmd0aCAmJiAoKGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQocG9zaXRpb24pKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpOyBwb3NpdGlvbisrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvc2l0aW9uID09IEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gSWxsZWdhbCBlbXB0eSBleHBvbmVudC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBDb2VyY2UgdGhlIHBhcnNlZCB2YWx1ZSB0byBhIEphdmFTY3JpcHQgbnVtYmVyLlxuICAgICAgICAgICAgICAgICAgcmV0dXJuICtzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQSBuZWdhdGl2ZSBzaWduIG1heSBvbmx5IHByZWNlZGUgbnVtYmVycy5cbiAgICAgICAgICAgICAgICBpZiAoaXNTaWduZWQpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGB0cnVlYCwgYGZhbHNlYCwgYW5kIGBudWxsYCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2Uuc2xpY2UoSW5kZXgsIEluZGV4ICsgNSkgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA1O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDQpID09IFwibnVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICBJbmRleCArPSA0O1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFVucmVjb2duaXplZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXR1cm4gdGhlIHNlbnRpbmVsIGAkYCBjaGFyYWN0ZXIgaWYgdGhlIHBhcnNlciBoYXMgcmVhY2hlZCB0aGUgZW5kXG4gICAgICAgICAgLy8gb2YgdGhlIHNvdXJjZSBzdHJpbmcuXG4gICAgICAgICAgcmV0dXJuIFwiJFwiO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBQYXJzZXMgYSBKU09OIGB2YWx1ZWAgdG9rZW4uXG4gICAgICAgIHZhciBnZXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0cywgaGFzTWVtYmVycztcbiAgICAgICAgICBpZiAodmFsdWUgPT0gXCIkXCIpIHtcbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0LlxuICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAoKGNoYXJJbmRleEJ1Z2d5ID8gdmFsdWUuY2hhckF0KDApIDogdmFsdWVbMF0pID09IFwiQFwiKSB7XG4gICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgc2VudGluZWwgYEBgIGNoYXJhY3Rlci5cbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUGFyc2Ugb2JqZWN0IGFuZCBhcnJheSBsaXRlcmFscy5cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIltcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIGFycmF5LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBhcnJheS5cbiAgICAgICAgICAgICAgcmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgICBmb3IgKDs7IGhhc01lbWJlcnMgfHwgKGhhc01lbWJlcnMgPSB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGV4KCk7XG4gICAgICAgICAgICAgICAgLy8gQSBjbG9zaW5nIHNxdWFyZSBicmFja2V0IG1hcmtzIHRoZSBlbmQgb2YgdGhlIGFycmF5IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGFycmF5IGxpdGVyYWwgY29udGFpbnMgZWxlbWVudHMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdGluZyB0aGUgcHJldmlvdXMgZWxlbWVudCBmcm9tIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJdXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgYCxgIG11c3Qgc2VwYXJhdGUgZWFjaCBhcnJheSBlbGVtZW50LlxuICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbGlzaW9ucyBhbmQgbGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZ2V0KHZhbHVlKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHZhbHVlID09IFwie1wiKSB7XG4gICAgICAgICAgICAgIC8vIFBhcnNlcyBhIEpTT04gb2JqZWN0LCByZXR1cm5pbmcgYSBuZXcgSmF2YVNjcmlwdCBvYmplY3QuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBjdXJseSBicmFjZSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGxpdGVyYWwgY29udGFpbnMgbWVtYmVycywgdGhlIGN1cnJlbnQgdG9rZW5cbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgYmUgYSBjb21tYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgaWYgKGhhc01lbWJlcnMpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJ9XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAvLyBVbmV4cGVjdGVkIHRyYWlsaW5nIGAsYCBpbiBvYmplY3QgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggb2JqZWN0IG1lbWJlci5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTGVhZGluZyBjb21tYXMgYXJlIG5vdCBwZXJtaXR0ZWQsIG9iamVjdCBwcm9wZXJ0eSBuYW1lcyBtdXN0IGJlXG4gICAgICAgICAgICAgICAgLy8gZG91YmxlLXF1b3RlZCBzdHJpbmdzLCBhbmQgYSBgOmAgbXVzdCBzZXBhcmF0ZSBlYWNoIHByb3BlcnR5XG4gICAgICAgICAgICAgICAgLy8gbmFtZSBhbmQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiLFwiIHx8IHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiIHx8IChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSAhPSBcIkBcIiB8fCBsZXgoKSAhPSBcIjpcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0c1t2YWx1ZS5zbGljZSgxKV0gPSBnZXQobGV4KCkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0b2tlbiBlbmNvdW50ZXJlZC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogVXBkYXRlcyBhIHRyYXZlcnNlZCBvYmplY3QgbWVtYmVyLlxuICAgICAgICB2YXIgdXBkYXRlID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnQgPSB3YWxrKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICBpZiAoZWxlbWVudCA9PT0gdW5kZWYpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBzb3VyY2VbcHJvcGVydHldO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzb3VyY2VbcHJvcGVydHldID0gZWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFJlY3Vyc2l2ZWx5IHRyYXZlcnNlcyBhIHBhcnNlZCBKU09OIG9iamVjdCwgaW52b2tpbmcgdGhlXG4gICAgICAgIC8vIGBjYWxsYmFja2AgZnVuY3Rpb24gZm9yIGVhY2ggdmFsdWUuIFRoaXMgaXMgYW4gaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGBXYWxrKGhvbGRlciwgbmFtZSlgIG9wZXJhdGlvbiBkZWZpbmVkIGluIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIHZhciB3YWxrID0gZnVuY3Rpb24gKHNvdXJjZSwgcHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHZhbHVlID0gc291cmNlW3Byb3BlcnR5XSwgbGVuZ3RoO1xuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJvYmplY3RcIiAmJiB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gYGZvckVhY2hgIGNhbid0IGJlIHVzZWQgdG8gdHJhdmVyc2UgYW4gYXJyYXkgaW4gT3BlcmEgPD0gOC41NFxuICAgICAgICAgICAgLy8gYmVjYXVzZSBpdHMgYE9iamVjdCNoYXNPd25Qcm9wZXJ0eWAgaW1wbGVtZW50YXRpb24gcmV0dXJucyBgZmFsc2VgXG4gICAgICAgICAgICAvLyBmb3IgYXJyYXkgaW5kaWNlcyAoZS5nLiwgYCFbMSwgMiwgM10uaGFzT3duUHJvcGVydHkoXCIwXCIpYCkuXG4gICAgICAgICAgICBpZiAoZ2V0Q2xhc3MuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcykge1xuICAgICAgICAgICAgICBmb3IgKGxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgbGVuZ3RoLS07KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBsZW5ndGgsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZm9yRWFjaCh2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlKHZhbHVlLCBwcm9wZXJ0eSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc291cmNlLCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFB1YmxpYzogYEpTT04ucGFyc2VgLiBTZWUgRVMgNS4xIHNlY3Rpb24gMTUuMTIuMi5cbiAgICAgICAgZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzb3VyY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCwgdmFsdWU7XG4gICAgICAgICAgSW5kZXggPSAwO1xuICAgICAgICAgIFNvdXJjZSA9IFwiXCIgKyBzb3VyY2U7XG4gICAgICAgICAgcmVzdWx0ID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAvLyBJZiBhIEpTT04gc3RyaW5nIGNvbnRhaW5zIG11bHRpcGxlIHRva2VucywgaXQgaXMgaW52YWxpZC5cbiAgICAgICAgICBpZiAobGV4KCkgIT0gXCIkXCIpIHtcbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlc2V0IHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgICAgSW5kZXggPSBTb3VyY2UgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBjYWxsYmFjayAmJiBnZXRDbGFzcy5jYWxsKGNhbGxiYWNrKSA9PSBmdW5jdGlvbkNsYXNzID8gd2FsaygodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSByZXN1bHQsIHZhbHVlKSwgXCJcIiwgY2FsbGJhY2spIDogcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydHNbXCJydW5JbkNvbnRleHRcIl0gPSBydW5JbkNvbnRleHQ7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH1cblxuICBpZiAoZnJlZUV4cG9ydHMgJiYgIWlzTG9hZGVyKSB7XG4gICAgLy8gRXhwb3J0IGZvciBDb21tb25KUyBlbnZpcm9ubWVudHMuXG4gICAgcnVuSW5Db250ZXh0KHJvb3QsIGZyZWVFeHBvcnRzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBFeHBvcnQgZm9yIHdlYiBicm93c2VycyBhbmQgSmF2YVNjcmlwdCBlbmdpbmVzLlxuICAgIHZhciBuYXRpdmVKU09OID0gcm9vdC5KU09OLFxuICAgICAgICBwcmV2aW91c0pTT04gPSByb290W1wiSlNPTjNcIl0sXG4gICAgICAgIGlzUmVzdG9yZWQgPSBmYWxzZTtcblxuICAgIHZhciBKU09OMyA9IHJ1bkluQ29udGV4dChyb290LCAocm9vdFtcIkpTT04zXCJdID0ge1xuICAgICAgLy8gUHVibGljOiBSZXN0b3JlcyB0aGUgb3JpZ2luYWwgdmFsdWUgb2YgdGhlIGdsb2JhbCBgSlNPTmAgb2JqZWN0IGFuZFxuICAgICAgLy8gcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgYEpTT04zYCBvYmplY3QuXG4gICAgICBcIm5vQ29uZmxpY3RcIjogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIWlzUmVzdG9yZWQpIHtcbiAgICAgICAgICBpc1Jlc3RvcmVkID0gdHJ1ZTtcbiAgICAgICAgICByb290LkpTT04gPSBuYXRpdmVKU09OO1xuICAgICAgICAgIHJvb3RbXCJKU09OM1wiXSA9IHByZXZpb3VzSlNPTjtcbiAgICAgICAgICBuYXRpdmVKU09OID0gcHJldmlvdXNKU09OID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTjM7XG4gICAgICB9XG4gICAgfSkpO1xuXG4gICAgcm9vdC5KU09OID0ge1xuICAgICAgXCJwYXJzZVwiOiBKU09OMy5wYXJzZSxcbiAgICAgIFwic3RyaW5naWZ5XCI6IEpTT04zLnN0cmluZ2lmeVxuICAgIH07XG4gIH1cblxuICAvLyBFeHBvcnQgZm9yIGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy5cbiAgaWYgKGlzTG9hZGVyKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBKU09OMztcbiAgICB9KTtcbiAgfVxufSkuY2FsbCh0aGlzKTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw4OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIGxvbGNhdGlvbiA9IHJlcXVpcmUoJy4vbG9sY2F0aW9uJylcbiAgLCBxcyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5naWZ5JylcbiAgLCByZWxhdGl2ZXJlID0gL15cXC8oPyFcXC8pLztcblxuLyoqXG4gKiBUaGVzZSBhcmUgdGhlIHBhcnNlIGluc3RydWN0aW9ucyBmb3IgdGhlIFVSTCBwYXJzZXJzLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBpbnN0cnVjdGlvbnMgPSBbXG4gIFsnIycsICdoYXNoJ10sICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBbJz8nLCAncXVlcnknXSwgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWycvLycsICdwcm90b2NvbCcsIDIsIDEsIDFdLCAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvXFw6KFxcZCspJC8sICdwb3J0J10sICAgICAgICAgICAgICAgICAvLyBSZWdFeHAgdGhlIGJhY2suXG4gIFtOYU4sICdob3N0bmFtZScsIHVuZGVmaW5lZCwgMSwgMV0gICAgLy8gU2V0IGxlZnQgb3Zlci5cbl07XG5cbi8qKlxuICogVGhlIGFjdHVhbCBVUkwgaW5zdGFuY2UuIEluc3RlYWQgb2YgcmV0dXJuaW5nIGFuIG9iamVjdCB3ZSd2ZSBvcHRlZC1pbiB0b1xuICogY3JlYXRlIGFuIGFjdHVhbCBjb25zdHJ1Y3RvciBhcyBpdCdzIG11Y2ggbW9yZSBtZW1vcnkgZWZmaWNpZW50IGFuZFxuICogZmFzdGVyIGFuZCBpdCBwbGVhc2VzIG15IENETy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIFVSTCB3ZSB3YW50IHRvIHBhcnNlLlxuICogQHBhcmFtIHtCb29sZWFufGZ1bmN0aW9ufSBwYXJzZXIgUGFyc2VyIGZvciB0aGUgcXVlcnkgc3RyaW5nLlxuICogQHBhcmFtIHtPYmplY3R9IGxvY2F0aW9uIExvY2F0aW9uIGRlZmF1bHRzIGZvciByZWxhdGl2ZSBwYXRocy5cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIFVSTChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBVUkwpKSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcik7XG4gIH1cblxuICB2YXIgcmVsYXRpdmUgPSByZWxhdGl2ZXJlLnRlc3QoYWRkcmVzcylcbiAgICAsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSB7XG4gICAgcGFyc2VyID0gcXMucGFyc2U7XG4gIH1cblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgZm9yICg7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICBpbnN0cnVjdGlvbiA9IGluc3RydWN0aW9uc1tpXTtcbiAgICBwYXJzZSA9IGluc3RydWN0aW9uWzBdO1xuICAgIGtleSA9IGluc3RydWN0aW9uWzFdO1xuXG4gICAgaWYgKHBhcnNlICE9PSBwYXJzZSkge1xuICAgICAgdXJsW2tleV0gPSBhZGRyZXNzO1xuICAgIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiBwYXJzZSkge1xuICAgICAgaWYgKH4oaW5kZXggPSBhZGRyZXNzLmluZGV4T2YocGFyc2UpKSkge1xuICAgICAgICBpZiAoJ251bWJlcicgPT09IHR5cGVvZiBpbnN0cnVjdGlvblsyXSkge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoaW5kZXggKyBpbnN0cnVjdGlvblsyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdXJsW2tleV0gPSBhZGRyZXNzLnNsaWNlKGluZGV4KTtcbiAgICAgICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGluZGV4ID0gcGFyc2UuZXhlYyhhZGRyZXNzKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGFkZHJlc3MubGVuZ3RoIC0gaW5kZXhbMF0ubGVuZ3RoKTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChpbnN0cnVjdGlvblszXSB8fCAoJ3BvcnQnID09PSBrZXkgJiYgcmVsYXRpdmUpID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHtcbiAgICAgIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gIH1cblxuICAvL1xuICAvLyBBbHNvIHBhcnNlIHRoZSBzdXBwbGllZCBxdWVyeSBzdHJpbmcgaW4gdG8gYW4gb2JqZWN0LiBJZiB3ZSdyZSBzdXBwbGllZFxuICAvLyB3aXRoIGEgY3VzdG9tIHBhcnNlciBhcyBmdW5jdGlvbiB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IGJ1aWxkLWluXG4gIC8vIHBhcnNlci5cbiAgLy9cbiAgaWYgKHBhcnNlcikgdXJsLnF1ZXJ5ID0gcGFyc2VyKHVybC5xdWVyeSk7XG5cbiAgLy9cbiAgLy8gV2Ugc2hvdWxkIG5vdCBhZGQgcG9ydCBudW1iZXJzIGlmIHRoZXkgYXJlIGFscmVhZHkgdGhlIGRlZmF1bHQgcG9ydCBudW1iZXJcbiAgLy8gZm9yIGEgZ2l2ZW4gcHJvdG9jb2wuIEFzIHRoZSBob3N0IGFsc28gY29udGFpbnMgdGhlIHBvcnQgbnVtYmVyIHdlJ3JlIGdvaW5nXG4gIC8vIG92ZXJyaWRlIGl0IHdpdGggdGhlIGhvc3RuYW1lIHdoaWNoIGNvbnRhaW5zIG5vIHBvcnQgbnVtYmVyLlxuICAvL1xuICBpZiAoIXJlcXVpcmVkKHVybC5wb3J0LCB1cmwucHJvdG9jb2wpKSB7XG4gICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgdXJsLnBvcnQgPSAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFBhcnNlIGRvd24gdGhlIGBhdXRoYCBmb3IgdGhlIHVzZXJuYW1lIGFuZCBwYXNzd29yZC5cbiAgLy9cbiAgdXJsLnVzZXJuYW1lID0gdXJsLnBhc3N3b3JkID0gJyc7XG4gIGlmICh1cmwuYXV0aCkge1xuICAgIGluc3RydWN0aW9uID0gdXJsLmF1dGguc3BsaXQoJzonKTtcbiAgICB1cmwudXNlcm5hbWUgPSBpbnN0cnVjdGlvblswXSB8fCAnJztcbiAgICB1cmwucGFzc3dvcmQgPSBpbnN0cnVjdGlvblsxXSB8fCAnJztcbiAgfVxuXG4gIC8vXG4gIC8vIFRoZSBocmVmIGlzIGp1c3QgdGhlIGNvbXBpbGVkIHJlc3VsdC5cbiAgLy9cbiAgdXJsLmhyZWYgPSB1cmwudG9TdHJpbmcoKTtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2hhbmdpbmcgcHJvcGVydGllcyBpbiB0aGUgVVJMIGluc3RhbmNlIHRvXG4gKiBpbnN1cmUgdGhhdCB0aGV5IGFsbCBwcm9wYWdhdGUgY29ycmVjdGx5LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wIFByb3BlcnR5IHdlIG5lZWQgdG8gYWRqdXN0LlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIG5ld2x5IGFzc2lnbmVkIHZhbHVlLlxuICogQHJldHVybnMge1VSTH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblVSTC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBpZiAoJ3F1ZXJ5JyA9PT0gcGFydCkge1xuICAgIGlmICgnc3RyaW5nJyA9PT0gdHlwZW9mIHZhbHVlICYmIHZhbHVlLmxlbmd0aCkge1xuICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICB9XG5cbiAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICgncG9ydCcgPT09IHBhcnQpIHtcbiAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgICAgdXJsW3BhcnRdID0gJyc7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWUgKyc6JysgdmFsdWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKCdob3N0bmFtZScgPT09IHBhcnQpIHtcbiAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgIGlmICh1cmwucG9ydCkgdmFsdWUgKz0gJzonKyB1cmwucG9ydDtcbiAgICB1cmwuaG9zdCA9IHZhbHVlO1xuICB9IGVsc2UgaWYgKCdob3N0JyA9PT0gcGFydCkge1xuICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuXG4gICAgaWYgKC9cXDpcXGQrLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnOicpO1xuICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWVbMF07XG4gICAgICB1cmwucG9ydCA9IHZhbHVlWzFdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB1cmxbcGFydF0gPSB2YWx1ZTtcbiAgfVxuXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBiYWNrIGluIHRvIGEgdmFsaWQgYW5kIGZ1bGwgVVJMIHN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmdpZnkgT3B0aW9uYWwgcXVlcnkgc3RyaW5naWZ5IGZ1bmN0aW9uLlxuICogQHJldHVybnMge1N0cmluZ31cbiAqIEBhcGkgcHVibGljXG4gKi9cblVSTC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyhzdHJpbmdpZnkpIHtcbiAgaWYgKCFzdHJpbmdpZnkgfHwgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHN0cmluZ2lmeSkgc3RyaW5naWZ5ID0gcXMuc3RyaW5naWZ5O1xuXG4gIHZhciBxdWVyeVxuICAgICwgdXJsID0gdGhpc1xuICAgICwgcmVzdWx0ID0gdXJsLnByb3RvY29sICsnLy8nO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0bmFtZTtcbiAgaWYgKHVybC5wb3J0KSByZXN1bHQgKz0gJzonKyB1cmwucG9ydDtcblxuICByZXN1bHQgKz0gdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vXG4vLyBFeHBvc2UgdGhlIFVSTCBwYXJzZXIgYW5kIHNvbWUgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgYmUgdXNlZnVsIGZvclxuLy8gb3RoZXJzLlxuLy9cblVSTC5xcyA9IHFzO1xuVVJMLmxvY2F0aW9uID0gbG9sY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBVUkw7XG5cbn0se1wiLi9sb2xjYXRpb25cIjo5MCxcInF1ZXJ5c3RyaW5naWZ5XCI6OTEsXCJyZXF1aXJlcy1wb3J0XCI6OTJ9XSw5MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlc2UgcHJvcGVydGllcyBzaG91bGQgbm90IGJlIGNvcGllZCBvciBpbmhlcml0ZWQgZnJvbS4gVGhpcyBpcyBvbmx5IG5lZWRlZFxuICogZm9yIGFsbCBub24gYmxvYiBVUkwncyBhcyB0aGUgYSBibG9iIFVSTCBkb2VzIG5vdCBpbmNsdWRlIGEgaGFzaCwgb25seSB0aGVcbiAqIG9yaWdpbi5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIGlnbm9yZSA9IHsgaGFzaDogMSwgcXVlcnk6IDEgfVxuICAsIFVSTDtcblxuLyoqXG4gKiBUaGUgbG9jYXRpb24gb2JqZWN0IGRpZmZlcnMgd2hlbiB5b3VyIGNvZGUgaXMgbG9hZGVkIHRocm91Z2ggYSBub3JtYWwgcGFnZSxcbiAqIFdvcmtlciBvciB0aHJvdWdoIGEgd29ya2VyIHVzaW5nIGEgYmxvYi4gQW5kIHdpdGggdGhlIGJsb2JibGUgYmVnaW5zIHRoZVxuICogdHJvdWJsZSBhcyB0aGUgbG9jYXRpb24gb2JqZWN0IHdpbGwgY29udGFpbiB0aGUgVVJMIG9mIHRoZSBibG9iLCBub3QgdGhlXG4gKiBsb2NhdGlvbiBvZiB0aGUgcGFnZSB3aGVyZSBvdXIgY29kZSBpcyBsb2FkZWQgaW4uIFRoZSBhY3R1YWwgb3JpZ2luIGlzXG4gKiBlbmNvZGVkIGluIHRoZSBgcGF0aG5hbWVgIHNvIHdlIGNhbiB0aGFua2Z1bGx5IGdlbmVyYXRlIGEgZ29vZCBcImRlZmF1bHRcIlxuICogbG9jYXRpb24gZnJvbSBpdCBzbyB3ZSBjYW4gZ2VuZXJhdGUgcHJvcGVyIHJlbGF0aXZlIFVSTCdzIGFnYWluLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2MgT3B0aW9uYWwgZGVmYXVsdCBsb2NhdGlvbiBvYmplY3QuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBsb2xjYXRpb24gb2JqZWN0LlxuICogQGFwaSBwdWJsaWNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsb2xjYXRpb24obG9jKSB7XG4gIGxvYyA9IGxvYyB8fCBnbG9iYWwubG9jYXRpb24gfHwge307XG4gIFVSTCA9IFVSTCB8fCByZXF1aXJlKCcuLycpO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVVJMKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkgZm9yIChrZXkgaW4gbG9jKSB7XG4gICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgIGZpbmFsZGVzdGluYXRpb25ba2V5XSA9IGxvY1trZXldO1xuICB9XG5cbiAgcmV0dXJuIGZpbmFsZGVzdGluYXRpb247XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9cIjo4OX1dLDkxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogU2ltcGxlIHF1ZXJ5IHN0cmluZyBwYXJzZXIuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHF1ZXJ5IFRoZSBxdWVyeSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBwYXJzZWQuXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmcocXVlcnkpIHtcbiAgdmFyIHBhcnNlciA9IC8oW149PyZdKyk9KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICAvL1xuICAvLyBMaXR0bGUgbmlmdHkgcGFyc2luZyBoYWNrLCBsZXZlcmFnZSB0aGUgZmFjdCB0aGF0IFJlZ0V4cC5leGVjIGluY3JlbWVudHNcbiAgLy8gdGhlIGxhc3RJbmRleCBwcm9wZXJ0eSBzbyB3ZSBjYW4gY29udGludWUgZXhlY3V0aW5nIHRoaXMgbG9vcCB1bnRpbCB3ZSd2ZVxuICAvLyBwYXJzZWQgYWxsIHJlc3VsdHMuXG4gIC8vXG4gIGZvciAoO1xuICAgIHBhcnQgPSBwYXJzZXIuZXhlYyhxdWVyeSk7XG4gICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChwYXJ0WzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQocGFydFsyXSlcbiAgKTtcblxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBhIHF1ZXJ5IHN0cmluZyB0byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iaiBPYmplY3QgdGhhdCBzaG91bGQgYmUgdHJhbnNmb3JtZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJlZml4IE9wdGlvbmFsIHByZWZpeC5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBxdWVyeXN0cmluZ2lmeShvYmosIHByZWZpeCkge1xuICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgdmFyIHBhaXJzID0gW107XG5cbiAgLy9cbiAgLy8gT3B0aW9uYWxseSBwcmVmaXggd2l0aCBhICc/JyBpZiBuZWVkZWRcbiAgLy9cbiAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJlZml4KSBwcmVmaXggPSAnPyc7XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHBhaXJzLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KGtleSkgKyc9JysgZW5jb2RlVVJJQ29tcG9uZW50KG9ialtrZXldKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhaXJzLmxlbmd0aCA/IHByZWZpeCArIHBhaXJzLmpvaW4oJyYnKSA6ICcnO1xufVxuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuZXhwb3J0cy5zdHJpbmdpZnkgPSBxdWVyeXN0cmluZ2lmeTtcbmV4cG9ydHMucGFyc2UgPSBxdWVyeXN0cmluZztcblxufSx7fV0sOTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrIGlmIHdlJ3JlIHJlcXVpcmVkIHRvIGFkZCBhIHBvcnQgbnVtYmVyLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkZWZhdWx0LXBvcnRcbiAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ30gcG9ydCBQb3J0IG51bWJlciB3ZSBuZWVkIHRvIGNoZWNrXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0LlxuICogQHJldHVybnMge0Jvb2xlYW59IElzIGl0IGEgZGVmYXVsdCBwb3J0IGZvciB0aGUgZ2l2ZW4gcHJvdG9jb2xcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHJlcXVpcmVkKHBvcnQsIHByb3RvY29sKSB7XG4gIHByb3RvY29sID0gcHJvdG9jb2wuc3BsaXQoJzonKVswXTtcbiAgcG9ydCA9ICtwb3J0O1xuXG4gIGlmICghcG9ydCkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaCAocHJvdG9jb2wpIHtcbiAgICBjYXNlICdodHRwJzpcbiAgICBjYXNlICd3cyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDgwO1xuXG4gICAgY2FzZSAnaHR0cHMnOlxuICAgIGNhc2UgJ3dzcyc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDQ0MztcblxuICAgIGNhc2UgJ2Z0cCc6XG4gICAgcmV0dXJuIHBvcnQgIT09IDIyO1xuXG4gICAgY2FzZSAnZ29waGVyJzpcbiAgICByZXR1cm4gcG9ydCAhPT0gNzA7XG5cbiAgICBjYXNlICdmaWxlJzpcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gcG9ydCAhPT0gMDtcbn07XG5cbn0se31dLDkzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJy4vaW5kZXgtY2xpZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvdHJhbnNwb3J0L1NvY2tqcycpO1xufSx7XCIuL2luZGV4LWNsaWVudFwiOjE3LFwiLi9saWIvY2xpZW50L3RyYW5zcG9ydC9Tb2NranNcIjoyN31dLDk0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnJlcXVpcmUoJ2ppaS9kZXBzJyk7XG5yZXF1aXJlKCdqaWktY29tZXQvc29ja2pzJyk7XG5yZXF1aXJlKCdqaWktY29tZXQvbmVhdCcpO1xucmVxdWlyZSgnamlpLWFyLXNxbCcpO1xuXG52YXIgYXBwID0gSmlpLm5hbWVzcGFjZSgnYXBwJyk7XG5cbnJlcXVpcmUoJy4uL21vZGVscy9EZW1vUm93Jyk7XG5cbiQoZnVuY3Rpb24gKCkge1xuXG4gICAgSmlpLmNyZWF0ZVdlYkFwcGxpY2F0aW9uKEppaS5tZXJnZUNvbmZpZ3Moe1xuICAgICAgICBhcHBsaWNhdGlvbjoge1xuICAgICAgICAgICAgYmFzZVBhdGg6ICcvJyxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6IHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBKaWkuYXBwLmNvbWV0XG4gICAgICAgICAgICAgICAgICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQuQ2xpZW50fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvbWV0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0ppaS5jb21ldC5jbGllbnQuQ2xpZW50JyxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyVXJsOiAnaHR0cDovLzEyNy4wLjAuMTozMTAwL3N0YXQvbm9kZS1jb21ldC8wLydcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQG5hbWUgSmlpLmFwcC5uZWF0XG4gICAgICAgICAgICAgICAgICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQuTmVhdENsaWVudH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBuZWF0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0ppaS5jb21ldC5jbGllbnQuTmVhdENsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIGVuZ2luZToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnTmVhdENvbWV0Lk5lYXRDb21ldENsaWVudCdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBAbmFtZSBKaWkuYXBwLmRiXG4gICAgICAgICAgICAgICAgICogQHR5cGUge0ppaS5zcWwucmVtb3RlLkNvbm5lY3Rpb259XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZGI6IHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvbicsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiAnSmlpLnNxbC5yZW1vdGUuU2NoZW1hJ1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSwgd2luZG93LkpJSV9DT05GSUcpKS5zdGFydCgpO1xuXG4gICAgdmFyIHByb2ZpbGUgPSBKaWkuYXBwLm5lYXQub3BlblByb2ZpbGUoJ3Rlc3QnLCB7XG4gICAgICAgIGNhdGVnb3J5OiAnbicsXG4gICAgICAgIGZpbHRlcjogJ25uJ1xuICAgIH0pO1xuXG4gICAgcHJvZmlsZS5nZXRDb2xsZWN0aW9uKCdhbGwnKS5vbihKaWkuYmFzZS5Db2xsZWN0aW9uLkVWRU5UX0NIQU5HRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIEppaS5fLmVhY2goZXZlbnQuYWRkZWQsIGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgJCgnJyArXG4gICAgICAgICAgICAgICAgJzx0ciBkYXRhLWlkPVwiJyArIG1vZGVsLmdldCgnaWQnKSArICdcIj4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyBtb2RlbC5nZXQoJ2lkJykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPjxpbnB1dCBjbGFzcz1cImZvcm0tY29udHJvbFwiIHZhbHVlPVwiJyArIG1vZGVsLmdldCgnc3ViamVjdCcpICsgJ1wiIC8+PC90ZD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyBtb2RlbC5nZXQoJ2tpbmQnKSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+JyArIG1vZGVsLmdldCgnY2F0ZWdvcnknKSArICc8L3RkPicgK1xuICAgICAgICAgICAgICAgICc8dGQ+PGEgaHJlZj1cIiNcIiBjbGFzcz1cImJ0bi1yZW1vdmVcIj54PC9hPjwvdGQ+JyArXG4gICAgICAgICAgICAgICAgJzwvdHI+J1xuICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIC5hcHBlbmRUbygkKCcjZGVtby1yb3dzIHRib2R5JykpXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICdhLmJ0bi1yZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgSmlpLl8uZWFjaChldmVudC5yZW1vdmVkLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICQoJyNkZW1vLXJvd3MgdGJvZHknKS5maW5kKCdbZGF0YS1pZD0nICsgbW9kZWwuZ2V0KCdpZCcpICsgJ10nKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZm9ybSA9ICQoJyNkZW1vLWZvcm0nKTtcblxuICAgIHZhciByYW5kVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JtLmZpbmQoJ1tuYW1lPXN1YmplY3RdJykudmFsKEppaS5fLnJhbmRvbSgxLCAxMDApKTtcbiAgICAgICAgZm9ybS5maW5kKCdbbmFtZT1jYXRlZ29yeV0nKS52YWwoSmlpLl8ucmFuZG9tKDEsIDkpKTtcbiAgICAgICAgZm9ybS5maW5kKCdbbmFtZT1raW5kXScpLnZhbChKaWkuXy5yYW5kb20oMSwgOSkpO1xuICAgIH1cbiAgICByYW5kVmFsdWVzKCk7XG5cbiAgICBmb3JtLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbmV3IGFwcC5tb2RlbHMuRGVtb1Jvdyh7XG4gICAgICAgICAgICBzdWJqZWN0OiBmb3JtLmZpbmQoJ1tuYW1lPXN1YmplY3RdJykudmFsKCksXG4gICAgICAgICAgICBjYXRlZ29yeTogZm9ybS5maW5kKCdbbmFtZT1jYXRlZ29yeV0nKS52YWwoKSxcbiAgICAgICAgICAgIGtpbmQ6IGZvcm0uZmluZCgnW25hbWU9a2luZF0nKS52YWwoKVxuICAgICAgICB9KS5zYXZlKCk7XG5cbiAgICAgICAgcmFuZFZhbHVlcygpO1xuICAgIH0pO1xuXG59KTtcbn0se1wiLi4vbW9kZWxzL0RlbW9Sb3dcIjo5NSxcImppaS1hci1zcWxcIjo5LFwiamlpLWNvbWV0L25lYXRcIjoyOSxcImppaS1jb21ldC9zb2NranNcIjo5MyxcImppaS9kZXBzXCI6MTIzfV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgYXBwLm1vZGVscy5EZW1vUm93XHJcbiAqIEBleHRlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkXHJcbiAqL1xyXG5KaWkuZGVmaW5lQ2xhc3MoJ2FwcC5tb2RlbHMuRGVtb1JvdycsIC8qKiBAbGVuZHMgYXBwLm1vZGVscy5EZW1vUm93LnByb3RvdHlwZSAqL3tcclxuXHJcblx0X19leHRlbmRzOiBKaWkuc3FsLkFjdGl2ZVJlY29yZCxcclxuXHJcblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmNvbWV0LnNlcnZlci5IdWJTZXJ2ZXIgKi97XHJcblxyXG4gICAgICAgIHRhYmxlTmFtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VwX2NvbWV0X3NhbXBsZV9kZW1vX3Jvd3MnO1xyXG4gICAgICAgIH1cclxuXHJcblx0fSxcclxuXHJcbiAgICBydWxlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1snc3ViamVjdCddLCAnc3RyaW5nJywge21heDogMjU1fV0sXHJcbiAgICAgICAgICAgIFtbJ2NhdGVnb3J5JywgJ2tpbmQnXSwgJ3N0cmluZycsIHttYXg6IDF9XVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHtcImppaVwiOjEyNH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdqaWknKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQWN0aXZlUmVjb3JkJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0NvbGxlY3Rpb24nKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvRGF0YVByb3ZpZGVyJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsQXR0cmlidXRlU2NoZW1hJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsU2NoZW1hJyk7XG5yZXF1aXJlKCcuL2xpYi9tb2RlbC9BcnJheURhdGFQcm92aWRlcicpO1xucmVxdWlyZSgnLi9saWIvbW9kZWwvQ2hhbmdlQXR0cmlidXRlRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL21vZGVsL0NoYW5nZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9tb2RlbC9Db2xsZWN0aW9uRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL21vZGVsL0xpbmtNb2RlbEV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL0Jvb2xlYW5WYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvQ29tcGFyZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9EYXRlVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL0RlZmF1bHRWYWx1ZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9FbWFpbFZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9GaWx0ZXJWYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvSW5saW5lVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL051bWJlclZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SYW5nZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SZWd1bGFyRXhwcmVzc2lvblZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SZXF1aXJlZFZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9TYWZlVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL1N0cmluZ1ZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9VcmxWYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvVmFsaWRhdG9yJyk7XG59LHtcIi4vbGliL2Jhc2UvQWN0aXZlUmVjb3JkXCI6OTcsXCIuL2xpYi9iYXNlL0NvbGxlY3Rpb25cIjo5OCxcIi4vbGliL2Jhc2UvRGF0YVByb3ZpZGVyXCI6OTksXCIuL2xpYi9iYXNlL01vZGVsXCI6MTAwLFwiLi9saWIvYmFzZS9Nb2RlbEF0dHJpYnV0ZVNjaGVtYVwiOjEwMSxcIi4vbGliL2Jhc2UvTW9kZWxTY2hlbWFcIjoxMDIsXCIuL2xpYi9tb2RlbC9BcnJheURhdGFQcm92aWRlclwiOjEwMyxcIi4vbGliL21vZGVsL0NoYW5nZUF0dHJpYnV0ZUV2ZW50XCI6MTA0LFwiLi9saWIvbW9kZWwvQ2hhbmdlRXZlbnRcIjoxMDUsXCIuL2xpYi9tb2RlbC9Db2xsZWN0aW9uRXZlbnRcIjoxMDYsXCIuL2xpYi9tb2RlbC9MaW5rTW9kZWxFdmVudFwiOjEwNyxcIi4vbGliL3ZhbGlkYXRvcnMvQm9vbGVhblZhbGlkYXRvclwiOjEwOCxcIi4vbGliL3ZhbGlkYXRvcnMvQ29tcGFyZVZhbGlkYXRvclwiOjEwOSxcIi4vbGliL3ZhbGlkYXRvcnMvRGF0ZVZhbGlkYXRvclwiOjExMCxcIi4vbGliL3ZhbGlkYXRvcnMvRGVmYXVsdFZhbHVlVmFsaWRhdG9yXCI6MTExLFwiLi9saWIvdmFsaWRhdG9ycy9FbWFpbFZhbGlkYXRvclwiOjExMixcIi4vbGliL3ZhbGlkYXRvcnMvRmlsdGVyVmFsaWRhdG9yXCI6MTEzLFwiLi9saWIvdmFsaWRhdG9ycy9JbmxpbmVWYWxpZGF0b3JcIjoxMTQsXCIuL2xpYi92YWxpZGF0b3JzL051bWJlclZhbGlkYXRvclwiOjExNSxcIi4vbGliL3ZhbGlkYXRvcnMvUmFuZ2VWYWxpZGF0b3JcIjoxMTYsXCIuL2xpYi92YWxpZGF0b3JzL1JlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdG9yXCI6MTE3LFwiLi9saWIvdmFsaWRhdG9ycy9SZXF1aXJlZFZhbGlkYXRvclwiOjExOCxcIi4vbGliL3ZhbGlkYXRvcnMvU2FmZVZhbGlkYXRvclwiOjExOSxcIi4vbGliL3ZhbGlkYXRvcnMvU3RyaW5nVmFsaWRhdG9yXCI6MTIwLFwiLi9saWIvdmFsaWRhdG9ycy9VcmxWYWxpZGF0b3JcIjoxMjEsXCIuL2xpYi92YWxpZGF0b3JzL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vTW9kZWwnKTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk1vZGVsXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuQWN0aXZlUmVjb3JkJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuTW9kZWwsXG5cdFxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmQgKi97XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjaW5pdFxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLkV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSByZWNvcmQgaXMgaW5pdGlhbGl6ZWQgdmlhIFtbaW5pdCgpXV0uXG4gICAgICAgICAqL1xuXHRcdEVWRU5UX0lOSVQ6ICdpbml0JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNhZnRlckZpbmRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlY29yZCBpcyBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQgd2l0aCBxdWVyeSByZXN1bHQuXG4gICAgICAgICAqL1xuXHRcdEVWRU5UX0FGVEVSX0ZJTkQ6ICdhZnRlckZpbmQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgbWF5IHNldCBbW0ppaS5iYXNlLk1vZGVsRXZlbnQuaXNWYWxpZF1dIHRvIGJlIGZhbHNlIHRvIHN0b3AgdGhlIGluc2VydGlvbi5cbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNiZWZvcmVJbnNlcnRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5Nb2RlbEV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBiZWZvcmUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuICAgICAgICAgKi9cblx0XHRFVkVOVF9CRUZPUkVfSU5TRVJUOiAnYmVmb3JlSW5zZXJ0JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSByZWNvcmQgaXMgaW5zZXJ0ZWQuXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjYWZ0ZXJJbnNlcnRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9BRlRFUl9JTlNFUlQ6ICdhZnRlckluc2VydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBtYXkgc2V0IFtbTW9kZWxFdmVudC5pc1ZhbGlkXV0gdG8gYmUgZmFsc2UgdG8gc3RvcCB0aGUgdXBkYXRlLlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2JlZm9yZVVwZGF0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLk1vZGVsRXZlbnR9IGV2ZW50IGFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJlZm9yZSB1cGRhdGluZyBhIHJlY29yZC5cbiAgICAgICAgICovXG5cdFx0RVZFTlRfQkVGT1JFX1VQREFURTogJ2JlZm9yZVVwZGF0ZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjYWZ0ZXJVcGRhdGVcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBhZnRlciBhIHJlY29yZCBpcyB1cGRhdGVkLlxuICAgICAgICAgKi9cblx0XHRFVkVOVF9BRlRFUl9VUERBVEU6ICdhZnRlclVwZGF0ZScsXG5cblx0XHQvKipcbiAgICAgICAgICogWW91IG1heSBzZXQgW1tNb2RlbEV2ZW50LmlzVmFsaWRdXSB0byBiZSBmYWxzZSB0byBzdG9wIHRoZSBkZWxldGlvbi5cbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNiZWZvcmVEZWxldGVcblx0XHQgKiBAcHJvcGVydHkge0ppaS5iYXNlLk1vZGVsRXZlbnR9IGV2ZW50IGFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJlZm9yZSBkZWxldGluZyBhIHJlY29yZC5cblx0XHQgKi9cblx0XHRFVkVOVF9CRUZPUkVfREVMRVRFOiAnYmVmb3JlRGVsZXRlJyxcblxuXHRcdC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2FmdGVyRGVsZXRlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSByZWNvcmQgaXMgZGVsZXRlZC5cblx0XHQgKi9cblx0XHRFVkVOVF9BRlRFUl9ERUxFVEU6ICdhZnRlckRlbGV0ZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjbGlua1xuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5tb2RlbC5MaW5rTW9kZWxFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG5cdFx0RVZFTlRfTElOSzogJ2xpbmsnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2xpbms6XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9MSU5LX05BTUU6ICdsaW5rOicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjdW5saW5rXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9VTkxJTks6ICd1bmxpbmsnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI3VubGluazpcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuTGlua01vZGVsRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuXHRcdEVWRU5UX1VOTElOS19OQU1FOiAndW5saW5rOicsXG5cbiAgICAgICAgX21vZGVsU2NoZW1hOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbFNjaGVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtKaWkuc3FsLlRhYmxlU2NoZW1hfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsU2NoZW1hID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZWxTY2hlbWEgPSB0aGlzLm1vZGVsU2NoZW1hKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9tb2RlbFNjaGVtYSBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbFNjaGVtYSA9IEppaS5iYXNlLk1vZGVsU2NoZW1hLmNyZWF0ZUZyb21PYmplY3QodGhpcy5fbW9kZWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlbFNjaGVtYTtcbiAgICAgICAgfSxcblxuICAgICAgICB0YWJsZU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cblx0XHQvKipcblx0XHQgKiBAaW5oZXJpdGRvY1xuXHRcdCAqIEByZXR1cm5zIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IEFjdGl2ZVJlY29yZCBpbnN0YW5jZSBtYXRjaGluZyB0aGUgY29uZGl0aW9uLCBvciBgbnVsbGAgaWYgbm90aGluZyBtYXRjaGVzLlxuXHRcdCAqL1xuXHRcdGZpbmRPbmU6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9maW5kQnlDb25kaXRpb24oY29uZGl0aW9uLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGluaGVyaXRkb2Ncblx0XHQgKiBAcmV0dXJucyB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkW119IGFuIGFycmF5IG9mIEFjdGl2ZVJlY29yZCBpbnN0YW5jZXMsIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vdGhpbmcgbWF0Y2hlcy5cblx0XHQgKi9cblx0XHRmaW5kQWxsOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZmluZEJ5Q29uZGl0aW9uKGNvbmRpdGlvbiwgZmFsc2UpO1xuXHRcdH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBAdG9kb1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGtleSBuYW1lKHMpIGZvciB0aGlzIEFSIGNsYXNzLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHJldHVybiB0aGUgcHJpbWFyeSBrZXkocykgYXMgZGVjbGFyZWRcbiAgICAgICAgICogaW4gdGhlIERCIHRhYmxlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBEQiB0YWJsZSBkb2VzIG5vdCBkZWNsYXJlIGFueSBwcmltYXJ5IGtleSwgeW91IHNob3VsZCBvdmVycmlkZVxuICAgICAgICAgKiB0aGlzIG1ldGhvZCB0byByZXR1cm4gdGhlIGF0dHJpYnV0ZXMgdGhhdCB5b3Ugd2FudCB0byB1c2UgYXMgcHJpbWFyeSBrZXlzXG4gICAgICAgICAqIGZvciB0aGlzIEFSIGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYW4gYXJyYXkgc2hvdWxkIGJlIHJldHVybmVkIGV2ZW4gZm9yIGEgdGFibGUgd2l0aCBzaW5nbGUgcHJpbWFyeSBrZXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdGhlIHByaW1hcnkga2V5cyBvZiB0aGUgYXNzb2NpYXRlZCBkYXRhYmFzZSB0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHByaW1hcnlLZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRhYmxlU2NoZW1hKCkucHJpbWFyeUtleTtcbiAgICAgICAgfSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIEFjdGl2ZVJlY29yZCBpbnN0YW5jZShzKSBieSB0aGUgZ2l2ZW4gY29uZGl0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGludGVybmFsbHkgY2FsbGVkIGJ5IFtbZmluZE9uZSgpXV0gYW5kIFtbZmluZEFsbCgpXV0uXG5cdFx0ICogQHBhcmFtIHsqfSBjb25kaXRpb24gcGxlYXNlIHJlZmVyIHRvIFtbZmluZE9uZSgpXV0gZm9yIHRoZSBleHBsYW5hdGlvbiBvZiB0aGlzIHBhcmFtZXRlclxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb25lIHdoZXRoZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFtbZmluZE9uZSgpXV0gb3IgW1tmaW5kQWxsKCldXVxuXHRcdCAqIEByZXR1cm5zIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR8SmlpLmJhc2UuQWN0aXZlUmVjb3JkW119XG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbn0gaWYgdGhlcmUgaXMgbm8gcHJpbWFyeSBrZXkgZGVmaW5lZFxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdF9maW5kQnlDb25kaXRpb246IGZ1bmN0aW9uIChjb25kaXRpb24sIG9uZSkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gdGhpcy5maW5kKCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShjb25kaXRpb24pIHx8IEppaS5fLmlzT2JqZWN0KGNvbmRpdGlvbikpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbmRpdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJpbWFyeUtleSA9IHRoaXMucHJpbWFyeUtleSgpO1xuXG5cdFx0XHRcdC8vIHF1ZXJ5IGJ5IHByaW1hcnkga2V5XG5cdFx0XHRcdGlmIChwcmltYXJ5S2V5Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgcGsgPSBwcmltYXJ5S2V5WzBdO1xuXHRcdFx0XHRcdGlmICghSmlpLl8uaXNFbXB0eShxdWVyeS5nZXRKb2luKCkpIHx8ICFKaWkuXy5pc0VtcHR5KHF1ZXJ5LmdldEpvaW5XaXRoKCkpKSB7XG5cdFx0XHRcdFx0XHRwayA9IHRoaXMudGFibGVOYW1lKCkgKyAnLicgKyBwaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY29uZGl0aW9uT2JqZWN0ID0ge307XG5cdFx0XHRcdFx0Y29uZGl0aW9uT2JqZWN0W3BrXSA9IGNvbmRpdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gY29uZGl0aW9uT2JqZWN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24odGhpcy5jbGFzc05hbWUoKSArICcgbXVzdCBoYXZlIGEgcHJpbWFyeSBrZXkuJyk7XG5cdFx0XHR9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24oY29uZGl0aW9uKSB7XG5cdFx0XHRcdHF1ZXJ5LmFuZFdoZXJlKGNvbmRpdGlvbik7XG5cblx0XHRcdFx0cmV0dXJuIG9uZSA/IHF1ZXJ5Lm9uZSgpIDogcXVlcnkuYWxsKCk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSB3aG9sZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgYXR0cmlidXRlIHZhbHVlcyBhbmQgY29uZGl0aW9ucy5cblx0XHQgKiBGb3IgZXhhbXBsZSwgdG8gY2hhbmdlIHRoZSBzdGF0dXMgdG8gYmUgMSBmb3IgYWxsIGN1c3RvbWVycyB3aG9zZSBzdGF0dXMgaXMgMjpcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIEN1c3RvbWVyLnVwZGF0ZUFsbCh7c3RhdHVzOiAxfSwgJ3N0YXR1cyA9IDInKTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHNhdmVkIGludG8gdGhlIHRhYmxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZFxuXHRcdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbn0gaWYgbm90IG92ZXJyaWRlZFxuXHRcdCAqL1xuXHRcdHVwZGF0ZUFsbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGNvbmRpdGlvbikge1xuXHRcdFx0Y29uZGl0aW9uID0gY29uZGl0aW9uIHx8ICcnO1xuXG5cdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uKCd1cGRhdGVBbGwoKSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSB3aG9sZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgY291bnRlciBjaGFuZ2VzIGFuZCBjb25kaXRpb25zLlxuXHRcdCAqIEZvciBleGFtcGxlLCB0byBpbmNyZW1lbnQgYWxsIGN1c3RvbWVycycgYWdlIGJ5IDEsXG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci51cGRhdGVBbGxDb3VudGVycyh7YWdlOiAxfSk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1tdfSBjb3VudGVycyB0aGUgY291bnRlcnMgdG8gYmUgdXBkYXRlZCAoYXR0cmlidXRlIG5hbWUgPT4gaW5jcmVtZW50IHZhbHVlKS5cblx0XHQgKiBVc2UgbmVnYXRpdmUgdmFsdWVzIGlmIHlvdSB3YW50IHRvIGRlY3JlbWVudCB0aGUgY291bnRlcnMuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9ufSBpZiBub3Qgb3ZlcnJpZGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlQWxsQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycywgY29uZGl0aW9uKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24oJ3VwZGF0ZUFsbENvdW50ZXJzKCkgaXMgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVsZXRlcyByb3dzIGluIHRoZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy5cblx0XHQgKiBXQVJOSU5HOiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYW55IGNvbmRpdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCBkZWxldGUgQUxMIHJvd3MgaW4gdGhlIHRhYmxlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGRlbGV0ZSBhbGwgY3VzdG9tZXJzIHdob3NlIHN0YXR1cyBpcyAzOlxuXHRcdCAqXG5cdFx0ICogfn5+XG5cdFx0ICogQ3VzdG9tZXIuZGVsZXRlQWxsKCdzdGF0dXMgPSAzJyk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xbXX0gW2NvbmRpdGlvbl0gdGhlIGNvbmRpdGlvbnMgdGhhdCB3aWxsIGJlIHB1dCBpbiB0aGUgV0hFUkUgcGFydCBvZiB0aGUgREVMRVRFIFNRTC5cblx0XHQgKiBQbGVhc2UgcmVmZXIgdG8gW1tRdWVyeS53aGVyZSgpXV0gb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogQHBhcmFtIHtbXX0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgKG5hbWUgPT4gdmFsdWUpIHRvIGJlIGJvdW5kIHRvIHRoZSBxdWVyeS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIHJvd3MgZGVsZXRlZFxuXHRcdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbn0gaWYgbm90IG92ZXJyaWRlZFxuXHRcdCAqL1xuXHRcdGRlbGV0ZUFsbDogZnVuY3Rpb24gKGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24oJ2RlbGV0ZUFsbCgpIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvcHVsYXRlcyBhbiBhY3RpdmUgcmVjb3JkIG9iamVjdCB1c2luZyBhIHJvdyBvZiBkYXRhIGZyb20gdGhlIGRhdGFiYXNlL3N0b3JhZ2UuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCBtZWFudCB0byBiZSBjYWxsZWQgdG8gY3JlYXRlIGFjdGl2ZSByZWNvcmQgb2JqZWN0cyBhZnRlclxuXHRcdCAqIGZldGNoaW5nIGRhdGEgZnJvbSB0aGUgZGF0YWJhc2UuIEl0IGlzIG1haW5seSB1c2VkIGJ5IFtbQWN0aXZlUXVlcnldXSB0byBwb3B1bGF0ZVxuXHRcdCAqIHRoZSBxdWVyeSByZXN1bHRzIGludG8gYWN0aXZlIHJlY29yZHMuXG5cdFx0ICpcblx0XHQgKiBXaGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgbWFudWFsbHkgeW91IHNob3VsZCBjYWxsIFtbYWZ0ZXJGaW5kKCldXSBvbiB0aGUgY3JlYXRlZFxuXHRcdCAqIHJlY29yZCB0byB0cmlnZ2VyIHRoZSBbW0VWRU5UX0FGVEVSX0ZJTkR8YWZ0ZXJGaW5kIEV2ZW50XV0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gcmVjb3JkIHRoZSByZWNvcmQgdG8gYmUgcG9wdWxhdGVkLiBJbiBtb3N0IGNhc2VzIHRoaXMgd2lsbCBiZSBhbiBpbnN0YW5jZVxuXHRcdCAqIGNyZWF0ZWQgYnkgW1tpbnN0YW50aWF0ZSgpXV0gYmVmb3JlaGFuZC5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gcm93IGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUgPT4gdmFsdWUpXG5cdFx0ICovXG5cdFx0cG9wdWxhdGVSZWNvcmQ6IGZ1bmN0aW9uIChyZWNvcmQsIHJvdykge1xuXHRcdFx0dmFyIGNvbHVtbnMgPSByZWNvcmQuYXR0cmlidXRlcygpO1xuXG5cdFx0XHRKaWkuXy5lYWNoKHJvdywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRpZiAoSmlpLl8uaW5kZXhPZihjb2x1bW5zLCBuYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZWNvcmQuX2F0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZWNvcmQuY2FuU2V0UHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRyZWNvcmQuc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cmVjb3JkLnNldE9sZEF0dHJpYnV0ZXMoSmlpLl8uY2xvbmUocmVjb3JkLl9hdHRyaWJ1dGVzKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYW4gYWN0aXZlIHJlY29yZCBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0b2dldGhlciB3aXRoIFtbcG9wdWxhdGVSZWNvcmQoKV1dIGJ5IFtbQWN0aXZlUXVlcnldXS5cblx0XHQgKiBJdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBmb3IgY3JlYXRpbmcgbmV3IHJlY29yZHMoKSBkaXJlY3RseS5cblx0XHQgKlxuXHRcdCAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZWRcblx0XHQgKiBkZXBlbmRzIG9uIHRoZSByb3cgZGF0YSB0byBiZSBwb3B1bGF0ZWQgaW50byB0aGUgcmVjb3JkLlxuXHRcdCAqIEZvciBleGFtcGxlLCBieSBjcmVhdGluZyBhIHJlY29yZCBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgYSBjb2x1bW4sXG5cdFx0ICogeW91IG1heSBpbXBsZW1lbnQgdGhlIHNvLWNhbGxlZCBzaW5nbGUtdGFibGUgaW5oZXJpdGFuY2UgbWFwcGluZy5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gcm93IHJvdyBkYXRhIHRvIGJlIHBvcHVsYXRlZCBpbnRvIHRoZSByZWNvcmQuXG5cdFx0ICogQHJldHVybnMge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gdGhlIG5ld2x5IGNyZWF0ZWQgYWN0aXZlIHJlY29yZFxuXHRcdCAqL1xuXHRcdGluc3RhbnRpYXRlOiBmdW5jdGlvbiAocm93KSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIGF0dHJpYnV0ZXMgcmVwcmVzZW50cyB0aGUgcHJpbWFyeSBrZXkgZm9yIHRoaXMgbW9kZWxcblx0XHQgKiBAcGFyYW0ge1tdfSBrZXlzIHRoZSBzZXQgb2YgYXR0cmlidXRlcyB0byBjaGVja1xuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgYXR0cmlidXRlcyByZXByZXNlbnRzIHRoZSBwcmltYXJ5IGtleSBmb3IgdGhpcyBtb2RlbFxuXHRcdCAqL1xuXHRcdGlzUHJpbWFyeUtleTogZnVuY3Rpb24gKGtleXMpIHtcblx0XHRcdHZhciBwa3MgPSB0aGlzLnByaW1hcnlLZXkoKTtcblxuXHRcdFx0aWYgKGtleXMubGVuZ3RoICE9PSBKaWkuXy5zaXplKHBrcykpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuICAgICAgICAgICAgcmV0dXJuICghSmlpLl8uaXNBcnJheShwa3MpID8gSmlpLl8ua2V5cyhwa3MpIDogcGtzKS5zb3J0KCkudG9TdHJpbmcoKSA9PT0ga2V5cy5zb3J0KCkudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogQHR5cGUge29iamVjdH0gcmVsYXRlZCBtb2RlbHMgaW5kZXhlZCBieSB0aGUgcmVsYXRpb24gbmFtZXNcblx0ICovXG5cdF9yZWxhdGVkOiB7fSxcblxuXHQvKipcblx0ICogQHR5cGUge29iamVjdH1cblx0ICovXG5cdF9yZWxhdGVkTGF6eUV2ZW50czoge30sXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtvYmplY3R8bnVsbH0gb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgaW5kZXhlZCBieSBhdHRyaWJ1dGUgbmFtZXMuXG5cdCAqIFRoaXMgaXMgYG51bGxgIGlmIHRoZSByZWNvcmQgW1tpc05ld1JlY29yZHxpcyBuZXddXS5cblx0ICovXG5cdF9vbGRBdHRyaWJ1dGVzOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgb2JqZWN0LlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgY29uc3RydWN0b3IuXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgdHJpZ2dlciBhbiBbW0VWRU5UX0lOSVRdXSBldmVudC5cblx0ICogSWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLCBtYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBhdCB0aGUgZW5kXG5cdCAqIHRvIGVuc3VyZSB0cmlnZ2VyaW5nIG9mIHRoZSBldmVudC5cblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9JTklUKTtcblxuXHRcdHRoaXMuX19zdXBlcigpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBhIGBoYXMtb25lYCByZWxhdGlvbi5cblx0ICogVGhlIGRlY2xhcmF0aW9uIGlzIHJldHVybmVkIGluIHRlcm1zIG9mIGEgcmVsYXRpb25hbCBbW0FjdGl2ZVF1ZXJ5XV0gaW5zdGFuY2Vcblx0ICogdGhyb3VnaCB3aGljaCB0aGUgcmVsYXRlZCByZWNvcmQgY2FuIGJlIHF1ZXJpZWQgYW5kIHJldHJpZXZlZCBiYWNrLlxuXHQgKlxuXHQgKiBBIGBoYXMtb25lYCByZWxhdGlvbiBtZWFucyB0aGF0IHRoZXJlIGlzIGF0IG1vc3Qgb25lIHJlbGF0ZWQgcmVjb3JkIG1hdGNoaW5nXG5cdCAqIHRoZSBjcml0ZXJpYSBzZXQgYnkgdGhpcyByZWxhdGlvbiwgZS5nLiwgYSBjdXN0b21lciBoYXMgb25lIGNvdW50cnkuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byBkZWNsYXJlIHRoZSBgY291bnRyeWAgcmVsYXRpb24gZm9yIGBDdXN0b21lcmAgY2xhc3MsIHdlIGNhbiB3cml0ZVxuXHQgKiB0aGUgZm9sbG93aW5nIGNvZGUgaW4gdGhlIGBDdXN0b21lcmAgY2xhc3M6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gZ2V0Q291bnRyeSgpXG5cdCAqIHtcbiAgICAgKiAgICAgcmV0dXJuIHRoaXMuaGFzT25lKENvdW50cnkuY2xhc3NOYW1lKCksIHtpZDogJ2NvdW50cnlfaWQnfSk7XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogTm90ZSB0aGF0IGluIHRoZSBhYm92ZSwgdGhlICdpZCcga2V5IGluIHRoZSBgbGlua2AgcGFyYW1ldGVyIHJlZmVycyB0byBhbiBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBpbiB0aGUgcmVsYXRlZCBjbGFzcyBgQ291bnRyeWAsIHdoaWxlIHRoZSAnY291bnRyeV9pZCcgdmFsdWUgcmVmZXJzIHRvIGFuIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIGluIHRoZSBjdXJyZW50IEFSIGNsYXNzLlxuXHQgKlxuXHQgKiBDYWxsIG1ldGhvZHMgZGVjbGFyZWQgaW4gW1tBY3RpdmVRdWVyeV1dIHRvIGZ1cnRoZXIgY3VzdG9taXplIHRoZSByZWxhdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgcmVsYXRlZCByZWNvcmRcblx0ICogQHBhcmFtIHtvYmplY3R9IGxpbmsgdGhlIHByaW1hcnktZm9yZWlnbiBrZXkgY29uc3RyYWludC4gVGhlIGtleXMgb2YgdGhlIGFycmF5IHJlZmVyIHRvXG5cdCAqIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSByZWNvcmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBgY2xhc3NgIG1vZGVsLCB3aGlsZSB0aGUgdmFsdWVzIG9mIHRoZVxuXHQgKiBhcnJheSByZWZlciB0byB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGluICoqdGhpcyoqIEFSIGNsYXNzLlxuXHQgKiBAcmV0dXJucyB7SmlpLnNxbC5BY3RpdmVRdWVyeX0gdGhlIHJlbGF0aW9uYWwgcXVlcnkgb2JqZWN0LlxuXHQgKi9cblx0aGFzT25lOiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBsaW5rKSB7XG5cdFx0LyoqIEB0eXBlZGVmIHtKaWkuc3FsLkFjdGl2ZVJlY29yZH0gY2xhc3NPYmplY3QgKi9cblx0XHR2YXIgY2xhc3NPYmplY3QgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cblx0XHQvKiogQHR5cGVkZWYge0ppaS5kYXRhLkFjdGl2ZVF1ZXJ5fSBxdWVyeSAqL1xuXHRcdHZhciBxdWVyeSA9IGNsYXNzT2JqZWN0LmZpbmQoKTtcblx0XHRxdWVyeS5wcmltYXJ5TW9kZWwgPSB0aGlzO1xuXHRcdHF1ZXJ5LmxpbmsgPSBsaW5rO1xuXHRcdHF1ZXJ5Lm11bHRpcGxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBhIGBoYXMtbWFueWAgcmVsYXRpb24uXG5cdCAqIFRoZSBkZWNsYXJhdGlvbiBpcyByZXR1cm5lZCBpbiB0ZXJtcyBvZiBhIHJlbGF0aW9uYWwgW1tBY3RpdmVRdWVyeV1dIGluc3RhbmNlXG5cdCAqIHRocm91Z2ggd2hpY2ggdGhlIHJlbGF0ZWQgcmVjb3JkIGNhbiBiZSBxdWVyaWVkIGFuZCByZXRyaWV2ZWQgYmFjay5cblx0ICpcblx0ICogQSBgaGFzLW1hbnlgIHJlbGF0aW9uIG1lYW5zIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHJlbGF0ZWQgcmVjb3JkcyBtYXRjaGluZ1xuXHQgKiB0aGUgY3JpdGVyaWEgc2V0IGJ5IHRoaXMgcmVsYXRpb24sIGUuZy4sIGEgY3VzdG9tZXIgaGFzIG1hbnkgb3JkZXJzLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZGVjbGFyZSB0aGUgYG9yZGVyc2AgcmVsYXRpb24gZm9yIGBDdXN0b21lcmAgY2xhc3MsIHdlIGNhbiB3cml0ZVxuXHQgKiB0aGUgZm9sbG93aW5nIGNvZGUgaW4gdGhlIGBDdXN0b21lcmAgY2xhc3M6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gZ2V0T3JkZXJzKClcblx0ICoge1xuXHRcdCAqICAgICByZXR1cm4gdGhpcy5oYXNNYW55KE9yZGVyLmNsYXNzTmFtZSgpLCB7Y3VzdG9tZXJfaWQ6ICdpZCd9KTtcblx0XHQgKiB9XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaW4gdGhlIGFib3ZlLCB0aGUgJ2N1c3RvbWVyX2lkJyBrZXkgaW4gdGhlIGBsaW5rYCBwYXJhbWV0ZXIgcmVmZXJzIHRvXG5cdCAqIGFuIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSByZWxhdGVkIGNsYXNzIGBPcmRlcmAsIHdoaWxlIHRoZSAnaWQnIHZhbHVlIHJlZmVycyB0b1xuXHQgKiBhbiBhdHRyaWJ1dGUgbmFtZSBpbiB0aGUgY3VycmVudCBBUiBjbGFzcy5cblx0ICpcblx0ICogQ2FsbCBtZXRob2RzIGRlY2xhcmVkIGluIFtbQWN0aXZlUXVlcnldXSB0byBmdXJ0aGVyIGN1c3RvbWl6ZSB0aGUgcmVsYXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHJlbGF0ZWQgcmVjb3JkXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsaW5rIHRoZSBwcmltYXJ5LWZvcmVpZ24ga2V5IGNvbnN0cmFpbnQuIFRoZSBrZXlzIG9mIHRoZSBhcnJheSByZWZlciB0b1xuXHQgKiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgcmVjb3JkIGFzc29jaWF0ZWQgd2l0aCB0aGUgYGNsYXNzYCBtb2RlbCwgd2hpbGUgdGhlIHZhbHVlcyBvZiB0aGVcblx0ICogYXJyYXkgcmVmZXIgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlcyBpbiAqKnRoaXMqKiBBUiBjbGFzcy5cblx0ICogQHJldHVybnMge0ppaS5zcWwuQWN0aXZlUXVlcnl9IHRoZSByZWxhdGlvbmFsIHF1ZXJ5IG9iamVjdC5cblx0ICovXG5cdGhhc01hbnk6IGZ1bmN0aW9uIChjbGFzc05hbWUsIGxpbmspIHtcblx0XHQvKiogQHR5cGUge2NsYXNzfSBBY3RpdmVSZWNvcmRJbnRlcmZhY2UgKi9cblx0XHR2YXIgY2xhc3NPYmplY3QgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cblx0XHQvKiogQHR5cGUge0ppaS5zcWwuQWN0aXZlUXVlcnl9ICovXG5cdFx0dmFyIHF1ZXJ5ID0gY2xhc3NPYmplY3QuZmluZCgpO1xuXHRcdHF1ZXJ5LnByaW1hcnlNb2RlbCA9IHRoaXM7XG5cdFx0cXVlcnkubGluayA9IGxpbms7XG5cdFx0cXVlcnkubXVsdGlwbGUgPSB0cnVlO1xuXHRcdHJldHVybiBxdWVyeTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0aWYgKHRoaXMuX3JlbGF0ZWRbbmFtZV0pIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVsYXRlZFtuYW1lXSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblx0XHRpZiAocmVsYXRpb24gaW5zdGFuY2VvZiBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm4gcmVsYXRpb24uZmluZEZvcihuYW1lLCB0aGlzKS50aGVuKGZ1bmN0aW9uKG1vZGVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgcmVsYXRpb24ubXVsdGlwbGUgPyBuZXcgSmlpLmJhc2UuQ29sbGVjdGlvbihtb2RlbHMsIHttb2RlbENsYXNzOiByZWxhdGlvbi5tb2RlbENsYXNzfSkgOiBtb2RlbHMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVsYXRlZFtuYW1lXTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbGF0aW9uO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3B1bGF0ZXMgdGhlIG5hbWVkIHJlbGF0aW9uIHdpdGggdGhlIHJlbGF0ZWQgcmVjb3Jkcy5cblx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGlmIHRoZSByZWxhdGlvbiBleGlzdHMgb3Igbm90LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcmVsYXRpb24gbmFtZSAoY2FzZS1zZW5zaXRpdmUpXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfEppaS5iYXNlLkFjdGl2ZVJlY29yZFtdfG51bGx9IHJlY29yZHMgdGhlIHJlbGF0ZWQgcmVjb3JkcyB0byBiZSBwb3B1bGF0ZWQgaW50byB0aGUgcmVsYXRpb24uXG5cdCAqL1xuXHRwb3B1bGF0ZVJlbGF0aW9uOiBmdW5jdGlvbiAobmFtZSwgcmVjb3Jkcykge1xuICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIEppaS5fLmlzQXJyYXkocmVjb3JkcykgPyBuZXcgSmlpLmJhc2UuQ29sbGVjdGlvbihyZWNvcmRzKSA6IHJlY29yZHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBuYW1lZCByZWxhdGlvbiBoYXMgYmVlbiBwb3B1bGF0ZWQgd2l0aCByZWNvcmRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcmVsYXRpb24gbmFtZSAoY2FzZS1zZW5zaXRpdmUpXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHJlbGF0aW9uIGhhcyBiZWVuIHBvcHVsYXRlZCB3aXRoIHJlY29yZHMuXG5cdCAqL1xuXHRpc1JlbGF0aW9uUG9wdWxhdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHBvcHVsYXRlZCByZWxhdGVkIHJlY29yZHMuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGFuIGFycmF5IG9mIHJlbGF0ZWQgcmVjb3JkcyBpbmRleGVkIGJ5IHJlbGF0aW9uIG5hbWVzLlxuXHQgKi9cblx0Z2V0UmVsYXRlZFJlY29yZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVsYXRlZDtcblx0fSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbGF0ZWRbbmFtZV0gJiYgcmVsYXRpb24ubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIG5ldyBKaWkuYmFzZS5Db2xsZWN0aW9uKFtdLCB7bW9kZWxDbGFzczogcmVsYXRpb24ubW9kZWxDbGFzc30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxhdGVkW25hbWVdIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWxhdGVkW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZFtuYW1lXS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLmdldFJlbGF0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxzID0gIUppaS5fLmlzQXJyYXkodmFsdWUpID8gW3ZhbHVlXSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIG5ldyBKaWkuYmFzZS5Db2xsZWN0aW9uKG1vZGVscywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxDbGFzczogcmVsYXRpb24ubW9kZWxDbGFzc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jbGFzcyA9IHJlbGF0aW9uLm1vZGVsQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlZGVmIHtKaWkuc3FsLkFjdGl2ZVJlY29yZH0gbW9kZWwgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gX2NsYXNzLmluc3RhbnRpYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnBvcHVsYXRlUmVjb3JkKG1vZGVsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgbW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNBcHBlbmRdXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKSB7XG4gICAgICAgIC8vIE11bHRpcGxlIG5hbWVzIHN1cHBvcnRcbiAgICAgICAgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50TmFtZXMobmFtZSk7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2gobmFtZSwgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIHRoaXMub24obiwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdWIgbW9kZWxzIHN1cHBvcnQ6IGZvb1swXVxuICAgICAgICB2YXIgY29sbGVjdGlvbkZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdENvbGxlY3Rpb24obmFtZSwgdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRSk7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uRm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgY29sbEV2ZW50TmFtZSA9IGNvbGxlY3Rpb25Gb3JtYXQuc3ViTmFtZSB8fCB0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Gb3JtYXQubW9kZWwub24oY29sbEV2ZW50TmFtZSwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb28uYmFyXG4gICAgICAgIHZhciBtb2RlbEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdE1vZGVsKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAobW9kZWxGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbEZvcm1hdC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIG1vZGVsRm9ybWF0Lm1vZGVsLm9uKG1vZGVsRm9ybWF0LnN1Yk5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGF6eSBzdWJzY3JpYmVcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGVkTGF6eUV2ZW50c1ttb2RlbEZvcm1hdC5uYW1lXSA9IHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW21vZGVsRm9ybWF0Lm5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW21vZGVsRm9ybWF0Lm5hbWVdLnB1c2goW21vZGVsRm9ybWF0LnN1Yk5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWxhdGlvbiBzdXBwb3J0XG4gICAgICAgIHZhciByZWxhdGlvbkZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdFJlbGF0aW9uKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAocmVsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGlvbkV2ZW50ID0gcmVsYXRpb25Gb3JtYXQubXVsdGlwbGUgPyBKaWkuYmFzZS5Db2xsZWN0aW9uLkVWRU5UX0NIQU5HRSA6IHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFO1xuICAgICAgICAgICAgaWYgKHJlbGF0aW9uRm9ybWF0Lm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRpb25Gb3JtYXQubW9kZWwub24ocmVsYXRpb25FdmVudCwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IHN1YnNjcmliZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdID0gdGhpcy5fcmVsYXRlZExhenlFdmVudHNbcmVsYXRpb25Gb3JtYXQubmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZExhenlFdmVudHNbcmVsYXRpb25Gb3JtYXQubmFtZV0ucHVzaChbcmVsYXRpb25FdmVudCwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihuYW1lLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIE11bHRpcGxlIG5hbWVzIHN1cHBvcnRcbiAgICAgICAgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50TmFtZXMobmFtZSk7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbihuLCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBib29sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1YiBtb2RlbHMgc3VwcG9ydDogZm9vWzBdXG4gICAgICAgIHZhciBjb2xsZWN0aW9uRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0Q29sbGVjdGlvbihuYW1lLCB0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRV9OQU1FKTtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBjb2xsRXZlbnROYW1lID0gY29sbGVjdGlvbkZvcm1hdC5zdWJOYW1lIHx8IHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25Gb3JtYXQubW9kZWwub2ZmKGNvbGxFdmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb28uYmFyXG4gICAgICAgIHZhciBtb2RlbEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdE1vZGVsKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAobW9kZWxGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbEZvcm1hdC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbEZvcm1hdC5tb2RlbC5vZmYobW9kZWxGb3JtYXQuc3ViTmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExhenkgdW5zdWJzY3JpYmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0gPSBKaWkuXy5maWx0ZXIodGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0sIGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyclswXSAhPT0gbW9kZWxGb3JtYXQuc3ViTmFtZSB8fCBhcnJbMV0gIT09IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbGF0aW9uIHN1cHBvcnRcbiAgICAgICAgdmFyIHJlbGF0aW9uRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0UmVsYXRpb24obmFtZSwgdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRSk7XG4gICAgICAgIGlmIChyZWxhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aW9uRXZlbnQgPSByZWxhdGlvbkZvcm1hdC5tdWx0aXBsZSA/IEppaS5iYXNlLkNvbGxlY3Rpb24uRVZFTlRfQ0hBTkdFIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0U7XG4gICAgICAgICAgICBpZiAocmVsYXRpb25Gb3JtYXQubW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVsYXRpb25Gb3JtYXQubW9kZWwub2ZmKHJlbGF0aW9uRXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IHVuc3Vic2NyaWJlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdID0gSmlpLl8uZmlsdGVyKHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdLCBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF0gIT09IHJlbGF0aW9uRXZlbnQgfHwgYXJyWzFdICE9PSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUsIGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdXG4gICAgICogQHJldHVybnMge3ttb2RlbDogSmlpLmJhc2UuQWN0aXZlUmVjb3JkfG51bGwsIG5hbWU6IHN0cmluZ318bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2RldGVjdEtleUZvcm1hdFJlbGF0aW9uOiBmdW5jdGlvbihuYW1lLCBwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gICAgICAgIGlmIChwcmVmaXggJiYgbmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11bHRpcGxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3JlbGF0ZWRbbmFtZV0pIHtcbiAgICAgICAgICAgIG11bHRpcGxlID0gdGhpcy5fcmVsYXRlZFtuYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLkNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpcGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBtdWx0aXBsZSA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSkubXVsdGlwbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0KG5hbWUpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRSZWxhdGVkOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZWxhdGVkW25hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgLy8gQXR0YWNoIGxhenkgZXZlbnRzXG4gICAgICAgIEppaS5fLmVhY2godGhpcy5fcmVsYXRlZExhenlFdmVudHNbbmFtZV0gfHwge30sIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRbbmFtZV0ub24uYXBwbHkodGhpcy5fcmVsYXRlZFtuYW1lXSwgYXJncyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0xJTkssIG5ldyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnQoe1xuICAgICAgICAgICAgcmVsYXRpb25OYW1lOiBuYW1lXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfTElOS19OQU1FICsgbmFtZSwgbmV3IEppaS5tb2RlbC5MaW5rTW9kZWxFdmVudCh7XG4gICAgICAgICAgICByZWxhdGlvbk5hbWU6IG5hbWVcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVSZWxhdGVkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWxhdGVkW25hbWVdO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX1VOTElOSywgbmV3IEppaS5tb2RlbC5MaW5rTW9kZWxFdmVudCh7XG4gICAgICAgICAgICByZWxhdGlvbk5hbWU6IG5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9VTkxJTktfTkFNRSArIG5hbWUsIG5ldyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnQoe1xuICAgICAgICAgICAgcmVsYXRpb25OYW1lOiBuYW1lXG4gICAgICAgIH0pKTtcbiAgICB9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0F0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIG5hbWUpIHx8IEppaS5fLmluZGV4T2YodGhpcy5hdHRyaWJ1dGVzKCksIG5hbWUpICE9PSAtMTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBvbGQgYXR0cmlidXRlIHZhbHVlcyAobmFtZS12YWx1ZSBwYWlycylcblx0ICovXG5cdGdldE9sZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2xkQXR0cmlidXRlcyB8fCB7fTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqIEFsbCBleGlzdGluZyBvbGQgYXR0cmlidXRlIHZhbHVlcyB3aWxsIGJlIGRpc2NhcmRlZC5cblx0ICogQHBhcmFtIHt7fXxudWxsfSB2YWx1ZXMgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gYmUgc2V0LlxuXHQgKiBJZiBzZXQgdG8gYG51bGxgIHRoaXMgcmVjb3JkIGlzIGNvbnNpZGVyZWQgdG8gYmUgW1tpc05ld1JlY29yZHxuZXddXS5cblx0ICovXG5cdHNldE9sZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvbGQgdmFsdWUgb2YgdGhlIG5hbWVkIGF0dHJpYnV0ZS5cblx0ICogSWYgdGhpcyByZWNvcmQgaXMgdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5IGFuZCB0aGUgYXR0cmlidXRlIGlzIG5vdCBsb2FkZWQsXG5cdCAqIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEByZXR1cm5zIHsqfSB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZS4gTnVsbCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBsb2FkZWQgYmVmb3JlXG5cdCAqIG9yIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAc2VlIGhhc0F0dHJpYnV0ZSgpXG5cdCAqL1xuXHRnZXRPbGRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9vbGRBdHRyaWJ1dGVzLCBuYW1lKSA/IHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBvbGQgdmFsdWUgb2YgdGhlIG5hbWVkIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgdGhlIG9sZCBhdHRyaWJ1dGUgdmFsdWUuXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbn0gaWYgdGhlIG5hbWVkIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC5cblx0ICogQHNlZSBoYXNBdHRyaWJ1dGUoKVxuXHQgKi9cblx0c2V0T2xkQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpIHx8IHRoaXMuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG5cdFx0XHRpZiAodGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0ge307XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbih0aGlzLmNsYXNzTmFtZSgpICsgJyBoYXMgbm8gYXR0cmlidXRlIG5hbWVkIFwiJyArIG5hbWUgKyAnXCIuJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1hcmtzIGFuIGF0dHJpYnV0ZSBkaXJ0eS5cblx0ICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCB0byBmb3JjZSB1cGRhdGluZyBhIHJlY29yZCB3aGVuIGNhbGxpbmcgW1t1cGRhdGUoKV1dLFxuXHQgKiBldmVuIGlmIHRoZXJlIGlzIG5vIGNoYW5nZSBiZWluZyBtYWRlIHRvIHRoZSByZWNvcmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKi9cblx0bWFya0F0dHJpYnV0ZURpcnR5OiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBuYW1lZCBhdHRyaWJ1dGUgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIGNoYW5nZWRcblx0ICovXG5cdGlzQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIG5hbWUpICYmIHRoaXMuX29sZEF0dHJpYnV0ZXMgJiYgSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gIUppaS5fLmlzRXF1YWwodGhpcy5fYXR0cmlidXRlc1tuYW1lXSwgdGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9hdHRyaWJ1dGVzLCBuYW1lKSB8fCAodGhpcy5fb2xkQXR0cmlidXRlcyAmJiBKaWkuXy5oYXModGhpcy5fb2xkQXR0cmlidXRlcywgbmFtZSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIG1vZGlmaWVkIHNpbmNlIHRoZXkgYXJlIGxvYWRlZCBvciBzYXZlZCBtb3N0IHJlY2VudGx5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfG51bGx9IG5hbWVzIHRoZSBuYW1lcyBvZiB0aGUgYXR0cmlidXRlcyB3aG9zZSB2YWx1ZXMgbWF5IGJlIHJldHVybmVkIGlmIHRoZXkgYXJlXG5cdCAqIGNoYW5nZWQgcmVjZW50bHkuIElmIG51bGwsIFtbYXR0cmlidXRlcygpXV0gd2lsbCBiZSB1c2VkLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgY2hhbmdlZCBhdHRyaWJ1dGUgdmFsdWVzIChuYW1lLXZhbHVlIHBhaXJzKVxuXHQgKi9cblx0Z2V0RGlydHlBdHRyaWJ1dGVzOiBmdW5jdGlvbiAobmFtZXMpIHtcblx0XHRuYW1lcyA9IG5hbWVzIHx8IG51bGw7XG5cblx0XHRpZiAobmFtZXMgPT09IG51bGwpIHtcblx0XHRcdG5hbWVzID0gdGhpcy5hdHRyaWJ1dGVzKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcblx0XHRKaWkuXy5lYWNoKHRoaXMuX2F0dHJpYnV0ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdGlmIChKaWkuXy5pbmRleE9mKG5hbWVzLCBuYW1lKSA9PT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbCB8fCAhSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpIHx8ICFKaWkuXy5pc0VxdWFsKHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0sIHZhbHVlKSkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdH0sXG5cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgYXR0cmlidXRlIG5hbWVzIG9mIHRoZSBtb2RlbC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCByZXR1cm4gYWxsIGNvbHVtbiBuYW1lcyBvZiB0aGUgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcy5cblx0ICovXG5cdGF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBKaWkuXy5rZXlzKHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKS5jb2x1bW5zKTtcblx0fSxcblxuXHQvKipcblx0ICogU2F2ZXMgdGhlIGN1cnJlbnQgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgW1tpbnNlcnQoKV1dIHdoZW4gW1tpc05ld1JlY29yZF1dIGlzIHRydWUsIG9yIFtbdXBkYXRlKCldXVxuXHQgKiB3aGVuIFtbaXNOZXdSZWNvcmRdXSBpcyBmYWxzZS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRvIHNhdmUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IG5ldyBDdXN0b21lcigpOyAgLy8gb3IgY3VzdG9tZXIgPSBDdXN0b21lci5maW5kT25lKGlkKTtcblx0ICogY3VzdG9tZXIubmFtZSA9IG5hbWU7XG5cdCAqIGN1c3RvbWVyLmVtYWlsID0gZW1haWw7XG5cdCAqIGN1c3RvbWVyLnNhdmUoKTtcblx0ICogfn5+XG5cdCAqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3J1blZhbGlkYXRpb25dIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgc2F2ZWQgdG8gZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IFthdHRyaWJ1dGVOYW1lc10gbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBuZWVkIHRvIGJlIHNhdmVkLiBEZWZhdWx0cyB0byBudWxsLFxuXHQgKiBtZWFuaW5nIGFsbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIGxvYWRlZCBmcm9tIERCIHdpbGwgYmUgc2F2ZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBzYXZpbmcgc3VjY2VlZHNcblx0ICovXG5cdHNhdmU6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVOYW1lcykge1xuXHRcdHJ1blZhbGlkYXRpb24gPSBydW5WYWxpZGF0aW9uICE9PSBmYWxzZTtcblx0XHRhdHRyaWJ1dGVOYW1lcyA9IGF0dHJpYnV0ZU5hbWVzIHx8IG51bGw7XG5cblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnQocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGUocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQgIT09IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnNlcnRzIHRoZSByZWNvcmQgaW50byB0aGUgZGF0YWJhc2UgdXNpbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhpcyByZWNvcmQuXG5cdCAqXG5cdCAqIFVzYWdlIGV4YW1wbGU6XG5cdCAqXG5cdCAqIGBgYHBocFxuXHQgKiAkY3VzdG9tZXIgPSBuZXcgQ3VzdG9tZXI7XG5cdCAqICRjdXN0b21lci0+bmFtZSA9ICRuYW1lO1xuXHQgKiAkY3VzdG9tZXItPmVtYWlsID0gJGVtYWlsO1xuXHQgKiAkY3VzdG9tZXItPmluc2VydCgpO1xuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBydW5WYWxpZGF0aW9uIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgaW5zZXJ0ZWQgaW50byB0aGUgZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVOYW1lcyBsaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHRvIGJlIHNhdmVkLiBEZWZhdWx0cyB0byBudWxsLFxuXHQgKiBtZWFuaW5nIGFsbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIGxvYWRlZCBmcm9tIERCIHdpbGwgYmUgc2F2ZWQuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBhdHRyaWJ1dGVzIGFyZSB2YWxpZCBhbmQgdGhlIHJlY29yZCBpcyBpbnNlcnRlZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRpbnNlcnQ6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVOYW1lcykge1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFNhdmVzIHRoZSBjaGFuZ2VzIHRvIHRoaXMgYWN0aXZlIHJlY29yZCBpbnRvIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlVmFsaWRhdGUoKV1dIHdoZW4gYHJ1blZhbGlkYXRpb25gIGlzIHRydWUuIElmIHZhbGlkYXRpb25cblx0ICogICAgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDIuIGNhbGwgW1thZnRlclZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLlxuXHQgKiAzLiBjYWxsIFtbYmVmb3JlU2F2ZSgpXV0uIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBza2lwIHRoZVxuXHQgKiAgICByZXN0IG9mIHRoZSBzdGVwcztcblx0ICogNC4gc2F2ZSB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfVVBEQVRFXV0sIFtbRVZFTlRfQUZURVJfVVBEQVRFXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byB1cGRhdGUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IEN1c3RvbWVyLmZpbmRPbmUoaWQpO1xuXHQgKiBjdXN0b21lci5uYW1lID0gbmFtZTtcblx0ICogY3VzdG9tZXIuZW1haWwgPSBlbWFpbDtcblx0ICogY3VzdG9tZXIudXBkYXRlKCk7XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIHVwZGF0ZSBkb2VzIG5vdCBhZmZlY3QgYW55IHJvdyBpbiB0aGUgdGFibGUuXG5cdCAqIEluIHRoaXMgY2FzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gMC4gRm9yIHRoaXMgcmVhc29uLCB5b3Ugc2hvdWxkIHVzZSB0aGUgZm9sbG93aW5nXG5cdCAqIGNvZGUgdG8gY2hlY2sgaWYgdXBkYXRlKCkgaXMgc3VjY2Vzc2Z1bCBvciBub3Q6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBpZiAodGhpcy51cGRhdGUoKSAhPT0gZmFsc2UpIHtcbiAgICAgKiAgICAgLy8gdXBkYXRlIHN1Y2Nlc3NmdWxcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgICAvLyB1cGRhdGUgZmFpbGVkXG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbcnVuVmFsaWRhdGlvbl0gd2hldGhlciB0byBwZXJmb3JtIHZhbGlkYXRpb24gYmVmb3JlIHNhdmluZyB0aGUgcmVjb3JkLlxuXHQgKiBJZiB0aGUgdmFsaWRhdGlvbiBmYWlscywgdGhlIHJlY29yZCB3aWxsIG5vdCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBkYXRhYmFzZS5cblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gW2F0dHJpYnV0ZU5hbWVzXSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge1Byb21pc2UuPG51bWJlcnxib29sZWFuPn0gdGhlIG51bWJlciBvZiByb3dzIGFmZmVjdGVkLCBvciBmYWxzZSBpZiB2YWxpZGF0aW9uIGZhaWxzXG5cdCAqIG9yIFtbYmVmb3JlU2F2ZSgpXV0gc3RvcHMgdGhlIHVwZGF0aW5nIHByb2Nlc3MuXG5cdCAqIEB0aHJvd3MgU3RhbGVPYmplY3RFeGNlcHRpb24gaWYgW1tvcHRpbWlzdGljTG9ja3xvcHRpbWlzdGljIGxvY2tpbmddXSBpcyBlbmFibGVkIGFuZCB0aGUgZGF0YVxuXHQgKiBiZWluZyB1cGRhdGVkIGlzIG91dGRhdGVkLlxuXHQgKiBAdGhyb3dzIFxcRXhjZXB0aW9uIGluIGNhc2UgdXBkYXRlIGZhaWxlZC5cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKHJ1blZhbGlkYXRpb24sIGF0dHJpYnV0ZU5hbWVzKSB7XG5cdFx0cnVuVmFsaWRhdGlvbiA9IHJ1blZhbGlkYXRpb24gIT09IGZhbHNlO1xuXHRcdGF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlTmFtZXMgfHwgbnVsbDtcblxuXHRcdHZhciB2YWxpZGF0ZVByb21pc2UgPSBydW5WYWxpZGF0aW9uID8gdGhpcy52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lcykgOiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdFx0cmV0dXJuIHZhbGlkYXRlUHJvbWlzZS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oaXNWYWxpZCkge1xuXHRcdFx0aWYgKCFpc1ZhbGlkKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZUludGVybmFsKGF0dHJpYnV0ZU5hbWVzKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIFtbdXBkYXRlKCldXSB3aGVuIGRhdGEgdmFsaWRhdGlvbiBpcyBub3QgbmVlZGVkXG5cdCAqIGFuZCBvbmx5IGEgc21hbGwgc2V0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZSB1cGRhdGVkLlxuXHQgKlxuXHQgKiBZb3UgbWF5IHNwZWNpZnkgdGhlIGF0dHJpYnV0ZXMgdG8gYmUgdXBkYXRlZCBhcyBuYW1lIGxpc3Qgb3IgbmFtZS12YWx1ZSBwYWlycy5cblx0ICogSWYgdGhlIGxhdHRlciwgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlcyB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZ2x5LlxuXHQgKiBUaGUgbWV0aG9kIHdpbGwgdGhlbiBzYXZlIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcyBpbnRvIGRhdGFiYXNlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCAqKm5vdCoqIHBlcmZvcm0gZGF0YSB2YWxpZGF0aW9uIGFuZCB3aWxsICoqbm90KiogdHJpZ2dlciBldmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7W119IGF0dHJpYnV0ZXMgdGhlIGF0dHJpYnV0ZXMgKG5hbWVzIG9yIG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHVwZGF0ZWRcblx0ICogQHJldHVybnMge1Byb21pc2UuPG51bWJlcj59IHRoZSBudW1iZXIgb2Ygcm93cyBhZmZlY3RlZC5cblx0ICovXG5cdHVwZGF0ZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cdFx0dmFyIGF0dHJzID0gW107XG5cdFx0SmlpLl8uZWFjaChhdHRyaWJ1dGVzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRpZiAoSmlpLl8uaXNOdW1iZXIobmFtZSkpIHtcblx0XHRcdFx0YXR0cnMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdGF0dHJzLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0RGlydHlBdHRyaWJ1dGVzKGF0dHJzKTtcblx0XHRpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDApO1xuXHRcdH1cblxuXHRcdHZhciBvbGRQcmltYXJ5S2V5ID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMudXBkYXRlQWxsKHZhbHVlcywgb2xkUHJpbWFyeUtleSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocm93cykge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZhbHVlcywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0gPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBzZWUgdXBkYXRlKClcblx0ICogQHBhcmFtIHtbXX0gW2F0dHJpYnV0ZXNdIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdCAqIEB0aHJvd3MgU3RhbGVPYmplY3RFeGNlcHRpb25cblx0ICovXG5cdF91cGRhdGVJbnRlcm5hbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgbnVsbDtcblxuXHRcdHZhciB2YWx1ZXMgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXMuYmVmb3JlU2F2ZShmYWxzZSkudGhlbihmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICBpZiAoIWJvb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXREaXJ0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWZ0ZXJTYXZlKGZhbHNlLCB2YWx1ZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRpYy5nZXREYigpLmNyZWF0ZUNvbW1hbmQoKS51cGRhdGVNb2RlbCh0aGlzLCB2YWx1ZXMpO1xuICAgICAgICB9LmJpbmQodGhpcykpLnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbihyb3dzKSB7XG5cblx0XHRcdHZhciBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0SmlpLl8uZWFjaCh2YWx1ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0Y2hhbmdlZEF0dHJpYnV0ZXNbbmFtZV0gPSBKaWkuXy5oYXModGhpcy5fb2xkQXR0cmlidXRlcywgbmFtZSkgPyB0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHRcdFx0dGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fSwgdGhpcykpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hZnRlclNhdmUoZmFsc2UsIGNoYW5nZWRBdHRyaWJ1dGVzKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcm93cztcblx0XHRcdH0pO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBvbmUgb3Igc2V2ZXJhbCBjb3VudGVyIGNvbHVtbnMgZm9yIHRoZSBjdXJyZW50IEFSIG9iamVjdC5cblx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBbW3VwZGF0ZUFsbENvdW50ZXJzKCldXSBpbiB0aGF0IGl0IG9ubHlcblx0ICogc2F2ZXMgY291bnRlcnMgZm9yIHRoZSBjdXJyZW50IEFSIG9iamVjdC5cblx0ICpcblx0ICogQW4gZXhhbXBsZSB1c2FnZSBpcyBhcyBmb2xsb3dzOlxuXHQgKlxuXHQgKiB+fn5cblx0ICogcG9zdCA9IFBvc3QuZmluZE9uZShpZCk7XG5cdCAqIHBvc3QudXBkYXRlQ291bnRlcnMoe3ZpZXdfY291bnQ6IDF9KTtcblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7W119IGNvdW50ZXJzIHRoZSBjb3VudGVycyB0byBiZSB1cGRhdGVkIChhdHRyaWJ1dGUgbmFtZSA9PiBpbmNyZW1lbnQgdmFsdWUpXG5cdCAqIFVzZSBuZWdhdGl2ZSB2YWx1ZXMgaWYgeW91IHdhbnQgdG8gZGVjcmVtZW50IHRoZSBjb3VudGVycy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHNhdmluZyBpcyBzdWNjZXNzZnVsXG5cdCAqIEBzZWUgdXBkYXRlQWxsQ291bnRlcnMoKVxuXHQgKi9cblx0dXBkYXRlQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycykge1xuXHRcdHZhciBvbGRQcmltYXJ5S2V5ID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXHRcdHJldHVybiB0aGlzLl9fc3RhdGljLnVwZGF0ZUFsbENvdW50ZXJzKEppaS5fLmNsb25lKGNvdW50ZXJzKSwgb2xkUHJpbWFyeUtleSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oYWZmZWN0ZWRSb3dzKSB7XG5cdFx0XHRcdGlmIChhZmZlY3RlZFJvd3MgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdEppaS5fLmVhY2goY291bnRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0cmlidXRlc1tuYW1lXSArPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0XHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGUgdGFibGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3RpdmUgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlRGVsZXRlKCldXS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIGZhbHNlLCBpdCB3aWxsIHNraXAgdGhlXG5cdCAqICAgIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBkZWxldGUgdGhlIHJlY29yZCBmcm9tIHRoZSBkYXRhYmFzZTtcblx0ICogMy4gY2FsbCBbW2FmdGVyRGVsZXRlKCldXS5cblx0ICpcblx0ICogSW4gdGhlIGFib3ZlIHN0ZXAgMSBhbmQgMywgZXZlbnRzIG5hbWVkIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGFuZCBbW0VWRU5UX0FGVEVSX0RFTEVURV1dXG5cdCAqIHdpbGwgYmUgcmFpc2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8Ym9vbGVhbn0gdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQsIG9yIGZhbHNlIGlmIHRoZSBkZWxldGlvbiBpcyB1bnN1Y2Nlc3NmdWwgZm9yIHNvbWUgcmVhc29uLlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQgaXMgMCwgZXZlbiB0aG91Z2ggdGhlIGRlbGV0aW9uIGV4ZWN1dGlvbiBpcyBzdWNjZXNzZnVsLlxuXHQgKiBAdGhyb3dzIFN0YWxlT2JqZWN0RXhjZXB0aW9uIGlmIFtbb3B0aW1pc3RpY0xvY2t8b3B0aW1pc3RpYyBsb2NraW5nXV0gaXMgZW5hYmxlZCBhbmQgdGhlIGRhdGFcblx0ICogYmVpbmcgZGVsZXRlZCBpcyBvdXRkYXRlZC5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGRlbGV0ZSBmYWlsZWQuXG5cdCAqL1xuXHRkZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWZvcmVEZWxldGUoKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oYm9vbCkge1xuXHRcdFx0aWYgKCFib29sKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29uZGl0aW9uID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0XHQvLyB3ZSBkbyBub3QgY2hlY2sgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxldGVBbGwoKSBiZWNhdXNlIGl0J3MgcG9zc2libGVcblx0XHRcdC8vIHRoZSByZWNvcmQgaXMgYWxyZWFkeSBkZWxldGVkIGluIHRoZSBkYXRhYmFzZSBhbmQgdGh1cyB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuIDBcblx0XHRcdHJldHVybiB0aGlzLl9fc3RhdGljLmRlbGV0ZUFsbChjb25kaXRpb24pO1xuXHRcdH0sIHRoaXMpKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cblx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXMgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hZnRlckRlbGV0ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9KTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGN1cnJlbnQgcmVjb3JkIGlzIG5ldy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBpcyBuZXcgYW5kKCkgc2hvdWxkIGJlIGluc2VydGVkIHdoZW4gY2FsbGluZyBbW3NhdmUoKV1dLlxuXHQgKi9cblx0aXNOZXdSZWNvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZWNvcmQgaXMgbmV3LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIHdoZXRoZXIgdGhlIHJlY29yZCBpcyBuZXcgYW5kKCkgc2hvdWxkIGJlIGluc2VydGVkIHdoZW4gY2FsbGluZyBbW3NhdmUoKV1dLlxuXHQgKiBAc2VlIGlzTmV3UmVjb3JkKClcblx0ICovXG5cdHNldElzTmV3UmVjb3JkOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0gdmFsdWUgPyBudWxsIDogdGhpcy5fYXR0cmlidXRlcztcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIEFSIG9iamVjdCBpcyBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQgd2l0aCB0aGUgcXVlcnkgcmVzdWx0LlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHRyaWdnZXIgYW4gW1tFVkVOVF9BRlRFUl9GSU5EXV0gZXZlbnQuXG5cdCAqIFdoZW4gb3ZlcnJpZGluZyB0aGlzIG1ldGhvZCwgbWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIHRoZVxuXHQgKiBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdCAqL1xuXHRhZnRlckZpbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9GSU5EKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgaW5zZXJ0aW5nIG9yIHVwZGF0aW5nIGEgcmVjb3JkLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHRyaWdnZXIgYW4gW1tFVkVOVF9CRUZPUkVfSU5TRVJUXV0gZXZlbnQgd2hlbiBgaW5zZXJ0YCBpcyB0cnVlLFxuXHQgKiBvciBhbiBbW0VWRU5UX0JFRk9SRV9VUERBVEVdXSBldmVudCBpZiBgaW5zZXJ0YCBpcyBmYWxzZS5cblx0ICogV2hlbiBvdmVycmlkaW5nIHRoaXMgbWV0aG9kLCBtYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gYmVmb3JlU2F2ZShpbnNlcnQpXG5cdCAqIHtcbiAgICAgKiAgICAgaWYgKHBhcmVudC5iZWZvcmVTYXZlKGluc2VydCkpIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLmN1c3RvbSBjb2RlIGhlcmUuLi5cbiAgICAgKiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnNlcnQgd2hldGhlciB0aGlzIG1ldGhvZCBjYWxsZWQgd2hpbGUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuXHQgKiBJZiBmYWxzZSwgaXQgbWVhbnMgdGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxib29sZWFuPn0gd2hldGhlciB0aGUgaW5zZXJ0aW9uIG9yIHVwZGF0aW5nIHNob3VsZCBjb250aW51ZS5cblx0ICogSWYgZmFsc2UsIHRoZSBpbnNlcnRpb24gb3IgdXBkYXRpbmcgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdCAqL1xuXHRiZWZvcmVTYXZlOiBmdW5jdGlvbiAoaW5zZXJ0KSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IEppaS5iYXNlLk1vZGVsRXZlbnQoKTtcblx0XHR0aGlzLnRyaWdnZXIoaW5zZXJ0ID8gdGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfSU5TRVJUIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfVVBEQVRFLCBldmVudCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV2ZW50LmlzVmFsaWQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiBpbnNlcnRpbmcgb3IgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgdHJpZ2dlciBhbiBbW0VWRU5UX0FGVEVSX0lOU0VSVF1dIGV2ZW50IHdoZW4gYGluc2VydGAgaXMgdHJ1ZSxcblx0ICogb3IgYW4gW1tFVkVOVF9BRlRFUl9VUERBVEVdXSBldmVudCBpZiBgaW5zZXJ0YCBpcyBmYWxzZS4gVGhlIGV2ZW50IGNsYXNzIHVzZWQgaXMgW1tBZnRlclNhdmVFdmVudF1dLlxuXHQgKiBXaGVuIG92ZXJyaWRpbmcgdGhpcyBtZXRob2QsIG1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIHNvIHRoYXRcblx0ICogdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBpbnNlcnQgd2hldGhlciB0aGlzIG1ldGhvZCBjYWxsZWQgd2hpbGUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuXHQgKiBJZiBmYWxzZSwgaXQgbWVhbnMgdGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFuZ2VkQXR0cmlidXRlcyBUaGUgb2xkIHZhbHVlcyBvZiBhdHRyaWJ1dGVzIHRoYXQgaGFkIGNoYW5nZWQgYW5kIHdlcmUgc2F2ZWQuXG5cdCAqIFlvdSBjYW4gdXNlIHRoaXMgcGFyYW1ldGVyIHRvIHRha2UgYWN0aW9uIGJhc2VkIG9uIHRoZSBjaGFuZ2VzIG1hZGUgZm9yIGV4YW1wbGUgc2VuZCBhbiBlbWFpbFxuXHQgKiB3aGVuIHRoZSBwYXNzd29yZCBoYWQgY2hhbmdlZCBvciBpbXBsZW1lbnQgYXVkaXQgdHJhaWwgdGhhdCB0cmFja3MgYWxsIHRoZSBjaGFuZ2VzLlxuXHQgKiBgY2hhbmdlZEF0dHJpYnV0ZXNgIGdpdmVzIHlvdSB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgdGhlIGFjdGl2ZSByZWNvcmQgKGB0aGlzYCkgaGFzXG5cdCAqIGFscmVhZHkgdGhlIG5ldywgdXBkYXRlZCB2YWx1ZXMuXG5cdCAqL1xuXHRhZnRlclNhdmU6IGZ1bmN0aW9uIChpbnNlcnQsIGNoYW5nZWRBdHRyaWJ1dGVzKSB7XG5cdFx0dmFyIGV2ZW50TmFtZSA9IGluc2VydCA/IHRoaXMuX19zdGF0aWMuRVZFTlRfQUZURVJfSU5TRVJUIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9VUERBVEU7XG5cblx0XHR0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBuZXcgSmlpLnNxbC5BZnRlclNhdmVFdmVudCh7XG5cdFx0XHRjaGFuZ2VkQXR0cmlidXRlczogY2hhbmdlZEF0dHJpYnV0ZXNcblx0XHR9KSk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGRlbGV0aW5nIGEgcmVjb3JkLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByYWlzZXMgdGhlIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGV2ZW50LlxuXHQgKiBXaGVuIG92ZXJyaWRpbmcgdGhpcyBtZXRob2QsIG1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0ICpcblx0ICogfn5+XG5cdCAqIHB1YmxpYyBmdW5jdGlvbiBiZWZvcmVEZWxldGUoKVxuXHQgKiB7XG4gICAgICogICAgIGlmIChwYXJlbnQuYmVmb3JlRGVsZXRlKCkpIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLmN1c3RvbSBjb2RlIGhlcmUuLi5cbiAgICAgKiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBzaG91bGQgYmUgZGVsZXRlZC4gRGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICovXG5cdGJlZm9yZURlbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudCA9IG5ldyBKaWkuYmFzZS5Nb2RlbEV2ZW50KCk7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQkVGT1JFX0RFTEVURSwgZXZlbnQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShldmVudC5pc1ZhbGlkKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBhZnRlciBkZWxldGluZyBhIHJlY29yZC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmFpc2VzIHRoZSBbW0VWRU5UX0FGVEVSX0RFTEVURV1dIGV2ZW50LlxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHBvc3Rwcm9jZXNzaW5nIGFmdGVyIHRoZSByZWNvcmQgaXMgZGVsZXRlZC5cblx0ICogTWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgZXZlbnQgaXMgcmFpc2VkIHByb3Blcmx5LlxuXHQgKi9cblx0YWZ0ZXJEZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9ERUxFVEUpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVwb3B1bGF0ZXMgdGhpcyBhY3RpdmUgcmVjb3JkIHdpdGggdGhlIGxhdGVzdCBkYXRhLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcm93IHN0aWxsIGV4aXN0cyBpbiB0aGUgZGF0YWJhc2UuIElmIHRydWUsIHRoZSBsYXRlc3QgZGF0YVxuXHQgKiB3aWxsIGJlIHBvcHVsYXRlZCB0byB0aGlzIGFjdGl2ZSByZWNvcmQuIE90aGVyd2lzZSwgdGhpcyByZWNvcmQgd2lsbCByZW1haW4gdW5jaGFuZ2VkLlxuXHQgKi9cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmltYXJ5S2V5ID0gdGhpcy5nZXRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMuZmluZE9uZShwcmltYXJ5S2V5KS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocmVjb3JkKSB7XG5cdFx0XHRpZiAocmVjb3JkID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRKaWkuXy5lYWNoKHRoaXMuYXR0cmlidXRlcygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IEppaS5fLmhhcyhyZWNvcmQuX2F0dHJpYnV0ZXMsIG5hbWUpID8gcmVjb3JkLl9hdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXMgPSBKaWkuXy5jbG9uZSh0aGlzLl9hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9yZWxhdGVkLCBmdW5jdGlvbihyZWxhdGlvbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlbGF0ZWQobmFtZSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiBhY3RpdmUgcmVjb3JkIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IG9uZS5cblx0ICogVGhlIGNvbXBhcmlzb24gaXMgbWFkZSBieSBjb21wYXJpbmcgdGhlIHRhYmxlIG5hbWVzIGFuZCB0aGUgcHJpbWFyeSBrZXkgdmFsdWVzIG9mIHRoZSB0d28gYWN0aXZlIHJlY29yZHMuXG5cdCAqIElmIG9uZSBvZiB0aGUgcmVjb3JkcyBbW2lzTmV3UmVjb3JkfGlzIG5ld11dIHRoZXkgYXJlIGFsc28gY29uc2lkZXJlZCBub3QgZXF1YWwuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSByZWNvcmQgcmVjb3JkIHRvIGNvbXBhcmUgdG9cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHR3byBhY3RpdmUgcmVjb3JkcyByZWZlciB0byB0aGUgc2FtZSByb3cgaW4gdGhlIHNhbWUgZGF0YWJhc2UgdGFibGUuXG5cdCAqL1xuXHRlcXVhbHM6IGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IHJlY29yZC5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuY2xhc3NOYW1lKCkgIT09IHJlY29yZC5jbGFzc05hbWUoKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldFByaW1hcnlLZXkoKS50b1N0cmluZygpID09PSByZWNvcmQuZ2V0UHJpbWFyeUtleSgpLnRvU3RyaW5nKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHByaW1hcnkga2V5IHZhbHVlKHMpLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc0FycmF5XSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcHJpbWFyeSBrZXkgdmFsdWUgYXMgYW4gYXJyYXkuIElmIHRydWUsXG5cdCAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBhcnJheSB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIGFuZCBjb2x1bW4gdmFsdWVzIGFzIHZhbHVlcy5cblx0ICogTm90ZSB0aGF0IGZvciBjb21wb3NpdGUgcHJpbWFyeSBrZXlzLCBhbiBhcnJheSB3aWxsIGFsd2F5cyBiZSByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRoaXMgcGFyYW1ldGVyIHZhbHVlLlxuXHQgKiBAcHJvcGVydHkgbWl4ZWQgVGhlIHByaW1hcnkga2V5IHZhbHVlLiBBbiBhcnJheSAoY29sdW1uIG5hbWUgPT4gY29sdW1uIHZhbHVlKSBpcyByZXR1cm5lZCBpZlxuXHQgKiB0aGUgcHJpbWFyeSBrZXkgaXMgY29tcG9zaXRlLiBBIHN0cmluZyBpcyByZXR1cm5lZCBvdGhlcndpc2UgKG51bGwgd2lsbCBiZSByZXR1cm5lZCBpZlxuXHQgKiB0aGUga2V5IHZhbHVlIGlzIG51bGwpLlxuXHQgKiBAcmV0dXJucyB7Kn0gdGhlIHByaW1hcnkga2V5IHZhbHVlLiBBbiBhcnJheSAoY29sdW1uIG5hbWUgPT4gY29sdW1uIHZhbHVlKSBpcyByZXR1cm5lZCBpZiB0aGUgcHJpbWFyeSBrZXlcblx0ICogaXMgY29tcG9zaXRlIG9yIGBhc0FycmF5YCBpcyB0cnVlLiBBIHN0cmluZyBpcyByZXR1cm5lZCBvdGhlcndpc2UgKG51bGwgd2lsbCBiZSByZXR1cm5lZCBpZlxuXHQgKiB0aGUga2V5IHZhbHVlIGlzIG51bGwpLlxuXHQgKi9cblx0Z2V0UHJpbWFyeUtleTogZnVuY3Rpb24gKGFzQXJyYXkpIHtcblx0XHRhc0FycmF5ID0gYXNBcnJheSB8fCBmYWxzZTtcblxuXHRcdHZhciBrZXlzID0gdGhpcy5fX3N0YXRpYy5wcmltYXJ5S2V5KCk7XG5cdFx0aWYgKGtleXMubGVuZ3RoID09PSAxICYmICFhc0FycmF5KSB7XG5cdFx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIGtleXNbMF0pID8gdGhpcy5fYXR0cmlidXRlc1trZXlzWzBdXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdEppaS5fLmVhY2goa2V5cywgSmlpLl8uYmluZChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YWx1ZXNbbmFtZV0gPSBKaWkuXy5oYXModGhpcy5fYXR0cmlidXRlcywgbmFtZSkgPyB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvbGQgcHJpbWFyeSBrZXkgdmFsdWUocykuXG5cdCAqIFRoaXMgcmVmZXJzIHRvIHRoZSBwcmltYXJ5IGtleSB2YWx1ZSB0aGF0IGlzIHBvcHVsYXRlZCBpbnRvIHRoZSByZWNvcmRcblx0ICogYWZ0ZXIgZXhlY3V0aW5nIGEgZmluZCBtZXRob2QgKGUuZy4gZmluZCgpLCBmaW5kT25lKCkpLlxuXHQgKiBUaGUgdmFsdWUgcmVtYWlucyB1bmNoYW5nZWQgZXZlbiBpZiB0aGUgcHJpbWFyeSBrZXkgYXR0cmlidXRlIGlzIG1hbnVhbGx5IGFzc2lnbmVkIHdpdGggYSBkaWZmZXJlbnQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzQXJyYXldIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwcmltYXJ5IGtleSB2YWx1ZSBhcyBhbiBhcnJheS4gSWYgdHJ1ZSxcblx0ICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFuIGFycmF5IHdpdGggY29sdW1uIG5hbWUgYXMga2V5IGFuZCBjb2x1bW4gdmFsdWUgYXMgdmFsdWUuXG5cdCAqIElmIHRoaXMgaXMgZmFsc2UgKGRlZmF1bHQpLCBhIHNjYWxhciB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGZvciBub24tY29tcG9zaXRlIHByaW1hcnkga2V5LlxuXHQgKiBAcHJvcGVydHkgbWl4ZWQgVGhlIG9sZCBwcmltYXJ5IGtleSB2YWx1ZS4gQW4gYXJyYXkgKGNvbHVtbiBuYW1lID0+IGNvbHVtbiB2YWx1ZSkgaXNcblx0ICogcmV0dXJuZWQgaWYgdGhlIHByaW1hcnkga2V5IGlzIGNvbXBvc2l0ZS4gQSBzdHJpbmcgaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIChudWxsIHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaWYgdGhlIGtleSB2YWx1ZSBpcyBudWxsKS5cblx0ICogQHJldHVybnMgeyp9IHRoZSBvbGQgcHJpbWFyeSBrZXkgdmFsdWUuIEFuIGFycmF5IChjb2x1bW4gbmFtZSA9PiBjb2x1bW4gdmFsdWUpIGlzIHJldHVybmVkIGlmIHRoZSBwcmltYXJ5IGtleVxuXHQgKiBpcyBjb21wb3NpdGUgb3IgYGFzQXJyYXlgIGlzIHRydWUuIEEgc3RyaW5nIGlzIHJldHVybmVkIG90aGVyd2lzZSAobnVsbCB3aWxsIGJlIHJldHVybmVkIGlmXG5cdCAqIHRoZSBrZXkgdmFsdWUgaXMgbnVsbCkuXG5cdCAqL1xuXHRnZXRPbGRQcmltYXJ5S2V5OiBmdW5jdGlvbiAoYXNBcnJheSkge1xuXHRcdGFzQXJyYXkgPSBhc0FycmF5IHx8IGZhbHNlO1xuXG5cdFx0dmFyIGtleXMgPSB0aGlzLl9fc3RhdGljLnByaW1hcnlLZXkoKTtcblxuXHRcdGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAhYXNBcnJheSkge1xuXHRcdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9vbGRBdHRyaWJ1dGVzLCBrZXlzWzBdKSA/IHRoaXMuX29sZEF0dHJpYnV0ZXNba2V5c1swXV0gOiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHRKaWkuXy5lYWNoKGtleXMsIEppaS5fLmJpbmQoZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFsdWVzW25hbWVdID0gSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpID8gdGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSA6IG51bGw7XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcmVsYXRpb24gb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuXHQgKiBBIHJlbGF0aW9uIGlzIGRlZmluZWQgYnkgYSBnZXR0ZXIgbWV0aG9kIHdoaWNoIHJldHVybnMgYW4gW1tBY3RpdmVRdWVyeUludGVyZmFjZV1dIG9iamVjdC5cblx0ICogSXQgY2FuIGJlIGRlY2xhcmVkIGluIGVpdGhlciB0aGUgQWN0aXZlIFJlY29yZCBjbGFzcyBpdHNlbGYgb3Igb25lIG9mIGl0cyBiZWhhdmlvcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSByZWxhdGlvbiBuYW1lXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rocm93RXhjZXB0aW9uXSB3aGV0aGVyIHRvIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgcmVsYXRpb24gZG9lcyBub3QgZXhpc3QuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxKaWkuc3FsLkFjdGl2ZVF1ZXJ5Pn0gdGhlIHJlbGF0aW9uYWwgcXVlcnkgb2JqZWN0LiBJZiB0aGUgcmVsYXRpb24gZG9lcyBub3QgZXhpc3Rcblx0ICogYW5kIGB0aHJvd0V4Y2VwdGlvbmAgaXMgZmFsc2UsIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9ufSBpZiB0aGUgbmFtZWQgcmVsYXRpb24gZG9lcyBub3QgZXhpc3QuXG5cdCAqL1xuXHRnZXRSZWxhdGlvbjogZnVuY3Rpb24gKG5hbWUsIHRocm93RXhjZXB0aW9uKSB7XG5cdFx0dGhyb3dFeGNlcHRpb24gPSAhSmlpLl8uaXNVbmRlZmluZWQodGhyb3dFeGNlcHRpb24pID8gdGhyb3dFeGNlcHRpb24gOiB0cnVlO1xuXG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgSmlpLl9zLmNhcGl0YWxpemUobmFtZSk7XG5cdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1tnZXR0ZXJdKSkge1xuXHRcdFx0cmV0dXJuIHRoaXNbZ2V0dGVyXSgpO1xuXHRcdH0gZWxzZSBpZiAodGhyb3dFeGNlcHRpb24pIHtcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24odGhpcy5jbGFzc05hbWUoKSArICcgaGFzIG5vIHJlbGF0aW9uIG5hbWVkIGAnICsgbmFtZSArICdgLicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlbGF0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSAnZ2V0JyArIEppaS5fcy5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbih0aGlzW2dldHRlcl0pO1xuICAgIH0sXG5cblx0LyoqXG5cdCAqIEVzdGFibGlzaGVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gbW9kZWxzLlxuXHQgKlxuXHQgKiBUaGUgcmVsYXRpb25zaGlwIGlzIGVzdGFibGlzaGVkIGJ5IHNldHRpbmcgdGhlIGZvcmVpZ24ga2V5IHZhbHVlKHMpIGluIG9uZSBtb2RlbFxuXHQgKiB0byBiZSB0aGUgY29ycmVzcG9uZGluZyBwcmltYXJ5IGtleSB2YWx1ZShzKSBpbiB0aGUgb3RoZXIgbW9kZWwuXG5cdCAqIFRoZSBtb2RlbCB3aXRoIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2Ugd2l0aG91dCBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG5cdCAqXG5cdCAqIElmIHRoZSByZWxhdGlvbnNoaXAgaW52b2x2ZXMgYSBwaXZvdCB0YWJsZSwgYSBuZXcgcm93KCkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvIHRoZVxuXHQgKiBwaXZvdCB0YWJsZSB3aGljaCBjb250YWlucyB0aGUgcHJpbWFyeSBrZXkgdmFsdWVzIGZyb20gYm90aCBtb2RlbHMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHRoZSBwcmltYXJ5IGtleSB2YWx1ZSBpcyBub3QgbnVsbC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGNhc2Ugc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHJlbGF0aW9uc2hpcFxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWwgdGhlIG1vZGVsIHRvIGJlIGxpbmtlZCB3aXRoIHRoZSBjdXJyZW50IG9uZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtleHRyYUNvbHVtbnNdIGFkZGl0aW9uYWwgY29sdW1uIHZhbHVlcyB0byBiZSBzYXZlZCBpbnRvIHRoZSBwaXZvdCB0YWJsZS5cblx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSBtZWFuaW5nZnVsIGZvciBhIHJlbGF0aW9uc2hpcCBpbnZvbHZpbmcgYSBwaXZvdCB0YWJsZVxuXHQgKiAoaS5lLiwgYSByZWxhdGlvbiBzZXQgd2l0aCBbW0FjdGl2ZVJlbGF0aW9uVHJhaXQudmlhKCldXSBvciBgW1tBY3RpdmVRdWVyeS52aWFUYWJsZSgpXV1gLilcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9ufSBpZiB0aGUgbWV0aG9kIGlzIHVuYWJsZSB0byBsaW5rIHR3byBtb2RlbHMuXG5cdCAqL1xuXHRsaW5rOiBmdW5jdGlvbiAobmFtZSwgbW9kZWwsIGV4dHJhQ29sdW1ucykge1xuXHRcdGV4dHJhQ29sdW1ucyA9IGV4dHJhQ29sdW1ucyB8fCB7fTtcblxuXHRcdHZhciByZWxhdGlvbiA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZWxhdGlvbi5nZXRWaWEoKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IG1vZGVsLmlzTmV3UmVjb3JkKCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENhbGxFeGNlcHRpb24oJ1VuYWJsZSB0byBsaW5rIG1vZGVsczogYm90aCBtb2RlbHMgbXVzdCBOT1QgYmUgbmV3bHkgY3JlYXRlZC4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2aWFOYW1lID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVJlbGF0aW9uID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYUNsYXNzID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVRhYmxlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFOYW1lID0gcmVsYXRpb24uZ2V0VmlhKClbMF07XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKVsxXTtcblxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSAqL1xuXHRcdFx0XHRcdHZpYUNsYXNzID0gdmlhUmVsYXRpb24ubW9kZWxDbGFzcztcblxuXHRcdFx0XHRcdC8vIHVuc2V0IHZpYU5hbWUgc28gdGhhdCBpdCBjYW4gYmUgcmVsb2FkZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlbGF0ZWQodmlhTmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKTtcblx0XHRcdFx0XHR2aWFUYWJsZSA9IEppaS5fLmZpcnN0KHJlbGF0aW9uLmdldFZpYSgpLmdldEZyb20oKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29sdW1ucyA9IHt9O1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZpYVJlbGF0aW9uLmxpbmssIGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRjb2x1bW5zW2FdID0gdGhpcy5nZXQoYik7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdEppaS5fLmVhY2gocmVsYXRpb24ubGluaywgZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYl0gPSBtb2RlbC5nZXQoYSk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdEppaS5fLmVhY2goZXh0cmFDb2x1bW5zLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1trXSA9IHY7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzQXJyYXkocmVsYXRpb24uZ2V0VmlhKCkpKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9ICovXG5cdFx0XHRcdFx0dmFyIHJlY29yZCA9IG5ldyB2aWFDbGFzcygpO1xuXHRcdFx0XHRcdEppaS5fLmVhY2goY29sdW1ucywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgY29sdW1uKSB7XG5cdFx0XHRcdFx0XHRyZWNvcmQuc2V0KGNvbHVtbiwgdmFsdWUpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkLmluc2VydChmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBAdHlwZSB7dmlhVGFibGV9IHN0cmluZyAqL1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX3N0YXRpYy5nZXREYigpLmNyZWF0ZUNvbW1hbmQoKS5pbnNlcnQodmlhVGFibGUsIGNvbHVtbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcDEgPSBtb2RlbC5fX3N0YXRpYy5pc1ByaW1hcnlLZXkoSmlpLl8ua2V5cyhyZWxhdGlvbi5saW5rKSk7XG5cdFx0XHR2YXIgcDIgPSB0aGlzLl9fc3RhdGljLmlzUHJpbWFyeUtleShKaWkuXy52YWx1ZXMocmVsYXRpb24ubGluaykpO1xuXHRcdFx0aWYgKHAxICYmIHAyKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzTmV3UmVjb3JkKCkgJiYgbW9kZWwuaXNOZXdSZWNvcmQoKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIGxpbmsgbW9kZWxzOiBib3RoIG1vZGVscyBhcmUgbmV3bHkgY3JlYXRlZC4nKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzTmV3UmVjb3JkKCkpIHtcblx0XHRcdFx0XHR2YXIgbGluayA9IHt9O1xuXHRcdFx0XHRcdGZvciAodmFyIGZrIGluIHJlbGF0aW9uLmxpbmspIHtcblx0XHRcdFx0XHRcdGlmIChyZWxhdGlvbi5saW5rLmhhc093blByb3BlcnR5KGZrKSkge1xuXHRcdFx0XHRcdFx0XHRsaW5rW3JlbGF0aW9uLmxpbmtbZmtdXSA9IGZrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYmluZE1vZGVscyhsaW5rLCB0aGlzLCBtb2RlbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2JpbmRNb2RlbHMocmVsYXRpb24ubGluaywgbW9kZWwsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHAxKSB7XG5cdFx0XHRcdHZhciBsaW5rMiA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBmazIgaW4gcmVsYXRpb24ubGluaykge1xuXHRcdFx0XHRcdGlmIChyZWxhdGlvbi5saW5rLmhhc093blByb3BlcnR5KGZrMikpIHtcblx0XHRcdFx0XHRcdGxpbmsyW3JlbGF0aW9uLmxpbmtbZmsyXV0gPSBmazI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9iaW5kTW9kZWxzKGxpbmsyLCB0aGlzLCBtb2RlbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHAyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9iaW5kTW9kZWxzKHJlbGF0aW9uLmxpbmssIG1vZGVsLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIGxpbmsgbW9kZWxzOiB0aGUgbGluayBkb2VzIG5vdCBpbnZvbHZlIGFueSBwcmltYXJ5IGtleS4nKTtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpLnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbigpIHtcblx0XHRcdC8vIHVwZGF0ZSBsYXppbHkgbG9hZGVkIHJlbGF0ZWQgb2JqZWN0c1xuXHRcdFx0aWYgKCFyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgbW9kZWwpO1xuXHRcdFx0fSBlbHNlIGlmIChKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGVkW25hbWVdLmFkZChtb2RlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gbW9kZWxzLlxuXHQgKlxuXHQgKiBUaGUgbW9kZWwgd2l0aCB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIHJlbGF0aW9uc2hpcCB3aWxsIGJlIGRlbGV0ZWQgaWYgYGRlbGV0ZWAgaXMgdHJ1ZS5cblx0ICogT3RoZXJ3aXNlLCB0aGUgZm9yZWlnbiBrZXkgd2lsbCBiZSBzZXQgbnVsbCBhbmQgdGhlIG1vZGVsIHdpbGwgYmUgc2F2ZWQgd2l0aG91dCB2YWxpZGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgY2FzZSBzZW5zaXRpdmUgbmFtZSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWwgdGhlIG1vZGVsIHRvIGJlIHVubGlua2VkIGZyb20gdGhlIGN1cnJlbnQgb25lLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlbGV0ZV0gd2hldGhlciB0byBkZWxldGUgdGhlIG1vZGVsIHRoYXQgY29udGFpbnMgdGhlIGZvcmVpZ24ga2V5LlxuXHQgKiBJZiBmYWxzZSwgdGhlIG1vZGVsJ3MgZm9yZWlnbiBrZXkgd2lsbCBiZSBzZXQgbnVsbCBhbmQgc2F2ZWQuXG5cdCAqIElmIHRydWUsIHRoZSBtb2RlbCBjb250YWluaW5nIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIGRlbGV0ZWQuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKiBAdGhyb3dzIEludmFsaWRDYWxsRXhjZXB0aW9uIGlmIHRoZSBtb2RlbHMgY2Fubm90IGJlIHVubGlua2VkXG5cdCAqL1xuXHR1bmxpbms6IGZ1bmN0aW9uIChuYW1lLCBtb2RlbCwgaXNEZWxldGUpIHtcblx0XHRpc0RlbGV0ZSA9IGlzRGVsZXRlIHx8IGZhbHNlO1xuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAocmVsYXRpb24uZ2V0VmlhKCkgIT09IG51bGwpIHtcblxuXHRcdFx0XHR2YXIgdmlhTmFtZSA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFSZWxhdGlvbiA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFUYWJsZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzQXJyYXkocmVsYXRpb24uZ2V0VmlhKCkpKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9ICovXG5cdFx0XHRcdFx0dmlhTmFtZSA9IHJlbGF0aW9uLmdldFZpYSgpWzBdO1xuXHRcdFx0XHRcdHZpYVJlbGF0aW9uID0gcmVsYXRpb24uZ2V0VmlhKClbMV07XG5cblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFDbGFzcyA9IHZpYVJlbGF0aW9uLm1vZGVsQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVsYXRlZCh2aWFOYW1lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWFSZWxhdGlvbiA9IHJlbGF0aW9uLmdldFZpYSgpO1xuXHRcdFx0XHRcdHZpYVRhYmxlID0gSmlpLl8uZmlyc3QocmVsYXRpb24uZ2V0VmlhKCkuZ2V0RnJvbSgpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb2x1bW5zID0ge307XG5cdFx0XHRcdHZhciBudWxscyA9IHt9O1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZpYVJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYV0gPSB0aGlzLmdldChiKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYl0gPSBtb2RlbC5nZXQoYSk7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0SmlpLl8uZWFjaChKaWkuXy5rZXlzKGNvbHVtbnMpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGspIHtcblx0XHRcdFx0XHRudWxsc1trXSA9IG51bGw7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2aWFDbGFzcy5kZWxldGVBbGwoY29sdW1ucyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZpYUNsYXNzLnVwZGF0ZUFsbChudWxscywgY29sdW1ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBAdHlwZSBKaWkuc3FsLkNvbW1hbmQgKi9cblx0XHRcdFx0dmFyIGNvbW1hbmQgPSB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpO1xuXHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tbWFuZC5kZWxldGUodmlhVGFibGUsIGNvbHVtbnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNvbW1hbmQudXBkYXRlKHZpYVRhYmxlLCBudWxscywgY29sdW1ucyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwMSA9IG1vZGVsLl9fc3RhdGljLmlzUHJpbWFyeUtleShKaWkuXy5rZXlzKHJlbGF0aW9uLmxpbmspKTtcblx0XHRcdHZhciBwMiA9IHRoaXMuX19zdGF0aWMuaXNQcmltYXJ5S2V5KEppaS5fLnZhbHVlcyhyZWxhdGlvbi5saW5rKSk7XG5cblx0XHRcdGlmIChwMSAmJiBwMiB8fCBwMikge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdG1vZGVsLnNldChhLCBudWxsKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXG5cdFx0XHRcdHJldHVybiBpc0RlbGV0ZSA/IG1vZGVsLmRlbGV0ZSgpIDogbW9kZWwuc2F2ZShmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwMSkge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldChiKTtcblxuXHRcdFx0XHRcdGlmIChKaWkuXy5pc0FycmF5KHZhbHVlcykpIHsgLy8gcmVsYXRpb24gdmlhIGFycmF5IHZhbHVlZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IEppaS5fLmluZGV4T2YodmFsdWVzLCBtb2RlbC5nZXQoYSkpO1xuXHRcdFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXQoYiwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdFx0cmV0dXJuIGlzRGVsZXRlID8gdGhpcy5kZWxldGUoKSA6IHRoaXMuc2F2ZShmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIHVubGluayBtb2RlbHM6IHRoZSBsaW5rIGRvZXMgbm90IGludm9sdmUgYW55IHByaW1hcnkga2V5LicpO1xuXHRcdH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCFyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWxhdGVkKG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWxhdGVkW25hbWVdLnJlbW92ZShtb2RlbCk7XG5cdFx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcmVsYXRpb25zaGlwIGluIGN1cnJlbnQgbW9kZWwuXG5cdCAqXG5cdCAqIFRoZSBtb2RlbCB3aXRoIHRoZSBmb3JlaWduIGtleSBvZiB0aGUgcmVsYXRpb25zaGlwIHdpbGwgYmUgZGVsZXRlZCBpZiBgZGVsZXRlYCBpcyB0cnVlLlxuXHQgKiBPdGhlcndpc2UsIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIHNldCBudWxsIGFuZCB0aGUgbW9kZWwgd2lsbCBiZSBzYXZlZCB3aXRob3V0IHZhbGlkYXRpb24uXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0byBkZXN0cm95IHRoZSByZWxhdGlvbnNoaXAgd2l0aG91dCByZW1vdmluZyByZWNvcmRzIG1ha2Ugc3VyZSB5b3VyIGtleXMgY2FuIGJlIHNldCB0byBudWxsXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBjYXNlIHNlbnNpdGl2ZSBuYW1lIG9mIHRoZSByZWxhdGlvbnNoaXAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVsZXRlXSB3aGV0aGVyIHRvIGRlbGV0ZSB0aGUgbW9kZWwgdGhhdCBjb250YWlucyB0aGUgZm9yZWlnbiBrZXkuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0dW5saW5rQWxsOiBmdW5jdGlvbiAobmFtZSwgaXNEZWxldGUpIHtcblx0XHRpc0RlbGV0ZSA9IGlzRGVsZXRlIHx8IGZhbHNlO1xuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmIChyZWxhdGlvbi5nZXRWaWEoKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHZhciB2aWFOYW1lID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVJlbGF0aW9uID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYUNsYXNzID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVRhYmxlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFOYW1lID0gcmVsYXRpb24uZ2V0VmlhKClbMF07XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKVsxXTtcblxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSAqL1xuXHRcdFx0XHRcdHZpYUNsYXNzID0gdmlhUmVsYXRpb24ubW9kZWxDbGFzcztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWxhdGVkKHZpYU5hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZpYVJlbGF0aW9uID0gcmVsYXRpb24uZ2V0VmlhKCk7XG5cdFx0XHRcdFx0dmlhVGFibGUgPSBKaWkuXy5maXJzdChyZWxhdGlvbi5nZXRWaWEoKS5nZXRGcm9tKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvbmRpdGlvbiA9IHt9O1xuXHRcdFx0XHR2YXIgbnVsbHMgPSB7fTtcblx0XHRcdFx0SmlpLl8uZWFjaCh2aWFSZWxhdGlvbi5saW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRudWxsc1thXSA9IG51bGw7XG5cdFx0XHRcdFx0Y29uZGl0aW9uW2FdID0gdGhpcy5nZXQoYik7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2aWFDbGFzcy5kZWxldGVBbGwoY29uZGl0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZpYUNsYXNzLnVwZGF0ZUFsbChudWxscywgY29uZGl0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7SmlpLnNxbC5Db21tYW5kfSAqL1xuXHRcdFx0XHR2YXIgY29tbWFuZCA9IHRoaXMuX19zdGF0aWMuZ2V0RGIoKS5jcmVhdGVDb21tYW5kKCk7XG5cdFx0XHRcdGlmIChpc0RlbGV0ZSkge1xuXHRcdFx0XHRcdHJldHVybiBjb21tYW5kLmRlbGV0ZSh2aWFUYWJsZSwgY29uZGl0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb21tYW5kLnVwZGF0ZSh2aWFUYWJsZSwgbnVsbHMsIGNvbmRpdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBAdHlwZWRlZiB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSByZWxhdGVkTW9kZWwgKi9cblx0XHRcdHZhciByZWxhdGVkTW9kZWwgPSByZWxhdGlvbi5tb2RlbENsYXNzO1xuXHRcdFx0dmFyIGtleSA9IHJlbGF0aW9uLmxpbmtbMF07XG5cdFx0XHRpZiAoIWlzRGVsZXRlICYmIHJlbGF0aW9uLmxpbmsubGVuZ3RoID09IDEgJiYgSmlpLl8uaXNBcnJheSh0aGlzLmdldChrZXkpKSkge1xuXHRcdFx0XHQvLyByZWxhdGlvbiB2aWEgYXJyYXkgdmFsdWVkIGF0dHJpYnV0ZVxuXHRcdFx0XHR0aGlzLnNldChrZXksIFtdKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2F2ZShmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbnVsbHMyID0ge307XG5cdFx0XHRcdHZhciBjb25kaXRpb24yID0ge307XG5cblx0XHRcdFx0SmlpLl8uZWFjaChyZWxhdGlvbi5saW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRudWxsczJbYV0gPSBudWxsO1xuXHRcdFx0XHRcdGNvbmRpdGlvbjJbYV0gPSB0aGlzLmdldChiKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRpZiAocmVsYXRpb24uZ2V0V2hlcmUoKSkge1xuXHRcdFx0XHRcdGNvbmRpdGlvbjIgPSBbJ2FuZCcsIGNvbmRpdGlvbjIsIHJlbGF0aW9uLmdldFdoZXJlKCldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzRGVsZXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbGF0ZWRNb2RlbC5kZWxldGVBbGwoY29uZGl0aW9uMik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlbGF0ZWRNb2RlbC51cGRhdGVBbGwobnVsbHMyLCBjb25kaXRpb24yKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSkudGhlbihKaWkuXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVsYXRlZChuYW1lKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsaW5rXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSBmb3JlaWduTW9kZWxcblx0ICogQHBhcmFtIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IHByaW1hcnlNb2RlbFxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbn1cblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRfYmluZE1vZGVsczogZnVuY3Rpb24gKGxpbmssIGZvcmVpZ25Nb2RlbCwgcHJpbWFyeU1vZGVsKSB7XG5cdFx0SmlpLl8uZWFjaChsaW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHBrLCBmaykge1xuXHRcdFx0dmFyIHZhbHVlID0gcHJpbWFyeU1vZGVsLmdldChwayk7XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9uKCdVbmFibGUgdG8gbGluayBtb2RlbHM6IHRoZSBwcmltYXJ5IGtleSBvZiBgJyArIHByaW1hcnlNb2RlbC5jbGFzc05hbWUoKSArICdgIGlzIG51bGwuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKaWkuXy5pc0FycmF5KGZvcmVpZ25Nb2RlbC5nZXQoZmspKSkgeyAvLyByZWxhdGlvbiB2aWEgYXJyYXkgdmFsdWVkIGF0dHJpYnV0ZVxuXHRcdFx0XHRmb3JlaWduTW9kZWwuZ2V0KGZrKS5jb25jYXQodmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yZWlnbk1vZGVsLnNldChmaywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblxuXHRcdHJldHVybiBmb3JlaWduTW9kZWwuc2F2ZShmYWxzZSk7XG5cdH0sXG5cblxuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRleHQgbGFiZWwgZm9yIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlLlxuXHQgKiBJZiB0aGUgYXR0cmlidXRlIGxvb2tzIGxpa2UgYHJlbGF0ZWRNb2RlbC5hdHRyaWJ1dGVgLCB0aGVuIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZWNlaXZlZCBmcm9tIHRoZSByZWxhdGVkIG1vZGVsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRoZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlIGxhYmVsXG5cdCAqIEBzZWUgZ2VuZXJhdGVBdHRyaWJ1dGVMYWJlbCgpXG5cdCAqIEBzZWUgYXR0cmlidXRlTGFiZWxzKClcblx0ICovXG5cdGdldEF0dHJpYnV0ZUxhYmVsOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0dmFyIGxhYmVscyA9IHRoaXMuYXR0cmlidXRlTGFiZWxzKCk7XG5cblx0XHRpZiAoSmlpLl8uaGFzKGxhYmVsc1thdHRyaWJ1dGVdKSkge1xuXHRcdFx0cmV0dXJuIGxhYmVsc1thdHRyaWJ1dGVdO1xuXHRcdH1cblxuXHRcdGlmIChhdHRyaWJ1dGUuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZVBhcnRzID0gYXR0cmlidXRlLnNwbGl0KCcuJyk7XG5cdFx0XHR2YXIgbmVlZGVkQXR0cmlidXRlID0gYXR0cmlidXRlUGFydHMucG9wKCk7XG5cblx0XHRcdHZhciByZWxhdGVkTW9kZWwgPSB0aGlzO1xuXHRcdFx0SmlpLl8uZWFjaChhdHRyaWJ1dGVQYXJ0cywgSmlpLl8uYmluZChmdW5jdGlvbihyZWxhdGlvbk5hbWUpIHtcblx0XHRcdFx0aWYgKEppaS5fLmhhcyh0aGlzLl9yZWxhdGVkLCByZWxhdGlvbk5hbWUpICYmIHRoaXMuX3JlbGF0ZWRbcmVsYXRpb25OYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkge1xuXHRcdFx0XHRcdHJlbGF0ZWRNb2RlbCA9IHRoaXMuX3JlbGF0ZWRbcmVsYXRpb25OYW1lXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdG9kb1xuXHRcdFx0XHRcdC8qdHJ5IHtcblx0XHRcdFx0XHRcdHJlbGF0aW9uID0gcmVsYXRlZE1vZGVsLmdldFJlbGF0aW9uKHJlbGF0aW9uTmFtZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoSW52YWxpZFBhcmFtRXhjZXB0aW9uIGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQXR0cmlidXRlTGFiZWwoYXR0cmlidXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVsYXRlZE1vZGVsID0gbmV3IHJlbGF0aW9uLm1vZGVsQ2xhc3MoKTsqL1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdGxhYmVscyA9IHJlbGF0ZWRNb2RlbC5hdHRyaWJ1dGVMYWJlbHMoKTtcblxuXHRcdFx0aWYgKEppaS5fLmhhcyhsYWJlbHNbYXR0cmlidXRlXSkpIHtcblx0XHRcdFx0cmV0dXJuIGxhYmVsc1thdHRyaWJ1dGVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQXR0cmlidXRlTGFiZWwoYXR0cmlidXRlKTtcblx0fVxuXG59KTtcblxufSx7XCIuL01vZGVsXCI6MTAwLFwiamlpXCI6MTI0fV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBCYXNlQ29sbGVjdGlvbiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBbW0NvbGxlY3Rpb25JbnRlcmZhY2VdXS5cbiAqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQ29sbGVjdGlvblxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBBcnJheVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkNvbGxlY3Rpb24nLCAvKiogQGxlbmRzIEppaS5iYXNlLkNvbGxlY3Rpb24ucHJvdG90eXBlICove1xuXG4gICAgX19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5Db2xsZWN0aW9uICove1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQ29sbGVjdGlvbiNhZGRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuQ29sbGVjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQUREOiAnYWRkJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkNvbGxlY3Rpb24jY2hhbmdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX0NIQU5HRTogJ2NoYW5nZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Db2xsZWN0aW9uI2NoYW5nZTpcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuQ29sbGVjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQ0hBTkdFX05BTUU6ICdjaGFuZ2U6JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkNvbGxlY3Rpb24jcmVtb3ZlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX1JFTU9WRTogJ3JlbW92ZSdcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8SmlpLmJhc2UuTW9kZWx9XG4gICAgICovXG4gICAgbW9kZWxDbGFzczogbnVsbCxcblxuICAgIF9ieUlkOiB7fSxcblxuICAgIF9ldmVudHNDaGFuZ2VOYW1lOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7W118b2JqZWN0fSBbbW9kZWxzXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnXVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAobW9kZWxzLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkobW9kZWxzKSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7W118b2JqZWN0fVxuICAgICAqL1xuICAgIGdldE1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W118SmlpLmJhc2UuTW9kZWx8SmlpLmJhc2UuTW9kZWxbXX0gbW9kZWxzXG4gICAgICovXG4gICAgc2V0TW9kZWxzOiBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZSh0aGlzLmxlbmd0aCwgbW9kZWxzLCBbXSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W118SmlpLmJhc2UuTW9kZWx8SmlpLmJhc2UuTW9kZWxbXX0gbW9kZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5kZXggJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlKGluZGV4LCBtb2RlbHMsIFtdKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp8KltdfSBtb2RlbHNcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uKG1vZGVscykge1xuICAgICAgICBpZiAoIUppaS5fLmlzQXJyYXkobW9kZWxzKSkge1xuICAgICAgICAgICAgbW9kZWxzID0gW21vZGVsc107XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY2hhbmdlKDAsIFtdLCBtb2RlbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdHxvYmplY3RbXX0gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gRm9ybWF0IFswXS5uYW1lXG4gICAgICAgIHZhciBpbmRleEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdEluZGV4KG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXhGb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoaW5kZXhGb3JtYXQuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsLnNldChpbmRleEZvcm1hdC5zdWJOYW1lLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24oJ05vdCBmb3VuZCBtb2RlbCB3aXRoIGluZGV4IGAnICsgaW5kZXhGb3JtYXQuaW5kZXggKyAnYCBmb3Igc2V0IGF0dHJpYnV0ZSBgJyArIGluZGV4Rm9ybWF0LnN1Yk5hbWUgKyAnYC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9iamVjdCBmb3JtYXRcbiAgICAgICAgaWYgKEppaS5fLmlzT2JqZWN0KG5hbWUpICYmICFKaWkuXy5oYXMobmFtZSwgJ21vZGVsQ2xhc3MnKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TW9kZWxzKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXJyYXkgZm9ybWF0XG4gICAgICAgIGlmIChKaWkuXy5pc0FycmF5KG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXRNb2RlbHMobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUsIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICAvLyBGb3JtYXQgWzBdLm5hbWVcbiAgICAgICAgdmFyIGluZGV4Rm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0SW5kZXgobmFtZSk7XG4gICAgICAgIGlmIChpbmRleEZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5hdChpbmRleEZvcm1hdC5pbmRleCk7XG4gICAgICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXhGb3JtYXQuc3ViTmFtZSA/IG1vZGVsLmdldChpbmRleEZvcm1hdC5zdWJOYW1lKSA6IG1vZGVsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBHZXQgYnkgcGtcbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB0aGlzLl9nZXRQcmltYXJ5S2V5KG5hbWUpO1xuICAgICAgICBpZiAoSmlpLl8uaGFzKHRoaXMuX2J5SWQsIHByaW1hcnlLZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYnlJZFtwcmltYXJ5S2V5XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3VwZXIobmFtZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBmb3IgTmVhdENvbWV0IGFwaVxuICAgICAqIEBwYXJhbSBuZXdBdHRyaWJ1dGVzXG4gICAgICogQHBhcmFtIG9sZEF0dHJpYnV0ZXNcbiAgICAgKi9cbiAgICB1cGRhdGU6IGZ1bmN0aW9uKG5ld0F0dHJpYnV0ZXMsIG9sZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRCeUlkKG9sZEF0dHJpYnV0ZXMpO1xuICAgICAgICBpZiAobW9kZWwpIHtcbiAgICAgICAgICAgIG1vZGVsLnNldChuZXdBdHRyaWJ1dGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYWRkKG5ld0F0dHJpYnV0ZXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7e2luZGV4OiBudW1iZXIsIHN1Yk5hbWU6IHN0cmluZ3xudWxsfX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kZXRlY3RLZXlGb3JtYXRJbmRleDogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICB2YXIgbWF0Y2hlcyA9IC9eXFxbKFswLTldKylcXF1cXC4/KC4qKS8uZXhlYyhuYW1lKTtcbiAgICAgICAgaWYgKG1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluZGV4OiBwYXJzZUludChtYXRjaGVzWzFdKSxcbiAgICAgICAgICAgIHN1Yk5hbWU6IG1hdGNoZXNbMl0gfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG9iamVjdH0gcHJpbWFyeUtleVxuICAgICAqIEByZXR1cm5zIHsqfG51bGx9XG4gICAgICovXG4gICAgZ2V0QnlJZDogZnVuY3Rpb24ocHJpbWFyeUtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYnlJZFt0aGlzLl9nZXRQcmltYXJ5S2V5KHByaW1hcnlLZXkpXSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZ2V0Q291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHRvSlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbC50b0pTT04ob3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGF0OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsIHRoaXMubGVuZ3RoICsgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2luZGV4XSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gW21vZGVsc11cbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24obW9kZWxzKSB7XG4gICAgICAgIG1vZGVscyA9IG1vZGVscyB8fCBbXTtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvQWRkID0gW107XG4gICAgICAgIEppaS5fLmVhY2gobW9kZWxzLCBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB2YXIgZmluZWRNb2RlbHMgPSB0aGlzLl9maW5kTW9kZWxzKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGZpbmVkTW9kZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgZGF0YSB0byBtb2RlbFxuICAgICAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZmluZE1vZGVscyhkYXRhKSwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEppaS5fLmluZGV4T2YodG9BZGQsIG1vZGVsKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvQWRkLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvQWRkLnB1c2goZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gW107XG4gICAgICAgIEppaS5fLmVhY2godGhpcy5nZXRNb2RlbHMoKSwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIGlmIChKaWkuXy5pbmRleE9mKHRvQWRkLCBtb2RlbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdG9SZW1vdmUucHVzaChtb2RlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuX2NoYW5nZSgwLCB0b0FkZCwgdG9SZW1vdmUsIHRydWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtKaWkuYmFzZS5PYmplY3QuX19zdXBlcn1cbiAgICAgKi9cbiAgICBjbG9uZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fX3N1cGVyKHRoaXMuZ2V0TW9kZWxzKCksIHtcbiAgICAgICAgICAgIG1vZGVsQ2xhc3M6IHRoaXMubW9kZWxDbGFzc1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgX3Jlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fYnlJZCAgPSB7fTtcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHRoaXMsIDAsIHRoaXMubGVuZ3RoKTtcbiAgICB9LFxuXG4gICAgX2NoYW5nZTogZnVuY3Rpb24oc3RhcnRJbmRleCwgdG9BZGQsIHRvUmVtb3ZlLCB1bmlxdWUpIHtcbiAgICAgICAgdW5pcXVlID0gdW5pcXVlIHx8IGZhbHNlO1xuXG4gICAgICAgIHZhciBhZGRlZCA9IFtdO1xuICAgICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgICB2YXIgaXNTb3J0ZWQgPSBmYWxzZTtcblxuICAgICAgICAvLyBSZW1vdmVcbiAgICAgICAgSmlpLl8uZWFjaCh0b1JlbW92ZSwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9maW5kTW9kZWxzKGRhdGEpLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXhPZihtb2RlbCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgc3RhcnRJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydEluZGV4LS07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmVtb3ZlZC5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgICAgICAgIC8vIEFycmF5IGFjY2Vzc1xuICAgICAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbCh0aGlzLCBpbmRleCwgMSk7XG5cbiAgICAgICAgICAgICAgICAvLyBCeSBpZFxuICAgICAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fYnlJZFt0aGlzLl9nZXRQcmltYXJ5S2V5KG1vZGVsKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBBZGRcbiAgICAgICAgSmlpLl8uZWFjaCh0b0FkZCwgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0c01vZGVscyA9IHVuaXF1ZSA/IHRoaXMuX2ZpbmRNb2RlbHMoZGF0YSkgOiBbXTtcbiAgICAgICAgICAgIHZhciBtb2RlbHMgPSBleGlzdHNNb2RlbHMubGVuZ3RoID4gMCA/IGV4aXN0c01vZGVscyA6IFt0aGlzLl9jcmVhdGVNb2RlbChkYXRhKV07XG5cbiAgICAgICAgICAgIEppaS5fLmVhY2gobW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIG1vdmluZ1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHNNb2RlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpc1NvcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwgJiYgSmlpLl8uaXNPYmplY3QoZGF0YSkgJiYgIShkYXRhIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHRoaXMsIHN0YXJ0SW5kZXgrKywgMCwgbW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnlJZFt0aGlzLl9nZXRQcmltYXJ5S2V5KG1vZGVsKV0gPSBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gTGF6eSBzdWJzY3JpYmUgb24gYWRkZWRcbiAgICAgICAgSmlpLl8uZWFjaChhZGRlZCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZXZlbnRzQ2hhbmdlTmFtZSwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwub24uYXBwbHkobW9kZWwsIGFycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBVbnN1YnNjcmliZSBvbiByZW1vdmVkXG4gICAgICAgIEppaS5fLmVhY2gocmVtb3ZlZCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZXZlbnRzQ2hhbmdlTmFtZSwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwub2ZmLmFwcGx5KG1vZGVsLCBhcnIuc2xpY2UoMCwgMikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEppaS5tb2RlbC5Db2xsZWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgICB9KVxuICAgICAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQURELCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfUkVNT1ZFLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0UsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Tb3J0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8b2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMgeyp8KltdfVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2ZpbmRNb2RlbHM6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHByaW1hcnlLZXkgPSB0aGlzLl9nZXRQcmltYXJ5S2V5KGRhdGEpO1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXIoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmltYXJ5S2V5ID09IHRoaXMuX2dldFByaW1hcnlLZXkobW9kZWwpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xvYmplY3R9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIF9nZXRQcmltYXJ5S2V5OiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChkYXRhKSAmJiB0aGlzLm1vZGVsQ2xhc3MgJiYgIShkYXRhIGluc3RhbmNlb2YgSmlpLmJhc2UuQWN0aXZlUmVjb3JkKSkge1xuICAgICAgICAgICAgZGF0YSA9IHRoaXMuX2NyZWF0ZU1vZGVsKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBKaWkuYmFzZS5BY3RpdmVSZWNvcmQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmdldFByaW1hcnlLZXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fCp9IGRhdGFcbiAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuTW9kZWx9XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY3JlYXRlTW9kZWw6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBtb2RlbFxuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERpc2FibGVkIG1vZGVsIGF1dG8gY3JlYXRlXG4gICAgICAgIGlmICh0aGlzLm1vZGVsQ2xhc3MgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlcXVpcmVkXG4gICAgICAgIGlmICh0aGlzLm1vZGVsQ2xhc3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ1Byb3BlcnR5IGBtb2RlbENsYXNzYCBpbiBjb2xsZWN0aW9uIGlzIHJlcXVpcmVkIChvciBzZXQgZmFsc2UgdG8gZm9yY2UgZGlzYWJsZSkuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSmlpLl8uaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbENsYXNzID0gdGhpcy5tb2RlbENsYXNzO1xuICAgICAgICAgICAgaWYgKEppaS5fLmlzU3RyaW5nKG1vZGVsQ2xhc3MpKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxDbGFzcyA9IEppaS5uYW1lc3BhY2UobW9kZWxDbGFzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIUppaS5fLmlzRnVuY3Rpb24obW9kZWxDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKCdOb3QgZm91bmQgbW9kZWwgY2xhc3MgZm9yIGNyZWF0ZSBpbnN0YW5jZSBpbiBjb2xsZWN0aW9uLCBtb2RlbENsYXNzOiAnICsgdGhpcy5tb2RlbENsYXNzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb2RlbENsYXNzKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignQ2Fubm90IGNyZWF0ZSBtb2RlbCBpbnN0YW5jZSBmcm9tIGRhdGE6ICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gICAgfSxcblxuICAgIF9vblNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kbyBUcmlnZ2VyIHNvcnQgZXZlbnRcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHsqfSBbZGF0YV1cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FwcGVuZF1cbiAgICAgKi9cbiAgICBvbjogZnVuY3Rpb24obmFtZSwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgbmFtZXMgc3VwcG9ydFxuICAgICAgICBuYW1lID0gdGhpcy5fbm9ybWFsaXplRXZlbnROYW1lcyhuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihuLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZClcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0dHJpYnV0ZXMgaW4gbW9kZWxzXG4gICAgICAgIHZhciBjaGFuZ2VOYW1lRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0Q2hhbmdlTmFtZShuYW1lKTtcbiAgICAgICAgaWYgKGNoYW5nZU5hbWVGb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBjaGFuZ2VOYW1lRXZlbnQgPSBKaWkuYmFzZS5Nb2RlbC5FVkVOVF9DSEFOR0VfTkFNRSArIGNoYW5nZU5hbWVGb3JtYXQuc3ViTmFtZTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50c0NoYW5nZU5hbWUucHVzaChbY2hhbmdlTmFtZUV2ZW50LCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZF0pO1xuICAgICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwub24oY2hhbmdlTmFtZUV2ZW50LCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fX3N1cGVyKG5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8c3RyaW5nW119IG5hbWVcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbaGFuZGxlcl1cbiAgICAgKiBAcmV0dXJuIGJvb2xlYW5cbiAgICAgKi9cbiAgICBvZmY6IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIpIHtcbiAgICAgICAgLy8gTXVsdGlwbGUgbmFtZXMgc3VwcG9ydFxuICAgICAgICBuYW1lID0gdGhpcy5fbm9ybWFsaXplRXZlbnROYW1lcyhuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdmFyIGJvb2wgPSBmYWxzZTtcbiAgICAgICAgICAgIEppaS5fLmVhY2gobmFtZSwgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9uKG4sIGhhbmRsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJvb2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gYm9vbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0cmlidXRlcyBpbiBtb2RlbHNcbiAgICAgICAgdmFyIGNoYW5nZU5hbWVGb3JtYXQgPSB0aGlzLl9kZXRlY3RLZXlGb3JtYXRDaGFuZ2VOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoY2hhbmdlTmFtZUZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZU5hbWVFdmVudCA9IEppaS5iYXNlLk1vZGVsLkVWRU5UX0NIQU5HRV9OQU1FICsgY2hhbmdlTmFtZUZvcm1hdC5zdWJOYW1lO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ2hhbmdlTmFtZSA9IEppaS5fLmZpbHRlcih0aGlzLl9ldmVudHNDaGFuZ2VOYW1lLCBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyWzBdICE9PSBjaGFuZ2VOYW1lRXZlbnQgfHwgYXJyWzFdICE9PSBoYW5kbGVyO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwub2ZmKGNoYW5nZU5hbWVFdmVudCwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdXBlcihuYW1lLCBoYW5kbGVyKTtcbiAgICB9LFxuXG4gICAgX2RldGVjdEtleUZvcm1hdENoYW5nZU5hbWU6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgaWYgKG5hbWUuaW5kZXhPZih0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRV9OQU1FKSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3ViTmFtZTogbmFtZS5zdWJzdHIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIEFycmF5IHByb3RvdHlwZVxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IHZhbHVlMVxuICAgICAqIEByZXR1cm5zIHtzZWxmfVxuICAgICAqL1xuICAgIGNvbmNhdDogZnVuY3Rpb24odmFsdWUxKSB7XG4gICAgICAgIHRoaXMuYWRkKEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUucmV2ZXJzZS5jYWxsKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNvcnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBBcnJheS5wcm90b3R5cGUuc29ydC5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLl9vblNvcnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRvZG9cbiAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRvZG9cbiAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHRvTG9jYWxlU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gQHRvZG9cbiAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGRlbGV0ZUNvdW50XG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R9IFttb2RlbDFdXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIHNwbGljZTogZnVuY3Rpb24oc3RhcnQsIGRlbGV0ZUNvdW50LCBtb2RlbDEpIHtcbiAgICAgICAgdmFyIHRvUmVtb3ZlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcywgc3RhcnQsIHN0YXJ0ICsgZGVsZXRlQ291bnQpO1xuICAgICAgICB0aGlzLnJlbW92ZSh0b1JlbW92ZSk7XG4gICAgICAgIHRoaXMuYWRkKEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgyKSwgc3RhcnQpO1xuICAgICAgICByZXR1cm4gdG9SZW1vdmU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGJlZ2luXG4gICAgICogQHBhcmFtIGVuZFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIHNsaWNlOiBmdW5jdGlvbihiZWdpbiwgZW5kKSB7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5fX3N0YXRpYyhBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBiZWdpbiwgZW5kKSwge1xuICAgICAgICAgICAgbW9kZWxDbGFzczogdGhpcy5tb2RlbENsYXNzXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fSBtb2RlbDFcbiAgICAgKi9cbiAgICBwdXNoOiBmdW5jdGlvbihtb2RlbDEpIHtcbiAgICAgICAgdGhpcy5hZGQoSmlpLl8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzW3RoaXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4ub2JqZWN0fSBtb2RlbDFcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHVuc2hpZnQ6IGZ1bmN0aW9uKG1vZGVsMSkge1xuICAgICAgICB0aGlzLmFkZChKaWkuXy50b0FycmF5KGFyZ3VtZW50cyksIDApO1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBzaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzWzBdO1xuICAgICAgICB0aGlzLnJlbW92ZShtb2RlbCk7XG4gICAgICAgIHJldHVybiBtb2RlbDtcbiAgICB9LFxuXG4gICAgLy8gQHRvZG8gRVM2IG1ldGhvZHNcbiAgICAvL2VzNiBjb3B5V2l0aGluOiBmdW5jdGlvbigpIHt9LFxuICAgIC8vZXM2IGVudHJpZXM6IGZ1bmN0aW9uKCkge30sXG4gICAgLy9lczYgZmlsbDogZnVuY3Rpb24oKSB7fSxcbiAgICAvL2VzNiBrZXlzOiBmdW5jdGlvbigpIHt9LFxuICAgIC8vZXM2IHZhbHVlczogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8vIFVuZGVyc2NvcmUgbWV0aG9kc1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uZWFjaCh0aGlzLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICovXG4gICAgZm9yRWFjaDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWFjaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBtYXA6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5tYXAodGhpcywgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICogQHBhcmFtIHsqfSBbbWVtb11cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIHJlZHVjZTogZnVuY3Rpb24oaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLnJlZHVjZSh0aGlzLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgcmVkdWNlUmlnaHQ6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5yZWR1Y2VSaWdodCh0aGlzLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZmluZDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5maW5kKHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBmaWx0ZXI6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uZmlsdGVyKHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXNcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHdoZXJlOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy53aGVyZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZmluZFdoZXJlOiBmdW5jdGlvbihwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5maW5kV2hlcmUodGhpcywgcHJvcGVydGllcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICByZWplY3Q6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8ucmVqZWN0KHRoaXMsIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZWRpY2F0ZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICovXG4gICAgZXZlcnk6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uZXZlcnkodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJlZGljYXRlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBzb21lOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLnNvbWUodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleF1cbiAgICAgKi9cbiAgICBjb250YWluczogZnVuY3Rpb24odmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uY29udGFpbnModGhpcywgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdXG4gICAgICovXG4gICAgaW5jbHVkZXM6IGZ1bmN0aW9uKHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZE5hbWVdXG4gICAgICogQHBhcmFtIHsuLi4qfSBbbWV0aG9kUGFyYW1dXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIGludm9rZTogZnVuY3Rpb24obWV0aG9kTmFtZSwgbWV0aG9kUGFyYW0pIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBKaWkuXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIEppaS5fLmludm9rZS5hcHBseShKaWkuXywgYXJncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5TmFtZVxuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBwbHVjazogZnVuY3Rpb24ocHJvcGVydHlOYW1lKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5tYXAodGhpcywgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKG1vZGVsLmdldCkgPyBtb2RlbC5nZXQocHJvcGVydHlOYW1lKSA6IG1vZGVsW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtpdGVyYXRlZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBtYXg6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5tYXgodGhpcywgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtpdGVyYXRlZV1cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBtaW46IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5taW4odGhpcywgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB2YWx1ZVxuICAgICAqIEBwYXJhbSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgc29ydEJ5OiBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBKaWkuXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKG1vZGVsLmdldCkgPyBtb2RlbC5nZXQodmFsdWUpIDogbW9kZWxbdmFsdWVdO1xuICAgICAgICB9O1xuICAgICAgICBKaWkuXy5lYWNoKEppaS5fLnNvcnRCeSh0aGlzLCBpdGVyYXRvciwgY29udGV4dCksIGZ1bmN0aW9uKG1vZGVsLCBpKSB7XG4gICAgICAgICAgICB0aGlzW2ldID0gbW9kZWw7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuX29uU29ydCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB2YWx1ZVxuICAgICAqIEBwYXJhbSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgZ3JvdXBCeTogZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gSmlpLl8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbihtb2RlbC5nZXQpID8gbW9kZWwuZ2V0KHZhbHVlKSA6IG1vZGVsW3ZhbHVlXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEppaS5fLmdyb3VwQnkodGhpcywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB2YWx1ZVxuICAgICAqIEBwYXJhbSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgaW5kZXhCeTogZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gSmlpLl8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbihtb2RlbC5nZXQpID8gbW9kZWwuZ2V0KHZhbHVlKSA6IG1vZGVsW3ZhbHVlXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEppaS5fLmluZGV4QnkodGhpcywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfGZ1bmN0aW9ufSB2YWx1ZVxuICAgICAqIEBwYXJhbSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgY291bnRCeTogZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gSmlpLl8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbihtb2RlbC5nZXQpID8gbW9kZWwuZ2V0KHZhbHVlKSA6IG1vZGVsW3ZhbHVlXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEppaS5fLmNvdW50QnkodGhpcywgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW251bV1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZpcnN0OiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmZpcnN0KHRoaXMsIG51bSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIFtudW1dXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIGluaXRpYWw6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICByZXR1cm4gSmlpLl8uaW5pdGlhbCh0aGlzLCBudW0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbbnVtXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgbGFzdDogZnVuY3Rpb24obnVtKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5sYXN0KHRoaXMsIG51bSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHJlc3Q6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5yZXN0KHRoaXMsIGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZV1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgd2l0aG91dDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBKaWkuXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIEppaS5fLndpdGhvdXQuYXBwbHkoSmlpLl8sIGFyZ3MpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU29ydGVkXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgaW5kZXhPZjogZnVuY3Rpb24odmFsdWUsIGlzU29ydGVkKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5pbmRleE9mKHRoaXMsIHZhbHVlLCBpc1NvcnRlZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4XVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgbGFzdEluZGV4T2Y6IGZ1bmN0aW9uKHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmxhc3RJbmRleE9mKHRoaXMsIHZhbHVlLCBmcm9tSW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzb3J0ZWRJbmRleDogZnVuY3Rpb24obW9kZWwsIHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IEppaS5fLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIEppaS5fLmlzRnVuY3Rpb24obW9kZWwuZ2V0KSA/IG1vZGVsLmdldCh2YWx1ZSkgOiBtb2RlbFt2YWx1ZV07XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBKaWkuXy5zb3J0ZWRJbmRleCh0aGlzLCBtb2RlbCwgaXRlcmF0b3IsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZpbmRJbmRleDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5maW5kSW5kZXgodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBmaW5kTGFzdEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmZpbmRMYXN0SW5kZXgodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKi9cbiAgICBzaHVmZmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgSmlpLl8uc2h1ZmZsZSh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc0VtcHR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAwO1xuICAgIH1cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sOTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9Db2xsZWN0aW9uJyk7XG5cbi8qKlxuICogQmFzZURhdGFQcm92aWRlciBwcm92aWRlcyBhIGJhc2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBbW0RhdGFQcm92aWRlckludGVyZmFjZV1dLlxuICpcbiAqIEBjbGFzcyBKaWkuYmFzZS5EYXRhUHJvdmlkZXJcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbGxlY3Rpb25cbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5EYXRhUHJvdmlkZXInLCAvKiogQGxlbmRzIEppaS5iYXNlLkRhdGFQcm92aWRlci5wcm90b3R5cGUgKi97XG5cbiAgICBfX2V4dGVuZHM6IEppaS5iYXNlLkNvbGxlY3Rpb24sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfSBhbiBJRCB0aGF0IHVuaXF1ZWx5IGlkZW50aWZpZXMgdGhlIGRhdGEgcHJvdmlkZXIgYW1vbmcgYWxsIGRhdGEgcHJvdmlkZXJzLlxuICAgICAqIFlvdSBzaG91bGQgc2V0IHRoaXMgcHJvcGVydHkgaWYgdGhlIHNhbWUgcGFnZSBjb250YWlucyB0d28gb3IgbW9yZSBkaWZmZXJlbnQgZGF0YSBwcm92aWRlcnMuXG4gICAgICogT3RoZXJ3aXNlLCB0aGUgW1twYWdpbmF0aW9uXV0gYW5kIFtbc29ydF1dIG1heSBub3Qgd29yayBwcm9wZXJseS5cbiAgICAgKi9cbiAgICBpZDogbnVsbCxcblxuICAgIF9zb3J0OiBudWxsLFxuICAgIF9wYWdpbmF0aW9uOiBudWxsLFxuICAgIF9rZXlzOiBudWxsLFxuICAgIF9pc01vZGVsc1ByZXBhcmU6IGZhbHNlLFxuICAgIF90b3RhbENvdW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgdGhlIGRhdGEgbW9kZWxzIHRoYXQgd2lsbCBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqIEByZXR1cm5zIHtbXX0gdGhlIGF2YWlsYWJsZSBkYXRhIG1vZGVsc1xuICAgICAqL1xuICAgIHByZXBhcmVNb2RlbHM6IGZ1bmN0aW9uICgpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUga2V5cyBhc3NvY2lhdGVkIHdpdGggdGhlIGN1cnJlbnRseSBhdmFpbGFibGUgZGF0YSBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtbXX0gbW9kZWxzIHRoZSBhdmFpbGFibGUgZGF0YSBtb2RlbHNcbiAgICAgKiBAcmV0dXJucyB7W119IHRoZSBrZXlzXG4gICAgICovXG4gICAgcHJlcGFyZUtleXM6IGZ1bmN0aW9uIChtb2RlbHMpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgbW9kZWxzIGluIHRoaXMgZGF0YSBwcm92aWRlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0b3RhbCBudW1iZXIgb2YgZGF0YSBtb2RlbHMgaW4gdGhpcyBkYXRhIHByb3ZpZGVyLlxuICAgICAqL1xuICAgIHByZXBhcmVUb3RhbENvdW50OiBmdW5jdGlvbiAoKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgdGhlIGRhdGEgbW9kZWxzIGFuZCBrZXlzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBwcmVwYXJlIHRoZSBkYXRhIG1vZGVscyBhbmQga2V5cyB0aGF0IGNhbiBiZSByZXRyaWV2ZWQgdmlhXG4gICAgICogW1tnZXRNb2RlbHMoKV1dIGFuZCBbW2dldEtleXMoKV1dLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2Qgd2lsbCBiZSBpbXBsaWNpdGx5IGNhbGxlZCBieSBbW2dldE1vZGVscygpXV0gYW5kIFtbZ2V0S2V5cygpXV0gaWYgaXQgaGFzIG5vdCBiZWVuIGNhbGxlZCBiZWZvcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZVByZXBhcmVdIHdoZXRoZXIgdG8gZm9yY2UgZGF0YSBwcmVwYXJhdGlvbiBldmVuIGlmIGl0IGhhcyBiZWVuIGRvbmUgYmVmb3JlLlxuICAgICAqL1xuICAgIHByZXBhcmU6IGZ1bmN0aW9uIChmb3JjZVByZXBhcmUpIHtcbiAgICAgICAgZm9yY2VQcmVwYXJlID0gZm9yY2VQcmVwYXJlIHx8IGZhbHNlO1xuXG4gICAgICAgIGlmIChmb3JjZVByZXBhcmUgfHwgIXRoaXMuX2lzTW9kZWxzUHJlcGFyZSkge1xuICAgICAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLnByZXBhcmVNb2RlbHMoKSwgZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcmNlUHJlcGFyZSB8fCB0aGlzLl9rZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9rZXlzID0gdGhpcy5wcmVwYXJlS2V5cyh0aGlzLl9tb2RlbHMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRhdGEgbW9kZWxzIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICogQHJldHVybnMge1tdfSB0aGUgbGlzdCBvZiBkYXRhIG1vZGVscyBpbiB0aGUgY3VycmVudCBwYWdlLlxuICAgICAqL1xuICAgIGdldE1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXBhcmUoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3N1cGVyKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGtleSB2YWx1ZXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBkYXRhIG1vZGVscy5cbiAgICAgKiBAcmV0dXJucyB7W119IHRoZSBsaXN0IG9mIGtleSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byBbW21vZGVsc11dLiBFYWNoIGRhdGEgbW9kZWwgaW4gW1ttb2RlbHNdXVxuICAgICAqIGlzIHVuaXF1ZWx5IGlkZW50aWZpZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcga2V5IHZhbHVlIGluIHRoaXMgYXJyYXkuXG4gICAgICovXG4gICAgZ2V0S2V5czogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnByZXBhcmUoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUga2V5IHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGRhdGEgbW9kZWxzLlxuICAgICAqIEBwYXJhbSB7W119IGtleXMgdGhlIGxpc3Qgb2Yga2V5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIFtbbW9kZWxzXV0uXG4gICAgICovXG4gICAgc2V0S2V5czogZnVuY3Rpb24gKGtleXMpIHtcbiAgICAgICAgdGhpcy5fa2V5cyA9IGtleXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIG1vZGVscy5cbiAgICAgKiBXaGVuIFtbcGFnaW5hdGlvbl1dIGlzIGZhbHNlLCB0aGlzIHJldHVybnMgdGhlIHNhbWUgdmFsdWUgYXMgW1tjb3VudF1dLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCBjYWxsIFtbcHJlcGFyZVRvdGFsQ291bnQoKV1dIHRvIGdldCB0aGUgY291bnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gdG90YWwgbnVtYmVyIG9mIHBvc3NpYmxlIGRhdGEgbW9kZWxzLlxuICAgICAqL1xuICAgIGdldFRvdGFsQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuZ2V0UGFnaW5hdGlvbigpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q291bnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl90b3RhbENvdW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl90b3RhbENvdW50ID0gdGhpcy5wcmVwYXJlVG90YWxDb3VudCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX3RvdGFsQ291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIG1vZGVscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgdGhlIHRvdGFsIG51bWJlciBvZiBkYXRhIG1vZGVscy5cbiAgICAgKi9cbiAgICBzZXRUb3RhbENvdW50OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fdG90YWxDb3VudCA9IHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYWdpbmF0aW9uIG9iamVjdCB1c2VkIGJ5IHRoaXMgZGF0YSBwcm92aWRlci5cbiAgICAgKiBOb3RlIHRoYXQgeW91IHNob3VsZCBjYWxsIFtbcHJlcGFyZSgpXV0gb3IgW1tnZXRNb2RlbHMoKV1dIGZpcnN0IHRvIGdldCBjb3JyZWN0IHZhbHVlc1xuICAgICAqIG9mIFtbUGFnaW5hdGlvbi50b3RhbENvdW50XV0gYW5kIFtbUGFnaW5hdGlvbi5wYWdlQ291bnRdXS5cbiAgICAgKiBAcmV0dXJucyB7amlpLmRhdGEuUGFnaW5hdGlvbnxib29sZWFufSB0aGUgcGFnaW5hdGlvbiBvYmplY3QuIElmIHRoaXMgaXMgZmFsc2UsIGl0IG1lYW5zIHRoZSBwYWdpbmF0aW9uIGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGdldFBhZ2luYXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQHRvZG8gUGFnaW5hdGlvbiAmIFNvcnRcbiAgICAgICAgLyppZiAodGhpcy5fcGFnaW5hdGlvbiA9PT0gbnVsbCkge1xuICAgICAgICAgdGhpcy5zZXRQYWdpbmF0aW9uKHt9KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3BhZ2luYXRpb247Ki9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgcGFnaW5hdGlvbiBmb3IgdGhpcyBkYXRhIHByb3ZpZGVyLlxuICAgICAqIEBwYXJhbSB7W118amlpLmRhdGEuUGFnaW5hdGlvbnxib29sZWFufSB2YWx1ZSB0aGUgcGFnaW5hdGlvbiB0byBiZSB1c2VkIGJ5IHRoaXMgZGF0YSBwcm92aWRlci5cbiAgICAgKiBUaGlzIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIC0gYSBjb25maWd1cmF0aW9uIGFycmF5IGZvciBjcmVhdGluZyB0aGUgcGFnaW5hdGlvbiBvYmplY3QuIFRoZSBcImNsYXNzXCIgZWxlbWVudCBkZWZhdWx0c1xuICAgICAqICAgdG8gJ2ppaVxcZGF0YVxcUGFnaW5hdGlvbidcbiAgICAgKiAtIGFuIGluc3RhbmNlIG9mIFtbUGFnaW5hdGlvbl1dIG9yIGl0cyBzdWJjbGFzc1xuICAgICAqIC0gZmFsc2UsIGlmIHBhZ2luYXRpb24gbmVlZHMgdG8gYmUgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEludmFsaWRQYXJhbUV4Y2VwdGlvblxuICAgICAqL1xuICAgIHNldFBhZ2luYXRpb246IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKmlmIChKaWkuXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgIGNvbmZpZyA9IHtjbGFzczogUGFnaW5hdGlvbi5jbGFzc05hbWUoKX07XG4gICAgICAgICBpZiAodGhpcy5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgY29uZmlnWydwYWdlUGFyYW0nXSA9IHRoaXMuaWQgLiAnLXBhZ2UnO1xuICAgICAgICAgY29uZmlnWydwYWdlU2l6ZVBhcmFtJ10gPSB0aGlzLmlkIC4gJy1wZXItcGFnZSc7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLl9wYWdpbmF0aW9uID0gSmlpLmNyZWF0ZU9iamVjdChhcnJheV9tZXJnZShjb25maWcsIHZhbHVlKSk7XG4gICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgUGFnaW5hdGlvbiB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgIHRoaXMuX3BhZ2luYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdPbmx5IFBhZ2luYXRpb24gaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24gYXJyYXkgb3IgZmFsc2UgaXMgYWxsb3dlZC4nKTtcbiAgICAgICAgIH0qL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7amlpLmRhdGEuU29ydHxib29sZWFufSB0aGUgc29ydGluZyBvYmplY3QuIElmIHRoaXMgaXMgZmFsc2UsIGl0IG1lYW5zIHRoZSBzb3J0aW5nIGlzIGRpc2FibGVkLlxuICAgICAqL1xuICAgIGdldFNvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gQHRvZG8gUGFnaW5hdGlvbiAmIFNvcnRcbiAgICAgICAgLyppZiAodGhpcy5fc29ydCA9PT0gbnVsbCkge1xuICAgICAgICAgdGhpcy5zZXRTb3J0KHt9KTtcbiAgICAgICAgIH1cblxuICAgICAgICAgcmV0dXJuIHRoaXMuX3NvcnQ7Ki9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgc29ydCBkZWZpbml0aW9uIGZvciB0aGlzIGRhdGEgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHtbXXxqaWkuZGF0YS5Tb3J0fGJvb2xlYW59IHZhbHVlIHRoZSBzb3J0IGRlZmluaXRpb24gdG8gYmUgdXNlZCBieSB0aGlzIGRhdGEgcHJvdmlkZXIuXG4gICAgICogVGhpcyBjYW4gYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAgICpcbiAgICAgKiAtIGEgY29uZmlndXJhdGlvbiBhcnJheSBmb3IgY3JlYXRpbmcgdGhlIHNvcnQgZGVmaW5pdGlvbiBvYmplY3QuIFRoZSBcImNsYXNzXCIgZWxlbWVudCBkZWZhdWx0c1xuICAgICAqICAgdG8gJ2ppaVxcZGF0YVxcU29ydCdcbiAgICAgKiAtIGFuIGluc3RhbmNlIG9mIFtbU29ydF1dIG9yIGl0cyBzdWJjbGFzc1xuICAgICAqIC0gZmFsc2UsIGlmIHNvcnRpbmcgbmVlZHMgdG8gYmUgZGlzYWJsZWQuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIEludmFsaWRQYXJhbUV4Y2VwdGlvblxuICAgICAqL1xuICAgIHNldFNvcnQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKmlmIChKaWkuXy5pc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgIGNvbmZpZyA9IHtjbGFzczogU29ydC5jbGFzc05hbWUoKX07XG4gICAgICAgICBpZiAodGhpcy5pZCAhPT0gbnVsbCkge1xuICAgICAgICAgY29uZmlnWydzb3J0UGFyYW0nXSA9IHRoaXMuaWQgLiAnLXNvcnQnO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5fc29ydCA9IEppaS5jcmVhdGVPYmplY3QoYXJyYXlfbWVyZ2UoY29uZmlnLCB2YWx1ZSkpO1xuICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNvcnQgfHwgdmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICB0aGlzLl9zb3J0ID0gdmFsdWU7XG4gICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRQYXJhbUV4Y2VwdGlvbignT25seSBTb3J0IGluc3RhbmNlLCBjb25maWd1cmF0aW9uIGFycmF5IG9yIGZhbHNlIGlzIGFsbG93ZWQuJyk7XG4gICAgICAgICB9Ki9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVmcmVzaGVzIHRoZSBkYXRhIHByb3ZpZGVyLlxuICAgICAqIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsIGlmIFtbZ2V0TW9kZWxzKCldXSwgW1tnZXRLZXlzKCldXSBvciBbW2dldFRvdGFsQ291bnQoKV1dIGlzIGNhbGxlZCBhZ2FpbixcbiAgICAgKiB0aGV5IHdpbGwgcmUtZXhlY3V0ZSB0aGUgcXVlcnkgYW5kIHJldHVybiB0aGUgbGF0ZXN0IGRhdGEgYXZhaWxhYmxlLlxuICAgICAqL1xuICAgIHJlZnJlc2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5zcGxpY2UoMCwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLl90b3RhbENvdW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fa2V5cyA9IG51bGw7XG4gICAgfVxuXG5cbn0pO1xuXG59LHtcIi4vQ29sbGVjdGlvblwiOjk4LFwiamlpXCI6MTI0fV0sMTAwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLk1vZGVsXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5Nb2RlbCcsIC8qKiBAbGVuZHMgSmlpLmJhc2UuTW9kZWwucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG5cdF9hdHRyaWJ1dGVzOiB7fSxcblx0X2Vycm9yczoge30sXG5cdF92YWxpZGF0b3JzOiBudWxsLFxuXHRfc2NlbmFyaW86ICdkZWZhdWx0JyxcblxuICAgIF9lZGl0ZWRMZXZlbDogMCxcbiAgICBfZWRpdGVkU3ViTW9kZWxzOiBbXSxcbiAgICBfZWRpdGVkQ2hhbmdlczoge30sXG5cbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2RlbCAqL3tcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLk1vZGVsI2NoYW5nZVxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5tb2RlbC5DaGFuZ2VFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX0NIQU5HRTogJ2NoYW5nZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Nb2RlbCNjaGFuZ2U6XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNoYW5nZUF0dHJpYnV0ZUV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQ0hBTkdFX05BTUU6ICdjaGFuZ2U6J1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoYXR0cmlidXRlcywgY29uZmlnKSB7XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChhdHRyaWJ1dGVzKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQoYXR0cmlidXRlcyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3VwZXIoY29uZmlnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogVmFsaWRhdGlvbiBydWxlc1xuICAgICAqIEByZXR1cm5zIHtBcnJheX1cbiAgICAgKi9cbiAgICBydWxlczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEJlZ2luIGNoYW5nZSBvcGVyYXRpb25cbiAgICAgKi9cbiAgICBiZWdpbkVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9lZGl0ZWRMZXZlbCsrO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWwgYWxsIGNoYW5nZXMgYWZ0ZXIgYmVnaW5FZGl0KCkgY2FsbFxuICAgICAqL1xuICAgIGNhbmNlbEVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZWRpdGVkTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0ZWRMZXZlbC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FuY2VsIGluIHN1Yi1tb2RlbHNcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRlZExldmVsID09PSAwKSB7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKHRoaXMuX2VkaXRlZFN1Yk1vZGVscywgZnVuY3Rpb24gKHN1Yk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgc3ViTW9kZWwuY2FuY2VsRWRpdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFJldmVydCBhdHRyaWJ1dGUgY2hhbmdlc1xuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9lZGl0ZWRDaGFuZ2VzLCBmdW5jdGlvbiAodmFsdWVzLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRW5kIGNoYW5nZSBvcGVyYXRpb24gLSB0cmlnZ2VyIGNoYW5nZSBldmVudHNcbiAgICAgKi9cbiAgICBlbmRFZGl0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VkaXRlZExldmVsID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZWRpdGVkTGV2ZWwtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9lZGl0ZWRMZXZlbCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRW5kIGluIHN1Yi1tb2RlbHNcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZWRpdGVkU3ViTW9kZWxzLCBmdW5jdGlvbihzdWJNb2RlbCkge1xuICAgICAgICAgICAgICAgIHN1Yk1vZGVsLmVuZEVkaXQoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGNoYW5nZSBhdHRyaWJ1dGUgZXZlbnRzXG4gICAgICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkodGhpcy5fZWRpdGVkQ2hhbmdlcykpIHtcbiAgICAgICAgICAgICAgICBKaWkuXy5lYWNoKHRoaXMuX2VkaXRlZENoYW5nZXMsIGZ1bmN0aW9uKHZhbHVlcywgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRSArIG5hbWUsIG5ldyBKaWkubW9kZWwuQ2hhbmdlQXR0cmlidXRlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWU6IHZhbHVlc1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZhbHVlOiB2YWx1ZXNbMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlczogdGhpcy5fZWRpdGVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgY2hhbmdlIGV2ZW50XG4gICAgICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFLCBuZXcgSmlpLm1vZGVsLkNoYW5nZUV2ZW50KHtcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiB0aGlzLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlczogdGhpcy5fZWRpdGVkQ2hhbmdlc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gUmVzZXQgc3RhdGVcbiAgICAgICAgICAgIHRoaXMuX2VkaXRlZFN1Yk1vZGVscyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZWRpdGVkQ2hhbmdlcyA9IHt9O1xuICAgICAgICB9XG4gICAgfSxcblxuXHQvKipcblx0ICogR2V0IGF0dHJpYnV0ZSB2YWx1ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdWIgbW9kZWxzIHN1cHBvcnQ6IGZvb1swXVxuICAgICAgICB2YXIgY29sbGVjdGlvbkZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdENvbGxlY3Rpb24obmFtZSwgJycsIHRydWUpO1xuICAgICAgICBpZiAoY29sbGVjdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25Gb3JtYXQuc3ViTmFtZSA/XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbkZvcm1hdC5tb2RlbC5nZXQoY29sbGVjdGlvbkZvcm1hdC5zdWJOYW1lKSA6XG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbkZvcm1hdC5tb2RlbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1YiBtb2RlbHMgc3VwcG9ydDogZm9vLmJhclxuICAgICAgICB2YXIgbW9kZWxGb3JtYXQgPSB0aGlzLl9kZXRlY3RLZXlGb3JtYXRNb2RlbChuYW1lKTtcbiAgICAgICAgaWYgKG1vZGVsRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWxGb3JtYXQubW9kZWwgP1xuICAgICAgICAgICAgICAgIG1vZGVsRm9ybWF0Lm1vZGVsLmdldChtb2RlbEZvcm1hdC5zdWJOYW1lKSA6XG4gICAgICAgICAgICAgICAgbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoIShlIGluc3RhbmNlb2YgSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uKSkge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgYXR0cmlidXRlIHZhbHVlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fHN0cmluZ30gbmFtZVxuXHQgKiBAcGFyYW0geyp9IFt2YWx1ZV1cblx0ICovXG5cdHNldDogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIE9iamVjdCBmb3JtYXQgc3VwcG9ydFxuICAgICAgICBpZiAoSmlpLl8uaXNPYmplY3QobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYmVnaW5FZGl0KCk7XG5cbiAgICAgICAgICAgIHZhciBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIEppaS5fLmVhY2gobmFtZSwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZXQobmFtZSwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgdGhpcy5lbmRFZGl0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXNDaGFuZ2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb29bMF0uYmFyLnplblxuICAgICAgICB2YXIgc3ViTWF0Y2hlcyA9IC9eKC4rKVxcLihbXlxcW1xcXS5dKykkLy5leGVjKG5hbWUpO1xuICAgICAgICBpZiAoc3ViTWF0Y2hlcyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHN1Yk1vZGVsID0gdGhpcy5nZXQoc3ViTWF0Y2hlc1sxXSk7XG5cbiAgICAgICAgICAgIC8vIENoZWNrIHN1Yi1tb2RlbCBpcyBKaWkuYmFzZS5Nb2RlbFxuICAgICAgICAgICAgaWYgKHN1Yk1vZGVsIGluc3RhbmNlb2YgSmlpLmJhc2UuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24oJ1RyeSBzZXQgcHJvcGVydHkgb2YgYXJyYXkgbW9kZWxzOiBgJyArIG5hbWUgKyAnYCcpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghKHN1Yk1vZGVsIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLlVua25vd25Qcm9wZXJ0eUV4Y2VwdGlvbignU2V0dGluZyBwcm9wZXJ0eSBvZiBudWxsIHN1Yi1tb2RlbCBgJyArIG5hbWUgKyAnYCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdWJNb2RlbC5iZWdpbkVkaXQoKTtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRlZFN1Yk1vZGVscy5wdXNoKHN1Yk1vZGVsKTtcblxuICAgICAgICAgICAgdmFyIGlzU3ViQ2hhbmdlZCA9IHN1Yk1vZGVsLnNldChzdWJNYXRjaGVzWzJdLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgIHRoaXMuZW5kRWRpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzU3ViQ2hhbmdlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbkVkaXQoKTtcblxuICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgICAgIHZhciBpc0F0dHJpYnV0ZUNoYW5nZWQgPSAhSmlpLl8uaXNFcXVhbChvbGRWYWx1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXG4gICAgICAgICAgICBpZiAoaXNBdHRyaWJ1dGVDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZWRpdGVkQ2hhbmdlc1tuYW1lXSA9IFtvbGRWYWx1ZSwgdmFsdWVdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmVuZEVkaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0F0dHJpYnV0ZUNoYW5nZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3VwZXIobmFtZSwgdmFsdWUpO1xuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NraXBUaHJvd11cbiAgICAgKiBAcmV0dXJucyB7e21vZGVsOiBKaWkuYmFzZS5BY3RpdmVSZWNvcmQsIG5hbWU6IHN0cmluZywgc3ViTmFtZTogc3RyaW5nfXxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZGV0ZWN0S2V5Rm9ybWF0Q29sbGVjdGlvbjogZnVuY3Rpb24obmFtZSwgcHJlZml4LCBza2lwVGhyb3cpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuICAgICAgICBza2lwVGhyb3cgPSBza2lwVGhyb3cgfHwgZmFsc2U7XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBjaGFuZ2U6Zm9vWzBdXG4gICAgICAgIHZhciBhcnJSZWdFeHAgPSBuZXcgUmVnRXhwKCdeJyArIHByZWZpeCArICcoW15cXFxcW1xcXFxdLl0rKVxcXFxbKFstMC05XSspXFxcXF0oXFxcXC4oLispKT8kJyk7XG4gICAgICAgIHZhciBhcnJNYXRjaGVzID0gYXJyUmVnRXhwLmV4ZWMobmFtZSk7XG4gICAgICAgIGlmIChhcnJNYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xsZWN0aW9uID0gdGhpcy5nZXQoYXJyTWF0Y2hlc1sxXSk7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uIGluc3RhbmNlb2YgSmlpLmJhc2UuQ29sbGVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoYXJyTWF0Y2hlc1syXSk7XG4gICAgICAgICAgICB2YXIgYXJyU3ViTW9kZWwgPSBjb2xsZWN0aW9uLmF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChhcnJTdWJNb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBhcnJTdWJNb2RlbCxcbiAgICAgICAgICAgICAgICAgICAgc3ViTmFtZTogYXJyTWF0Y2hlc1s0XSA/IHByZWZpeCArIGFyck1hdGNoZXNbNF0gOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc2tpcFRocm93KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignTW9kZWwgd2l0aCBpbmRleCBgJyArIGluZGV4ICsgJ2AgaW4gY29sbGVjdGlvbiBgJyArIGFyck1hdGNoZXNbMV0gKyAnYCBpcyBub3QgZm91bmQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIXNraXBUaHJvdykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignUmVsYXRpb24gYCcgKyBhcnJNYXRjaGVzWzFdICsgJ2AgaXMgbm90IGNvbGxlY3Rpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbcHJlZml4XVxuICAgICAqIEByZXR1cm5zIHt7bW9kZWw6IEppaS5iYXNlLkFjdGl2ZVJlY29yZHxudWxsLCBuYW1lOiBzdHJpbmcsIHN1Yk5hbWU6IHN0cmluZ318bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2RldGVjdEtleUZvcm1hdE1vZGVsOiBmdW5jdGlvbihuYW1lLCBwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gICAgICAgIGlmIChwcmVmaXggJiYgbmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcblxuICAgICAgICB2YXIgZG90SW5kZXggPSBuYW1lLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKGRvdEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVsYXRpb25OYW1lID0gbmFtZS5zdWJzdHIoMCwgZG90SW5kZXgpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtb2RlbDogdGhpcy5nZXQocmVsYXRpb25OYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IHJlbGF0aW9uTmFtZSxcbiAgICAgICAgICAgIHN1Yk5hbWU6IHByZWZpeCArIG5hbWUuc3Vic3RyKGRvdEluZGV4ICsgMSlcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIElmIHRoaXMgcmVjb3JkIGlzIHRoZSByZXN1bHQgb2YgYSBxdWVyeSBhbmQgdGhlIGF0dHJpYnV0ZSBpcyBub3QgbG9hZGVkLFxuICAgICAqIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn0gdGhlIGF0dHJpYnV0ZSB2YWx1ZS4gTnVsbCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBzZXQgb3IgZG9lcyBub3QgZXhpc3QuXG4gICAgICogQHNlZSBoYXNBdHRyaWJ1dGUoKVxuICAgICAqL1xuICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmhhcyh0aGlzLl9hdHRyaWJ1dGVzLCBuYW1lKSA/IHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gOiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBuYW1lZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGF0dHJpYnV0ZSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSB0aGUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbn0gaWYgdGhlIG5hbWVkIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAc2VlIGhhc0F0dHJpYnV0ZSgpXG4gICAgICovXG4gICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKHRoaXMuY2xhc3NOYW1lKCkgKyAnIGhhcyBubyBhdHRyaWJ1dGUgbmFtZWQgXCInICsgbmFtZSArICdcIi4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBtb2RlbCBhdHRyaWJ1dGVzLiBUaGlzIG1ldGhvZCBydW4gY2hhbmdlXG5cdCAqIGFuZCBjaGFuZ2U6KiBldmVudHMsIGlmIGF0dHJpYnV0ZXMgd2lsbCBiZSBjaGFuZ2VzXG5cdCAqIEBwYXJhbSBhdHRyaWJ1dGVzXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW3NhZmVPbmx5XVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHNldEF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBzYWZlT25seSkge1xuXHRcdGlmIChKaWkuXy5pc1VuZGVmaW5lZChzYWZlT25seSkpIHtcblx0XHRcdHNhZmVPbmx5ID0gdHJ1ZTtcblx0XHR9XG5cbiAgICAgICAgdmFyIGZpbHRlcmVkQXR0cmlidXRlcyA9IHt9O1xuXHRcdHZhciBhdHRyaWJ1dGVOYW1lcyA9IHNhZmVPbmx5ID8gdGhpcy5zYWZlQXR0cmlidXRlcygpIDogdGhpcy5hdHRyaWJ1dGVzKCk7XG5cblx0XHRKaWkuXy5lYWNoKGF0dHJpYnV0ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcblx0XHRcdGlmIChKaWkuXy5pbmRleE9mKGF0dHJpYnV0ZU5hbWVzLCBrZXkpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQXR0cmlidXRlc1trZXldID0gdmFsdWU7XG5cdFx0XHR9IGVsc2UgaWYgKHNhZmVPbmx5KSB7XG5cdFx0XHRcdHRoaXMub25VbnNhZmVBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIHRoaXMuc2V0KGZpbHRlcmVkQXR0cmlidXRlcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgd2hlbiBhbiB1bnNhZmUgYXR0cmlidXRlIGlzIGJlaW5nIG1hc3NpdmVseSBhc3NpZ25lZC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCBsb2cgYSB3YXJuaW5nIG1lc3NhZ2UgaWYgWUlJX0RFQlVHIGlzIG9uLlxuXHQgKiBJdCBkb2VzIG5vdGhpbmcgb3RoZXJ3aXNlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgdW5zYWZlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgdGhlIGF0dHJpYnV0ZSB2YWx1ZVxuXHQgKi9cblx0b25VbnNhZmVBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuXHRcdGlmIChKaWkuZGVidWcpIHtcblx0XHRcdEppaS50cmFjZSgnRmFpbGVkIHRvIHNldCB1bnNhZmUgYXR0cmlidXRlIGAnICsgbmFtZSArICdgIGluICcgKyB0aGlzLmNsYXNzTmFtZSgpICsgJ2AnKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYXR0cmlidXRlIHZhbHVlcy5cblx0ICogQHBhcmFtIHtBcnJheX0gW25hbWVzXVxuXHQgKiBAcGFyYW0ge0FycmF5fSBbZXhjZXB0XVxuXHQgKiBAcmV0dXJucyB7e319IEF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUgPT4gdmFsdWUpLlxuXHQgKi9cblx0Z2V0QXR0cmlidXRlczogZnVuY3Rpb24gKG5hbWVzLCBleGNlcHQpIHtcblx0XHR2YXIgdmFsdWVzID0ge307XG5cblx0XHRpZiAoIUppaS5fLmlzQXJyYXkobmFtZXMpKSB7XG5cdFx0XHRuYW1lcyA9IHRoaXMuYXR0cmlidXRlcygpO1xuXHRcdH1cblxuXHRcdEppaS5fLmVhY2gobmFtZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRcdGlmICghSmlpLl8uaXNBcnJheShleGNlcHQpIHx8IEppaS5fLmluZGV4T2YobmFtZSwgZXhjZXB0KSA9PT0gLTEpIHtcblx0XHRcdFx0dmFsdWVzW25hbWVdID0gdGhpcy5nZXQobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogR2V0IGF0dHJpYnV0ZXMgbGlzdCBmb3IgdGhpcyBtb2RlbFxuXHQgKiBAcmV0dXJuIHtBcnJheX1cblx0ICovXG5cdGF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gSmlpLl8ua2V5cyh0aGlzLl9hdHRyaWJ1dGVzKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2sgYXR0cmlidXRlIGV4aXN0cyBpbiB0aGlzIG1vZGVsXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0aGFzQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdC8vcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIEppaS5fLmluZGV4T2YodGhpcy5hdHRyaWJ1dGVzKCksIG5hbWUpICE9PSAtMTtcblx0fSxcblxuXHQvKipcblx0ICogRm9ybWF0OiBhdHRyaWJ1dGUgPT4gbGFiZWxcblx0ICogQHJldHVybiB7b2JqZWN0fVxuXHQgKi9cblx0YXR0cmlidXRlTGFiZWxzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgbGFiZWwgYnkgYXR0cmlidXRlIG5hbWVcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldEF0dHJpYnV0ZUxhYmVsOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHZhciBhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVMYWJlbHMoKTtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKGF0dHJpYnV0ZXMsIG5hbWUpID8gYXR0cmlidXRlc1tuYW1lXSA6IG5hbWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBzY2VuYXJpb1xuXHQgKi9cblx0c2V0U2NlbmFyaW86IGZ1bmN0aW9uIChzY2VuYXJpbykge1xuXHRcdHRoaXMuX3NjZW5hcmlvID0gc2NlbmFyaW87XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRTY2VuYXJpbzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9zY2VuYXJpbztcblx0fSxcblxuXHRzYWZlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY2VuYXJpbyA9IHRoaXMuZ2V0U2NlbmFyaW8oKTtcblx0XHR2YXIgc2NlbmFyaW9zID0gdGhpcy5zY2VuYXJpb3MoKTtcblxuXHRcdGlmICghSmlpLl8uaGFzKHNjZW5hcmlvcywgc2NlbmFyaW8pKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBbXTtcblx0XHRKaWkuXy5lYWNoKHNjZW5hcmlvc1tzY2VuYXJpb10sIGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGkpIHtcblx0XHRcdGlmIChhdHRyaWJ1dGUuc3Vic3RyKDAsIDEpICE9PSAnIScpIHtcblx0XHRcdFx0YXR0cmlidXRlcy5wdXNoKGF0dHJpYnV0ZSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0YWN0aXZlQXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBzY2VuYXJpbyA9IHRoaXMuZ2V0U2NlbmFyaW8oKTtcblx0XHR2YXIgc2NlbmFyaW9zID0gdGhpcy5zY2VuYXJpb3MoKTtcblxuXHRcdGlmICghSmlpLl8uaGFzKHNjZW5hcmlvcywgc2NlbmFyaW8pKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSBzY2VuYXJpb3Nbc2NlbmFyaW9dO1xuXHRcdEppaS5fLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHJpYnV0ZSwgaSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZS5zdWJzdHIoMCwgMSkgPT09ICchJykge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW2ldID0gYXR0cmlidXRlLnN1YnN0cigxKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHJldHVybiBhdHRyaWJ1dGVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7T2JqZWN0fVxuXHQgKi9cblx0c2NlbmFyaW9zOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjZW5hcmlvcyA9IHt9O1xuXHRcdHNjZW5hcmlvc1snZGVmYXVsdCddID0gW107XG5cblx0XHRKaWkuXy5lYWNoKHRoaXMuZ2V0VmFsaWRhdG9ycygpLCBmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG5cdFx0XHRKaWkuXy5lYWNoKHZhbGlkYXRvci5vbiwgZnVuY3Rpb24oc2NlbmFyaW8pIHtcblx0XHRcdFx0c2NlbmFyaW9zW3NjZW5hcmlvXSA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0XHRKaWkuXy5lYWNoKHZhbGlkYXRvci5leGNlcHQsIGZ1bmN0aW9uKHNjZW5hcmlvKSB7XG5cdFx0XHRcdHNjZW5hcmlvc1tzY2VuYXJpb10gPSBbXTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHZhciBuYW1lcyA9IEppaS5fLmtleXMoc2NlbmFyaW9zKTtcblxuXHRcdEppaS5fLmVhY2godGhpcy5nZXRWYWxpZGF0b3JzKCksIGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcblx0XHRcdHZhciB2YWxpZGF0b3JTY2VuYXJpb3MgPSB2YWxpZGF0b3Iub24gJiYgdmFsaWRhdG9yLm9uLmxlbmd0aCA+IDAgPyB2YWxpZGF0b3Iub24gOiBuYW1lcztcblx0XHRcdEppaS5fLmVhY2godmFsaWRhdG9yU2NlbmFyaW9zLCBmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0XHRpZiAoIXNjZW5hcmlvc1tuYW1lXSkge1xuXHRcdFx0XHRcdHNjZW5hcmlvc1tuYW1lXSA9IFtdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKEppaS5fLmluZGV4T2YodmFsaWRhdG9yLmV4Y2VwdCwgbmFtZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0SmlpLl8uZWFjaCh2YWxpZGF0b3IuYXR0cmlidXRlcywgZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXG5cdFx0XHRcdFx0aWYgKEppaS5fLmluZGV4T2Yoc2NlbmFyaW9zW25hbWVdLCBhdHRyaWJ1dGUpICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHNjZW5hcmlvc1tuYW1lXS5wdXNoKGF0dHJpYnV0ZSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gc2NlbmFyaW9zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRjcmVhdGVWYWxpZGF0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHZhbGlkYXRvcnMgPSBbXTtcblx0XHRKaWkuXy5lYWNoKHRoaXMucnVsZXMoKSwgSmlpLl8uYmluZChmdW5jdGlvbiAocnVsZSkge1xuXHRcdFx0aWYgKHJ1bGUgaW5zdGFuY2VvZiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IpIHtcblx0XHRcdFx0dmFsaWRhdG9ycy5wdXNoKHJ1bGUpO1xuXHRcdFx0fSBlbHNlIGlmIChKaWkuXy5pc0FycmF5KHJ1bGUpICYmIHJ1bGUubGVuZ3RoID49IDIpIHtcblx0XHRcdFx0dmFyIGF0dHJpYnV0ZXMgPSBKaWkuXy5pc1N0cmluZyhydWxlWzBdKSA/IFtydWxlWzBdXSA6IHJ1bGVbMF07XG5cdFx0XHRcdHZhciBwYXJhbXMgPSBydWxlWzJdIHx8IHt9O1xuXHRcdFx0XHRwYXJhbXMub24gPSBKaWkuXy5pc1N0cmluZyhwYXJhbXMub24pID8gW3BhcmFtcy5vbl0gOiBwYXJhbXMub247XG5cblx0XHRcdFx0dmFyIHZhbGlkYXRvciA9IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvci5jcmVhdGUocnVsZVsxXSwgdGhpcywgYXR0cmlidXRlcywgcGFyYW1zKTtcblx0XHRcdFx0dmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ0ludmFsaWQgdmFsaWRhdGlvbiBydWxlOiBhIHJ1bGUgbXVzdCBzcGVjaWZ5IGJvdGggYXR0cmlidXRlIG5hbWVzIGFuZCB2YWxpZGF0b3IgdHlwZS4nKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSk7XG5cdFx0cmV0dXJuIHZhbGlkYXRvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Z2V0VmFsaWRhdG9yczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl92YWxpZGF0b3JzID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl92YWxpZGF0b3JzID0gdGhpcy5jcmVhdGVWYWxpZGF0b3JzKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl92YWxpZGF0b3JzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0gW2F0dHJpYnV0ZV1cblx0ICogQHJldHVybnMge0FycmF5fVxuXHQgKi9cblx0Z2V0QWN0aXZlVmFsaWRhdG9yczogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHZhciB2YWxpZGF0b3JzID0gW107XG5cdFx0dmFyIHNjZW5hcmlvID0gdGhpcy5nZXRTY2VuYXJpbygpO1xuXG5cdFx0SmlpLl8uZWFjaCh0aGlzLmdldFZhbGlkYXRvcnMoKSwgZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuXHRcdFx0aWYgKCF2YWxpZGF0b3IuaXNBY3RpdmUoc2NlbmFyaW8pKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGF0dHJpYnV0ZSAmJiBKaWkuXy5pbmRleE9mKHZhbGlkYXRvci5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGUpID09PSAtMSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhbGlkYXRvcnMucHVzaCh2YWxpZGF0b3IpO1xuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIHZhbGlkYXRvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFZhbGlkYXRlIG1vZGVsIGJ5IHJ1bGVzLCBzZWUgcnVsZXMoKSBtZXRob2QuXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFthdHRyaWJ1dGVzXVxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc0NsZWFyRXJyb3JzXVxuXHQgKi9cblx0dmFsaWRhdGU6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBpc0NsZWFyRXJyb3JzKSB7XG5cdFx0aWYgKEppaS5fLmlzVW5kZWZpbmVkKGlzQ2xlYXJFcnJvcnMpKSB7XG5cdFx0XHRpc0NsZWFyRXJyb3JzID0gdHJ1ZTtcblx0XHR9XG5cdFx0aWYgKCFhdHRyaWJ1dGVzKSB7XG5cdFx0XHRhdHRyaWJ1dGVzID0gdGhpcy5hY3RpdmVBdHRyaWJ1dGVzKCk7XG5cdFx0fVxuXG5cdFx0dmFyIHNjZW5hcmlvcyA9IHRoaXMuc2NlbmFyaW9zKCk7XG5cdFx0dmFyIHNjZW5hcmlvID0gdGhpcy5nZXRTY2VuYXJpbygpO1xuXHRcdGlmICghSmlpLl8uaGFzKHNjZW5hcmlvcywgc2NlbmFyaW8pKSB7XG5cdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ1Vua25vd24gc2NlbmFyaW8gYCcgKyBzY2VuYXJpbyArICdgLicpO1xuXHRcdH1cblxuXHRcdGlmIChpc0NsZWFyRXJyb3JzKSB7XG5cdFx0XHR0aGlzLmNsZWFyRXJyb3JzKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmJlZm9yZVZhbGlkYXRlKCkpXG5cdFx0XHQudGhlbihKaWkuXy5iaW5kKGZ1bmN0aW9uIChib29sKSB7XG5cdFx0XHRcdGlmICghYm9vbCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIHByb21pc2VzID0gSmlpLl8ubWFwKHRoaXMuZ2V0QWN0aXZlVmFsaWRhdG9ycygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsaWRhdG9yLnZhbGlkYXRlKHRoaXMsIGF0dHJpYnV0ZXMpO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG5cdFx0XHR9LCB0aGlzKSlcblx0XHRcdC50aGVuKHRoaXMuYWZ0ZXJWYWxpZGF0ZSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAodGhpcy5oYXNFcnJvcnMoKSkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIHJlc3VsdFxuXHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHRcdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdGFkZEVycm9yOiBmdW5jdGlvbiAoYXR0cmlidXRlLCBlcnJvcikge1xuXHRcdGlmICghdGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV0pIHtcblx0XHRcdHRoaXMuX2Vycm9yc1thdHRyaWJ1dGVdID0gW107XG5cdFx0fVxuXG5cdFx0dGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV0ucHVzaChlcnJvcik7XG5cdH0sXG5cblx0c2V0RXJyb3JzOiBmdW5jdGlvbiAoZXJyb3JzKSB7XG5cdFx0dGhpcy5fZXJyb3JzID0gZXJyb3JzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0gW2F0dHJpYnV0ZV1cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRnZXRFcnJvcnM6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblx0XHRyZXR1cm4gIWF0dHJpYnV0ZSA/IHRoaXMuX2Vycm9ycyA6IHRoaXMuX2Vycm9yc1thdHRyaWJ1dGVdIHx8IHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0gW2F0dHJpYnV0ZV1cblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRoYXNFcnJvcnM6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblx0XHRyZXR1cm4gYXR0cmlidXRlID8gSmlpLl8uaGFzKHRoaXMuX2Vycm9ycywgYXR0cmlidXRlKSA6ICFKaWkuXy5pc0VtcHR5KHRoaXMuX2Vycm9ycyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBbYXR0cmlidXRlXVxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGNsZWFyRXJyb3JzOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0aWYgKCFhdHRyaWJ1dGUpIHtcblx0XHRcdHRoaXMuX2Vycm9ycyA9IHt9O1xuXHRcdH0gZWxzZSBpZiAodGhpcy5fZXJyb3JzKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV07XG5cdFx0fVxuXHR9LFxuXG5cdGJlZm9yZVZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0YWZ0ZXJWYWxpZGF0ZTogZnVuY3Rpb24gKCkge1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQuXG5cdCAqIFRoaXMgaXMgZGV0ZXJtaW5lZCBieSBjaGVja2luZyBpZiB0aGUgYXR0cmlidXRlIGlzIGFzc29jaWF0ZWQgd2l0aCBhXG5cdCAqIFtbXFxqaWlcXHZhbGlkYXRvcnNcXFJlcXVpcmVkVmFsaWRhdG9yfHJlcXVpcmVkXV0gdmFsaWRhdGlvbiBydWxlIGluIHRoZVxuXHQgKiBjdXJyZW50IFtbc2NlbmFyaW9dXS5cblx0ICpcblx0ICogTm90ZSB0aGF0IHdoZW4gdGhlIHZhbGlkYXRvciBoYXMgYSBjb25kaXRpb25hbCB2YWxpZGF0aW9uIGFwcGxpZWQgdXNpbmdcblx0ICogW1tcXGppaVxcdmFsaWRhdG9yc1xcUmVxdWlyZWRWYWxpZGF0b3Iud2hlbnx3aGVuXV0gdGhpcyBtZXRob2Qgd2lsbCByZXR1cm5cblx0ICogYGZhbHNlYCByZWdhcmRsZXNzIG9mIHRoZSBgd2hlbmAgY29uZGl0aW9uIGJlY2F1c2UgaXQgbWF5IGJlIGNhbGxlZCBiZVxuXHQgKiBiZWZvcmUgdGhlIG1vZGVsIGlzIGxvYWRlZCB3aXRoIGRhdGEuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgYXR0cmlidXRlIG5hbWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyByZXF1aXJlZFxuXHQgKi9cblx0aXNBdHRyaWJ1dGVSZXF1aXJlZDogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHZhciBib29sID0gZmFsc2U7XG5cdFx0SmlpLl8uZWFjaCh0aGlzLmdldEFjdGl2ZVZhbGlkYXRvcnMoYXR0cmlidXRlKSwgSmlpLl8uYmluZChmdW5jdGlvbih2YWxpZGF0b3IpIHtcblx0XHRcdGlmICh2YWxpZGF0b3IgaW5zdGFuY2VvZiBKaWkudmFsaWRhdG9ycy5SZXF1aXJlZFZhbGlkYXRvciAmJiB2YWxpZGF0b3Iud2hlbiA9PT0gbnVsbCkge1xuXHRcdFx0XHRib29sID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSk7XG5cdFx0cmV0dXJuIGJvb2w7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBzYWZlIGZvciBtYXNzaXZlIGFzc2lnbm1lbnRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgaXMgc2FmZSBmb3IgbWFzc2l2ZSBhc3NpZ25tZW50c1xuXHQgKiBAc2VlIHNhZmVBdHRyaWJ1dGVzKClcblx0ICovXG5cdGlzQXR0cmlidXRlU2FmZTogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHJldHVybiBKaWkuXy5pbmRleE9mKHRoaXMuc2FmZUF0dHJpYnV0ZXMoKSwgYXR0cmlidXRlKSAhPT0gLTE7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2NlbmFyaW8uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgYXR0cmlidXRlIG5hbWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBhY3RpdmUgaW4gdGhlIGN1cnJlbnQgc2NlbmFyaW9cblx0ICogQHNlZSBhY3RpdmVBdHRyaWJ1dGVzKClcblx0ICovXG5cdGlzQXR0cmlidXRlQWN0aXZlOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0cmV0dXJuIEppaS5fLmluZGV4T2YodGhpcy5hY3RpdmVBdHRyaWJ1dGVzKCksIGF0dHJpYnV0ZSkgIT09IC0xO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBmaXJzdCBlcnJvciBvZiBldmVyeSBhdHRyaWJ1dGUgaW4gdGhlIG1vZGVsLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgZmlyc3QgZXJyb3JzLiBUaGUgYXJyYXkga2V5cyBhcmUgdGhlIGF0dHJpYnV0ZSBuYW1lcywgYW5kIHRoZSBhcnJheVxuXHQgKiB2YWx1ZXMgYXJlIHRoZSBjb3JyZXNwb25kaW5nIGVycm9yIG1lc3NhZ2VzLiBBbiBlbXB0eSBhcnJheSB3aWxsIGJlIHJldHVybmVkIGlmIHRoZXJlIGlzIG5vIGVycm9yLlxuXHQgKiBAc2VlIGdldEVycm9ycygpXG5cdCAqIEBzZWUgZ2V0Rmlyc3RFcnJvcigpXG5cdCAqL1xuXHRnZXRGaXJzdEVycm9yczogZnVuY3Rpb24gKCkge1xuXHRcdGlmIChKaWkuXy5pc0VtcHR5KHRoaXMuX2Vycm9ycykpIHtcblx0XHRcdHJldHVybiB7fTtcblx0XHR9XG5cblx0XHR2YXIgZXJyb3JzID0ge307XG5cdFx0SmlpLl8uZWFjaCh0aGlzLl9lcnJvcnMsIEppaS5fLmJpbmQoZnVuY3Rpb24oZXMsIG5hbWUpIHtcblx0XHRcdGlmIChlcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdGVycm9yc1tuYW1lXSA9IGVzWzBdO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblxuXHRcdHJldHVybiBlcnJvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IGVycm9yIG9mIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIGF0dHJpYnV0ZSBuYW1lLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgZXJyb3IgbWVzc2FnZS4gTnVsbCBpcyByZXR1cm5lZCBpZiBubyBlcnJvci5cblx0ICogQHNlZSBnZXRFcnJvcnMoKVxuXHQgKiBAc2VlIGdldEZpcnN0RXJyb3JzKClcblx0ICovXG5cdGdldEZpcnN0RXJyb3I6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2Vycm9ycywgYXR0cmlidXRlKSA/IHRoaXMuX2Vycm9yc1thdHRyaWJ1dGVdWzBdIDogbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogR2VuZXJhdGVzIGEgdXNlciBmcmllbmRseSBhdHRyaWJ1dGUgbGFiZWwgYmFzZWQgb24gdGhlIGdpdmUgYXR0cmlidXRlIG5hbWUuXG5cdCAqIFRoaXMgaXMgZG9uZSBieSByZXBsYWNpbmcgdW5kZXJzY29yZXMsIGRhc2hlcyBhbmQgZG90cyB3aXRoIGJsYW5rcyBhbmRcblx0ICogY2hhbmdpbmcgdGhlIGZpcnN0IGxldHRlciBvZiBlYWNoIHdvcmQgdG8gdXBwZXIgY2FzZS5cblx0ICogRm9yIGV4YW1wbGUsICdkZXBhcnRtZW50X25hbWUnIG9yICdEZXBhcnRtZW50TmFtZScgd2lsbCBnZW5lcmF0ZSAnRGVwYXJ0bWVudCBOYW1lJy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGNvbHVtbiBuYW1lXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBhdHRyaWJ1dGUgbGFiZWxcblx0ICovXG5cdGdlbmVyYXRlQXR0cmlidXRlTGFiZWw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIEppaS5fcy5odW1hbml6ZShuYW1lKTtcblx0fVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWFcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2RlbEF0dHJpYnV0ZVNjaGVtYS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0LyoqXG5cdCAqIEB2YXIge3N0cmluZ30gbmFtZSBvZiB0aGlzIGNvbHVtbiAod2l0aG91dCBxdW90ZXMpLlxuXHQgKi9cblx0bmFtZTogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nfSBhYnN0cmFjdCB0eXBlIG9mIHRoaXMgY29sdW1uLiBQb3NzaWJsZSBhYnN0cmFjdCB0eXBlcyBpbmNsdWRlOlxuXHQgKiBzdHJpbmcsIHRleHQsIGJvb2xlYW4sIHNtYWxsaW50LCBpbnRlZ2VyLCBiaWdpbnQsIGZsb2F0LCBkZWNpbWFsLCBkYXRldGltZSxcblx0ICogdGltZXN0YW1wLCB0aW1lLCBkYXRlLCBiaW5hcnksIGFuZCBtb25leS5cblx0ICovXG5cdHR5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB2YXIge3N0cmluZ30gdGhlIEpTIHR5cGUgb2YgdGhpcyBjb2x1bW4uIFBvc3NpYmxlIEpTIHR5cGVzIGluY2x1ZGU6XG5cdCAqIHN0cmluZywgYm9vbGVhbiwgbnVtYmVyLCBkb3VibGUuXG5cdCAqL1xuXHRqc1R5cGU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB2YXIgeyp9IGRlZmF1bHQgdmFsdWUgb2YgdGhpcyBjb2x1bW5cblx0ICovXG5cdGRlZmF1bHRWYWx1ZTogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7Ym9vbGVhbn0gd2hldGhlciB0aGlzIGNvbHVtbiBpcyBhIHByaW1hcnkga2V5XG5cdCAqL1xuXHRpc1ByaW1hcnlLZXk6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyB0aGUgaW5wdXQgdmFsdWUgYWNjb3JkaW5nIHRvIFtbanNUeXBlXV0uXG5cdCAqIElmIHRoZSB2YWx1ZSBpcyBudWxsIG9yIGFuIFtbRXhwcmVzc2lvbl1dLCBpdCB3aWxsIG5vdCBiZSBjb252ZXJ0ZWQuXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgaW5wdXQgdmFsdWVcblx0ICogQHJldHVybiB7Kn0gY29udmVydGVkIHZhbHVlXG5cdCAqL1xuXHR0eXBlY2FzdDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHRpZiAodmFsdWUgPT09ICcnICYmIHRoaXMudHlwZSAhPT0gSmlpLnNxbC5CYXNlU2NoZW1hLlRZUEVfVEVYVCAmJlxuXHRcdFx0dGhpcy50eXBlICE9PSBKaWkuc3FsLkJhc2VTY2hlbWEuVFlQRV9TVFJJTkcgJiZcblx0XHRcdHRoaXMudHlwZSAhPT0gSmlpLnNxbC5CYXNlU2NoZW1hLlRZUEVfQklOQVJZKSB7XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHQvLyBAdG9kbyBwaHAtPmpzIHR5cGVzXG5cdFx0aWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZih2YWx1ZSkgPT09IHRoaXMuanNUeXBlIHx8IHZhbHVlIGluc3RhbmNlb2YgSmlpLnNxbC5FeHByZXNzaW9uKSB7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0c3dpdGNoICh0aGlzLmpzVHlwZSkge1xuXHRcdFx0Y2FzZSAnc3RyaW5nJzpcblx0XHRcdFx0cmV0dXJuIFN0cmluZyh2YWx1ZSk7XG5cblx0XHRcdGNhc2UgJ251bWJlcic6XG5cdFx0XHRcdHJldHVybiBKaWkuXy5pc0Jvb2xlYW4odmFsdWUpID9cblx0XHRcdFx0XHQodmFsdWUgPyAxIDogMCkgOlxuXHRcdFx0XHRcdHBhcnNlRmxvYXQodmFsdWUpO1xuXG5cdFx0XHRjYXNlICdib29sZWFuJzpcblx0XHRcdFx0cmV0dXJuICEhdmFsdWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9LFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9iaiA9IHt9O1xuXG4gICAgICAgIGlmICh0aGlzLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqLmRlZmF1bHRWYWx1ZSA9IHRoaXMuZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgICAgb2JqLmlzUHJpbWFyeUtleSA9IHRoaXMuaXNQcmltYXJ5S2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmpzVHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqLmpzVHlwZSA9IHRoaXMuanNUeXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9iai5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEppaS5fLmlzRW1wdHkob2JqKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG9iai50eXBlID0gdGhpcy50eXBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuTW9kZWxTY2hlbWFcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk1vZGVsU2NoZW1hJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2RlbFNjaGVtYS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2RlbFNjaGVtYSAqL3tcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9ialxuICAgICAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuTW9kZWxTY2hlbWF9XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVGcm9tT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2gob2JqLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbHVtbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICghKGNvbHVtbiBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoSmlpLl8uaXNTdHJpbmcoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEppaS5fLmlzTnVtYmVyKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcnRzID0gY29sdW1uLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3N0cmluZydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGNvbHVtblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghSmlpLl8uaXNPYmplY3QoY29sdW1uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ0ludmFsaWQgY29sdW1uIGZvcm1hdDogJyArIGNvbHVtbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFKaWkuXy5pc1N0cmluZyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uLm5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG9iai5jb2x1bW5zW25hbWVdID0gbmV3IEppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hKGNvbHVtbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBKaWkuYmFzZS5Nb2RlbFNjaGVtYShvYmopO1xuICAgICAgICB9XG5cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtzdHJpbmd9IHRoZSBuYW1lIG9mIHRoZSBzY2hlbWEgdGhhdCB0aGlzIHRhYmxlIGJlbG9uZ3MgdG8uXG5cdCAqL1xuXHRzY2hlbWFOYW1lOiAnJyxcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nW119IHByaW1hcnkga2V5cyBvZiB0aGlzIHRhYmxlLlxuXHQgKi9cblx0cHJpbWFyeUtleTogW10sXG5cblx0LyoqXG5cdCAqIEB2YXIge3tzdHJpbmc6IEppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hfX0gY29sdW1uIG1ldGFkYXRhIG9mIHRoaXMgdGFibGUuIEVhY2ggYXJyYXkgZWxlbWVudCBpcyBhIFtbSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWFdXSBvYmplY3QsIGluZGV4ZWQgYnkgY29sdW1uIG5hbWVzLlxuXHQgKi9cblx0Y29sdW1uczoge30sXG5cblx0LyoqXG5cdCAqIEdldHMgdGhlIG5hbWVkIGNvbHVtbiBtZXRhZGF0YS5cblx0ICogVGhpcyBpcyBhIGNvbnZlbmllbnQgbWV0aG9kIGZvciByZXRyaWV2aW5nIGEgbmFtZWQgY29sdW1uIGV2ZW4gaWYgaXQgZG9lcyBub3QgZXhpc3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIGNvbHVtbiBuYW1lXG5cdCAqIEByZXR1cm4ge0ppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hfSBtZXRhZGF0YSBvZiB0aGUgbmFtZWQgY29sdW1uLiBOdWxsIGlmIHRoZSBuYW1lZCBjb2x1bW4gZG9lcyBub3QgZXhpc3QuXG5cdCAqL1xuXHRnZXRDb2x1bW46IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLmNvbHVtbnMsIG5hbWUpID8gdGhpcy5jb2x1bW5zW25hbWVdIDogbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZXMgb2YgYWxsIGNvbHVtbnMgaW4gdGhpcyB0YWJsZS5cblx0ICogQHJldHVybiB7W119IGxpc3Qgb2YgY29sdW1uIG5hbWVzXG5cdCAqL1xuXHRnZXRDb2x1bW5OYW1lczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBKaWkuXy5rZXlzKHRoaXMuY29sdW1ucyk7XG5cdH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgICAgaWYgKCFKaWkuXy5pc0VtcHR5KHRoaXMucHJpbWFyeUtleSkpIHtcbiAgICAgICAgICAgIG9iai5wcmltYXJ5S2V5ID0gdGhpcy5wcmltYXJ5S2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghSmlpLl8uaXNFbXB0eSh0aGlzLnNjaGVtYU5hbWUpKSB7XG4gICAgICAgICAgICBvYmouc2NoZW1hTmFtZSA9IHRoaXMuc2NoZW1hTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkodGhpcy5jb2x1bW5zKSkge1xuICAgICAgICAgICAgb2JqLmNvbHVtbnMgPSB7fTtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5jb2x1bW5zLCBmdW5jdGlvbihjb2x1bW4sIG5hbWUpIHtcbiAgICAgICAgICAgICAgICBvYmouY29sdW1uc1tuYW1lXSA9IGNvbHVtbi50b0pTT04oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEwMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEFycmF5RGF0YVByb3ZpZGVyIGltcGxlbWVudHMgYSBkYXRhIHByb3ZpZGVyIGJhc2VkIG9uIGEgZGF0YSBhcnJheS5cbiAqXG4gKiBUaGUgW1thbGxNb2RlbHNdXSBwcm9wZXJ0eSBjb250YWlucyBhbGwgZGF0YSBtb2RlbHMgdGhhdCBtYXkgYmUgc29ydGVkIGFuZC9vciBwYWdpbmF0ZWQuXG4gKiBBcnJheURhdGFQcm92aWRlciB3aWxsIHByb3ZpZGUgdGhlIGRhdGEgYWZ0ZXIgc29ydGluZyBhbmQvb3IgcGFnaW5hdGlvbi5cbiAqIFlvdSBtYXkgY29uZmlndXJlIHRoZSBbW3NvcnRdXSBhbmQgW1twYWdpbmF0aW9uXV0gcHJvcGVydGllcyB0b1xuICogY3VzdG9taXplIHRoZSBzb3J0aW5nIGFuZCBwYWdpbmF0aW9uIGJlaGF2aW9ycy5cbiAqXG4gKiBFbGVtZW50cyBpbiB0aGUgW1thbGxNb2RlbHNdXSBhcnJheSBtYXkgYmUgZWl0aGVyIG9iamVjdHMgKGUuZy4gbW9kZWwgb2JqZWN0cylcbiAqIG9yIGFzc29jaWF0aXZlIGFycmF5cyAoZS5nLiBxdWVyeSByZXN1bHRzIG9mIERBTykuXG4gKiBNYWtlIHN1cmUgdG8gc2V0IHRoZSBbW2tleV1dIHByb3BlcnR5IHRvIHRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0aGF0IHVuaXF1ZWx5XG4gKiBpZGVudGlmaWVzIGEgZGF0YSByZWNvcmQgb3IgZmFsc2UgaWYgeW91IGRvIG5vdCBoYXZlIHN1Y2ggYSBmaWVsZC5cbiAqXG4gKiBDb21wYXJlZCB0byBbW0FjdGl2ZURhdGFQcm92aWRlcl1dLCBBcnJheURhdGFQcm92aWRlciBjb3VsZCBiZSBsZXNzIGVmZmljaWVudFxuICogYmVjYXVzZSBpdCBuZWVkcyB0byBoYXZlIFtbYWxsTW9kZWxzXV0gcmVhZHkuXG4gKlxuICogQGNsYXNzIEppaS5iYXNlLkFycmF5RGF0YVByb3ZpZGVyXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5EYXRhUHJvdmlkZXJcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5BcnJheURhdGFQcm92aWRlcicsIC8qKiBAbGVuZHMgSmlpLmJhc2UuQXJyYXlEYXRhUHJvdmlkZXIucHJvdG90eXBlICove1xuXG4gICAgX19leHRlbmRzOiBKaWkuYmFzZS5EYXRhUHJvdmlkZXIsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfGZ1bmN0aW9ufSB0aGUgY29sdW1uIHRoYXQgaXMgdXNlZCBhcyB0aGUga2V5IG9mIHRoZSBkYXRhIG1vZGVscy5cbiAgICAgKiBUaGlzIGNhbiBiZSBlaXRoZXIgYSBjb2x1bW4gbmFtZSwgb3IgYSBjYWxsYWJsZSB0aGF0IHJldHVybnMgdGhlIGtleSB2YWx1ZSBvZiBhIGdpdmVuIGRhdGEgbW9kZWwuXG4gICAgICogSWYgdGhpcyBpcyBub3Qgc2V0LCB0aGUgaW5kZXggb2YgdGhlIFtbbW9kZWxzXV0gYXJyYXkgd2lsbCBiZSB1c2VkLlxuICAgICAqIEBzZWUgZ2V0S2V5cygpXG4gICAgICovXG4gICAga2V5OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge1tdfSB0aGUgZGF0YSB0aGF0IGlzIG5vdCBwYWdpbmF0ZWQgb3Igc29ydGVkLiBXaGVuIHBhZ2luYXRpb24gaXMgZW5hYmxlZCxcbiAgICAgKiB0aGlzIHByb3BlcnR5IHVzdWFsbHkgY29udGFpbnMgbW9yZSBlbGVtZW50cyB0aGFuIFtbbW9kZWxzXV0uXG4gICAgICogVGhlIGFycmF5IGVsZW1lbnRzIG11c3QgdXNlIHplcm8tYmFzZWQgaW50ZWdlciBrZXlzLlxuICAgICAqL1xuICAgIGFsbE1vZGVsczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgX3ByZXBhcmVNb2RlbHM6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1vZGVscyA9IHRoaXMuYWxsTW9kZWxzO1xuICAgICAgICBpZiAobW9kZWxzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKnZhciBzb3J0ID0gdGhpcy5nZXRTb3J0KCk7XG4gICAgICAgIGlmIChzb3J0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgbW9kZWxzID0gdGhpcy5fc29ydE1vZGVscyhKaWkuXy5jbG9uZShtb2RlbHMpLCBzb3J0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYWdpbmF0aW9uID0gdGhpcy5nZXRQYWdpbmF0aW9uKCk7XG4gICAgICAgIGlmIChwYWdpbmF0aW9uICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgcGFnaW5hdGlvbi50b3RhbENvdW50ID0gdGhpcy5nZXRUb3RhbENvdW50KCk7XG5cbiAgICAgICAgICAgIGlmIChwYWdpbmF0aW9uLmdldFBhZ2VTaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgbW9kZWxzID0gYXJyYXlfc2xpY2UobW9kZWxzLCBwYWdpbmF0aW9uLmdldE9mZnNldCgpLCBwYWdpbmF0aW9uLmdldExpbWl0KCksIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9Ki9cblxuICAgICAgICByZXR1cm4gbW9kZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAaW5oZXJpdGRvY1xuICAgICAqL1xuICAgIF9wcmVwYXJlS2V5czogZnVuY3Rpb24gKG1vZGVscykge1xuICAgICAgICBpZiAodGhpcy5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5tYXAobW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmIChKaWkuXy5pc1N0cmluZyh0aGlzLmtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vZGVsW3RoaXMua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5LmNhbGwobnVsbCwgbW9kZWwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBKaWkuXy5rZXlzKG1vZGVscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgX3ByZXBhcmVUb3RhbENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFsbE1vZGVscy5sZW5ndGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNvcnRzIHRoZSBkYXRhIG1vZGVscyBhY2NvcmRpbmcgdG8gdGhlIGdpdmVuIHNvcnQgZGVmaW5pdGlvblxuICAgICAqIEBwYXJhbSB7W119IG1vZGVscyB0aGUgbW9kZWxzIHRvIGJlIHNvcnRlZFxuICAgICAqIEBwYXJhbSB7amlpLmRhdGEuU29ydH0gc29ydCB0aGUgc29ydCBkZWZpbml0aW9uXG4gICAgICogQHJldHVybnMge1tdfSB0aGUgc29ydGVkIGRhdGEgbW9kZWxzXG4gICAgICovXG4gICAgX3NvcnRNb2RlbHM6IGZ1bmN0aW9uIChtb2RlbHMsIHNvcnQpIHtcbiAgICAgICAgLy8gQHRvZG8gUGFnaW5hdGlvbiAmIFNvcnRcbiAgICAgICAgLyp2YXIgb3JkZXJzID0gc29ydC5nZXRPcmRlcnMoKTtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0VtcHR5KG9yZGVycykpIHtcbiAgICAgICAgICAgIEFycmF5SGVscGVyLm11bHRpc29ydChtb2RlbHMsIGFycmF5X2tleXMob3JkZXJzKSwgYXJyYXlfdmFsdWVzKG9yZGVycykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsczsqL1xuICAgIH1cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTA0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9DaGFuZ2VFdmVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkubW9kZWwuQ2hhbmdlQXR0cmlidXRlRXZlbnRcbiAqIEBleHRlbmRzIEppaS5tb2RlbC5DaGFuZ2VFdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5tb2RlbC5DaGFuZ2VBdHRyaWJ1dGVFdmVudCcsIC8qKiBAbGVuZHMgSmlpLm1vZGVsLkNoYW5nZUF0dHJpYnV0ZUV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5tb2RlbC5DaGFuZ2VFdmVudCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgYXR0cmlidXRlOiAnJyxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIG9sZFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgbmV3VmFsdWU6IG51bGxcblxufSk7XG5cbn0se1wiLi9DaGFuZ2VFdmVudFwiOjEwNSxcImppaVwiOjEyNH1dLDEwNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5tb2RlbC5DaGFuZ2VFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkubW9kZWwuQ2hhbmdlRXZlbnQnLCAvKiogQGxlbmRzIEppaS5tb2RlbC5DaGFuZ2VFdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5FdmVudCxcblxuICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiB7fVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkubW9kZWwuQ29sbGVjdGlvbkV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5tb2RlbC5Db2xsZWN0aW9uRXZlbnQnLCAvKiogQGxlbmRzIEppaS5tb2RlbC5Db2xsZWN0aW9uRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtKaWkuYmFzZS5Nb2RlbFtdfVxuICAgICAqL1xuICAgIGFkZGVkOiBbXSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0ppaS5iYXNlLk1vZGVsW119XG4gICAgICovXG4gICAgcmVtb3ZlZDogW11cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTA3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5tb2RlbC5MaW5rTW9kZWxFdmVudCcsIC8qKiBAbGVuZHMgSmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG4gICAgLyoqXG4gICAgICogUmVsYXRpb24gbmFtZVxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICovXG4gICAgcmVsYXRpb25OYW1lOiBudWxsXG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEwODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5Cb29sZWFuVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5Cb29sZWFuVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5Cb29sZWFuVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuICAgIHRydWVWYWx1ZTogJzEnLFxuXG4gICAgZmFsc2VWYWx1ZTogJzAnLFxuXG4gICAgc3RyaWN0OiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gJyc7IC8vIEB0b2RvXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UsIHtcbiAgICAgICAgICAgICAgICB0cnVlVmFsdWU6IHRoaXMudHJ1ZVZhbHVlLFxuICAgICAgICAgICAgICAgIGZhbHNlVmFsdWU6IHRoaXMuZmFsc2VWYWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IHRoaXMudHJ1ZVZhbHVlIHx8IHZhbHVlID09PSB0aGlzLmZhbHNlVmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT0gdGhpcy50cnVlVmFsdWUgfHwgdmFsdWUgPT0gdGhpcy5mYWxzZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDEwOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5Db21wYXJlVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5Db21wYXJlVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5Db21wYXJlVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuICAgIGNvbXBhcmVBdHRyaWJ1dGU6IG51bGwsXG5cbiAgICBjb21wYXJlVmFsdWU6IG51bGwsXG5cbiAgICBvcGVyYXRvcjogJz09JyxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gJyc7IC8vIEB0b2RvXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBjb21wYXJlTGFiZWwgPSBudWxsO1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCBKaWkudCgne2F0dHJpYnV0ZX0gaXMgaW52YWxpZC4nKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jb21wYXJlVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBhcmVBdHRyaWJ1dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbXBhcmVBdHRyaWJ1dGUgPSBhdHRyaWJ1dGUgKyAnX3JlcGVhdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wYXJlTGFiZWwgPSBvYmplY3QuZ2V0QXR0cmlidXRlTGFiZWwodGhpcy5jb21wYXJlQXR0cmlidXRlKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGFyZVZhbHVlID0gb2JqZWN0LmdldCh0aGlzLmNvbXBhcmVBdHRyaWJ1dGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29tcGFyZUxhYmVsID0gdGhpcy5jb21wYXJlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIGNvbXBhcmVBdHRyaWJ1dGU6IGNvbXBhcmVMYWJlbCxcbiAgICAgICAgICAgICAgICBjb21wYXJlVmFsdWU6IHRoaXMuY29tcGFyZVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29tcGFyZVZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ0NvbXBhcmVWYWxpZGF0b3I6OmNvbXBhcmVWYWx1ZSBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aXRjaCAodGhpcy5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSAnPT0nOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgPT0gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICc9PT0nOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgPT09IHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnIT0nOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgIT0gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICchPT0nOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgIT09IHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnPic6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSA+IHZhbHVlO1xuICAgICAgICAgICAgY2FzZSAnPj0nOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgPj0gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICc8JzogcmV0dXJuIHRoaXMuY29tcGFyZVZhbHVlIDwgdmFsdWU7XG4gICAgICAgICAgICBjYXNlICc8PSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSA8PSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5EYXRlVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5EYXRlVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5EYXRlVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRmb3JtYXQ6ICdZLW0tZCcsXG5cbiAgICB0aW1lc3RhbXBBdHRyaWJ1dGU6IG51bGwsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IEppaS50KCdqaWknLCAnVGhlIGZvcm1hdCBvZiB7YXR0cmlidXRlfSBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGltZXN0YW1wQXR0cmlidXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBAdG9kbyBQYXJzZSBieSBmb3JtYXRcbiAgICAgICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgICAgIG9iamVjdC5zZXQodGhpcy50aW1lc3RhbXBBdHRyaWJ1dGUsIE1hdGgucm91bmQodGltZXN0YW1wIC8gMTAwMCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIC8vIEB0b2RvIFZhbGlkYXRlIGJ5IGZvcm1hdFxuICAgICAgICB2YXIgdGltZXN0YW1wID0gRGF0ZS5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhSmlpLl8uaXNOYU4odGltZXN0YW1wKTtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTExOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLkRlZmF1bHRWYWx1ZVZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuRGVmYXVsdFZhbHVlVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5EZWZhdWx0VmFsdWVWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdHZhbHVlOiBudWxsLFxuXG4gICAgc2tpcE9uRW1wdHk6IGZhbHNlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJzsgLy8gQHRvZG9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNFbXB0eShvYmplY3QuZ2V0KGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgICAgICBvYmplY3Quc2V0KGF0dHJpYnV0ZSwgdGhpcy52YWx1ZSk7XG4gICAgICAgIH1cblxuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuRW1haWxWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLkVtYWlsVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5FbWFpbFZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0cGF0dGVybjogL15bYS16QS1aMC05ISMkJSZcXCcqK1xcXFwvPT9eX2B7fH1+LV0rKD86XFwuW2EtekEtWjAtOSEjJCUmXFwnKitcXFxcLz0/Xl9ge3x9fi1dKykqQCg/OlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dKlthLXpBLVowLTldKT9cXC4pK1thLXpBLVowLTldKD86W2EtekEtWjAtOS1dKlthLXpBLVowLTldKT8kLyxcblxuICAgIGZ1bGxQYXR0ZXJuOiAvXlteQF0qPFthLXpBLVowLTkhIyQlJlxcJyorXFxcXC89P15fYHt8fX4tXSsoPzpcXC5bYS16QS1aMC05ISMkJSZcXCcqK1xcXFwvPT9eX2B7fH1+LV0rKSpAKD86W2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV0qW2EtekEtWjAtOV0pP1xcLikrW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV0qW2EtekEtWjAtOV0pPz4kLyxcblxuICAgIGFsbG93TmFtZTogZmFsc2UsXG5cbiAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uIChvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID4gMzIwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5wYXR0ZXJuLnRlc3QodmFsdWUpIHx8ICh0aGlzLmFsbG93TmFtZSAmJiB0aGlzLmZ1bGxQYXR0ZXJuLnRlc3QodmFsdWUpKTtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLkZpbHRlclZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuRmlsdGVyVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5GaWx0ZXJWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdGZpbHRlcjogbnVsbCxcblxuICAgIHNraXBPbkVtcHR5OiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMuZmlsdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ1RoZSBgZmlsdGVyYCBwcm9wZXJ0eSBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgb2JqZWN0LnNldChhdHRyaWJ1dGUsIHRoaXMuZmlsdGVyLmNhbGwob2JqZWN0LCBvYmplY3QuZ2V0KGF0dHJpYnV0ZSkpKTtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTE0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLklubGluZVZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuSW5saW5lVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5JbmxpbmVWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdG1ldGhvZDogbnVsbCxcblxuICAgIHBhcmFtczogbnVsbCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gJyc7IC8vIEB0b2RvXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmplY3RbdGhpcy5tZXRob2RdO1xuXG4gICAgICAgIGlmICghSmlpLl8uaXNGdW5jdGlvbihtZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ05vdCBmaW5kIG1ldGhvZCBgJyArIHRoaXMubWV0aG9kICsgJ2AgaW4gbW9kZWwgYCcgKyBvYmplY3QuZGVidWdDbGFzc05hbWUgKyAnYC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtZXRob2QuY2FsbChvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5wYXJhbXMgfHwge30pO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuTnVtYmVyVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5OdW1iZXJWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLk51bWJlclZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0aW50ZWdlck9ubHk6IGZhbHNlLFxuXG4gICAgbWF4OiBudWxsLFxuXG4gICAgbWluOiBudWxsLFxuXG4gICAgdG9vQmlnOiBudWxsLFxuXG4gICAgdG9vU21hbGw6IG51bGwsXG5cbiAgICBpbnRlZ2VyUGF0dGVybjogL15cXHMqWystXT9cXGQrXFxzKiQvLFxuXG4gICAgbnVtYmVyUGF0dGVybjogL15cXHMqWy0rXT9bMC05XSpcXC4/WzAtOV0rKFtlRV1bLStdP1swLTldKyk/XFxzKiQvLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMuaW50ZWdlck9ubHkgP1xuICAgICAgICAgICAgICAgIEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gbXVzdCBiZSBhbiBpbnRlZ2VyLicpIDpcbiAgICAgICAgICAgICAgICBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IG11c3QgYmUgYW4gbnVtYmVyLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiB0aGlzLnRvb1NtYWxsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRvb1NtYWxsID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBtdXN0IGJlIG5vIGxlc3MgdGhhbiB7bWlufS4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXggIT09IG51bGwgJiYgdGhpcy50b29CaWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudG9vQmlnID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBtdXN0IGJlIG5vIGdyZWF0ZXIgdGhhbiB7bWF4fS4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmdldChhdHRyaWJ1dGUpO1xuXG4gICAgICAgIGlmIChKaWkuXy5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgSmlpLnQoJ3thdHRyaWJ1dGV9IGlzIGludmFsaWQuJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLmludGVnZXJPbmx5ID8gdGhpcy5pbnRlZ2VyUGF0dGVybiA6IHRoaXMubnVtYmVyUGF0dGVybjtcbiAgICAgICAgaWYgKCFwYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWluICE9PSBudWxsICYmIHZhbHVlIDwgdGhpcy5taW4pIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMudG9vU21hbGwsIHtcbiAgICAgICAgICAgICAgICBtaW46IHRoaXMubWluXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5tYXggIT09IG51bGwgJiYgdmFsdWUgPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy50b29CaWcsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuaW50ZWdlck9ubHkgPyB0aGlzLmludGVnZXJQYXR0ZXJuIDogdGhpcy5udW1iZXJQYXR0ZXJuO1xuICAgICAgICByZXR1cm4gcGF0dGVybi50ZXN0KHZhbHVlKSAmJlxuICAgICAgICAgICAgKHRoaXMubWluID09PSBudWxsIHx8IHZhbHVlID49IHRoaXMubWluKSAmJlxuICAgICAgICAgICAgKHRoaXMubWF4ID09PSBudWxsIHx8IHZhbHVlIDw9IHRoaXMubWF4KTtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLlJhbmdlVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5SYW5nZVZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuUmFuZ2VWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdHJhbmdlOiBudWxsLFxuXG4gICAgc3RyaWN0OiBmYWxzZSxcblxuICAgIG5vdDogZmFsc2UsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG5cbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KHRoaXMucmFuZ2UpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ1RoZSBgcmFuZ2VgIHByb3BlcnR5IG11c3QgYmUgc2V0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaXNGaW5lZCA9IGZhbHNlO1xuXG4gICAgICAgIEppaS5fLmVhY2godGhpcy5yYW5nZSwgSmlpLl8uYmluZChmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdHJpY3QgJiYgdmFsdWUgPT09IGl0ZW0pIHtcbiAgICAgICAgICAgICAgICBpc0ZpbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJpY3QgJiYgdmFsdWUgPT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIGlzRmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiAhdGhpcy5ub3QgPyBpc0ZpbmVkIDogIWlzRmluZWQ7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5SZWd1bGFyRXhwcmVzc2lvblZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuUmVndWxhckV4cHJlc3Npb25WYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLlJlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRwYXR0ZXJuOiBudWxsLFxuXG4gICAgbm90OiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcblxuICAgICAgICBpZiAoIUppaS5fLmlzUmVnRXhwKHRoaXMucGF0dGVybikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignVGhlIGBwYXR0ZXJuYCBwcm9wZXJ0eSBtdXN0IGJlIHNldC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gaXMgaW52YWxpZC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmdldChhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIGlzTWF0Y2ggPSB0aGlzLnBhdHRlcm4udGVzdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhdGhpcy5ub3QgPyBpc01hdGNoIDogIWlzTWF0Y2g7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5SZXF1aXJlZFZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuUmVxdWlyZWRWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLlJlcXVpcmVkVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRza2lwT25FbXB0eTogZmFsc2UsXG5cbiAgICByZXF1aXJlZFZhbHVlOiBudWxsLFxuXG4gICAgc3RyaWN0OiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMucmVxdWlyZWRWYWx1ZSA9PT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBjYW5ub3QgYmUgYmxhbmsuJykgOlxuICAgICAgICAgICAgICAgIEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gbXVzdCBiZSBge3JlcXVpcmVkVmFsdWV9YC4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5yZXF1aXJlZFZhbHVlICE9PSBudWxsID8ge3JlcXVpcmVkVmFsdWU6IHRoaXMucmVxdWlyZWRWYWx1ZX0gOiB7fTtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSwgcGFyYW1zKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxdWlyZWRWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaWN0ID8gdmFsdWUgIT09IG51bGwgOiAhdGhpcy5pc0VtcHR5KHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zdHJpY3QgPyB2YWx1ZSAhPT0gdGhpcy5yZXF1aXJlZFZhbHVlIDogdmFsdWUgIT0gdGhpcy5yZXF1aXJlZFZhbHVlO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuU2FmZVZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuU2FmZVZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuU2FmZVZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0dmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDEyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5TdHJpbmdWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLlN0cmluZ1ZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuU3RyaW5nVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRsZW5ndGg6IG51bGwsXG5cbiAgICBtYXg6IG51bGwsXG5cbiAgICBtaW46IG51bGwsXG5cbiAgICB0b29Mb25nOiBudWxsLFxuXG4gICAgdG9vU2hvcnQ6IG51bGwsXG5cbiAgICBub3RFcXVhbDogbnVsbCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcblxuICAgICAgICBpZiAoSmlpLl8uaXNBcnJheSh0aGlzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aFswXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWluID0gdGhpcy5sZW5ndGhbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5sZW5ndGhbMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heCA9IHRoaXMubGVuZ3RoWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5sZW5ndGggPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBtdXN0IGJlIGEgc3RyaW5nLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiB0aGlzLnRvb1Nob3J0ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnRvb1Nob3J0ID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBzaG91bGQgY29udGFpbiBhdCBsZWFzdCB7bWlufSBjaGFyYWN0ZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gbnVsbCAmJiB0aGlzLnRvb0xvbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudG9vTG9uZyA9IEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gc2hvdWxkIGNvbnRhaW4gYXQgbW9zdCB7bWF4fSBjaGFyYWN0ZXJzLicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxlbmd0aCAhPT0gbnVsbCAmJiB0aGlzLm5vdEVxdWFsID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm5vdEVxdWFsID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBzaG91bGQgY29udGFpbiB7bGVuZ3RofSBjaGFyYWN0ZXJzLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgaWYgKCFKaWkuXy5pc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgICAgIGlmICh0aGlzLm1pbiAhPT0gbnVsbCAmJiBsZW5ndGggPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy50b29TaG9ydCwge1xuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gbnVsbCAmJiBsZW5ndGggPiB0aGlzLm1heCkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy50b29Mb25nLCB7XG4gICAgICAgICAgICAgICAgbWF4OiB0aGlzLm1heFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSBudWxsICYmIGxlbmd0aCAhPT0gdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubm90RXF1YWwsIHtcbiAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIUppaS5fLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuICh0aGlzLm1pbiA9PT0gbnVsbCB8fCBsZW5ndGggPj0gdGhpcy5taW4pICYmXG4gICAgICAgICAgICAodGhpcy5tYXggPT09IG51bGwgfHwgbGVuZ3RoIDw9IHRoaXMubWF4KSAmJlxuICAgICAgICAgICAgKHRoaXMubGVuZ3RoID09PSBudWxsIHx8IGxlbmd0aCA9PT0gdGhpcy5sZW5ndGgpO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuVXJsVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5VcmxWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLlVybFZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0cGF0dGVybjogL157c2NoZW1lc306XFwvXFwvKChbQS1aMC05XVtBLVowLTlfLV0qKShcXC5bQS1aMC05XVtBLVowLTlfLV0qKSspL2ksXG5cbiAgICB2YWxpZFNjaGVtZXM6IFtcbiAgICAgICAgJ2h0dHAnLFxuICAgICAgICAnaHR0cHMnXG4gICAgXSxcblxuICAgIGRlZmF1bHRTY2hlbWU6IG51bGwsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gaXMgbm90IGEgdmFsaWQgVVJMLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRTY2hlbWUgIT09IG51bGwgJiYgdmFsdWUuaW5kZXhPZignOi8vJykgPT09IC0xKSB7XG4gICAgICAgICAgICBvYmplY3Quc2V0KGF0dHJpYnV0ZSwgdGhpcy5kZWZhdWx0U2NoZW1lICsgJzovLycgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc1N0cmluZyh2YWx1ZSkgfHwgdmFsdWUubGVuZ3RoID4gMjAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFNjaGVtZSAhPT0gbnVsbCAmJiB2YWx1ZS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5kZWZhdWx0U2NoZW1lICsgJzovLycgKyB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5wYXR0ZXJuLnNvdXJjZTtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4ucmVwbGFjZSgne3NjaGVtZXN9JywgJygnICsgdGhpcy52YWxpZFNjaGVtZXMuam9pbignfCcpICsgJyknKTtcblxuICAgICAgICB2YXIgZmxhZ3MgPSAnJztcbiAgICAgICAgSmlpLl8uZWFjaCh7Z2xvYmFsOiAnZycsIGlnbm9yZUNhc2U6ICdpJywgbXVsdGlsaW5lOiAnbSd9LCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGZsYWcsIGtleSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGF0dGVybltrZXldKSB7XG4gICAgICAgICAgICAgICAgZmxhZ3MgKz0gZmxhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiAobmV3IFJlZ0V4cChwYXR0ZXJuLCBmbGFncykpLnRlc3QodmFsdWUpO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yICove1xuXG5cdFx0ZGVmYXVsdFZhbGlkYXRvcnM6IHtcblxuXHRcdFx0J2Jvb2xlYW4nOiAnSmlpLnZhbGlkYXRvcnMuQm9vbGVhblZhbGlkYXRvcicsXG5cdFx0XHQnY29tcGFyZSc6ICdKaWkudmFsaWRhdG9ycy5Db21wYXJlVmFsaWRhdG9yJyxcblx0XHRcdCdkYXRlJzogJ0ppaS52YWxpZGF0b3JzLkRhdGVWYWxpZGF0b3InLFxuXHRcdFx0J2RlZmF1bHQnOiAnSmlpLnZhbGlkYXRvcnMuRGVmYXVsdFZhbHVlVmFsaWRhdG9yJyxcblx0XHRcdCdkb3VibGUnOiAnSmlpLnZhbGlkYXRvcnMuTnVtYmVyVmFsaWRhdG9yJyxcblx0XHRcdCdlbWFpbCc6ICdKaWkudmFsaWRhdG9ycy5FbWFpbFZhbGlkYXRvcicsXG5cdFx0XHQvLydleGlzdCc6ICdKaWkudmFsaWRhdG9ycy5FeGlzdFZhbGlkYXRvcicsXG5cdFx0XHQvLydmaWxlJzogJ0ppaS52YWxpZGF0b3JzLkZpbGVWYWxpZGF0b3InLFxuXHRcdFx0J2ZpbHRlcic6ICdKaWkudmFsaWRhdG9ycy5GaWx0ZXJWYWxpZGF0b3InLFxuXHRcdFx0Ly8naW1hZ2UnOiAnSmlpLnZhbGlkYXRvcnMuSW1hZ2VWYWxpZGF0b3InLFxuXHRcdFx0J2luJzogJ0ppaS52YWxpZGF0b3JzLlJhbmdlVmFsaWRhdG9yJyxcblx0XHRcdCdpbnRlZ2VyJzoge1xuXHRcdFx0XHQnY2xhc3NOYW1lJzogJ0ppaS52YWxpZGF0b3JzLk51bWJlclZhbGlkYXRvcicsXG5cdFx0XHRcdCdpbnRlZ2VyT25seSc6IHRydWVcblx0XHRcdH0sXG5cdFx0XHQnbWF0Y2gnOiAnSmlpLnZhbGlkYXRvcnMuUmVndWxhckV4cHJlc3Npb25WYWxpZGF0b3InLFxuXHRcdFx0J251bWJlcic6ICdKaWkudmFsaWRhdG9ycy5OdW1iZXJWYWxpZGF0b3InLFxuXHRcdFx0J3JlcXVpcmVkJzogJ0ppaS52YWxpZGF0b3JzLlJlcXVpcmVkVmFsaWRhdG9yJyxcblx0XHRcdCdzYWZlJzogJ0ppaS52YWxpZGF0b3JzLlNhZmVWYWxpZGF0b3InLFxuXHRcdFx0J3N0cmluZyc6ICdKaWkudmFsaWRhdG9ycy5TdHJpbmdWYWxpZGF0b3InLFxuXHRcdFx0Ly8ndW5pcXVlJzogJ0ppaS52YWxpZGF0b3JzLlVuaXF1ZVZhbGlkYXRvcicsXG5cdFx0XHQndXJsJzogJ0ppaS52YWxpZGF0b3JzLlVybFZhbGlkYXRvcidcblx0XHR9LFxuXG5cdFx0Y3JlYXRlOiBmdW5jdGlvbiAodHlwZSwgb2JqZWN0LCBhdHRyaWJ1dGVzLCBwYXJhbXMpIHtcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHRcdHBhcmFtcy5hdHRyaWJ1dGVzID0gYXR0cmlidXRlcztcblxuXHRcdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W3R5cGVdKSkge1xuXHRcdFx0XHRwYXJhbXMuY2xhc3NOYW1lID0gJ0ppaS52YWxpZGF0b3JzLklubGluZVZhbGlkYXRvcic7XG5cdFx0XHRcdHBhcmFtcy5tZXRob2QgPSB0eXBlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKEppaS5fLmhhcyh0aGlzLmRlZmF1bHRWYWxpZGF0b3JzLCB0eXBlKSkge1xuXHRcdFx0XHRcdHR5cGUgPSB0aGlzLmRlZmF1bHRWYWxpZGF0b3JzW3R5cGVdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzQXJyYXkodHlwZSkpIHtcblx0XHRcdFx0XHRKaWkuXy5leHRlbmQocGFyYW1zLCB0eXBlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJhbXMuY2xhc3NOYW1lID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gSmlpLmNyZWF0ZU9iamVjdChwYXJhbXMpO1xuXHRcdH1cblxuXHR9LFxuXG4gICAgYXR0cmlidXRlczogW10sXG4gICAgbWVzc2FnZTogbnVsbCxcbiAgICBvbjogW10sXG4gICAgZXhjZXB0OiBbXSxcbiAgICBza2lwT25FcnJvcjogdHJ1ZSxcbiAgICBza2lwT25FbXB0eTogdHJ1ZSxcbiAgICBkZWZlcnJlZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqIEBwYXJhbSBvYmplY3RcbiAgICAgKiBAcGFyYW0gYXR0cmlidXRlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfG51bGx9XG4gICAgICovXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uIChvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uKCdOb3QgZm91bmQgaW1wbGVtZW50YXRpb24gZm9yIG1ldGhvZCBgdmFsaWRhdGVWYWx1ZSgpYC4nKTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyaWJ1dGVzID0gSmlpLl8uaXNBcnJheShhdHRyaWJ1dGVzKSA/XG4gICAgICAgICAgICBKaWkuXy5pbnRlcnNlY3Rpb24odGhpcy5hdHRyaWJ1dGVzLCBhdHRyaWJ1dGVzKSA6XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXM7XG5cbiAgICAgICAgdmFyIHByb21pc2VzID0gSmlpLl8ubWFwKGF0dHJpYnV0ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24oYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5za2lwT25FcnJvciAmJiBvYmplY3QuaGFzRXJyb3JzKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBPbkVtcHR5ICYmIHRoaXMuaXNFbXB0eShvYmplY3QuZ2V0KGF0dHJpYnV0ZSkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWxpZGF0ZUF0dHJpYnV0ZShvYmplY3QsIGF0dHJpYnV0ZSk7XG4gICAgICAgIH0sIHRoaXMpKTtcblxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0sXG5cbiAgICBpc0FjdGl2ZTogZnVuY3Rpb24oc2NlbmFyaW8pIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmluZGV4T2YodGhpcy5leGNlcHQsIHNjZW5hcmlvKSA9PT0gLTEgJiZcbiAgICAgICAgICAgICghdGhpcy5vbiB8fCB0aGlzLm9uLmxlbmd0aCA9PT0gMCB8fCBKaWkuXy5pbmRleE9mKHRoaXMub24sIHNjZW5hcmlvKSAhPT0gLTEpO1xuICAgIH0sXG5cbiAgICBhZGRFcnJvcjogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUsIG1lc3NhZ2UsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHBhcmFtcy5hdHRyaWJ1dGUgPSBvYmplY3QuZ2V0QXR0cmlidXRlTGFiZWwoYXR0cmlidXRlKTtcbiAgICAgICAgcGFyYW1zLnZhbHVlID0gb2JqZWN0LmdldChhdHRyaWJ1dGUpO1xuXG4gICAgICAgIC8vIEB0b2RvXG4gICAgICAgIC8vbWVzc2FnZSA9IEppaS50KCdqaWknLCBtZXNzYWdlKTtcbiAgICAgICAgSmlpLl8uZWFjaChwYXJhbXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnJlcGxhY2UoJ3snICsga2V5ICsgJ30nLCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG9iamVjdC5hZGRFcnJvcihhdHRyaWJ1dGUsIG1lc3NhZ2UpO1xuICAgICAgICBKaWkud2FybmluZygnVmFsaWRhdGlvbiBlcnJvciBpbiBtb2RlbCBgJyArIG9iamVjdC5jbGFzc05hbWUoKSArICdgOiAnICsgbWVzc2FnZSk7XG4gICAgfSxcblxuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKHZhbHVlLCBpc1RyaW0pIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8XG4gICAgICAgICAgICB2YWx1ZSA9PT0gJycgfHxcbiAgICAgICAgICAgIChpc1RyaW0gJiYgSmlpLl8uaXNTdHJpbmcodmFsdWUpICYmIHZhbHVlLnJlcGxhY2UoL15cXHMrfFxccyskL2csICcnKSA9PT0gJycpIHx8XG4gICAgICAgICAgICAoSmlpLl8uaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoID09PSAwKTtcbiAgICB9XG5cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcbkppaS5fID0gcmVxdWlyZSgndW5kZXJzY29yZScpO1xuSmlpLl9zID0gcmVxdWlyZSgndW5kZXJzY29yZS5zdHJpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBKaWk7XG59LHtcImppaVwiOjEyNCxcInVuZGVyc2NvcmVcIjoxNjEsXCJ1bmRlcnNjb3JlLnN0cmluZ1wiOjE2MH1dLDEyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIFJlcXVpcmUgcmVsYXRpb25zIGxpYnMgYW5kIGppaSBmaWxlc1xuICpcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gbW9kdWxlLmV4cG9ydHMgPSB3aW5kb3cuSmlpID0gcmVxdWlyZSgnLi9saWIvSmlpJyk7XG5cbi8vIEdsb2JhbCBsaWJyYXJpZXNcbkppaS5fID0gd2luZG93Ll8gfHwgbnVsbDtcbkppaS5fcyA9IHdpbmRvdy5fcyB8fCB3aW5kb3cucyB8fCAod2luZG93Ll8gPyB3aW5kb3cuXy5zdHJpbmcgOiBudWxsKSB8fCBudWxsO1xuSmlpLmlzTm9kZSA9IGZhbHNlO1xuXG4vLyBMb2FkIGZyYW1ld29yayBmaWxlc1xucmVxdWlyZSgnLi9saWIvYXBwbGljYXRpb24vV2ViQXBwbGljYXRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQWN0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0FjdGlvbkV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0FwcGxpY2F0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0JlaGF2aW9yJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0NvbXBvbmVudCcpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9Db250ZXh0Jyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0NvbnRyb2xsZXInKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvSHR0cFJlcXVlc3QnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvTW9kZWxFdmVudCcpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9Nb2R1bGUnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvT2JqZWN0Jyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL1JlcXVlc3QnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvUmVzcG9uc2UnKTtcbnJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbnMvQXBwbGljYXRpb25FeGNlcHRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbnMvSW52YWxpZENhbGxFeGNlcHRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbnMvSW52YWxpZENvbmZpZ0V4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkUGFyYW1FeGNlcHRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbnMvSW52YWxpZFJvdXRlRXhjZXB0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9leGNlcHRpb25zL05vdFN1cHBvcnRlZEV4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9Vbmtub3duUHJvcGVydHlFeGNlcHRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2hlbHBlcnMvRmlsZScpO1xucmVxdWlyZSgnLi9saWIvaGVscGVycy9TdHJpbmcnKTtcbnJlcXVpcmUoJy4vbGliL2hlbHBlcnMvVXJsJyk7XG5yZXF1aXJlKCcuL2xpYi9yZXF1ZXN0L0Fub255bW91c0FjdGlvbicpO1xucmVxdWlyZSgnLi9saWIvcmVxdWVzdC9IZWFkZXJDb2xsZWN0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9yZXF1ZXN0L0lubGluZUFjdGlvbicpO1xuXG59LHtcIi4vbGliL0ppaVwiOjEyNSxcIi4vbGliL2FwcGxpY2F0aW9uL1dlYkFwcGxpY2F0aW9uXCI6MTI2LFwiLi9saWIvYmFzZS9BY3Rpb25cIjoxMjcsXCIuL2xpYi9iYXNlL0FjdGlvbkV2ZW50XCI6MTI4LFwiLi9saWIvYmFzZS9BcHBsaWNhdGlvblwiOjEyOSxcIi4vbGliL2Jhc2UvQmVoYXZpb3JcIjoxMzAsXCIuL2xpYi9iYXNlL0NvbXBvbmVudFwiOjEzMSxcIi4vbGliL2Jhc2UvQ29udGV4dFwiOjEzMixcIi4vbGliL2Jhc2UvQ29udHJvbGxlclwiOjEzMyxcIi4vbGliL2Jhc2UvRXZlbnRcIjoxMzQsXCIuL2xpYi9iYXNlL0h0dHBSZXF1ZXN0XCI6MTM1LFwiLi9saWIvYmFzZS9Nb2RlbEV2ZW50XCI6MTM2LFwiLi9saWIvYmFzZS9Nb2R1bGVcIjoxMzcsXCIuL2xpYi9iYXNlL09iamVjdFwiOjEzOCxcIi4vbGliL2Jhc2UvUmVxdWVzdFwiOjEzOSxcIi4vbGliL2Jhc2UvUmVzcG9uc2VcIjoxNDAsXCIuL2xpYi9leGNlcHRpb25zL0FwcGxpY2F0aW9uRXhjZXB0aW9uXCI6MTQxLFwiLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkQ2FsbEV4Y2VwdGlvblwiOjE0MixcIi4vbGliL2V4Y2VwdGlvbnMvSW52YWxpZENvbmZpZ0V4Y2VwdGlvblwiOjE0MyxcIi4vbGliL2V4Y2VwdGlvbnMvSW52YWxpZFBhcmFtRXhjZXB0aW9uXCI6MTQ0LFwiLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkUm91dGVFeGNlcHRpb25cIjoxNDUsXCIuL2xpYi9leGNlcHRpb25zL05vdFN1cHBvcnRlZEV4Y2VwdGlvblwiOjE0NixcIi4vbGliL2V4Y2VwdGlvbnMvVW5rbm93blByb3BlcnR5RXhjZXB0aW9uXCI6MTQ3LFwiLi9saWIvaGVscGVycy9GaWxlXCI6MTQ4LFwiLi9saWIvaGVscGVycy9TdHJpbmdcIjoxNDksXCIuL2xpYi9oZWxwZXJzL1VybFwiOjE1MCxcIi4vbGliL3JlcXVlc3QvQW5vbnltb3VzQWN0aW9uXCI6MTUxLFwiLi9saWIvcmVxdWVzdC9IZWFkZXJDb2xsZWN0aW9uXCI6MTUyLFwiLi9saWIvcmVxdWVzdC9JbmxpbmVBY3Rpb25cIjoxNTN9XSwxMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLF9fZGlybmFtZSl7XG4vKipcclxuICogSmlpIOKAlCBGdWxsLVN0YWNrIEphdmFTY3JpcHQgRnJhbWV3b3JrIGJhc2VkIG9uIFBIUCBZaWkgMiBGcmFtZXdvcmsgYXJjaGl0ZWN0dXJlLlxyXG4gKlxyXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbnZhciBOZWF0bmVzcyA9IHJlcXVpcmUoJ25lYXRuZXNzJykubmV3Q29udGV4dCgpO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2VcclxuICogQGFsaWFzIG1vZHVsZTpqaWlcclxuICovXHJcbnZhciBKaWkgPSBOZWF0bmVzcy5uYW1lc3BhY2UoJ0ppaScpO1xyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBKaWlcclxuICovXHJcbkppaSA9IE5lYXRuZXNzLmRlZmluZUNsYXNzKCdKaWknLCB7XHJcblxyXG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaSAqL3tcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBhbGlhcyBsb2Rhc2hcclxuXHRcdCAqL1xyXG5cdFx0XzogbnVsbCxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEBhbGlhcyBfc1xyXG5cdFx0ICovXHJcblx0XHRfczogbnVsbCxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEB0eXBlIG1vZHVsZTp3aGVuXHJcblx0XHQgKi9cclxuXHRcdHdoZW46IG51bGwsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBAdHlwZSB7SmlpLmJhc2UuQXBwbGljYXRpb259XHJcblx0XHQgKi9cclxuXHRcdGFwcDogbnVsbCxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdGFsaWFzZXM6IG51bGwsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUcnVlLCBpZiBydW5uaW5nIGluIG5vZGUganNcclxuXHRcdCAqIEB0eXBlIHtib29sZWFufVxyXG5cdFx0ICovXHJcblx0XHRpc05vZGU6IGZhbHNlLFxyXG5cclxuXHRcdF9jb250ZXh0Q29uZmlnOiBudWxsLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmV0dXJucyBmcmFtZXdvcmsgdmVyc2lvblxyXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cclxuXHRcdCAqL1xyXG5cdFx0Z2V0VmVyc2lvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBHZXQgY2xhc3MgYnkgZnVsbCBuYW1lc3BhY2UuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxyXG5cdFx0ICogQHJldHVybnMge2Z1bmN0aW9ufG9iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0bmFtZXNwYWNlOiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRyZXR1cm4gSmlpLl8uaXNTdHJpbmcobmFtZSkgPyBOZWF0bmVzcy5uYW1lc3BhY2UuYXBwbHkoTmVhdG5lc3MsIGFyZ3VtZW50cykgOiBuYW1lO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE1vdmUgbmFtZXNwYWNlIHRvIG90aGVyIG9iamVjdFxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IG5ld0NvbnRleHRcclxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZUZyb21PbGRdXHJcblx0XHQgKiBAcmV0dXJucyB7KnxGdW5jdGlvbnxPYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdG5hbWVzcGFjZU1vdmVDb250ZXh0OiBmdW5jdGlvbiAobmV3Q29udGV4dCwgcmVtb3ZlRnJvbU9sZCkge1xyXG5cdFx0XHRyZXR1cm4gTmVhdG5lc3MubW92ZUNvbnRleHQuYXBwbHkoTmVhdG5lc3MsIGFyZ3VtZW50cyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTWV0aG9kIGZvciBkZWZpbmUgY2xhc3MuIE9wdGlvbnMgb2JqZWN0IHdpbGwgYmUgY29udmVydGVyIHRvIGNsYXNzIHByb3RvdHlwZS5cclxuXHRcdCAqIEZvciBzZXQgc3RhdGljIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMsIHNldCBwYXJhbSBgX19zdGF0aWNgIGFzIG9iamVjdCB3aXRoIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMuXHJcblx0XHQgKiBGb3IgZXh0ZW5kcyBmcm9tIGNsYXNzLCBzZXQgYF9fZXh0ZW5kc2AgcHJvcGVydHkgYXMgZXh0ZW5kZWQgY2xhc3MgKGZ1bmN0aW9uKS4gRXhhbXBsZSBmb3JtYXQ6XHJcblx0XHQgKiAgICB7XHJcblx0XHQgKiAgICAgIF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxyXG5cdFx0ICogICAgICBfX3N0YXRpYzoge1xyXG5cdFx0ICogICAgICAgICAgc3RhdGljUGFyYW06IDEwLFxyXG5cdFx0ICogICAgICAgICAgTVlfQ09OU1RBTlQ6ICdjb25zdGFudCcsXHJcblx0XHQgKiAgICAgICAgICBub3JtYWxpemVOYW1lOiBmdW5jdGlvbigpIHt9LFxyXG5cdFx0ICogICAgICB9LFxyXG5cdFx0ICogICAgICBwcm90b3R5cGVQYXJhbTogMjAsXHJcblx0XHQgKiAgICAgIGdldE5hbWU6IGZ1bmN0aW9uKCkge31cclxuXHRcdCAqIH1cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBnbG9iYWxOYW1lXHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xyXG5cdFx0ICogQHJldHVybiB7b2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHRkZWZpbmVDbGFzczogZnVuY3Rpb24gKGdsb2JhbE5hbWUsIG9wdGlvbnMpIHtcclxuXHRcdFx0cmV0dXJuIE5lYXRuZXNzLmRlZmluZUNsYXNzLmFwcGx5KE5lYXRuZXNzLCBhcmd1bWVudHMpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0ZSB3ZWIgYXBwbGljYXRpb24sIHdoaWNoIGF2YWlsYWJsZSBieSBKaWkuYXBwXHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXHJcblx0XHQgKiBAcmV0dXJucyB7SmlpLmFwcC5BcHBsaWNhdGlvbn1cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlV2ViQXBwbGljYXRpb246IGZ1bmN0aW9uIChjb25maWcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlQXBwbGljYXRpb24oJ0ppaS5hcHBsaWNhdGlvbi5XZWJBcHBsaWNhdGlvbicsIGNvbmZpZyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRlIGNvbnNvbGUgYXBwbGljYXRpb24sIHdoaWNoIGF2YWlsYWJsZSBieSBKaWkuYXBwXHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXHJcblx0XHQgKiBAcmV0dXJucyB7SmlpLmFwcC5BcHBsaWNhdGlvbn1cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlQ29uc29sZUFwcGxpY2F0aW9uOiBmdW5jdGlvbiAoY29uZmlnKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNyZWF0ZUFwcGxpY2F0aW9uKCdKaWkuYXBwbGljYXRpb24uQ29uc29sZUFwcGxpY2F0aW9uJywgY29uZmlnKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBNYWluIG1ldGhvZCB3aGljaCBjcmVhdGUgYXBwbGljYXRpb24gYnkgY2xhc3MgbmFtZSBhbmQgY29uZmlnLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZVxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xyXG5cdFx0ICogQHJldHVybnMge0ppaS5hcHAuQXBwbGljYXRpb259XHJcblx0XHQgKi9cclxuXHRcdGNyZWF0ZUFwcGxpY2F0aW9uOiBmdW5jdGlvbihjbGFzc05hbWUsIGNvbmZpZykge1xyXG5cdFx0XHRjb25maWcgPSBjb25maWcgfHwge307XHJcblx0XHRcdGNvbmZpZy5hcHBsaWNhdGlvbiA9IGNvbmZpZy5hcHBsaWNhdGlvbiB8fCB7fTtcclxuXHJcblx0XHRcdC8vIFNhdmUgY29udGV4dCBjb25maWdcclxuXHRcdFx0dGhpcy5fY29udGV4dENvbmZpZyA9IGNvbmZpZy5jb250ZXh0IHx8IHt9O1xyXG5cclxuXHRcdFx0dmFyIEFwcGxpY2F0aW9uQ2xhc3MgPSB0aGlzLm5hbWVzcGFjZShjbGFzc05hbWUpO1xyXG5cdFx0XHRpZiAoIUppaS5fLmlzRnVuY3Rpb24oQXBwbGljYXRpb25DbGFzcykpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdOb3QgZm91bmQgYXBwbGljYXRpb24gY2xhc3M6ICcgKyBjbGFzc05hbWUpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJbml0IGFsaWFzZXNcclxuXHRcdFx0dGhpcy5hbGlhc2VzID0ge307XHJcblx0XHRcdGlmICh0aGlzLmlzTm9kZSkge1xyXG5cdFx0XHRcdHRoaXMuYWxpYXNlc1snQGppaSddID0gX19kaXJuYW1lO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDcmVhdGUgYXBwbGljYXRpb24gaW5zdGFuY2VcclxuXHRcdFx0cmV0dXJuIG5ldyBBcHBsaWNhdGlvbkNsYXNzKGNvbmZpZy5hcHBsaWNhdGlvbik7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTWFpbiBtZXRob2Qgd2hpY2ggY3JlYXRlIGFwcGxpY2F0aW9uIGJ5IGNsYXNzIG5hbWUgYW5kIGNvbmZpZy5cclxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcclxuXHRcdCAqIEByZXR1cm5zIHtKaWkuYmFzZS5Db250ZXh0fVxyXG5cdFx0ICovXHJcblx0XHRjcmVhdGVDb250ZXh0OiBmdW5jdGlvbihjb25maWcpIHtcclxuXHRcdFx0Y29uZmlnID0gY29uZmlnIHx8IHt9O1xyXG5cclxuXHRcdFx0Ly8gTWVyZ2Ugd2l0aCBkZWZhdWx0IGNvbnRleHQgY29uZmlnXHJcbiAgICAgICAgICAgIGNvbmZpZyA9IHRoaXMubWVyZ2VDb25maWdzKHRoaXMuX2NvbnRleHRDb25maWcgfHwge30sIGNvbmZpZyk7XHJcblxyXG5cdFx0XHRpZiAoY29uZmlnLmNsYXNzTmFtZSkge1xyXG5cdFx0XHRcdHZhciBDb250ZXh0Q2xhc3MgPSB0aGlzLm5hbWVzcGFjZShjb25maWcuY2xhc3NOYW1lKTtcclxuXHRcdFx0XHRpZiAoIUppaS5fLmlzRnVuY3Rpb24oQ29udGV4dENsYXNzKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignTm90IGZvdW5kIGNvbnRleHQgY2xhc3M6ICcgKyBjbGFzc05hbWUpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIG5ldyBDb250ZXh0Q2xhc3MoY29uZmlnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIG5ldyBKaWkuYmFzZS5Db250ZXh0KGNvbmZpZyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogVHJhbnNsYXRlcyBhIHBhdGggYWxpYXMgaW50byBhbiBhY3R1YWwgcGF0aC5cclxuXHRcdCAqXHJcblx0XHQgKiBUaGUgdHJhbnNsYXRpb24gaXMgZG9uZSBhY2NvcmRpbmcgdG8gdGhlIGZvbGxvd2luZyBwcm9jZWR1cmU6XHJcblx0XHQgKlxyXG5cdFx0ICogMS4gSWYgdGhlIGdpdmVuIGFsaWFzIGRvZXMgbm90IHN0YXJ0IHdpdGggJ0AnLCBpdCBpcyByZXR1cm5lZCBiYWNrIHdpdGhvdXQgY2hhbmdlO1xyXG5cdFx0ICogMi4gT3RoZXJ3aXNlLCBsb29rIGZvciB0aGUgbG9uZ2VzdCByZWdpc3RlcmVkIGFsaWFzIHRoYXQgbWF0Y2hlcyB0aGUgYmVnaW5uaW5nIHBhcnRcclxuXHRcdCAqICAgIG9mIHRoZSBnaXZlbiBhbGlhcy4gSWYgaXQgZXhpc3RzLCByZXBsYWNlIHRoZSBtYXRjaGluZyBwYXJ0IG9mIHRoZSBnaXZlbiBhbGlhcyB3aXRoXHJcblx0XHQgKiAgICB0aGUgY29ycmVzcG9uZGluZyByZWdpc3RlcmVkIHBhdGguXHJcblx0XHQgKiAzLiBUaHJvdyBhbiBleGNlcHRpb24gb3IgcmV0dXJuIGZhbHNlLCBkZXBlbmRpbmcgb24gdGhlIGAkdGhyb3dFeGNlcHRpb25gIHBhcmFtZXRlci5cclxuXHRcdCAqXHJcblx0XHQgKiBGb3IgZXhhbXBsZSwgYnkgZGVmYXVsdCAnQGppaScgaXMgcmVnaXN0ZXJlZCBhcyB0aGUgYWxpYXMgdG8gdGhlIEppaSBmcmFtZXdvcmsgZGlyZWN0b3J5LFxyXG5cdFx0ICogc2F5ICcvcGF0aC90by9qaWknLiBUaGUgYWxpYXMgJ0BqaWkvd2ViJyB3b3VsZCB0aGVuIGJlIHRyYW5zbGF0ZWQgaW50byAnL3BhdGgvdG8vamlpL3dlYicuXHJcblx0XHQgKlxyXG5cdFx0ICogSWYgeW91IGhhdmUgcmVnaXN0ZXJlZCB0d28gYWxpYXNlcyAnQGZvbycgYW5kICdAZm9vL2JhcicuIFRoZW4gdHJhbnNsYXRpbmcgJ0Bmb28vYmFyL2NvbmZpZydcclxuXHRcdCAqIHdvdWxkIHJlcGxhY2UgdGhlIHBhcnQgJ0Bmb28vYmFyJyAoaW5zdGVhZCBvZiAnQGZvbycpIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgcmVnaXN0ZXJlZCBwYXRoLlxyXG5cdFx0ICogVGhpcyBpcyBiZWNhdXNlIHRoZSBsb25nZXN0IGFsaWFzIHRha2VzIHByZWNlZGVuY2UuXHJcblx0XHQgKlxyXG5cdFx0ICogSG93ZXZlciwgaWYgdGhlIGFsaWFzIHRvIGJlIHRyYW5zbGF0ZWQgaXMgJ0Bmb28vYmFyYmFyL2NvbmZpZycsIHRoZW4gJ0Bmb28nIHdpbGwgYmUgcmVwbGFjZWRcclxuXHRcdCAqIGluc3RlYWQgb2YgJ0Bmb28vYmFyJywgYmVjYXVzZSAnLycgc2VydmVzIGFzIHRoZSBib3VuZGFyeSBjaGFyYWN0ZXIuXHJcblx0XHQgKlxyXG5cdFx0ICogTm90ZSwgdGhpcyBtZXRob2QgZG9lcyBub3QgY2hlY2sgaWYgdGhlIHJldHVybmVkIHBhdGggZXhpc3RzIG9yIG5vdC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgdGhlIGFsaWFzIHRvIGJlIHRyYW5zbGF0ZWQuXHJcblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFt0aHJvd0V4Y2VwdGlvbl0gd2hldGhlciB0byB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlIGdpdmVuIGFsaWFzIGlzIGludmFsaWQuXHJcblx0XHQgKiBJZiB0aGlzIGlzIGZhbHNlIGFuZCBhbiBpbnZhbGlkIGFsaWFzIGlzIGdpdmVuLCBmYWxzZSB3aWxsIGJlIHJldHVybmVkIGJ5IHRoaXMgbWV0aG9kLlxyXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfGJvb2xlYW59IHRoZSBwYXRoIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFsaWFzLCBmYWxzZSBpZiB0aGUgcm9vdCBhbGlhcyBpcyBub3QgcHJldmlvdXNseSByZWdpc3RlcmVkLlxyXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9ufSBpZiB0aGUgYWxpYXMgaXMgaW52YWxpZCB3aGlsZSB0aHJvd0V4Y2VwdGlvbiBpcyB0cnVlLlxyXG5cdFx0ICogQHNlZSBzZXRBbGlhcygpXHJcblx0XHQgKi9cclxuXHRcdGdldEFsaWFzOiBmdW5jdGlvbiAoYWxpYXMsIHRocm93RXhjZXB0aW9uKSB7XHJcblx0XHRcdGlmIChKaWkuXy5pc1VuZGVmaW5lZCh0aHJvd0V4Y2VwdGlvbikpIHtcclxuXHRcdFx0XHR0aHJvd0V4Y2VwdGlvbiA9IHRydWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChhbGlhcy5pbmRleE9mKCdAJykgIT09IDApIHtcclxuXHRcdFx0XHRyZXR1cm4gYWxpYXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGFsaWFzLmluZGV4T2YoJy8nKTtcclxuXHRcdFx0dmFyIHJvb3QgPSBpbmRleCA9PT0gLTEgPyBhbGlhcyA6IGFsaWFzLnN1YnN0cigwLCBpbmRleCk7XHJcblxyXG5cdFx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuYWxpYXNlcywgcm9vdCkpIHtcclxuXHRcdFx0XHRpZiAoSmlpLl8uaXNTdHJpbmcodGhpcy5hbGlhc2VzW3Jvb3RdKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuYWxpYXNlc1tyb290XSArIChpbmRleCAhPT0gLTEgPyBhbGlhcy5zdWJzdHIoaW5kZXgpIDogJycpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGZpbmVkUGF0aCA9IG51bGw7XHJcblx0XHRcdFx0SmlpLl8uZWFjaCh0aGlzLmFsaWFzZXNbcm9vdF0sIGZ1bmN0aW9uIChwYXRoLCBuYW1lKSB7XHJcblx0XHRcdFx0XHR2YXIgdGVzdEFsaWFzID0gYWxpYXMgKyAnLyc7XHJcblx0XHRcdFx0XHRpZiAodGVzdEFsaWFzLmluZGV4T2YobmFtZSArICcvJykgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0ZmluZWRQYXRoID0gcGF0aCArIGFsaWFzLnN1YnN0cihuYW1lLmxlbmd0aCk7XHJcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRpZiAoZmluZWRQYXRoICE9PSBudWxsKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmluZWRQYXRoO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKHRocm93RXhjZXB0aW9uKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignSW52YWxpZCBwYXRoIGFsaWFzOiAnICsgYWxpYXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIHRoZSByb290IGFsaWFzIHBhcnQgb2YgYSBnaXZlbiBhbGlhcy5cclxuXHRcdCAqIEEgcm9vdCBhbGlhcyBpcyBhbiBhbGlhcyB0aGF0IGhhcyBiZWVuIHJlZ2lzdGVyZWQgdmlhIFtbc2V0QWxpYXMoKV1dIHByZXZpb3VzbHkuXHJcblx0XHQgKiBJZiBhIGdpdmVuIGFsaWFzIG1hdGNoZXMgbXVsdGlwbGUgcm9vdCBhbGlhc2VzLCB0aGUgbG9uZ2VzdCBvbmUgd2lsbCBiZSByZXR1cm5lZC5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyB0aGUgYWxpYXNcclxuXHRcdCAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufSB0aGUgcm9vdCBhbGlhcywgb3IgZmFsc2UgaWYgbm8gcm9vdCBhbGlhcyBpcyBmb3VuZFxyXG5cdFx0ICovXHJcblx0XHRnZXRSb290QWxpYXM6IGZ1bmN0aW9uIChhbGlhcykge1xyXG5cdFx0XHR2YXIgaW5kZXggPSBhbGlhcy5pbmRleE9mKCcvJyk7XHJcblx0XHRcdHZhciByb290ID0gaW5kZXggPT09IC0xID8gYWxpYXMgOiBhbGlhcy5zdWJzdHIoMCwgaW5kZXgpO1xyXG5cclxuXHRcdFx0aWYgKEppaS5fLmhhcyh0aGlzLmFsaWFzZXMsIHJvb3QpKSB7XHJcblx0XHRcdFx0aWYgKEppaS5fLmlzU3RyaW5nKHRoaXMuYWxpYXNlc1tyb290XSkpIHtcclxuXHRcdFx0XHRcdHJldHVybiByb290O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0dmFyIGZpbmVkUGF0aCA9IG51bGw7XHJcblx0XHRcdFx0SmlpLl8uZWFjaCh0aGlzLmFsaWFzZXNbcm9vdF0sIGZ1bmN0aW9uIChwYXRoLCBuYW1lKSB7XHJcblx0XHRcdFx0XHRpZiAoSmlpLl8uaW5kZXhPZihhbGlhcyArICcvJywgbmFtZSArICcvJykgPT09IDApIHtcclxuXHRcdFx0XHRcdFx0ZmluZWRQYXRoID0gbmFtZTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGlmIChmaW5lZFBhdGggIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmaW5lZFBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogUmVnaXN0ZXJzIGEgcGF0aCBhbGlhcy5cclxuXHRcdCAqXHJcblx0XHQgKiBBIHBhdGggYWxpYXMgaXMgYSBzaG9ydCBuYW1lIHJlcHJlc2VudGluZyBhIGxvbmcgcGF0aCAoYSBmaWxlIHBhdGgsIGEgVVJMLCBldGMuKVxyXG5cdFx0ICogRm9yIGV4YW1wbGUsIHdlIHVzZSAnQGppaScgYXMgdGhlIGFsaWFzIG9mIHRoZSBwYXRoIHRvIHRoZSBKaWkgZnJhbWV3b3JrIGRpcmVjdG9yeS5cclxuXHRcdCAqXHJcblx0XHQgKiBBIHBhdGggYWxpYXMgbXVzdCBzdGFydCB3aXRoIHRoZSBjaGFyYWN0ZXIgJ0AnIHNvIHRoYXQgaXQgY2FuIGJlIGVhc2lseSBkaWZmZXJlbnRpYXRlZFxyXG5cdFx0ICogZnJvbSBub24tYWxpYXMgcGF0aHMuXHJcblx0XHQgKlxyXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGlmIHRoZSBnaXZlbiBwYXRoIGV4aXN0cyBvciBub3QuIEFsbCBpdCBkb2VzIGlzXHJcblx0XHQgKiB0byBhc3NvY2lhdGUgdGhlIGFsaWFzIHdpdGggdGhlIHBhdGguXHJcblx0XHQgKlxyXG5cdFx0ICogQW55IHRyYWlsaW5nICcvJyBhbmQgJ1xcJyBjaGFyYWN0ZXJzIGluIHRoZSBnaXZlbiBwYXRoIHdpbGwgYmUgdHJpbW1lZC5cclxuXHRcdCAqXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gYWxpYXMgdGhlIGFsaWFzIG5hbWUgKGUuZy4gXCJAamlpXCIpLiBJdCBtdXN0IHN0YXJ0IHdpdGggYSAnQCcgY2hhcmFjdGVyLlxyXG5cdFx0ICogSXQgbWF5IGNvbnRhaW4gdGhlIGZvcndhcmQgc2xhc2ggJy8nIHdoaWNoIHNlcnZlcyBhcyBib3VuZGFyeSBjaGFyYWN0ZXIgd2hlbiBwZXJmb3JtaW5nXHJcblx0XHQgKiBhbGlhcyB0cmFuc2xhdGlvbiBieSBbW2dldEFsaWFzKCldXS5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSBwYXRoIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGFsaWFzLiBUcmFpbGluZyAnLycgYW5kICdcXCcgY2hhcmFjdGVyc1xyXG5cdFx0ICogd2lsbCBiZSB0cmltbWVkLiBUaGlzIGNhbiBiZVxyXG5cdFx0ICpcclxuXHRcdCAqIC0gYSBkaXJlY3Rvcnkgb3IgYSBmaWxlIHBhdGggKGUuZy4gYC90bXBgLCBgL3RtcC9tYWluLnR4dGApXHJcblx0XHQgKiAtIGEgVVJMIChlLmcuIGBodHRwOi8vZXhhbXBsZS5jb21gKVxyXG5cdFx0ICogLSBhIHBhdGggYWxpYXMgKGUuZy4gYEBqaWkvYmFzZWApLiBJbiB0aGlzIGNhc2UsIHRoZSBwYXRoIGFsaWFzIHdpbGwgYmUgY29udmVydGVkIGludG8gdGhlXHJcblx0XHQgKiAgIGFjdHVhbCBwYXRoIGZpcnN0IGJ5IGNhbGxpbmcgW1tnZXRBbGlhcygpXV0uXHJcblx0XHQgKlxyXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9ufSBpZiAkcGF0aCBpcyBhbiBpbnZhbGlkIGFsaWFzLlxyXG5cdFx0ICogQHNlZSBnZXRBbGlhcygpXHJcblx0XHQgKi9cclxuXHRcdHNldEFsaWFzOiBmdW5jdGlvbiAoYWxpYXMsIHBhdGgpIHtcclxuXHRcdFx0aWYgKGFsaWFzLmluZGV4T2YoJ0AnKSAhPT0gMCkge1xyXG5cdFx0XHRcdGFsaWFzID0gJ0AnICsgYWxpYXM7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBpbmRleCA9IGFsaWFzLmluZGV4T2YoJy8nKTtcclxuXHRcdFx0dmFyIHJvb3QgPSBpbmRleCA9PT0gLTEgPyBhbGlhcyA6IGFsaWFzLnN1YnN0cigwLCBpbmRleCk7XHJcblxyXG5cdFx0XHRpZiAocGF0aCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdHBhdGggPSBhbGlhcy5pbmRleE9mKCdAJykgIT09IDAgPyBKaWkuX3MucnRyaW0ocGF0aCwgJy8nKSA6IHRoaXMuZ2V0QWxpYXMocGF0aCk7XHJcblxyXG5cdFx0XHRcdGlmICghSmlpLl8uaGFzKHRoaXMuYWxpYXNlcywgcm9vdCkpIHtcclxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdID0gcGF0aDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHRoaXMuYWxpYXNlc1tyb290XSA9IHt9O1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFsaWFzZXNbcm9vdF1bYWxpYXNdID0gcGF0aDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKEppaS5fLmlzU3RyaW5nKHRoaXMuYWxpYXNlc1tyb290XSkpIHtcclxuXHRcdFx0XHRcdGlmIChpbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdID0gcGF0aDtcclxuXHRcdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRcdHZhciBvbGRQYXRoID0gdGhpcy5hbGlhc2VzW3Jvb3RdO1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFsaWFzZXNbcm9vdF0gPSB7fTtcclxuXHRcdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdW2FsaWFzXSA9IHBhdGg7XHJcblx0XHRcdFx0XHRcdHRoaXMuYWxpYXNlc1tyb290XVtyb290XSA9IG9sZFBhdGg7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRoaXMuYWxpYXNlc1tyb290XVthbGlhc10gPSBwYXRoO1xyXG5cdFx0XHRcdFx0Ly9rcnNvcnQoc3RhdGljOjokYWxpYXNlc1skcm9vdF0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChKaWkuXy5oYXModGhpcy5hbGlhc2VzLCByb290KSkge1xyXG5cdFx0XHRcdGlmIChKaWkuXy5pc09iamVjdCh0aGlzLmFsaWFzZXNbcm9vdF0pKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5hbGlhc2VzW3Jvb3RdW2FsaWFzXTtcclxuXHRcdFx0XHR9IGVsc2UgaWYgKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRoaXMuYWxpYXNlc1tyb290XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIHVzaW5nIHRoZSBnaXZlbiBjb25maWd1cmF0aW9uLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjb25maWcgQ2xhc3MgbmFtZSBvciBvYmplY3Qgd2l0aCBwYXJhbSBgY2xhc3NOYW1lYFxyXG5cdFx0ICogQHJldHVybnMge29iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlT2JqZWN0OiBmdW5jdGlvbiAoY29uZmlnKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBudWxsO1xyXG5cclxuXHRcdFx0Ly8gTm9ybWFsaXplIGNvbmZpZ1xyXG5cdFx0XHRpZiAoSmlpLl8uaXNTdHJpbmcoY29uZmlnKSkge1xyXG5cdFx0XHRcdGNsYXNzTmFtZSA9IGNvbmZpZztcclxuXHRcdFx0XHRjb25maWcgPSB7fTtcclxuXHRcdFx0fSBlbHNlIGlmIChKaWkuXy5oYXMoY29uZmlnLCAnY2xhc3NOYW1lJykpIHtcclxuXHRcdFx0XHRjb25maWcgPSBKaWkuXy5jbG9uZShjb25maWcpO1xyXG5cdFx0XHRcdGNsYXNzTmFtZSA9IGNvbmZpZy5jbGFzc05hbWU7XHJcblx0XHRcdFx0ZGVsZXRlIGNvbmZpZy5jbGFzc05hbWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uKCdXcm9uZyBjb25maWd1cmF0aW9uIGZvciBjcmVhdGUgb2JqZWN0LicpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBHZXQgY2xhc3NcclxuXHRcdFx0dmFyIG9iamVjdENsYXNzID0gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xyXG5cdFx0XHRpZiAoIUppaS5fLmlzRnVuY3Rpb24ob2JqZWN0Q2xhc3MpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uKCdOb3QgZm91bmQgY2xhc3MgYCcgKyBjbGFzc05hbWUgKyAnYCBmb3IgY3JlYXRlIGluc3RhbmNlLicpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBBcmd1bWVudHMgZm9yIGNvbnN0cnVjdG9yIG9mIGNsYXNzXHJcblx0XHRcdHZhciBhcmdzID0gW29iamVjdENsYXNzXTtcclxuXHRcdFx0YXJncyA9IGFyZ3MuY29uY2F0KEppaS5fLnJlc3QoYXJndW1lbnRzKSk7XHJcblx0XHRcdGlmICghSmlpLl8uaXNFbXB0eShjb25maWcpKSB7XHJcblx0XHRcdFx0YXJncy5wdXNoKGNvbmZpZyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEB0b2RvIFN1cHBvcnQgb2xkIGJyb3dzZXJzIChiaW5kIGZ1bmN0aW9uKVxyXG5cdFx0XHRyZXR1cm4gbmV3IChvYmplY3RDbGFzcy5iaW5kLmFwcGx5KG9iamVjdENsYXNzLCBhcmdzKSkoKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBTZXQgY29uZmlndXJhdGlvbiB0byBvYmplY3QuIFRoaXMgbWV0aG9kIGZpbmQgcHVibGljIHBhcmFtIGluIG9iamVjdCBvciBzZXR0ZXIgbWV0aG9kLlxyXG5cdFx0ICogWW91IGNhbiBub3QgdXNlIHNldHRlciBhbmQgcHVibGljIHBhcmFtIGF0IHRoZSBzYW1lIHRpbWUgZm9yIHNhZmV0eSByZWFzb25cclxuXHRcdCAqIEBwYXJhbSB7SmlpLmJhc2UuT2JqZWN0fSBvYmplY3QgQ2xhc3MgaW5zdGFuY2VcclxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgQ29uZmlndXJhdGlvbiBvYmplY3Qge2tleTogdmFsdWUsIC4ufVxyXG5cdFx0ICovXHJcblx0XHRjb25maWd1cmU6IGZ1bmN0aW9uIChvYmplY3QsIGNvbmZpZykge1xyXG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gY29uZmlnKSB7XHJcblx0XHRcdFx0aWYgKCFjb25maWcuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0fVxyXG5cclxuICAgICAgICAgICAgICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db21wb25lbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICBvYmplY3Quc2V0KGtleSwgY29uZmlnW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuXHRcdFx0XHQvLyBHZW5lcmF0ZSBzZXR0ZXIgbmFtZVxyXG5cdFx0XHRcdHZhciBzZXR0ZXIgPSAnc2V0JyArIEppaS5fcy5jYXBpdGFsaXplKGtleSk7XHJcblxyXG5cdFx0XHRcdGlmICghSmlpLl8uaXNGdW5jdGlvbihvYmplY3Rbc2V0dGVyXSkpIHtcclxuXHRcdFx0XHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKG9iamVjdFtrZXldKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbignWW91IGNhbiBub3QgcmVwbGFjZSBmcm9tIGNvbmZpZyBmdW5jdGlvbiBgJyArIGtleSArICdgIGluIG9iamVjdCBgJyArIG9iamVjdC5jbGFzc05hbWUoKSArICdgLicpO1xyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChKaWkuXy5pc1VuZGVmaW5lZChvYmplY3Rba2V5XSkpIHtcclxuXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ0NvbmZpZyBwYXJhbSBgJyArIGtleSArICdgIGlzIHVuZGVmaW5lZCBpbiBvYmplY3QgYCcgKyBvYmplY3QuY2xhc3NOYW1lKCkgKyAnYC4nKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmICghSmlpLl8uaXNVbmRlZmluZWQob2JqZWN0W2tleV0pICYmICFKaWkuXy5pc0Z1bmN0aW9uKG9iamVjdFtrZXldKSAmJiBKaWkuXy5pc0Z1bmN0aW9uKG9iamVjdFtzZXR0ZXJdKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ1lvdSBoYXZlIHR3byBzZXR0ZXJzIChmdW5jdGlvbiBhbmQgcHVibGljIHBhcmFtKSBmb3IgY29uZmlnIHBhcmFtIGAnICsga2V5ICsgJ2AgaW4gb2JqZWN0IGAnICsgb2JqZWN0LmNsYXNzTmFtZSgpICsgJ2AuICBQbGVhc2UgY2hhbmdlIHBhcmFtIGFjY2VzcyAodG8gYF8nICsga2V5ICsgJ2ApIG9yIHJlbW92ZSBzZXR0ZXIgbWV0aG9kLicpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFKaWkuXy5pc1VuZGVmaW5lZChvYmplY3Rba2V5XSkgJiYgIUppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W2tleV0pKSB7XHJcblx0XHRcdFx0XHRpZiAoSmlpLl8uaXNPYmplY3Qob2JqZWN0W2tleV0pICYmIEppaS5fLmlzT2JqZWN0KGNvbmZpZ1trZXldKSAmJiAhSmlpLl8uaXNBcnJheShvYmplY3Rba2V5XSkgJiYgIUppaS5fLmlzQXJyYXkoY29uZmlnW2tleV0pKSB7XHJcblx0XHRcdFx0XHRcdG9iamVjdFtrZXldID0gSmlpLm1lcmdlQ29uZmlncyhvYmplY3Rba2V5XSwgY29uZmlnW2tleV0pO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0b2JqZWN0W2tleV0gPSBjb25maWdba2V5XTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2UgaWYgKEppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W3NldHRlcl0pKSB7XHJcblx0XHRcdFx0XHRvYmplY3Rbc2V0dGVyXS5jYWxsKG9iamVjdCwgY29uZmlnW2tleV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIExvZ3MgYSB0cmFjZSBtZXNzYWdlLlxyXG5cdFx0ICogVHJhY2UgbWVzc2FnZXMgYXJlIGxvZ2dlZCBtYWlubHkgZm9yIGRldmVsb3BtZW50IHB1cnBvc2UgdG8gc2VlXHJcblx0XHQgKiB0aGUgZXhlY3V0aW9uIHdvcmsgZmxvdyBvZiBzb21lIGNvZGUuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWQuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG1lc3NhZ2UuXHJcblx0XHQgKi9cclxuXHRcdHRyYWNlOiBmdW5jdGlvbiAobWVzc2FnZSwgY2F0ZWdvcnkpIHtcclxuXHRcdFx0Y2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCAnJztcclxuXHJcblx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xyXG5cdFx0XHQvL2lmIChZSUlfREVCVUcpIHtcclxuXHRcdFx0XHQvLyBAdG9kbyBzdGF0aWMuZ2V0TG9nZ2VyKCkubG9nKG1lc3NhZ2UsIExvZ2dlci5MRVZFTF9UUkFDRSwgY2F0ZWdvcnkpO1xyXG5cdFx0XHQvL31cclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBMb2dzIGFuIGVycm9yIG1lc3NhZ2UuXHJcblx0XHQgKiBBbiBlcnJvciBtZXNzYWdlIGlzIHR5cGljYWxseSBsb2dnZWQgd2hlbiBhbiB1bnJlY292ZXJhYmxlIGVycm9yIG9jY3Vyc1xyXG5cdFx0ICogZHVyaW5nIHRoZSBleGVjdXRpb24gb2YgYW4gYXBwbGljYXRpb24uXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWQuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG1lc3NhZ2UuXHJcblx0XHQgKi9cclxuXHRcdGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSwgY2F0ZWdvcnkpIHtcclxuXHRcdFx0Y2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCAnJztcclxuXHJcblx0XHRcdGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XHJcblx0XHRcdC8vIEB0b2RvIHN0YXRpYy5nZXRMb2dnZXIoKS5sb2cobWVzc2FnZSwgTG9nZ2VyLkxFVkVMX0VSUk9SLCBjYXRlZ29yeSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTG9ncyBhIHdhcm5pbmcgbWVzc2FnZS5cclxuXHRcdCAqIEEgd2FybmluZyBtZXNzYWdlIGlzIHR5cGljYWxseSBsb2dnZWQgd2hlbiBhbiBlcnJvciBvY2N1cnMgd2hpbGUgdGhlIGV4ZWN1dGlvblxyXG5cdFx0ICogY2FuIHN0aWxsIGNvbnRpbnVlLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjYXRlZ29yeV0gdGhlIGNhdGVnb3J5IG9mIHRoZSBtZXNzYWdlLlxyXG5cdFx0ICovXHJcblx0XHR3YXJuaW5nOiBmdW5jdGlvbiAobWVzc2FnZSwgY2F0ZWdvcnkpIHtcclxuXHRcdFx0Y2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCAnJztcclxuXHJcblx0XHRcdGNvbnNvbGUud2FybihtZXNzYWdlKTtcclxuXHRcdFx0Ly8gQHRvZG8gc3RhdGljLmdldExvZ2dlcigpLmxvZyhtZXNzYWdlLCBMb2dnZXIuTEVWRUxfV0FSTklORywgY2F0ZWdvcnkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIExvZ3MgYW4gaW5mb3JtYXRpdmUgbWVzc2FnZS5cclxuXHRcdCAqIEFuIGluZm9ybWF0aXZlIG1lc3NhZ2UgaXMgdHlwaWNhbGx5IGxvZ2dlZCBieSBhbiBhcHBsaWNhdGlvbiB0byBrZWVwIHJlY29yZCBvZlxyXG5cdFx0ICogc29tZXRoaW5nIGltcG9ydGFudCAoZS5nLiBhbiBhZG1pbmlzdHJhdG9yIGxvZ3MgaW4pLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgdGhlIG1lc3NhZ2UgdG8gYmUgbG9nZ2VkLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtjYXRlZ29yeV0gdGhlIGNhdGVnb3J5IG9mIHRoZSBtZXNzYWdlLlxyXG5cdFx0ICovXHJcblx0XHRpbmZvOiBmdW5jdGlvbiAobWVzc2FnZSwgY2F0ZWdvcnkpIHtcclxuXHRcdFx0Y2F0ZWdvcnkgPSBjYXRlZ29yeSB8fCAnJztcclxuXHJcblx0XHRcdGNvbnNvbGUuaW5mbyhtZXNzYWdlKTtcclxuXHRcdFx0Ly8gQHRvZG8gc3RhdGljLmdldExvZ2dlcigpLmxvZyhtZXNzYWdlLCBMb2dnZXIuTEVWRUxfSU5GTywgY2F0ZWdvcnkpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNob3J0IGFsaWFzIGZvciB0cmFuc2xhdGUgdGV4dHNcclxuXHRcdCAqIEBwYXJhbSBncm91cFxyXG5cdFx0ICogQHBhcmFtIFttZXNzYWdlXVxyXG5cdFx0ICogQHJldHVybnMgeyp9XHJcblx0XHQgKi9cclxuXHRcdHQ6IGZ1bmN0aW9uIChncm91cCwgbWVzc2FnZSkge1xyXG5cdFx0XHQvLyBAdG9kb1xyXG5cdFx0XHRyZXR1cm4gbWVzc2FnZTtcclxuXHRcdH0sXHJcblxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb2JqXVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb2JqXVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb2JqXVxyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbb2JqXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgbWVyZ2VDb25maWdzOiBmdW5jdGlvbihvYmopIHtcclxuICAgICAgICAgICAgdmFyIGRzdCA9IHt9O1xyXG5cclxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlpID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlpOyArK2kpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvYmogPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoIUppaS5fLmlzT2JqZWN0KG9iaikpIHtcclxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChKaWkuXy5pc09iamVjdChvYmpba2V5XSkgJiYgIUppaS5fLmlzQXJyYXkob2JqW2tleV0pICYmICFKaWkuXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0W2tleV0gPSB0aGlzLm1lcmdlQ29uZmlncyhkc3Rba2V5XSwgb2JqW2tleV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHN0W2tleV0gPSBvYmpba2V5XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgcmV0dXJuIGRzdDtcclxuICAgICAgICB9LFxyXG5cclxuICAgICAgICBjYXRjaEhhbmRsZXI6IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlLnN0YWNrIHx8IGUpXHJcbiAgICAgICAgfVxyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuLy8gQHRvZG8gTW92ZSB0byBFcnJvcnMgbW9kdWxlXHJcbnByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIGZ1bmN0aW9uKHJlYXNvbiwgcHJvbWlzZSkge1xyXG4gICAgY29uc29sZS53YXJuKFwiUG9zc2libHkgVW5oYW5kbGVkIFJlamVjdGlvbiBhdDogUHJvbWlzZSBcIiwgcHJvbWlzZSwgXCIgcmVhc29uOiBcIiwgcmVhc29uKTtcclxufSk7XHJcblxyXG4vKipcclxuICogQG1vZHVsZSBKaWlcclxuICovXHJcbm1vZHVsZS5leHBvcnRzID0gSmlpO1xufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksXCIvLi4vLi4vLi4vamlpL2xpYlwiKVxufSx7XCIuLi9wYWNrYWdlLmpzb25cIjoxNjIsXCJfcHJvY2Vzc1wiOjMwLFwibmVhdG5lc3NcIjoxNTR9XSwxMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuLi9iYXNlL0FwcGxpY2F0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5hcHBsaWNhdGlvbi5XZWJBcHBsaWNhdGlvblxuICogQGV4dGVuZHMgSmlpLmJhc2UuQXBwbGljYXRpb25cbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYXBwbGljYXRpb24uV2ViQXBwbGljYXRpb24nLCAvKiogQGxlbmRzIEppaS5hcHBsaWNhdGlvbi5XZWJBcHBsaWNhdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5BcHBsaWNhdGlvbixcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nfGJvb2xlYW59IHRoZSBsYXlvdXQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBmb3Igdmlld3MgaW4gdGhpcyBhcHBsaWNhdGlvbi4gRGVmYXVsdHMgdG8gJ21haW4nLlxuXHQgKiBJZiB0aGlzIGlzIGZhbHNlLCBsYXlvdXQgd2lsbCBiZSBkaXNhYmxlZC5cblx0ICovXG5cdGxheW91dDogJ21haW4nLFxuXG4gICAgZGVmYXVsdFJvdXRlOiAnc2l0ZScsXG5cblx0X3ByZUluaXQ6IGZ1bmN0aW9uKGNvbmZpZykge1xuXHRcdHRoaXMuX19zdXBlcihjb25maWcpO1xuXG5cdFx0Ly8gU2V0IGRlZmF1bHQgd2Vicm9vdFxuXHRcdHRoaXMuc2V0V2ViUGF0aChjb25maWcud2ViUGF0aCB8fCB0aGlzLmdldEJhc2VQYXRoKCkgKyAnL3dlYicpO1xuXHRcdHRoaXMuc2V0V2ViVXJsKGNvbmZpZy53ZWJVcmwgfHwgJy8nKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0V2ViUGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBKaWkuZ2V0QWxpYXMoJ0B3ZWJyb290Jyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSAge1N0cmluZ30gcGF0aFxuXHQgKi9cblx0c2V0V2ViUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRKaWkuc2V0QWxpYXMoJ0B3ZWJyb290JywgcGF0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEByZXR1cm4ge1N0cmluZ31cblx0ICovXG5cdGdldFdlYlVybDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBKaWkuZ2V0QWxpYXMoJ0B3ZWInKTtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG5cdCAqL1xuXHRzZXRXZWJVcmw6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0SmlpLnNldEFsaWFzKCdAd2ViJywgcGF0aCk7XG5cdH1cblxufSk7XG59LHtcIi4uL0ppaVwiOjEyNSxcIi4uL2Jhc2UvQXBwbGljYXRpb25cIjoxMjl9XSwxMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9PYmplY3QnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQWN0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5BY3Rpb24nLCAvKiogQGxlbmRzIEppaS5iYXNlLkFjdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9IElEIG9mIHRoZSBhY3Rpb25cblx0ICovXG5cdGlkOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLmJhc2UuQ29udHJvbGxlcn0gdGhlIGNvbnRyb2xsZXIgdGhhdCBvd25zIHRoaXMgYWN0aW9uXG5cdCAqL1xuXHRjb250cm9sbGVyOiBudWxsLFxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoaWQsIGNvbnRyb2xsZXIsIGNvbmZpZykge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLmNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuXHRcdHRoaXMuX19zdXBlcihjb25maWcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgdGhpcyBhY3Rpb24gYW1vbmcgdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdW5pcXVlIElEIG9mIHRoaXMgYWN0aW9uIGFtb25nIHRoZSB3aG9sZSBhcHBsaWNhdGlvbi5cblx0ICovXG5cdGdldFVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuY29udHJvbGxlci5nZXRVbmlxdWVJZCgpICsgJy8nICsgdGhpcy5pZDtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqL1xuXHRydW46IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1bnMgdGhpcyBhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHBhcmFtZXRlcnMuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG1haW5seSBpbnZva2VkIGJ5IHRoZSBjb250cm9sbGVyLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcblx0ICogQHJldHVybnMge1Byb21pc2V9IHRoZSByZXN1bHQgb2YgdGhlIGFjdGlvblxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9ufSBpZiB0aGUgYWN0aW9uIGNsYXNzIGRvZXMgbm90IGhhdmUgYSBydW4oKSBtZXRob2Rcblx0ICovXG5cdHJ1bldpdGhQYXJhbXM6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0aWYgKCFKaWkuXy5pc0Z1bmN0aW9uKHRoaXMucnVuKSkge1xuXHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24odGhpcy5kZWJ1Z0NsYXNzTmFtZSArICcgbXVzdCBkZWZpbmUgYSBgcnVuKClgIG1ldGhvZC4nKTtcblx0XHR9XG5cblx0XHQvL1lpaTo6dHJhY2UoJ1J1bm5pbmcgYWN0aW9uOiAnIC4gZ2V0X2NsYXNzKCR0aGlzKSAuICc6OnJ1bigpJywgX19NRVRIT0RfXyk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYmVmb3JlUnVuKGNvbnRleHQpKVxuXHRcdFx0LnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbiAoYm9vbCkge1xuXHRcdFx0XHRpZiAoIWJvb2wpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0aGlzLnJ1bihjb250ZXh0KTtcblx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0LnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZnRlclJ1bigpKS50aGVuKGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBgcnVuKClgIGlzIGV4ZWN1dGVkLlxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHByZXBhcmF0aW9uIHdvcmsgZm9yIHRoZSBhY3Rpb24gcnVuLlxuXHQgKiBJZiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UsIGl0IHdpbGwgY2FuY2VsIHRoZSBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfGJvb2xlYW59IHdoZXRoZXIgdG8gcnVuIHRoZSBhY3Rpb24uXG5cdCAqL1xuXHRiZWZvcmVSdW46IGZ1bmN0aW9uIChjb250ZXh0KSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCByaWdodCBhZnRlciBgcnVuKClgIGlzIGV4ZWN1dGVkLlxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHBvc3QtcHJvY2Vzc2luZyB3b3JrIGZvciB0aGUgYWN0aW9uIHJ1bi5cblx0ICovXG5cdGFmdGVyUnVuOiBmdW5jdGlvbiAoKSB7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9PYmplY3RcIjoxMzh9XSwxMjg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkFjdGlvbkV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkFjdGlvbkV2ZW50JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5BY3Rpb25FdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5FdmVudCxcblxuXHQvKipcblx0ICogQHR5cGUge0ppaS5iYXNlLkFjdGlvbn1cblx0ICovXG5cdGFjdGlvbjogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge0ppaS5iYXNlLkNvbnRleHR9XG5cdCAqL1xuXHRjb250ZXh0OiBudWxsXG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vRXZlbnRcIjoxMzR9XSwxMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcclxuXHJcbnJlcXVpcmUoJy4vTW9kdWxlJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEppaS5iYXNlLkFwcGxpY2F0aW9uXHJcbiAqIEBleHRlbmRzIEppaS5iYXNlLk1vZHVsZVxyXG4gKi9cclxuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5BcHBsaWNhdGlvbicsIC8qKiBAbGVuZHMgSmlpLmJhc2UuQXBwbGljYXRpb24ucHJvdG90eXBlICove1xyXG5cclxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk1vZHVsZSxcclxuXHJcblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmJhc2UuQXBwbGljYXRpb24gKi97XHJcblxyXG5cdFx0RU5WSVJPTk1FTlRfUFJPRFVDVElPTjogJ3Byb2R1Y3Rpb24nLFxyXG5cdFx0RU5WSVJPTk1FTlRfREVWRUxPUE1FTlQ6ICdkZXZlbG9wbWVudCcsXHJcblx0XHRFTlZJUk9OTUVOVF9URVNUOiAndGVzdCdcclxuXHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIG5hbWVzcGFjZSB0aGF0IGNvbnRyb2xsZXIgY2xhc3NlcyBhcmUgaW4uIElmIG5vdCBzZXQsXHJcblx0ICogaXQgd2lsbCB1c2UgdGhlIFwiYXBwXFxjb250cm9sbGVyc1wiIG5hbWVzcGFjZS5cclxuXHQgKi9cclxuXHRjb250cm9sbGVyTmFtZXNwYWNlOiAnYXBwLmNvbnRyb2xsZXJzJyxcclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIGFwcGxpY2F0aW9uIG5hbWUuXHJcblx0ICovXHJcblx0bmFtZTogJ015IEFwcGxpY2F0aW9uJyxcclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIHZlcnNpb24gb2YgdGhpcyBhcHBsaWNhdGlvbi5cclxuXHQgKi9cclxuXHR2ZXJzaW9uOiAnMS4wJyxcclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIGNoYXJzZXQgY3VycmVudGx5IHVzZWQgZm9yIHRoZSBhcHBsaWNhdGlvbi5cclxuXHQgKi9cclxuXHRjaGFyc2V0OiAnVVRGLTgnLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgbGFuZ3VhZ2UgdGhhdCBpcyBtZWFudCB0byBiZSB1c2VkIGZvciBlbmQgdXNlcnMuXHJcblx0ICogQHNlZSBzb3VyY2VMYW5ndWFnZVxyXG5cdCAqL1xyXG5cdGxhbmd1YWdlOiAnZW4nLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGUgYXBwbGljYXRpb24gaXMgd3JpdHRlbiBpbi4gVGhpcyBtYWlubHkgcmVmZXJzIHRvXHJcblx0ICogdGhlIGxhbmd1YWdlIHRoYXQgdGhlIG1lc3NhZ2VzIGFuZCB2aWV3IGZpbGVzIGFyZSB3cml0dGVuIGluLlxyXG5cdCAqIEBzZWUgbGFuZ3VhZ2VcclxuXHQgKi9cclxuXHRzb3VyY2VMYW5ndWFnZTogJ2VuJyxcclxuXHJcblx0LyoqXHJcblx0ICogVGhlIElEcyBvZiB0aGUgY29tcG9uZW50cyBvciBtb2R1bGVzIHRoYXQgc2hvdWxkIGJlIHByZWxvYWRlZCByaWdodCBhZnRlciBpbml0aWFsaXphdGlvbi5cclxuXHQgKiBAdHlwZSB7c3RyaW5nW119XHJcblx0ICovXHJcblx0Ym9vdHN0cmFwOiBudWxsLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdGVudmlyb25tZW50OiAnZGV2ZWxvcG1lbnQnLFxyXG5cclxuXHQvKipcclxuXHQgKiBAY29uc3RydWN0c1xyXG5cdCAqL1xyXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoY29uZmlnKSB7XHJcblx0XHRKaWkuYXBwID0gdGhpcztcclxuXHJcblx0XHR0aGlzLmJvb3RzdHJhcCA9IFtdO1xyXG5cclxuXHRcdC8vIE1lcmdlIHdpdGggZGVmYXVsdCBjb25maWdcclxuXHRcdGNvbmZpZyA9IEppaS5tZXJnZUNvbmZpZ3ModGhpcy5fZ2V0QmFzZUNvbmZpZygpLCBjb25maWcpO1xyXG5cclxuXHRcdHRoaXMuX3ByZUluaXQoY29uZmlnKTtcclxuXHRcdHRoaXMuX2xvYWRCb290c3RyYXBDb21wb25lbnRzKCk7XHJcblxyXG5cdFx0dGhpcy5fX3N1cGVyKG51bGwsIG51bGwsIGNvbmZpZyk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdCAqL1xyXG5cdGdldFVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gJyc7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogU2V0cyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIGFwcGxpY2F0aW9uIGFuZCB0aGUgQGFwcCBhbGlhcy5cclxuXHQgKiBUaGlzIG1ldGhvZCBjYW4gb25seSBiZSBpbnZva2VkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGNvbnN0cnVjdG9yLlxyXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgYXBwbGljYXRpb24uXHJcblx0ICovXHJcblx0c2V0QmFzZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XHJcblx0XHR0aGlzLl9fc3VwZXIocGF0aCk7XHJcblx0XHRKaWkuc2V0QWxpYXMoJ0BhcHAnLCB0aGlzLmdldEJhc2VQYXRoKCkpO1xyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIE92ZXJ3cml0ZSB0aGlzIG1ldGhvZCBmb3IgcmV0dXJuIGRlZmF1bHQgY29uZmlndXJhdGlvbiBzcGVjaWZpZWQgZm9yIGFwcGxpY2F0aW9uXHJcblx0ICogQHR5cGUge29iamVjdH0gYmFzZSBhcHBsaWNhdGlvbidzIGNvbmZpZy5cclxuXHQgKi9cclxuXHRfZ2V0QmFzZUNvbmZpZzogZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge307XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICpcclxuXHQgKiBAcGFyYW0gY29uZmlnXHJcblx0ICogQHByaXZhdGVcclxuXHQgKi9cclxuXHRfcHJlSW5pdDogZnVuY3Rpb24gKGNvbmZpZykge1xyXG5cdFx0aWYgKEppaS5fLmhhcyhjb25maWcsICdiYXNlUGF0aCcpKSB7XHJcblx0XHRcdHRoaXMuc2V0QmFzZVBhdGgoY29uZmlnLmJhc2VQYXRoKTtcclxuXHRcdFx0ZGVsZXRlIGNvbmZpZy5iYXNlUGF0aDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKCdUaGUgYGJhc2VQYXRoYCBjb25maWd1cmF0aW9uIGlzIHJlcXVpcmVkLicpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8qKlxyXG5cdCAqIExvYWRzIGNvbXBvbmVudHMgdGhhdCBhcmUgZGVjbGFyZWQgaW4gW1tib290c3RyYXBdXS5cclxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9ufSBpZiBhIGNvbXBvbmVudCBvciBtb2R1bGUgdG8gYmUgcHJlbG9hZGVkIGlzIHVua25vd25cclxuXHQgKi9cclxuXHRfbG9hZEJvb3RzdHJhcENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEppaS5fLmVhY2godGhpcy5ib290c3RyYXAsIEppaS5fLmJpbmQoZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRcdGlmICh0aGlzLmhhc0NvbXBvbmVudChpZCkpIHtcclxuXHRcdFx0XHR0aGlzLmdldENvbXBvbmVudChpZCk7XHJcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5oYXNNb2R1bGUoaWQpKSB7XHJcblx0XHRcdFx0dGhpcy5nZXRNb2R1bGUoaWQpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKFwiVW5rbm93biBjb21wb25lbnQgb3IgbW9kdWxlOiBcIiArIGlkKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcykpO1xyXG5cdH1cclxufSk7XHJcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL01vZHVsZVwiOjEzN31dLDEzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vT2JqZWN0Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkJlaGF2aW9yXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5CZWhhdmlvcicsIC8qKiBAbGVuZHMgSmlpLmJhc2UuQmVoYXZpb3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtKaWkuYmFzZS5Db21wb25lbnR9IHRoZSBvd25lciBvZiB0aGlzIGJlaGF2aW9yXG5cdCAqL1xuXHRvd25lcjogbnVsbCxcblxuXHQvKipcblx0ICogRGVjbGFyZXMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBbW293bmVyXV0ncyBldmVudHMuXG5cdCAqXG5cdCAqIENoaWxkIGNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRlY2xhcmUgd2hhdCBjYWxsYmFja3Mgc2hvdWxkXG5cdCAqIGJlIGF0dGFjaGVkIHRvIHRoZSBldmVudHMgb2YgdGhlIFtbb3duZXJdXSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIFRoZSBjYWxsYmFja3Mgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgW1tvd25lcl1dJ3MgZXZlbnRzIHdoZW4gdGhlIGJlaGF2aW9yIGlzXG5cdCAqIGF0dGFjaGVkIHRvIHRoZSBvd25lcjsgYW5kIHRoZXkgd2lsbCBiZSBkZXRhY2hlZCBmcm9tIHRoZSBldmVudHMgd2hlblxuXHQgKiB0aGUgYmVoYXZpb3IgaXMgZGV0YWNoZWQgZnJvbSB0aGUgY29tcG9uZW50LlxuXHQgKlxuXHQgKiBUaGUgY2FsbGJhY2tzIGNhbiBiZSBhbnkgb2YgdGhlIGZvbGxvd2luZ3M6XG5cdCAqXG5cdCAqIC0gbWV0aG9kIGluIHRoaXMgYmVoYXZpb3I6IGAnaGFuZGxlQ2xpY2snYFxuXHQgKiAtIGFub255bW91cyBmdW5jdGlvbjogYGZ1bmN0aW9uIChldmVudCkgeyAuLi4gfWBcblx0ICogLSBtZXRob2Qgd2l0aCBjb250ZXh0OiBge2NhbGxiYWNrOiBmdW5jdGlvbiAoZXZlbnQpIHsgLi4uIH0sIGNvbnRleHQ6IHRoaXN9YFxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGU6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiB7XG5cdCAqICAgICBiZWZvcmVWYWxpZGF0ZTogJ215QmVmb3JlVmFsaWRhdGUnLFxuXHQgKiAgICAgYWZ0ZXJWYWxpZGF0ZToge1xuXHQgKiAgICAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbigpIHt9LFxuXHQgKiAgICAgICAgIGNvbnRleHQ6IHRoaXNcblx0ICogICAgIH1cblx0ICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHJldHVybiB7b2JqZWN0fSBldmVudHMgKGFycmF5IGtleXMpIGFuZCB0aGUgY29ycmVzcG9uZGluZyBldmVudCBoYW5kbGVyIG1ldGhvZHMgKGFycmF5IHZhbHVlcykuXG5cdCAqL1xuXHRldmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIHRoZSBiZWhhdmlvciBvYmplY3QgdG8gdGhlIGNvbXBvbmVudC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCBzZXQgdGhlIFtbb3duZXJdXSBwcm9wZXJ0eVxuXHQgKiBhbmQgYXR0YWNoIGV2ZW50IGhhbmRsZXJzIGFzIGRlY2xhcmVkIGluIFtbZXZlbnRzXV0uXG5cdCAqIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIGlmIHlvdSBvdmVycmlkZSB0aGlzIG1ldGhvZC5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db21wb25lbnR9IG93bmVyIHRoZSBjb21wb25lbnQgdGhhdCB0aGlzIGJlaGF2aW9yIGlzIHRvIGJlIGF0dGFjaGVkIHRvLlxuXHQgKi9cblx0YXR0YWNoOiBmdW5jdGlvbiAob3duZXIpIHtcblx0XHR0aGlzLm93bmVyID0gb3duZXI7XG5cblx0XHRKaWkuXy5lYWNoKHRoaXMuZXZlbnRzKCksIEppaS5fLmJpbmQoZnVuY3Rpb24oaGFuZGxlciwgZXZlbnQpIHtcblx0XHRcdGhhbmRsZXIgPSBKaWkuYmFzZS5FdmVudC5ub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIsIHRoaXMpO1xuXHRcdFx0dGhpcy5vd25lci5vbihldmVudCwgaGFuZGxlcik7XG5cdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXRhY2hlcyB0aGUgYmVoYXZpb3Igb2JqZWN0IGZyb20gdGhlIGNvbXBvbmVudC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCB1bnNldCB0aGUgW1tvd25lcl1dIHByb3BlcnR5XG5cdCAqIGFuZCBkZXRhY2ggZXZlbnQgaGFuZGxlcnMgZGVjbGFyZWQgaW4gW1tldmVudHNdXS5cblx0ICogTWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gaWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuXHQgKi9cblx0ZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLm93bmVyKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0SmlpLl8uZWFjaCh0aGlzLmV2ZW50cygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGhhbmRsZXIsIGV2ZW50KSB7XG5cdFx0XHRoYW5kbGVyID0gSmlpLmJhc2UuRXZlbnQubm9ybWFsaXplSGFuZGxlcihoYW5kbGVyLCB0aGlzKTtcblx0XHRcdHRoaXMub3duZXIub2ZmKGV2ZW50LCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKSk7XG5cdFx0dGhpcy5vd25lciA9IG51bGw7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9PYmplY3RcIjoxMzh9XSwxMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL09iamVjdCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkNvbXBvbmVudCcsIC8qKiBAbGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHZhciB7b2JqZWN0fSB0aGUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlcnMgKGV2ZW50IG5hbWU6IGhhbmRsZXJzKVxuXHQgKi9cblx0X2V2ZW50czogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7b2JqZWN0fSB0aGUgYXR0YWNoZWQgYmVoYXZpb3JzIChiZWhhdmlvciBuYW1lOiBiZWhhdmlvcilcblx0ICovXG5cdF9iZWhhdmlvcnM6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcblx0XHQvLyBQcm94eSBiZWhhdmlvdXIgbWV0aG9kc1xuXHRcdHRoaXMucHJveHlCZWhhdmlvcnMoKTtcblxuXHRcdHRoaXMuX19zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgbGlzdCBvZiBiZWhhdmlvcnMgdGhhdCB0aGlzIGNvbXBvbmVudCBzaG91bGQgYmVoYXZlIGFzLlxuXHQgKlxuXHQgKiBDaGlsZCBjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBzcGVjaWZ5IHRoZSBiZWhhdmlvcnMgdGhleSB3YW50IHRvIGJlaGF2ZSBhcy5cblx0ICpcblx0ICogVGhlIHJldHVybiB2YWx1ZSBvZiB0aGlzIG1ldGhvZCBzaG91bGQgYmUgYW4gYXJyYXkgb2YgYmVoYXZpb3Igb2JqZWN0cyBvciBjb25maWd1cmF0aW9uc1xuXHQgKiBpbmRleGVkIGJ5IGJlaGF2aW9yIG5hbWVzLiBBIGJlaGF2aW9yIGNvbmZpZ3VyYXRpb24gY2FuIGJlIGVpdGhlciBhIHN0cmluZyBzcGVjaWZ5aW5nXG5cdCAqIHRoZSBiZWhhdmlvciBjbGFzcyBvciBhbiBhcnJheSBvZiB0aGUgZm9sbG93aW5nIHN0cnVjdHVyZTpcblx0ICpcblx0ICogfn5+XG5cdCAqIGJlaGF2aW9yTmFtZToge1xuXHQgKiAgICAgY2xhc3M6ICdCZWhhdmlvckNsYXNzJyxcblx0ICogICAgIHByb3BlcnR5MTogJ3ZhbHVlMScsXG5cdCAqICAgICBwcm9wZXJ0eTI6ICd2YWx1ZTInXG5cdCAqIH1cblx0ICogfn5+XG5cdCAqXG5cdCAqIE5vdGUgdGhhdCBhIGJlaGF2aW9yIGNsYXNzIG11c3QgZXh0ZW5kIGZyb20gW1tKaWkuYmFzZS5CZWhhdmlvcl1dLiBCZWhhdmlvciBuYW1lcyBjYW4gYmUgc3RyaW5nc1xuXHQgKiBvciBpbnRlZ2Vycy4gSWYgdGhlIGZvcm1lciwgdGhleSB1bmlxdWVseSBpZGVudGlmeSB0aGUgYmVoYXZpb3JzLiBJZiB0aGUgbGF0dGVyLCB0aGUgY29ycmVzcG9uZGluZ1xuXHQgKiBiZWhhdmlvcnMgYXJlIGFub255bW91cyBhbmQgdGhlaXIgcHJvcGVydGllcyBhbmQgbWV0aG9kcyB3aWxsIE5PVCBiZSBtYWRlIGF2YWlsYWJsZSB2aWEgdGhlIGNvbXBvbmVudFxuXHQgKiAoaG93ZXZlciwgdGhlIGJlaGF2aW9ycyBjYW4gc3RpbGwgcmVzcG9uZCB0byB0aGUgY29tcG9uZW50J3MgZXZlbnRzKS5cblx0ICpcblx0ICogQmVoYXZpb3JzIGRlY2xhcmVkIGluIHRoaXMgbWV0aG9kIHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGNvbXBvbmVudCBhdXRvbWF0aWNhbGx5IChvbiBkZW1hbmQpLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBiZWhhdmlvciBjb25maWd1cmF0aW9ucy5cblx0ICovXG5cdGJlaGF2aW9yczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpcyBhbnkgaGFuZGxlciBhdHRhY2hlZCB0byB0aGUgbmFtZWQgZXZlbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBldmVudCBuYW1lXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlcmUgaXMgYW55IGhhbmRsZXIgYXR0YWNoZWQgdG8gdGhlIGV2ZW50LlxuXHQgKi9cblx0aGFzRXZlbnRIYW5kbGVyczogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbbmFtZV0gJiYgdGhpcy5fZXZlbnRzW25hbWVdLmxlbmd0aCA+IDAgPyB0cnVlIDogZmFsc2U7Ly8gQHRvZG8gfHwgRXZlbnQ6Omhhc0hhbmRsZXJzKHRoaXMsIG5hbWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIHRvIGFuIGV2ZW50LlxuXHQgKlxuXHQgKiBUaGUgZXZlbnQgaGFuZGxlciBtdXN0IGJlIGEgdmFsaWQgUEhQIGNhbGxiYWNrLiBUaGUgZm9sbG93aW5ncyBhcmVcblx0ICogc29tZSBleGFtcGxlczpcblx0ICpcblx0ICogfn5+XG5cdCAqIGZ1bmN0aW9uIChldmVudCkgeyAuLi4gfSAgICAgICAgIC8vIGFub255bW91cyBmdW5jdGlvblxuXHQgKiB+fn5cblx0ICpcblx0ICogVGhlIGV2ZW50IGhhbmRsZXIgbXVzdCBiZSBkZWZpbmVkIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmUsXG5cdCAqXG5cdCAqIH5+flxuXHQgKiBmdW5jdGlvbiAoZXZlbnQpXG5cdCAqIH5+flxuXHQgKlxuXHQgKiB3aGVyZSBgZXZlbnRgIGlzIGFuIFtbSmlpLmJhc2UuRXZlbnRdXSBvYmplY3Qgd2hpY2ggaW5jbHVkZXMgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50LlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZSB0aGUgZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge2Z1bmN0aW9ufSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyXG5cdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIHRoZSBkYXRhIHRvIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdCAqIFdoZW4gdGhlIGV2ZW50IGhhbmRsZXIgaXMgaW52b2tlZCwgdGhpcyBkYXRhIGNhbiBiZSBhY2Nlc3NlZCB2aWEgZGF0YS5cblx0ICogQHBhcmFtIHtib29sZWFufSBbaXNBcHBlbmRdIHdoZXRoZXIgdG8gYXBwZW5kIG5ldyBldmVudCBoYW5kbGVyIHRvIHRoZSBlbmQgb2YgdGhlIGV4aXN0aW5nXG5cdCAqIGhhbmRsZXIgbGlzdC4gSWYgZmFsc2UsIHRoZSBuZXcgaGFuZGxlciB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGV4aXN0aW5nXG5cdCAqIGhhbmRsZXIgbGlzdC5cblx0ICogQHNlZSBvZmYoKVxuXHQgKi9cblx0b246IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZCkge1xuXHRcdGRhdGEgPSBkYXRhIHx8IG51bGw7XG5cdFx0aXNBcHBlbmQgPSBKaWkuXy5pc1VuZGVmaW5lZChpc0FwcGVuZCkgPyB0cnVlIDogaXNBcHBlbmQ7XG5cbiAgICAgICAgLy8gTXVsdGlwbGUgbmFtZXMgc3VwcG9ydFxuICAgICAgICBuYW1lID0gdGhpcy5fbm9ybWFsaXplRXZlbnROYW1lcyhuYW1lKTtcbiAgICAgICAgaWYgKG5hbWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihuLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZClcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cdFx0aWYgKGlzQXBwZW5kIHx8ICF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSkge1xuXHRcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuXHRcdFx0dGhpcy5fZXZlbnRzW25hbWVdID0gdGhpcy5fZXZlbnRzW25hbWVdIHx8IFtdO1xuXHRcdFx0dGhpcy5fZXZlbnRzW25hbWVdLnB1c2goW2hhbmRsZXIsIGRhdGFdKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZXZlbnRzW25hbWVdLnVuc2hpZnQoW2hhbmRsZXIsIGRhdGFdKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIERldGFjaGVzIGFuIGV4aXN0aW5nIGV2ZW50IGhhbmRsZXIgZnJvbSB0aGlzIGNvbXBvbmVudC5cblx0ICogVGhpcyBtZXRob2QgaXMgdGhlIG9wcG9zaXRlIG9mIFtbb24oKV1dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXSB0aGUgZXZlbnQgaGFuZGxlciB0byBiZSByZW1vdmVkLlxuXHQgKiBJZiBpdCBpcyBudWxsLCBhbGwgaGFuZGxlcnMgYXR0YWNoZWQgdG8gdGhlIG5hbWVkIGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC5cblx0ICogQHJldHVybiBib29sZWFuIGlmIGEgaGFuZGxlciBpcyBmb3VuZCBhbmQgZGV0YWNoZWRcblx0ICogQHNlZSBvbigpXG5cdCAqL1xuXHRvZmY6IGZ1bmN0aW9uIChuYW1lLCBoYW5kbGVyKSB7XG5cdFx0aGFuZGxlciA9IGhhbmRsZXIgfHwgbnVsbDtcblxuICAgICAgICAvLyBNdWx0aXBsZSBuYW1lcyBzdXBwb3J0XG4gICAgICAgIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVFdmVudE5hbWVzKG5hbWUpO1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgYm9vbCA9IGZhbHNlO1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub24obiwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVbMF07XG4gICAgICAgIH1cblxuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cdFx0aWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdGlmIChoYW5kbGVyID09PSBudWxsKSB7XG5cdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0V2ZW50cyA9IFtdO1xuXHRcdHZhciBpc1JlbW92ZWQgPSBmYWxzZTtcblx0XHRKaWkuXy5lYWNoKHRoaXMuX2V2ZW50c1tuYW1lXSwgZnVuY3Rpb24oZXZlbnQsIGkpIHtcbiAgICAgICAgICAgIGlmIChKaWkuXy5pc09iamVjdChoYW5kbGVyKSAmJiBKaWkuXy5oYXMoaGFuZGxlciwgJ2NvbnRleHQnKSAmJiBKaWkuXy5pc0Z1bmN0aW9uKGhhbmRsZXIuY2FsbGJhY2spKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrIHx8IGV2ZW50LmNvbnRleHQgIT09IGhhbmRsZXIuY29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5jYWxsYmFjayAhPT0gaGFuZGxlci5jYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBuZXdFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cdFx0dGhpcy5fZXZlbnRzW25hbWVdID0gbmV3RXZlbnRzO1xuXG5cdFx0cmV0dXJuIGlzUmVtb3ZlZDtcblx0fSxcblxuICAgIF9ub3JtYWxpemVFdmVudE5hbWVzOiBmdW5jdGlvbihuYW1lcykge1xuICAgICAgICByZXR1cm4gSmlpLl8uaXNTdHJpbmcobmFtZXMpID9cbiAgICAgICAgICAgIG5hbWVzLnNwbGl0KC9bICxdKy8pIDpcbiAgICAgICAgICAgIG5hbWVzO1xuICAgIH0sXG5cblx0LyoqXG5cdCAqIFRyaWdnZXJzIGFuIGV2ZW50LlxuXHQgKiBUaGlzIG1ldGhvZCByZXByZXNlbnRzIHRoZSBoYXBwZW5pbmcgb2YgYW4gZXZlbnQuIEl0IGludm9rZXNcblx0ICogYWxsIGF0dGFjaGVkIGhhbmRsZXJzIGZvciB0aGUgZXZlbnQgaW5jbHVkaW5nIGNsYXNzLWxldmVsIGhhbmRsZXJzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZXZlbnQgbmFtZVxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkV2ZW50fSBbZXZlbnRdIHRoZSBldmVudCBwYXJhbWV0ZXIuIElmIG5vdCBzZXQsIGEgZGVmYXVsdCBbW0ppaS5iYXNlLkV2ZW50XV0gb2JqZWN0IHdpbGwgYmUgY3JlYXRlZC5cblx0ICovXG5cdHRyaWdnZXI6IGZ1bmN0aW9uIChuYW1lLCBldmVudCkge1xuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cdFx0aWYgKHRoaXMuX2V2ZW50cyAmJiB0aGlzLl9ldmVudHNbbmFtZV0pIHtcblx0XHRcdGlmIChldmVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRldmVudCA9IG5ldyBKaWkuYmFzZS5FdmVudCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCEoZXZlbnQgaW5zdGFuY2VvZiBKaWkuYmFzZS5FdmVudCkpIHtcblx0XHRcdFx0ZXZlbnQgPSBuZXcgSmlpLmJhc2UuRXZlbnQoe1xuXHRcdFx0XHRcdHBhcmFtczogZXZlbnRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudC5zZW5kZXIgPT09IG51bGwpIHtcblx0XHRcdFx0ZXZlbnQuc2VuZGVyID0gdGhpcztcblx0XHRcdH1cblxuXHRcdFx0ZXZlbnQuaGFuZGxlZCA9IGZhbHNlO1xuXHRcdFx0ZXZlbnQubmFtZSA9IG5hbWU7XG5cblx0XHRcdHZhciBpc1N0b3BwZWQgPSBmYWxzZTtcblx0XHRcdEppaS5fLmVhY2godGhpcy5fZXZlbnRzW25hbWVdLCBmdW5jdGlvbihoYW5kbGVyKSB7XG5cdFx0XHRcdGlmIChpc1N0b3BwZWQpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlclsxXTtcblx0XHRcdFx0aGFuZGxlclswXSA9IEppaS5iYXNlLkV2ZW50Lm5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlclswXSk7XG5cdFx0XHRcdGhhbmRsZXJbMF0uY2FsbGJhY2suY2FsbChoYW5kbGVyWzBdLmNvbnRleHQsIGV2ZW50KTtcblxuXHRcdFx0XHQvLyBzdG9wIGZ1cnRoZXIgaGFuZGxpbmcgaWYgdGhlIGV2ZW50IGlzIGhhbmRsZWRcblx0XHRcdFx0aWYgKGV2ZW50LmhhbmRsZWQpIHtcblx0XHRcdFx0XHRpc1N0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHQvLyBpbnZva2UgY2xhc3MtbGV2ZWwgYXR0YWNoZWQgaGFuZGxlcnNcblx0XHRKaWkuYmFzZS5FdmVudC50cmlnZ2VyKHRoaXMsIG5hbWUsIGV2ZW50KTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZWQgYmVoYXZpb3Igb2JqZWN0LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgYmVoYXZpb3IgbmFtZVxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5CZWhhdmlvcn0gdGhlIGJlaGF2aW9yIG9iamVjdCwgb3IgbnVsbCBpZiB0aGUgYmVoYXZpb3IgZG9lcyBub3QgZXhpc3Rcblx0ICovXG5cdGdldEJlaGF2aW9yOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5fYmVoYXZpb3JzICYmIHRoaXMuX2JlaGF2aW9yc1tuYW1lXSA/IHRoaXMuX2JlaGF2aW9yc1tuYW1lXSA6IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIGJlaGF2aW9ycyBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7b2JqZWN0fSBsaXN0IG9mIGJlaGF2aW9ycyBhdHRhY2hlZCB0byB0aGlzIGNvbXBvbmVudFxuXHQgKi9cblx0Z2V0QmVoYXZpb3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblxuXHRcdHJldHVybiB0aGlzLl9iZWhhdmlvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIGEgYmVoYXZpb3IgdG8gdGhpcyBjb21wb25lbnQuXG5cdCAqIFRoaXMgbWV0aG9kIHdpbGwgY3JlYXRlIHRoZSBiZWhhdmlvciBvYmplY3QgYmFzZWQgb24gdGhlIGdpdmVuXG5cdCAqIGNvbmZpZ3VyYXRpb24uIEFmdGVyIHRoYXQsIHRoZSBiZWhhdmlvciBvYmplY3Qgd2lsbCBiZSBhdHRhY2hlZCB0b1xuXHQgKiB0aGlzIGNvbXBvbmVudCBieSBjYWxsaW5nIHRoZSBhdHRhY2ggbWV0aG9kLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYmVoYXZpb3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEppaS5iYXNlLkJlaGF2aW9yW118SmlpLmJhc2UuQmVoYXZpb3J9IGJlaGF2aW9yIHRoZSBiZWhhdmlvciBjb25maWd1cmF0aW9uLiBUaGlzIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcblx0ICpcblx0ICogIC0gYSBbW0ppaS5iYXNlLkJlaGF2aW9yXV0gb2JqZWN0XG5cdCAqICAtIGEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIGJlaGF2aW9yIGNsYXNzXG5cdCAqICAtIGFuIG9iamVjdCBjb25maWd1cmF0aW9uIGFycmF5IHRoYXQgd2lsbCBiZSBwYXNzZWQgdG8gW1tKaWkuY3JlYXRlT2JqZWN0KCldXSB0byBjcmVhdGUgdGhlIGJlaGF2aW9yIG9iamVjdC5cblx0ICpcblx0ICogQHJldHVybiB7SmlpLmJhc2UuQmVoYXZpb3J9IHRoZSBiZWhhdmlvciBvYmplY3Rcblx0ICogQHNlZSBkZXRhY2hCZWhhdmlvcigpXG5cdCAqL1xuXHRhdHRhY2hCZWhhdmlvcjogZnVuY3Rpb24gKG5hbWUsIGJlaGF2aW9yKSB7XG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblxuXHRcdHJldHVybiB0aGlzLl9hdHRhY2hCZWhhdmlvckludGVybmFsKG5hbWUsIGJlaGF2aW9yKTtcblx0fSxcblxuXHQvKipcblx0ICogQXR0YWNoZXMgYSBsaXN0IG9mIGJlaGF2aW9ycyB0byB0aGUgY29tcG9uZW50LlxuXHQgKiBFYWNoIGJlaGF2aW9yIGlzIGluZGV4ZWQgYnkgaXRzIG5hbWUgYW5kIHNob3VsZCBiZSBhIFtbSmlpLmJhc2UuQmVoYXZpb3JdXSBvYmplY3QsXG5cdCAqIGEgc3RyaW5nIHNwZWNpZnlpbmcgdGhlIGJlaGF2aW9yIGNsYXNzLCBvciBhbiBjb25maWd1cmF0aW9uIGFycmF5IGZvciBjcmVhdGluZyB0aGUgYmVoYXZpb3IuXG5cdCAqIEBwYXJhbSB7W119IGJlaGF2aW9ycyBsaXN0IG9mIGJlaGF2aW9ycyB0byBiZSBhdHRhY2hlZCB0byB0aGUgY29tcG9uZW50XG5cdCAqIEBzZWUgYXR0YWNoQmVoYXZpb3IoKVxuXHQgKi9cblx0YXR0YWNoQmVoYXZpb3JzOiBmdW5jdGlvbiAoYmVoYXZpb3JzKSB7XG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblxuXHRcdEppaS5fLmVhY2goYmVoYXZpb3JzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGJlaGF2aW9yLCBuYW1lKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hCZWhhdmlvckludGVybmFsKG5hbWUsIGJlaGF2aW9yKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERldGFjaGVzIGEgYmVoYXZpb3IgZnJvbSB0aGUgY29tcG9uZW50LlxuXHQgKiBUaGUgYmVoYXZpb3IncyBkZXRhY2ggbWV0aG9kIHdpbGwgYmUgaW52b2tlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGJlaGF2aW9yJ3MgbmFtZS5cblx0ICogQHJldHVybiB7SmlpLmJhc2UuQmVoYXZpb3J9IHRoZSBkZXRhY2hlZCBiZWhhdmlvci4gTnVsbCBpZiB0aGUgYmVoYXZpb3IgZG9lcyBub3QgZXhpc3QuXG5cdCAqL1xuXHRkZXRhY2hCZWhhdmlvcjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXHRcdGlmICh0aGlzLl9iZWhhdmlvcnMgJiYgdGhpcy5fYmVoYXZpb3JzW25hbWVdKSB7XG5cdFx0XHR2YXIgYmVoYXZpb3IgPSB0aGlzLl9iZWhhdmlvcnNbbmFtZV07XG5cdFx0XHRkZWxldGUgdGhpcy5fYmVoYXZpb3JzW25hbWVdO1xuXHRcdFx0YmVoYXZpb3IuZGV0YWNoKCk7XG5cblx0XHRcdHJldHVybiBiZWhhdmlvcjtcblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogRGV0YWNoZXMgYWxsIGJlaGF2aW9ycyBmcm9tIHRoZSBjb21wb25lbnQuXG5cdCAqL1xuXHRkZXRhY2hCZWhhdmlvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXG5cdFx0SmlpLl8uZWFjaChKaWkuXy5rZXlzKHRoaXMuX2JlaGF2aW9ycyksIEppaS5fLmJpbmQodGhpcy5kZXRhY2hCZWhhdmlvciwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYWtlcyBzdXJlIHRoYXQgdGhlIGJlaGF2aW9ycyBkZWNsYXJlZCBpbiBbW2JlaGF2aW9ycygpXV0gYXJlIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LlxuXHQgKi9cblx0ZW5zdXJlQmVoYXZpb3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2JlaGF2aW9ycyAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX2JlaGF2aW9ycyA9IFtdO1xuXHRcdEppaS5fLmVhY2godGhpcy5iZWhhdmlvcnMoKSwgSmlpLl8uYmluZChmdW5jdGlvbihiZWhhdmlvciwgbmFtZSkge1xuXHRcdFx0dGhpcy5fYXR0YWNoQmVoYXZpb3JJbnRlcm5hbChuYW1lLCBiZWhhdmlvcik7XG5cdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKi9cblx0cHJveHlCZWhhdmlvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRKaWkuXy5lYWNoKHRoaXMuYmVoYXZpb3JzKCksIEppaS5fLmJpbmQoZnVuY3Rpb24oYmVoYXZpb3IsIG5hbWUpIHtcblx0XHRcdHZhciBjbGFzc05hbWUgPSBKaWkuXy5pc1N0cmluZyhiZWhhdmlvcikgPyBiZWhhdmlvciA6IGJlaGF2aW9yLmNsYXNzTmFtZTtcblx0XHRcdHRoaXMuX3Byb3h5QmVoYXZpb3JJbnRlcm5hbChuYW1lLCBjbGFzc05hbWUpO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogQXR0YWNoZXMgYSBiZWhhdmlvciB0byB0aGlzIGNvbXBvbmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGJlaGF2aW9yLlxuXHQgKiBAcGFyYW0ge3N0cmluZ3xKaWkuYmFzZS5CZWhhdmlvcltdfEppaS5iYXNlLkJlaGF2aW9yfSBiZWhhdmlvciB0aGUgYmVoYXZpb3IgdG8gYmUgYXR0YWNoZWRcblx0ICogQHJldHVybiB7SmlpLmJhc2UuQmVoYXZpb3J9IHRoZSBhdHRhY2hlZCBiZWhhdmlvci5cblx0ICogQHByaXZhdGVcblx0ICovXG5cdF9hdHRhY2hCZWhhdmlvckludGVybmFsOiBmdW5jdGlvbiAobmFtZSwgYmVoYXZpb3IpIHtcblx0XHRpZiAoIShiZWhhdmlvciBpbnN0YW5jZW9mIEppaS5iYXNlLkJlaGF2aW9yKSkge1xuXHRcdFx0YmVoYXZpb3IgPSBKaWkuY3JlYXRlT2JqZWN0KGJlaGF2aW9yKTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fYmVoYXZpb3JzW25hbWVdKSB7XG5cdFx0XHR0aGlzLl9iZWhhdmlvcnNbbmFtZV0uZGV0YWNoKCk7XG5cdFx0fVxuXHRcdGJlaGF2aW9yLmF0dGFjaCh0aGlzKTtcblxuXHRcdHRoaXMuX3Byb3h5QmVoYXZpb3JJbnRlcm5hbChuYW1lLCBiZWhhdmlvci5jbGFzc05hbWUoKSk7XG5cblx0XHR0aGlzLl9iZWhhdmlvcnNbbmFtZV0gPSBiZWhhdmlvcjtcblx0XHRyZXR1cm4gYmVoYXZpb3I7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqL1xuXHRfcHJveHlCZWhhdmlvckludGVybmFsOiBmdW5jdGlvbiAoYmVoYXZpb3JOYW1lLCBjbGFzc05hbWUpIHtcblx0XHR2YXIgYmVoYXZpb3JDbGFzcyA9IEppaS5uYW1lc3BhY2UoY2xhc3NOYW1lKTtcblxuXHRcdHdoaWxlICh0cnVlKSB7XG5cdFx0XHRpZiAoIWJlaGF2aW9yQ2xhc3MgfHwgIWJlaGF2aW9yQ2xhc3MucHJvdG90eXBlIHx8IGNsYXNzTmFtZSA9PT0gJ0ppaS5iYXNlLkJlaGF2aW9yJykge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWhhdmlvckNsYXNzLnByb3RvdHlwZSkge1xuXHRcdFx0XHRpZiAoIWJlaGF2aW9yQ2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTa2lwIGNvbnN0cnVjdG9yIGFuZCBub24tcHVibGljIG1ldGhvZHNcblx0XHRcdFx0aWYgKG5hbWUgPT09ICdjb25zdHJ1Y3RvcicgfHwgbmFtZS5zdWJzdHIoMCwgMSkgPT09ICdfJykge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2tpcCBwcm9wZXJ0aWVzXG5cdFx0XHRcdGlmICghSmlpLl8uaXNGdW5jdGlvbihiZWhhdmlvckNsYXNzLnByb3RvdHlwZVtuYW1lXSkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRoaXNbbmFtZV0gPSB0aGlzLl9nZXRQcm94eUJlaGF2aW9yTWV0aG9kKGJlaGF2aW9yTmFtZSwgbmFtZSk7XG5cdFx0XHR9XG5cblx0XHRcdGNsYXNzTmFtZSA9IGJlaGF2aW9yQ2xhc3MucGFyZW50Q2xhc3NOYW1lKCk7XG5cdFx0XHRiZWhhdmlvckNsYXNzID0gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0UHJveHlCZWhhdmlvck1ldGhvZDogZnVuY3Rpb24oYmVoYXZpb3JOYW1lLCBtZXRob2ROYW1lKSB7XG5cdFx0dmFyIGNvbnRleHQgPSB0aGlzO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0QmVoYXZpb3IoYmVoYXZpb3JOYW1lKVttZXRob2ROYW1lXS5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuXHRcdH07XG5cdH0sXG5cblx0aGFzUHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIGNoZWNrVmFycywgY2hlY2tCZWhhdmlvcnMpIHtcblx0XHRjaGVja1ZhcnMgPSBjaGVja1ZhcnMgIT09IGZhbHNlO1xuXHRcdGNoZWNrQmVoYXZpb3JzID0gY2hlY2tCZWhhdmlvcnMgIT09IGZhbHNlO1xuXG5cdFx0cmV0dXJuIHRoaXMuY2FuR2V0UHJvcGVydHkobmFtZSwgY2hlY2tWYXJzLCBjaGVja0JlaGF2aW9ycykgfHwgdGhpcy5jYW5TZXRQcm9wZXJ0eShuYW1lLCBmYWxzZSwgY2hlY2tCZWhhdmlvcnMpO1xuXHR9LFxuXG5cdC8vIEB0b2RvIG1vdmUgZ2V0LCBzZXQgdG8gT2JqZWN0XG5cdHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gT2JqZWN0IGZvcm1hdCBzdXBwb3J0XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuXHRcdC8vIEdlbmVyYXRlIHNldHRlciBuYW1lXG5cdFx0dmFyIHNldHRlciA9ICdzZXQnICsgSmlpLl9zLmNhcGl0YWxpemUobmFtZSk7XG5cblx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbih0aGlzW3NldHRlcl0pKSB7XG5cdFx0XHR0aGlzW3NldHRlcl0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG5cdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0fSBlbHNlIGlmIChuYW1lLnN1YnN0cigwLCAzKSA9PT0gJ29uICcpIHtcbiAgICAgICAgICAgIHRoaXMub24obmFtZS5zdWJzdHIoMyksIHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKG5hbWUuc3Vic3RyKDAsIDMpID09PSAnYXMgJykge1xuICAgICAgICAgICAgdGhpcy5hdHRhY2hCZWhhdmlvcihuYW1lLnN1YnN0cigzKSwgdmFsdWUgaW5zdGFuY2VvZiBKaWkuYmFzZS5CZWhhdmlvciA/IHZhbHVlIDogSmlpLmNyZWF0ZU9iamVjdCh2YWx1ZSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBAdG9kbyBhcywgc2VlIENvbXBvbmVudCBZaWkyXG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Vbmtub3duUHJvcGVydHlFeGNlcHRpb24oJ1NldHRpbmcgdW5rbm93biBwcm9wZXJ0eTogJyArIHRoaXMuY2xhc3NOYW1lKCkgKyAnLicgKyBuYW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Y2FuU2V0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIGNoZWNrVmFycywgY2hlY2tCZWhhdmlvcnMpIHtcblx0XHRjaGVja1ZhcnMgPSBjaGVja1ZhcnMgIT09IGZhbHNlO1xuXHRcdGNoZWNrQmVoYXZpb3JzID0gY2hlY2tCZWhhdmlvcnMgIT09IGZhbHNlO1xuXG5cdFx0dmFyIHNldHRlciA9ICdzZXQnICsgSmlpLl9zLmNhcGl0YWxpemUobmFtZSk7XG5cdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1tzZXR0ZXJdKSB8fCAoY2hlY2tWYXJzICYmIHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNoZWNrQmVoYXZpb3JzKSB7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0OiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0Ly8gR2VuZXJhdGUgZ2V0dGVyIG5hbWVcblx0XHR2YXIgc2V0dGVyID0gJ2dldCcgKyBKaWkuX3MuY2FwaXRhbGl6ZShuYW1lKTtcblxuXHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKHRoaXNbc2V0dGVyXSkpIHtcblx0XHRcdHJldHVybiB0aGlzW3NldHRlcl0uY2FsbCh0aGlzKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uKCdHZXR0aW5nIHVua25vd24gcHJvcGVydHk6ICcgKyB0aGlzLmNsYXNzTmFtZSgpICsgJy4nICsgbmFtZSk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbkdldFByb3BlcnR5OiBmdW5jdGlvbihuYW1lLCBjaGVja1ZhcnMsIGNoZWNrQmVoYXZpb3JzKSB7XG5cdFx0Y2hlY2tWYXJzID0gY2hlY2tWYXJzICE9PSBmYWxzZTtcblx0XHRjaGVja0JlaGF2aW9ycyA9IGNoZWNrQmVoYXZpb3JzICE9PSBmYWxzZTtcblxuXHRcdHZhciBnZXR0ZXIgPSAnZ2V0JyArIEppaS5fcy5jYXBpdGFsaXplKGtleSk7XG5cdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1tnZXR0ZXJdKSB8fCAoY2hlY2tWYXJzICYmIHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGNoZWNrQmVoYXZpb3JzKSB7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9PYmplY3RcIjoxMzh9XSwxMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0NvbXBvbmVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Db250ZXh0XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5Db250ZXh0JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Db250ZXh0LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuXHQvKipcblx0ICogQ3VzdG9tIGNvbnRleHQgcGFyYW1ldGVycyAobmFtZSA9PiB2YWx1ZSkuXG5cdCAqIEB0eXBlIHtvYmplY3R9XG5cdCAqL1xuXHRwYXJhbXM6IHt9LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7b2JqZWN0fVxuXHQgKi9cblx0X2NvbXBvbmVudHM6IHt9LFxuXG5cdC8qKlxuXHQgKiBDaGVja3Mgd2hldGhlciB0aGUgbmFtZWQgY29tcG9uZW50IGV4aXN0cy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIGNvbXBvbmVudCBJRFxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBuYW1lZCBjb21wb25lbnQgZXhpc3RzLiBCb3RoIGxvYWRlZCBhbmQgdW5sb2FkZWQgY29tcG9uZW50c1xuXHQgKiBhcmUgY29uc2lkZXJlZC5cblx0ICovXG5cdGhhc0NvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9jb21wb25lbnRzLCBpZCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgbmFtZWQgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgY29tcG9uZW50IElEIChjYXNlLXNlbnNpdGl2ZSlcblx0ICogQHJldHVybiB7SmlpLmJhc2UuQ29tcG9uZW50fG51bGx9IHRoZSBjb21wb25lbnQgaW5zdGFuY2UsIG51bGwgaWYgdGhlIGNvbXBvbmVudCBkb2VzIG5vdCBleGlzdC5cblx0ICovXG5cdGdldENvbXBvbmVudDogZnVuY3Rpb24gKGlkKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbXBvbmVudHNbaWRdIHx8IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlZ2lzdGVycyBhIGNvbXBvbmVudCB3aXRoIHRoaXMgbW9kdWxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgY29tcG9uZW50IElEXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29tcG9uZW50fGFycmF5fG51bGx9IGNvbXBvbmVudCB0aGUgY29tcG9uZW50IHRvIGJlIHJlZ2lzdGVyZWQgd2l0aCB0aGUgbW9kdWxlLiBUaGlzIGNhblxuXHQgKiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZ3M6XG5cdCAqXG5cdCAqIC0gYSBbW0ppaS5iYXNlLkNvbXBvbmVudF1dIG9iamVjdFxuXHQgKiAtIGEgY29uZmlndXJhdGlvbiBhcnJheTogd2hlbiBbW2dldENvbXBvbmVudCgpXV0gaXMgY2FsbGVkIGluaXRpYWxseSBmb3IgdGhpcyBjb21wb25lbnQsIHRoZSBhcnJheVxuXHQgKiAgIHdpbGwgYmUgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgY29tcG9uZW50IHZpYSBbW0ppaS5jcmVhdGVPYmplY3QoKV1dLlxuXHQgKiAtIG51bGw6IHRoZSBuYW1lZCBjb21wb25lbnQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIG1vZHVsZVxuXHQgKi9cblx0c2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQsIGNvbXBvbmVudCkge1xuXHRcdGlmIChjb21wb25lbnQgPT09IG51bGwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9jb21wb25lbnRzW2lkXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gQ3JlYXRlIGNvbXBvbmVudCBpbnN0YW5jZVxuXHRcdFx0aWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgSmlpLmJhc2UuQ29tcG9uZW50KSkge1xuXHRcdFx0XHRjb21wb25lbnQgPSBKaWkuY3JlYXRlT2JqZWN0KGNvbXBvbmVudCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBsaW5rc1xuXHRcdFx0dGhpc1tpZF0gPSB0aGlzLl9jb21wb25lbnRzW2lkXSA9IGNvbXBvbmVudDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlZ2lzdGVyZWQgY29tcG9uZW50cy5cblx0ICogQHJldHVybiB7SmlpLmJhc2UuQ29tcG9uZW50W119IHRoZSBjb21wb25lbnRzIChpbmRleGVkIGJ5IHRoZWlyIElEcylcblx0ICovXG5cdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29tcG9uZW50cztcblx0fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgc2V0IG9mIGNvbXBvbmVudHMgaW4gdGhpcyBtb2R1bGUuXG5cdCAqXG5cdCAqIEVhY2ggY29tcG9uZW50IHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYSBuYW1lLXZhbHVlIHBhaXIsIHdoZXJlXG5cdCAqIG5hbWUgcmVmZXJzIHRvIHRoZSBJRCBvZiB0aGUgY29tcG9uZW50IGFuZCB2YWx1ZSB0aGUgY29tcG9uZW50IG9yIGEgY29uZmlndXJhdGlvblxuXHQgKiBhcnJheSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50LiBJbiB0aGUgbGF0dGVyIGNhc2UsIFtbSmlpLmNyZWF0ZU9iamVjdCgpXV1cblx0ICogd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgY29tcG9uZW50LlxuXHQgKlxuXHQgKiBJZiBhIG5ldyBjb21wb25lbnQgaGFzIHRoZSBzYW1lIElEIGFzIGFuIGV4aXN0aW5nIG9uZSwgdGhlIGV4aXN0aW5nIG9uZSB3aWxsIGJlIG92ZXJ3cml0dGVuIHNpbGVudGx5LlxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgZm9yIHNldHRpbmcgdHdvIGNvbXBvbmVudHM6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiB7XG4gICAgICogICAgIGRiOiB7XG4gICAgICogICAgICAgICBjbGFzczogJ0ppaS5kYi5Db25uZWN0aW9uJyxcbiAgICAgKiAgICAgICAgIGRzbjogJ3NxbGl0ZTpwYXRoL3RvL2ZpbGUuZGInXG4gICAgICogICAgIH0sXG4gICAgICogICAgIGNhY2hlOiB7XG4gICAgICogICAgICAgICBjbGFzczogJ0ppaS5jYWNoaW5nLkRiQ2FjaGUnLFxuICAgICAqICAgICAgICAgZGI6ICdkYidcbiAgICAgKiAgICAgfVxuICAgICAqIH1cblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7YXJyYXl9IGNvbXBvbmVudHMgY29tcG9uZW50cyAoaWQgPT4gY29tcG9uZW50IGNvbmZpZ3VyYXRpb24gb3IgaW5zdGFuY2UpXG5cdCAqL1xuXHRzZXRDb21wb25lbnRzOiBmdW5jdGlvbiAoY29tcG9uZW50cykge1xuXHRcdEppaS5fLmVhY2goY29tcG9uZW50cywgSmlpLl8uYmluZChmdW5jdGlvbiAoY29tcG9uZW50LCBpZCkge1xuXHRcdFx0Ly8gRXh0ZW5kIGRlZmF1bHQgY2xhc3MgbmFtZVxuXHRcdFx0aWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgSmlpLmJhc2UuQ29tcG9uZW50KSAmJiB0aGlzLl9jb21wb25lbnRzW2lkXSAmJiAhY29tcG9uZW50LmNsYXNzTmFtZSkge1xuXHRcdFx0XHRjb21wb25lbnQuY2xhc3NOYW1lID0gdGhpcy5fY29tcG9uZW50c1tpZF0uY2xhc3NOYW1lO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLnNldENvbXBvbmVudChpZCwgY29tcG9uZW50KTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIExvYWRzIGNvbXBvbmVudHMgdGhhdCBhcmUgZGVjbGFyZWQgaW4gW1twcmVsb2FkXV0uXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb259IGlmIGEgY29tcG9uZW50IG9yIG1vZHVsZSB0byBiZSBwcmVsb2FkZWQgaXMgdW5rbm93blxuXHQgKi9cblx0cHJlbG9hZENvbXBvbmVudHM6IGZ1bmN0aW9uICgpIHtcblx0XHRKaWkuXy5lYWNoKHRoaXMucHJlbG9hZCwgSmlpLl8uYmluZChmdW5jdGlvbiAoaWQpIHtcblx0XHRcdGlmICh0aGlzLmhhc0NvbXBvbmVudChpZCkpIHtcblx0XHRcdFx0dGhpcy5nZXRDb21wb25lbnQoaWQpO1xuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmhhc01vZHVsZShpZCkpIHtcblx0XHRcdFx0dGhpcy5nZXRNb2R1bGUoaWQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oXCJVbmtub3duIGNvbXBvbmVudCBvciBtb2R1bGU6IFwiICsgaWQpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0NvbXBvbmVudFwiOjEzMX1dLDEzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL09iamVjdCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Db250cm9sbGVyXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5Db250cm9sbGVyJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Db250cm9sbGVyLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuICAgIF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5iYXNlLkNvbnRyb2xsZXIgKi97XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Nb2R1bGUjYmVmb3JlQWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLmJhc2UuQWN0aW9uRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9CRUZPUkVfQUNUSU9OOiAnYmVmb3JlQWN0aW9uJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLk1vZHVsZSNhZnRlckFjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLkFjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQUZURVJfQUNUSU9OOiAnYWZ0ZXJBY3Rpb24nXG5cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfSBUaGUgSUQgb2YgdGhpcyBjb250cm9sbGVyLlxuXHQgKi9cblx0aWQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtKaWkuYmFzZS5Nb2R1bGV9IFRoZSBtb2R1bGUgdGhhdCB0aGlzIGNvbnRyb2xsZXIgYmVsb25ncyB0by5cblx0ICovXG5cdG1vZHVsZTogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ30gVGhlIElEIG9mIHRoZSBhY3Rpb24gdGhhdCBpcyB1c2VkIHdoZW4gdGhlIGFjdGlvbiBJRCBpcyBub3Qgc3BlY2lmaWVkXG5cdCAqIGluIHRoZSByZXF1ZXN0LiBEZWZhdWx0cyB0byAnaW5kZXgnLlxuXHQgKi9cblx0ZGVmYXVsdEFjdGlvbjogJ2luZGV4JyxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ3xib29sZWFufSB0aGUgbmFtZSBvZiB0aGUgbGF5b3V0IHRvIGJlIGFwcGxpZWQgdG8gdGhpcyBjb250cm9sbGVyJ3Mgdmlld3MuXG5cdCAqIFRoaXMgcHJvcGVydHkgbWFpbmx5IGFmZmVjdHMgdGhlIGJlaGF2aW9yIG9mIFtbcmVuZGVyKCldXS5cblx0ICogRGVmYXVsdHMgdG8gbnVsbCwgbWVhbmluZyB0aGUgYWN0dWFsIGxheW91dCB2YWx1ZSBzaG91bGQgaW5oZXJpdCB0aGF0IGZyb20gW1ttb2R1bGVdXSdzIGxheW91dCB2YWx1ZS5cblx0ICogSWYgZmFsc2UsIG5vIGxheW91dCB3aWxsIGJlIGFwcGxpZWQuXG5cdCAqL1xuXHRsYXlvdXQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIFRoZSB2aWV3IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlbmRlciB2aWV3cyBvciB2aWV3IGZpbGVzLlxuXHQgKiBAdHlwZSB7SmlpLnZpZXcuVmlld31cblx0ICovXG5cdF92aWV3OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoaWQsIG1vZHVsZU9iamVjdCwgY29uZmlnKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMubW9kdWxlID0gbW9kdWxlT2JqZWN0O1xuXHRcdHRoaXMuX19zdXBlcihjb25maWcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBleHRlcm5hbCBhY3Rpb25zIGZvciB0aGUgY29udHJvbGxlci5cblx0ICogVGhpcyBtZXRob2QgaXMgbWVhbnQgdG8gYmUgb3ZlcndyaXR0ZW4gdG8gZGVjbGFyZSBleHRlcm5hbCBhY3Rpb25zIGZvciB0aGUgY29udHJvbGxlci5cblx0ICogSXQgc2hvdWxkIHJldHVybiBhbiBhcnJheSwgd2l0aCBhcnJheSBrZXlzIGJlaW5nIGFjdGlvbiBJRHMsIGFuZCBhcnJheSB2YWx1ZXMgdGhlIGNvcnJlc3BvbmRpbmdcblx0ICogYWN0aW9uIGNsYXNzIG5hbWVzIG9yIGFjdGlvbiBjb25maWd1cmF0aW9uIGFycmF5cy4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqIH5+flxuXHQgKiByZXR1cm4ge1xuICAgICAqICAgICAnYWN0aW9uMSc6ICdhcHAuY29tcG9uZW50cy5BY3Rpb24xJyxcbiAgICAgKiAgICAgJ2FjdGlvbjInOiB7XG4gICAgICogICAgICAgICAnY2xhc3NOYW1lJzogJ2FwcC5jb21wb25lbnRzLkFjdGlvbjInLFxuICAgICAqICAgICAgICAgJ3Byb3BlcnR5MSc6ICd2YWx1ZTEnLFxuICAgICAqICAgICAgICAgJ3Byb3BlcnR5Mic6ICd2YWx1ZTInXG4gICAgICogICAgIH1cbiAgICAgKiB9O1xuXHQgKiB+fn5cblx0ICpcblx0ICogW1tKaWkuY3JlYXRlT2JqZWN0KCldXSB3aWxsIGJlIHVzZWQgbGF0ZXIgdG8gY3JlYXRlIHRoZSByZXF1ZXN0ZWQgYWN0aW9uXG5cdCAqIHVzaW5nIHRoZSBjb25maWd1cmF0aW9uIHByb3ZpZGVkIGhlcmUuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuXHRhY3Rpb25zOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSdW5zIGEgcmVxdWVzdCBzcGVjaWZpZWQgaW4gdGVybXMgb2YgYSByb3V0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlIHRoZSByb3V0ZSB0byBiZSBoYW5kbGVkLCBlLmcuLCAndmlldycsICdjb21tZW50L3ZpZXcnLCAnYWRtaW4vY29tbWVudC92aWV3Jy5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRydW46IGZ1bmN0aW9uIChyb3V0ZSwgY29udGV4dCkge1xuXHRcdHZhciBzbGFzaEluZGV4ID0gcm91dGUuaW5kZXhPZignLycpO1xuXHRcdGlmIChzbGFzaEluZGV4ID09PSAtMSkge1xuXHRcdFx0cmV0dXJuIHRoaXMucnVuQWN0aW9uKHJvdXRlLCBjb250ZXh0KTtcblx0XHR9IGVsc2UgaWYgKHNsYXNoSW5kZXggPiAwKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5tb2R1bGUucnVuQWN0aW9uKHJvdXRlLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHRyb3V0ZSA9IEppaS5fcy5sdHJpbShyb3V0ZSwgJy8nKTtcblx0XHRyZXR1cm4gSmlpLmFwcC5ydW5BY3Rpb24ocm91dGUsIGNvbnRleHQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSdW5zIGFuIGFjdGlvbiB3aXRoaW4gdGhpcyBjb250cm9sbGVyIHdpdGggdGhlIHNwZWNpZmllZCBhY3Rpb24gSUQgYW5kIHBhcmFtZXRlcnMuXG5cdCAqIElmIHRoZSBhY3Rpb24gSUQgaXMgZW1wdHksIHRoZSBtZXRob2Qgd2lsbCB1c2UgW1tkZWZhdWx0QWN0aW9uXV0uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqIEByZXR1cm4ge1Byb21pc2V9IFRoZSByZXN1bHQgb2YgdGhlIGFjdGlvbi5cblx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFJvdXRlRXhjZXB0aW9ufSBpZiB0aGUgcmVxdWVzdGVkIGFjdGlvbiBJRCBjYW5ub3QgYmUgcmVzb2x2ZWQgaW50byBhbiBhY3Rpb24gc3VjY2Vzc2Z1bGx5LlxuXHQgKi9cblx0cnVuQWN0aW9uOiBmdW5jdGlvbiAoaWQsIGNvbnRleHQpIHtcblx0XHR2YXIgYWN0aW9uID0gdGhpcy5jcmVhdGVBY3Rpb24oaWQpO1xuXHRcdGlmIChhY3Rpb24gPT09IG51bGwpIHtcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUm91dGVFeGNlcHRpb24oSmlpLnQoJ2ppaScsICdVbmFibGUgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdDogJyArIHRoaXMuZ2V0VW5pcXVlSWQoKSArICcvJyArIGlkKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFByb21pc2UuYWxsKFtcblx0XHRcdFx0dGhpcy5tb2R1bGUuYmVmb3JlQWN0aW9uKGFjdGlvbiwgY29udGV4dCksXG5cdFx0XHRcdHRoaXMuYmVmb3JlQWN0aW9uKGFjdGlvbiwgY29udGV4dClcblx0XHRcdF0pLnRoZW4oZnVuY3Rpb24gKHJlc3VsdHMpIHtcblx0XHRcdFx0aWYgKHJlc3VsdHMuaW5kZXhPZihmYWxzZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG5cdFx0XHRcdH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uLnJ1bldpdGhQYXJhbXMoY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfSkudGhlbihmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghSmlpLl8uaXNVbmRlZmluZWQoZGF0YSkgJiYgY29udGV4dC5yZXNwb25zZSBpbnN0YW5jZW9mIEppaS5iYXNlLlJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubW9kdWxlLmFmdGVyQWN0aW9uKGFjdGlvbiwgY29udGV4dCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFmdGVyQWN0aW9uKGFjdGlvbiwgY29udGV4dClcbiAgICAgICAgICAgICAgICAgICAgXSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnJlc3BvbnNlIGluc3RhbmNlb2YgSmlpLmJhc2UuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKS5jYXRjaChKaWkuY2F0Y2hIYW5kbGVyKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhY3Rpb24gYmFzZWQgb24gdGhlIGdpdmVuIGFjdGlvbiBJRC5cblx0ICogVGhlIG1ldGhvZCBmaXJzdCBjaGVja3MgaWYgdGhlIGFjdGlvbiBJRCBoYXMgYmVlbiBkZWNsYXJlZCBpbiBbW2FjdGlvbnMoKV1dLiBJZiBzbyxcblx0ICogaXQgd2lsbCB1c2UgdGhlIGNvbmZpZ3VyYXRpb24gZGVjbGFyZWQgdGhlcmUgdG8gY3JlYXRlIHRoZSBhY3Rpb24gb2JqZWN0LlxuXHQgKiBJZiBub3QsIGl0IHdpbGwgbG9vayBmb3IgYSBjb250cm9sbGVyIG1ldGhvZCB3aG9zZSBuYW1lIGlzIGluIHRoZSBmb3JtYXQgb2YgYGFjdGlvblh5emBcblx0ICogd2hlcmUgYFh5emAgc3RhbmRzIGZvciB0aGUgYWN0aW9uIElELiBJZiBmb3VuZCwgYW4gW1tJbmxpbmVBY3Rpb25dXSByZXByZXNlbnRpbmcgdGhhdFxuXHQgKiBtZXRob2Qgd2lsbCBiZSBjcmVhdGVkIGFuZCByZXR1cm5lZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIHRoZSBhY3Rpb24gSUQuXG5cdCAqIEByZXR1cm4ge0ppaS5iYXNlLkFjdGlvbn0gdGhlIG5ld2x5IGNyZWF0ZWQgYWN0aW9uIGluc3RhbmNlLiBOdWxsIGlmIHRoZSBJRCBkb2Vzbid0IHJlc29sdmUgaW50byBhbnkgYWN0aW9uLlxuXHQgKi9cblx0Y3JlYXRlQWN0aW9uOiBmdW5jdGlvbiAoaWQpIHtcblx0XHRpZiAoaWQgPT09ICcnKSB7XG5cdFx0XHRpZCA9IHRoaXMuZGVmYXVsdEFjdGlvbjtcblx0XHR9XG5cblx0XHR2YXIgYWN0aW9uTWFwID0gdGhpcy5hY3Rpb25zKCk7XG5cdFx0aWYgKEppaS5fLmhhcyhhY3Rpb25NYXAsIGlkKSkge1xuXHRcdFx0cmV0dXJuIEppaS5jcmVhdGVPYmplY3QoYWN0aW9uTWFwW2lkXSwgaWQsIHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAoL15bYS16MC05XFxcXC1fXSskLy50ZXN0KGlkKSkge1xuXHRcdFx0dmFyIG1ldGhvZCA9ICdhY3Rpb24nICsgKCctJyArIGlkKS5yZXBsYWNlKC8tKFthLXpdKS9nLCBmdW5jdGlvbihtLCB2KSB7IHJldHVybiB2LnRvVXBwZXJDYXNlKCk7IH0pXG5cblx0XHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSkpIHtcblx0XHRcdFx0cmV0dXJuIG5ldyBKaWkucmVxdWVzdC5JbmxpbmVBY3Rpb24oaWQsIHRoaXMsIG1ldGhvZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aGFzQWN0aW9uOiBmdW5jdGlvbihpZCkge1xuXHRcdGlmIChpZCA9PT0gJycpIHtcblx0XHRcdGlkID0gdGhpcy5kZWZhdWx0QWN0aW9uO1xuXHRcdH1cblxuXHRcdHZhciBhY3Rpb25NYXAgPSB0aGlzLmFjdGlvbnMoKTtcblx0XHRpZiAoSmlpLl8uaGFzKGFjdGlvbk1hcCwgaWQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKC9eW2EtejAtOVxcXFwtX10rJC8udGVzdChpZCkpIHtcblx0XHRcdHZhciBtZXRob2QgPSBpZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlkLnNsaWNlKDEpO1xuXHRcdFx0bWV0aG9kID0gJ2FjdGlvbicgKyBtZXRob2QucmVwbGFjZSgnLScsICcgJyk7XG5cblx0XHRcdHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKHRoaXNbbWV0aG9kXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHN0cmluZyB0aGUgY29udHJvbGxlciBJRCB0aGF0IGlzIHByZWZpeGVkIHdpdGggdGhlIG1vZHVsZSBJRCAoaWYgYW55KS5cblx0ICovXG5cdGdldFVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMubW9kdWxlIGluc3RhbmNlb2YgSmlpLmJhc2UuQXBwbGljYXRpb24gPyB0aGlzLmlkIDogdGhpcy5tb2R1bGUuZ2V0VW5pcXVlSWQoKSArICcvJyArIHRoaXMuaWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgcmlnaHQgYmVmb3JlIGFuIGFjdGlvbiBpcyB0byBiZSBleGVjdXRlZCAoYWZ0ZXIgYWxsIHBvc3NpYmxlIGZpbHRlcnMpLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGlvbn0gYWN0aW9uXG4gICAgICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdGJlZm9yZUFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfQUNUSU9OLCBuZXcgSmlpLmJhc2UuQWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH0pKTtcblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHJpZ2h0IGFmdGVyIGFuIGFjdGlvbiBpcyBleGVjdXRlZC5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5BY3Rpb259IGFjdGlvblxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHQgKi9cblx0YWZ0ZXJBY3Rpb246IGZ1bmN0aW9uIChhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQUZURVJfQUNUSU9OLCBuZXcgSmlpLmJhc2UuQWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0XG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGEgdmlldyBhbmQgYXBwbGllcyBsYXlvdXQgaWYgYXZhaWxhYmxlLlxuXHQgKlxuXHQgKiBUaGUgdmlldyB0byBiZSByZW5kZXJlZCBjYW4gYmUgc3BlY2lmaWVkIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1hdHM6XG5cdCAqXG5cdCAqIC0gcGF0aCBhbGlhcyAoZS5nLiBcIkBhcHAvdmlld3Mvc2l0ZS9pbmRleFwiKTtcblx0ICogLSBhYnNvbHV0ZSBwYXRoIHdpdGhpbiBhcHBsaWNhdGlvbiAoZS5nLiBcIi8vc2l0ZS9pbmRleFwiKTogdGhlIHZpZXcgbmFtZSBzdGFydHMgd2l0aCBkb3VibGUgc2xhc2hlcy5cblx0ICogICBUaGUgYWN0dWFsIHZpZXcgZmlsZSB3aWxsIGJlIGxvb2tlZCBmb3IgdW5kZXIgdGhlIFtbQXBwbGljYXRpb246OnZpZXdQYXRofHZpZXcgcGF0aF1dIG9mIHRoZSBhcHBsaWNhdGlvbi5cblx0ICogLSBhYnNvbHV0ZSBwYXRoIHdpdGhpbiBtb2R1bGUgKGUuZy4gXCIvc2l0ZS9pbmRleFwiKTogdGhlIHZpZXcgbmFtZSBzdGFydHMgd2l0aCBhIHNpbmdsZSBzbGFzaC5cblx0ICogICBUaGUgYWN0dWFsIHZpZXcgZmlsZSB3aWxsIGJlIGxvb2tlZCBmb3IgdW5kZXIgdGhlIFtbTW9kdWxlOjp2aWV3UGF0aHx2aWV3IHBhdGhdXSBvZiBbW21vZHVsZV1dLlxuXHQgKiAtIHJlbGF0aXZlIHBhdGggKGUuZy4gXCJpbmRleFwiKTogdGhlIGFjdHVhbCB2aWV3IGZpbGUgd2lsbCBiZSBsb29rZWQgZm9yIHVuZGVyIFtbdmlld1BhdGhdXS5cblx0ICpcblx0ICogVG8gZGV0ZXJtaW5lIHdoaWNoIGxheW91dCBzaG91bGQgYmUgYXBwbGllZCwgdGhlIGZvbGxvd2luZyB0d28gc3RlcHMgYXJlIGNvbmR1Y3RlZDpcblx0ICpcblx0ICogMS4gSW4gdGhlIGZpcnN0IHN0ZXAsIGl0IGRldGVybWluZXMgdGhlIGxheW91dCBuYW1lIGFuZCB0aGUgY29udGV4dCBtb2R1bGU6XG5cdCAqXG5cdCAqIC0gSWYgW1tsYXlvdXRdXSBpcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcsIHVzZSBpdCBhcyB0aGUgbGF5b3V0IG5hbWUgYW5kIFtbbW9kdWxlXV0gYXMgdGhlIGNvbnRleHQgbW9kdWxlO1xuXHQgKiAtIElmIFtbbGF5b3V0XV0gaXMgbnVsbCwgc2VhcmNoIHRocm91Z2ggYWxsIGFuY2VzdG9yIG1vZHVsZXMgb2YgdGhpcyBjb250cm9sbGVyIGFuZCBmaW5kIHRoZSBmaXJzdFxuXHQgKiAgIG1vZHVsZSB3aG9zZSBbW01vZHVsZTo6bGF5b3V0fGxheW91dF1dIGlzIG5vdCBudWxsLiBUaGUgbGF5b3V0IGFuZCB0aGUgY29ycmVzcG9uZGluZyBtb2R1bGVcblx0ICogICBhcmUgdXNlZCBhcyB0aGUgbGF5b3V0IG5hbWUgYW5kIHRoZSBjb250ZXh0IG1vZHVsZSwgcmVzcGVjdGl2ZWx5LiBJZiBzdWNoIGEgbW9kdWxlIGlzIG5vdCBmb3VuZFxuXHQgKiAgIG9yIHRoZSBjb3JyZXNwb25kaW5nIGxheW91dCBpcyBub3QgYSBzdHJpbmcsIGl0IHdpbGwgcmV0dXJuIGZhbHNlLCBtZWFuaW5nIG5vIGFwcGxpY2FibGUgbGF5b3V0LlxuXHQgKlxuXHQgKiAyLiBJbiB0aGUgc2Vjb25kIHN0ZXAsIGl0IGRldGVybWluZXMgdGhlIGFjdHVhbCBsYXlvdXQgZmlsZSBhY2NvcmRpbmcgdG8gdGhlIHByZXZpb3VzbHkgZm91bmQgbGF5b3V0IG5hbWVcblx0ICogICAgYW5kIGNvbnRleHQgbW9kdWxlLiBUaGUgbGF5b3V0IG5hbWUgY2FuIGJlOlxuXHQgKlxuXHQgKiAtIGEgcGF0aCBhbGlhcyAoZS5nLiBcIkBhcHAvdmlld3MvbGF5b3V0cy9tYWluXCIpO1xuXHQgKiAtIGFuIGFic29sdXRlIHBhdGggKGUuZy4gXCIvbWFpblwiKTogdGhlIGxheW91dCBuYW1lIHN0YXJ0cyB3aXRoIGEgc2xhc2guIFRoZSBhY3R1YWwgbGF5b3V0IGZpbGUgd2lsbCBiZVxuXHQgKiAgIGxvb2tlZCBmb3IgdW5kZXIgdGhlIFtbQXBwbGljYXRpb246OmxheW91dFBhdGh8bGF5b3V0IHBhdGhdXSBvZiB0aGUgYXBwbGljYXRpb247XG5cdCAqIC0gYSByZWxhdGl2ZSBwYXRoIChlLmcuIFwibWFpblwiKTogdGhlIGFjdHVhbCBsYXlvdXQgbGF5b3V0IGZpbGUgd2lsbCBiZSBsb29rZWQgZm9yIHVuZGVyIHRoZVxuXHQgKiAgIFtbTW9kdWxlOjpsYXlvdXRQYXRofGxheW91dCBwYXRoXV0gb2YgdGhlIGNvbnRleHQgbW9kdWxlLlxuXHQgKlxuXHQgKiBJZiB0aGUgbGF5b3V0IG5hbWUgZG9lcyBub3QgY29udGFpbiBhIGZpbGUgZXh0ZW5zaW9uLCBpdCB3aWxsIHVzZSB0aGUgZGVmYXVsdCBvbmUgYC5waHBgLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmlldyAgIHRoZSB2aWV3IG5hbWUuIFBsZWFzZSByZWZlciB0byBbW2ZpbmRWaWV3RmlsZSgpXV0gb24gaG93IHRvIHNwZWNpZnkgYSB2aWV3IG5hbWUuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSB0aGUgcGFyYW1ldGVycyAobmFtZS12YWx1ZSBwYWlycykgdGhhdCBzaG91bGQgYmUgbWFkZSBhdmFpbGFibGUgaW4gdGhlIHZpZXcuXG5cdCAqIFRoZXNlIHBhcmFtZXRlcnMgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGluIHRoZSBsYXlvdXQuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlbmRlcmluZyByZXN1bHQuXG5cdCAqL1xuXHRyZW5kZXI6IGZ1bmN0aW9uICh2aWV3LCBwYXJhbXMpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHR2YXIgb3V0cHV0ID0gdGhpcy5nZXRWaWV3KCkucmVuZGVyKHZpZXcsIHBhcmFtcywgdGhpcyk7XG5cdFx0aWYgKHRoaXMuZ2V0VmlldygpIGluc3RhbmNlb2YgSmlpLnZpZXcuV2ViVmlldykge1xuXHRcdFx0dmFyIGxheW91dEZpbGUgPSB0aGlzLl9maW5kTGF5b3V0RmlsZSh0aGlzLmdldFZpZXcoKSk7XG5cdFx0XHRpZiAobGF5b3V0RmlsZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0cGFyYW1zLmNvbnRlbnQgPSBvdXRwdXQ7XG5cdFx0XHRcdHJldHVybiB0aGlzLmdldFZpZXcoKS5yZW5kZXJMYXlvdXQobGF5b3V0RmlsZSwge2NvbnRlbnQ6IG91dHB1dH0sIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgYSB2aWV3LlxuXHQgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gW1tyZW5kZXIoKV1dIGluIHRoYXQgaXQgZG9lcyBub3QgYXBwbHkgYW55IGxheW91dC5cblx0ICogQHBhcmFtICB7c3RyaW5nfSB2aWV3ICAgdGhlIHZpZXcgbmFtZS4gUGxlYXNlIHJlZmVyIHRvIFtbcmVuZGVyKCldXSBvbiBob3cgdG8gc3BlY2lmeSBhIHZpZXcgbmFtZS5cblx0ICogQHBhcmFtICB7b2JqZWN0fSBbcGFyYW1zXSB0aGUgcGFyYW1ldGVycyAobmFtZS12YWx1ZSBwYWlycykgdGhhdCBzaG91bGQgYmUgbWFkZSBhdmFpbGFibGUgaW4gdGhlIHZpZXcuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJlbmRlcmluZyByZXN1bHQuXG5cdCAqL1xuXHRyZW5kZXJQYXJ0aWFsOiBmdW5jdGlvbiAodmlldywgcGFyYW1zKSB7XG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmlldygpLnJlbmRlcih2aWV3LCBwYXJhbXMsIHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZW5kZXJzIGEgdmlldyBmaWxlLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IGZpbGUgICB0aGUgdmlldyBmaWxlIHRvIGJlIHJlbmRlcmVkLiBUaGlzIGNhbiBiZSBlaXRoZXIgYSBmaWxlIHBhdGggb3IgYSBwYXRoIGFsaWFzLlxuXHQgKiBAcGFyYW0gIHtvYmplY3R9IFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIChuYW1lLXZhbHVlIHBhaXJzKSB0aGF0IHNob3VsZCBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgdmlldy5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVuZGVyaW5nIHJlc3VsdC5cblx0ICovXG5cdHJlbmRlckZpbGU6IGZ1bmN0aW9uIChmaWxlLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRWaWV3KCkucmVuZGVyRmlsZShmaWxlLCBwYXJhbXMsIHRoaXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSB2aWV3IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlbmRlciB2aWV3cyBvciB2aWV3IGZpbGVzLlxuXHQgKiBUaGUgW1tyZW5kZXIoKV1dLCBbW3JlbmRlclBhcnRpYWwoKV1dIGFuZCBbW3JlbmRlckZpbGUoKV1dIG1ldGhvZHMgd2lsbCB1c2Vcblx0ICogdGhpcyB2aWV3IG9iamVjdCB0byBpbXBsZW1lbnQgdGhlIGFjdHVhbCB2aWV3IHJlbmRlcmluZy5cblx0ICogSWYgbm90IHNldCwgaXQgd2lsbCBkZWZhdWx0IHRvIHRoZSBcInZpZXdcIiBhcHBsaWNhdGlvbiBjb21wb25lbnQuXG5cdCAqIEByZXR1cm4ge0ppaS52aWV3LlZpZXd9IHRoZSB2aWV3IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlbmRlciB2aWV3cyBvciB2aWV3IGZpbGVzLlxuXHQgKi9cblx0Z2V0VmlldzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl92aWV3ID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl92aWV3ID0gSmlpLmFwcC52aWV3O1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSB2aWV3IG9iamVjdCB0byBiZSB1c2VkIGJ5IHRoaXMgY29udHJvbGxlci5cblx0ICogQHBhcmFtIHtKaWkudmlldy5WaWV3fSB2aWV3IHRoZSB2aWV3IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlbmRlciB2aWV3cyBvciB2aWV3IGZpbGVzLlxuXHQgKi9cblx0c2V0VmlldzogZnVuY3Rpb24gKHZpZXcpIHtcblx0XHR0aGlzLl92aWV3ID0gdmlldztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdmlldyBmaWxlcyBmb3IgdGhpcyBjb250cm9sbGVyLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRoZSBkaXJlY3RvcnkgbmFtZWQgYXMgY29udHJvbGxlciBbW2lkXV0gdW5kZXIgdGhlIFtbbW9kdWxlXV0nc1xuXHQgKiBbW3ZpZXdQYXRoXV0gZGlyZWN0b3J5LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB0aGUgdmlldyBmaWxlcyBmb3IgdGhpcyBjb250cm9sbGVyLlxuXHQgKi9cblx0Z2V0Vmlld1BhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5tb2R1bGUuZ2V0Vmlld1BhdGgoKSArICcvJyArIHRoaXMuaWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSB2aWV3IGZpbGUgYmFzZWQgb24gdGhlIGdpdmVuIHZpZXcgbmFtZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZpZXcgdGhlIHZpZXcgbmFtZSBvciB0aGUgcGF0aCBhbGlhcyBvZiB0aGUgdmlldyBmaWxlLiBQbGVhc2UgcmVmZXIgdG8gW1tyZW5kZXIoKV1dXG5cdCAqIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSB2aWV3IGZpbGUgcGF0aC4gTm90ZSB0aGF0IHRoZSBmaWxlIG1heSBub3QgZXhpc3QuXG5cdCAqL1xuXHRmaW5kVmlld0ZpbGU6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Vmlld1BhdGgoKSArICcvJyArIHZpZXc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEZpbmRzIHRoZSBhcHBsaWNhYmxlIGxheW91dCBmaWxlLlxuXHQgKiBAcGFyYW0ge0ppaS52aWV3LlZpZXd9IHZpZXcgdGhlIHZpZXcgb2JqZWN0IHRvIHJlbmRlciB0aGUgbGF5b3V0IGZpbGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ3xib29sZWFufSB0aGUgbGF5b3V0IGZpbGUgcGF0aCwgb3IgZmFsc2UgaWYgbGF5b3V0IGlzIG5vdCBuZWVkZWQuXG5cdCAqIFBsZWFzZSByZWZlciB0byBbW3JlbmRlcigpXV0gb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdCAqL1xuXHRfZmluZExheW91dEZpbGU6IGZ1bmN0aW9uICh2aWV3KSB7XG5cdFx0dmFyIG1vZHVsZSA9IHRoaXMubW9kdWxlO1xuXHRcdHZhciBsYXlvdXQgPSBudWxsO1xuXG5cdFx0aWYgKEppaS5fLmlzU3RyaW5nKHRoaXMubGF5b3V0KSkge1xuXHRcdFx0bGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG5cdFx0fSBlbHNlIGlmICh0aGlzLmxheW91dCA9PT0gbnVsbCkge1xuXHRcdFx0d2hpbGUgKG1vZHVsZSAhPT0gbnVsbCAmJiBtb2R1bGUubGF5b3V0ID09PSBudWxsKSB7XG5cdFx0XHRcdG1vZHVsZSA9IG1vZHVsZS5tb2R1bGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobW9kdWxlICE9PSBudWxsICYmIEppaS5fLmlzU3RyaW5nKG1vZHVsZS5sYXlvdXQpKSB7XG5cdFx0XHRcdGxheW91dCA9IG1vZHVsZS5sYXlvdXQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFsYXlvdXQpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHR2YXIgZmlsZSA9IG51bGw7XG5cdFx0aWYgKGxheW91dC5pbmRleE9mKCdAJykgPT09IDApIHtcblx0XHRcdGZpbGUgPSBKaWkuZ2V0QWxpYXMobGF5b3V0KTtcblx0XHR9IGVsc2UgaWYgKGxheW91dC5pbmRleE9mKCcvJykgPT09IDApIHtcblx0XHRcdGZpbGUgPSBKaWkuYXBwLmdldExheW91dFBhdGgoKSArICcvJyArIGxheW91dC5zdWJzdHIoMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZpbGUgPSBtb2R1bGUuZ2V0TGF5b3V0UGF0aCgpICsgJy8nICsgbGF5b3V0O1xuXHRcdH1cblxuXHRcdHZhciBleHQgPSBKaWkuaGVscGVycy5GaWxlLmdldEZpbGVFeHRlbnNpb24oZmlsZSk7XG5cdFx0aWYgKGV4dCAhPT0gJycpIHtcblx0XHRcdHJldHVybiBmaWxlO1xuXHRcdH1cblxuXHRcdHZhciBwYXRoID0gZmlsZSArICcuJyArIHZpZXcuZGVmYXVsdEV4dGVuc2lvbjtcblx0XHRpZiAodmlldy5kZWZhdWx0RXh0ZW5zaW9uICE9PSAnZWpzJyAmJiBleHQgPT09ICcnKSB7XG5cdFx0XHRwYXRoID0gZmlsZSArICcuZWpzJztcblx0XHR9XG5cblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG59KTtcblxuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vT2JqZWN0XCI6MTM4fV0sMTM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9PYmplY3QnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkV2ZW50JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5FdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0LyoqXG5cdCAqIEB2YXIge3N0cmluZ30gdGhlIGV2ZW50IG5hbWUuIFRoaXMgcHJvcGVydHkgaXMgc2V0IGJ5IFtbSmlpLmJhc2UuQ29tcG9uZW50LnRyaWdnZXIoKV1dIGFuZCBbW3RyaWdnZXIoKV1dLlxuXHQgKiBFdmVudCBoYW5kbGVycyBtYXkgdXNlIHRoaXMgcHJvcGVydHkgdG8gY2hlY2sgd2hhdCBldmVudCBpdCBpcyBoYW5kbGluZy5cblx0ICovXG5cdG5hbWU6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB2YXIge29iamVjdH0gdGhlIHNlbmRlciBvZiB0aGlzIGV2ZW50LiBJZiBub3Qgc2V0LCB0aGlzIHByb3BlcnR5IHdpbGwgYmVcblx0ICogc2V0IGFzIHRoZSBvYmplY3Qgd2hvc2UgXCJ0cmlnZ2VyKClcIiBtZXRob2QgaXMgY2FsbGVkLlxuXHQgKiBUaGlzIHByb3BlcnR5IG1heSBhbHNvIGJlIGEgYG51bGxgIHdoZW4gdGhpcyBldmVudCBpcyBhXG5cdCAqIGNsYXNzLWxldmVsIGV2ZW50IHdoaWNoIGlzIHRyaWdnZXJlZCBpbiBhIHN0YXRpYyBjb250ZXh0LlxuXHQgKi9cblx0c2VuZGVyOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtib29sZWFufSB3aGV0aGVyIHRoZSBldmVudCBpcyBoYW5kbGVkLiBEZWZhdWx0cyB0byBmYWxzZS5cblx0ICogV2hlbiBhIGhhbmRsZXIgc2V0cyB0aGlzIHRvIGJlIHRydWUsIHRoZSBldmVudCBwcm9jZXNzaW5nIHdpbGwgc3RvcCBhbmRcblx0ICogaWdub3JlIHRoZSByZXN0IG9mIHRoZSB1bmludm9rZWQgZXZlbnQgaGFuZGxlcnMuXG5cdCAqL1xuXHRoYW5kbGVkOiBmYWxzZSxcblxuXHQvKipcblx0ICogQHZhciB7Kn0gdGhlIGRhdGEgdGhhdCBpcyBwYXNzZWQgdG8gW1tKaWkuYmFzZS5Db21wb25lbnQub24oKV1dIHdoZW4gYXR0YWNoaW5nIGFuIGV2ZW50IGhhbmRsZXIuXG5cdCAqIE5vdGUgdGhhdCB0aGlzIHZhcmllcyBhY2NvcmRpbmcgdG8gd2hpY2ggZXZlbnQgaGFuZGxlciBpcyBjdXJyZW50bHkgZXhlY3V0aW5nLlxuXHQgKi9cblx0ZGF0YTogbnVsbCxcblxuXHRwYXJhbXM6IHt9LFxuXG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5iYXNlLkV2ZW50ICove1xuXG5cdFx0LyoqXG5cdFx0ICogQ29udmVydCBzdHJpbmcvZnVuY3Rpb24vb2JqZWN0IHRvIG9iamVjdCBoYW5kbGVyIHdpdGggY29udGV4dCBhbmQgY2FsbGJhY2sgcGFyYW1zXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fFtdfSBoYW5kbGVyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuXHRcdCAqIEByZXR1cm5zIHsqfVxuXHRcdCAqL1xuXHRcdG5vcm1hbGl6ZUhhbmRsZXI6IGZ1bmN0aW9uIChoYW5kbGVyLCBjb250ZXh0KSB7XG5cdFx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBudWxsO1xuXG5cdFx0XHRpZiAoSmlpLl8uaXNPYmplY3QoaGFuZGxlcikgJiYgSmlpLl8uaGFzKGhhbmRsZXIsICdjYWxsYmFjaycpICYmIEppaS5fLmhhcyhoYW5kbGVyLCAnY29udGV4dCcpKSB7XG5cdFx0XHRcdHJldHVybiBoYW5kbGVyO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoSmlpLl8uaXNBcnJheShoYW5kbGVyKSAmJiBoYW5kbGVyLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbihoYW5kbGVyWzBdKSAmJiBKaWkuXy5pc09iamVjdChoYW5kbGVyWzFdKSkge1xuXHRcdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0XHRjb250ZXh0OiBoYW5kbGVyWzFdLFxuXHRcdFx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXJbMF1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzU3RyaW5nKGhhbmRsZXJbMF0pKSB7XG5cdFx0XHRcdFx0aGFuZGxlclswXSA9IEppaS5uYW1lc3BhY2UoaGFuZGxlclswXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjb250ZXh0OiBoYW5kbGVyWzBdLFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBoYW5kbGVyWzBdW2hhbmRsZXJbMV1dXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKaWkuXy5pc1N0cmluZyhoYW5kbGVyKSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbnRleHQ6IGNvbnRleHQsXG5cdFx0XHRcdFx0Y2FsbGJhY2s6IHRoaXNbaGFuZGxlcl1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24oaGFuZGxlcikpIHtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRjb250ZXh0OiBjb250ZXh0LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiBoYW5kbGVyXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignV3JvbmcgaGFuZGxlciBmb3JtYXQ6JyArIEpTT04uc3RyaW5naWZ5KGhhbmRsZXIpKTtcblx0XHR9LFxuXG5cdFx0X2V2ZW50czoge30sXG5cblx0XHQvKipcblx0XHQgKiBBdHRhY2hlcyBhbiBldmVudCBoYW5kbGVyIHRvIGEgY2xhc3MtbGV2ZWwgZXZlbnQuXG5cdFx0ICpcblx0XHQgKiBXaGVuIGEgY2xhc3MtbGV2ZWwgZXZlbnQgaXMgdHJpZ2dlcmVkLCBldmVudCBoYW5kbGVycyBhdHRhY2hlZFxuXHRcdCAqIHRvIHRoYXQgY2xhc3MgYW5kIGFsbCBwYXJlbnQgY2xhc3NlcyB3aWxsIGJlIGludm9rZWQuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgdGhlIGZvbGxvd2luZyBjb2RlIGF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYEFjdGl2ZVJlY29yZGAnc1xuXHRcdCAqIGBhZnRlckluc2VydGAgZXZlbnQ6XG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBKaWkuYmFzZS5FdmVudC5vbihBY3RpdmVSZWNvcmQuY2xhc3NOYW1lKCksIEFjdGl2ZVJlY29yZC5FVkVOVF9BRlRFUl9JTlNFUlQsIGZ1bmN0aW9uIChldmVudCkge1xuXHRcdCAqICAgICBjb25zb2xlLmxvZyhldmVudC5zZW5kZXIuY2xhc3NOYW1lKCkgKyAnIGlzIGluc2VydGVkLicpO1xuXHRcdCAqIH0pO1xuXHRcdCAqIH5+flxuXHRcdCAqXG5cdFx0ICogVGhlIGhhbmRsZXIgd2lsbCBiZSBpbnZva2VkIGZvciBFVkVSWSBzdWNjZXNzZnVsIEFjdGl2ZVJlY29yZCBpbnNlcnRpb24uXG5cdFx0ICpcblx0XHQgKiBGb3IgbW9yZSBkZXRhaWxzIGFib3V0IGhvdyB0byBkZWNsYXJlIGFuIGV2ZW50IGhhbmRsZXIsIHBsZWFzZSByZWZlciB0byBbW0ppaS5iYXNlLkNvbXBvbmVudC5vbigpXV0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lIHRoZSBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSB0byB3aGljaCB0aGUgZXZlbnQgaGFuZGxlciBuZWVkcyB0byBhdHRhY2guXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBoYW5kbGVyIHRoZSBldmVudCBoYW5kbGVyLlxuXHRcdCAqIEBwYXJhbSB7Kn0gW2RhdGFdIHRoZSBkYXRhIHRvIGJlIHBhc3NlZCB0byB0aGUgZXZlbnQgaGFuZGxlciB3aGVuIHRoZSBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdFx0ICogV2hlbiB0aGUgZXZlbnQgaGFuZGxlciBpcyBpbnZva2VkLCB0aGlzIGRhdGEgY2FuIGJlIGFjY2Vzc2VkIHZpYSBbW0ppaS5iYXNlLkV2ZW50LmRhdGFdXS5cblx0XHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FwcGVuZF0gd2hldGhlciB0byBhcHBlbmQgbmV3IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVuZCBvZiB0aGUgZXhpc3Rpbmdcblx0XHQgKiBoYW5kbGVyIGxpc3QuIElmIGZhbHNlLCB0aGUgbmV3IGhhbmRsZXIgd2lsbCBiZSBpbnNlcnRlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBleGlzdGluZ1xuXHRcdCAqIGhhbmRsZXIgbGlzdC5cblx0XHQgKiBAc2VlIG9mZigpXG5cdFx0ICovXG5cdFx0b246IGZ1bmN0aW9uIChjbGFzc05hbWUsIG5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKSB7XG5cdFx0XHRkYXRhID0gZGF0YSB8fCBudWxsO1xuXHRcdFx0aXNBcHBlbmQgPSBKaWkuXy5pc1VuZGVmaW5lZChpc0FwcGVuZCkgPyB0cnVlIDogaXNBcHBlbmQ7XG5cblx0XHRcdGlmIChpc0FwcGVuZCB8fCAhdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbbmFtZV0gfHwgIXRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdKSB7XG5cdFx0XHRcdHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcblx0XHRcdFx0dGhpcy5fZXZlbnRzW25hbWVdID0gdGhpcy5fZXZlbnRzW25hbWVdIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXSA9IHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdIHx8IFtdO1xuXHRcdFx0XHR0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXS5wdXNoKFtoYW5kbGVyLCBkYXRhXSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0udW5zaGlmdChbaGFuZGxlciwgZGF0YV0pO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZXRhY2hlcyBhbiBldmVudCBoYW5kbGVyIGZyb20gYSBjbGFzcy1sZXZlbCBldmVudC5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIHRoZSBvcHBvc2l0ZSBvZiBbW29uKCldXS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIGZyb20gd2hpY2ggdGhlIGV2ZW50IGhhbmRsZXIgbmVlZHMgdG8gYmUgZGV0YWNoZWQuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb258b2JqZWN0fSBbaGFuZGxlcl0gdGhlIGV2ZW50IGhhbmRsZXIgdG8gYmUgcmVtb3ZlZC5cblx0XHQgKiBJZiBpdCBpcyBudWxsLCBhbGwgaGFuZGxlcnMgYXR0YWNoZWQgdG8gdGhlIG5hbWVkIGV2ZW50IHdpbGwgYmUgcmVtb3ZlZC5cblx0XHQgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciBhIGhhbmRsZXIgaXMgZm91bmQgYW5kIGRldGFjaGVkLlxuXHRcdCAqIEBzZWUgb24oKVxuXHRcdCAqL1xuXHRcdG9mZjogZnVuY3Rpb24gKGNsYXNzTmFtZSwgbmFtZSwgaGFuZGxlcikge1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZXIgfHwgbnVsbDtcblxuXHRcdFx0aWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSB8fCAhdGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoaGFuZGxlciA9PT0gbnVsbCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV07XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbmV3RXZlbnRzID0gW107XG5cdFx0XHR2YXIgaXNSZW1vdmVkID0gZmFsc2U7XG5cdFx0XHRKaWkuXy5lYWNoKHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmIChldmVudFswXSAhPT0gaGFuZGxlcikge1xuXHRcdFx0XHRcdG5ld0V2ZW50cy5wdXNoKGV2ZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpc1JlbW92ZWQgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSk7XG5cdFx0XHRpZiAobmV3RXZlbnRzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRkZWxldGUgdGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXSA9IG5ld0V2ZW50cztcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGlzUmVtb3ZlZDtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGVyZSBpcyBhbnkgaGFuZGxlciBhdHRhY2hlZCB0byB0aGUgc3BlY2lmaWVkIGNsYXNzLWxldmVsIGV2ZW50LlxuXHRcdCAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCB3aWxsIGFsc28gY2hlY2sgYWxsIHBhcmVudCBjbGFzc2VzIHRvIHNlZSBpZiB0aGVyZSBpcyBhbnkgaGFuZGxlciBhdHRhY2hlZFxuXHRcdCAqIHRvIHRoZSBuYW1lZCBldmVudC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNsYXNzTmFtZSB0aGUgb2JqZWN0IG9yIHRoZSBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSBzcGVjaWZ5aW5nIHRoZSBjbGFzcy1sZXZlbCBldmVudC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGVyZSBpcyBhbnkgaGFuZGxlciBhdHRhY2hlZCB0byB0aGUgZXZlbnQuXG5cdFx0ICovXG5cdFx0aGFzSGFuZGxlcnM6IGZ1bmN0aW9uIChjbGFzc05hbWUsIG5hbWUpIHtcblx0XHRcdGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbbmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoSmlpLl8uaXNPYmplY3QoY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUuY2xhc3NOYW1lKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJyZW50Q2xhc3MgPSBKaWkuXy5pc09iamVjdChjbGFzc05hbWUpID8gY2xhc3NOYW1lIDogSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbGFzc05hbWUgPSBjdXJyZW50Q2xhc3MucGFyZW50Q2xhc3NOYW1lKCk7XG5cdFx0XHRcdGN1cnJlbnRDbGFzcyA9IGNsYXNzTmFtZSA/IEppaS5uYW1lc3BhY2UoY2xhc3NOYW1lKSA6IG51bGw7XG5cblx0XHRcdFx0aWYgKCFjdXJyZW50Q2xhc3MpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFRyaWdnZXJzIGEgY2xhc3MtbGV2ZWwgZXZlbnQuXG5cdFx0ICogVGhpcyBtZXRob2Qgd2lsbCBjYXVzZSBpbnZvY2F0aW9uIG9mIGV2ZW50IGhhbmRsZXJzIHRoYXQgYXJlIGF0dGFjaGVkIHRvIHRoZSBuYW1lZCBldmVudFxuXHRcdCAqIGZvciB0aGUgc3BlY2lmaWVkIGNsYXNzIGFuZCBhbGwgaXRzIHBhcmVudCBjbGFzc2VzLlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY2xhc3NOYW1lIHRoZSBvYmplY3Qgb3IgdGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIHNwZWNpZnlpbmcgdGhlIGNsYXNzLWxldmVsIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEBwYXJhbSB7SmlpLmJhc2UuRXZlbnR9IFtldmVudF0gdGhlIGV2ZW50IHBhcmFtZXRlci4gSWYgbm90IHNldCwgYSBkZWZhdWx0IFtbRXZlbnRdXSBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkLlxuXHRcdCAqL1xuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uIChjbGFzc05hbWUsIG5hbWUsIGV2ZW50KSB7XG5cdFx0XHRldmVudCA9IGV2ZW50IHx8IG51bGw7XG5cblx0XHRcdGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbbmFtZV0pIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoZXZlbnQgPT09IG51bGwpIHtcblx0XHRcdFx0ZXZlbnQgPSBuZXcgdGhpcygpO1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRldmVudC5oYW5kbGVkID0gZmFsc2U7XG5cdFx0XHRldmVudC5uYW1lID0gbmFtZTtcblxuXHRcdFx0aWYgKEppaS5fLmlzT2JqZWN0KGNsYXNzTmFtZSkpIHtcblx0XHRcdFx0aWYgKGV2ZW50LnNlbmRlciA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdGV2ZW50LnNlbmRlciA9IGNsYXNzTmFtZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUuY2xhc3NOYW1lKCk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBjdXJyZW50Q2xhc3MgPSBKaWkuXy5pc09iamVjdChjbGFzc05hbWUpID8gY2xhc3NOYW1lIDogSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuXHRcdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaGFuZGxlciwgaSA9IDAsIGwgPSB0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXVtpXTtcblxuXHRcdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZXJbMV07XG5cdFx0XHRcdFx0XHRoYW5kbGVyWzBdID0gdGhpcy5ub3JtYWxpemVIYW5kbGVyKGhhbmRsZXJbMF0pO1xuXHRcdFx0XHRcdFx0aGFuZGxlclswXS5jYWxsYmFjay5jYWxsKGhhbmRsZXJbMF0uY29udGV4dCwgZXZlbnQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoZXZlbnQuaGFuZGxlZCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Y2xhc3NOYW1lID0gY3VycmVudENsYXNzLnBhcmVudENsYXNzTmFtZSgpO1xuXHRcdFx0XHRjdXJyZW50Q2xhc3MgPSBjbGFzc05hbWUgPyBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSkgOiBudWxsO1xuXG5cdFx0XHRcdGlmICghY3VycmVudENsYXNzKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9PYmplY3RcIjoxMzh9XSwxMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9SZXF1ZXN0Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkh0dHBSZXF1ZXN0XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5SZXF1ZXN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuSHR0cFJlcXVlc3QnLCAvKiogQGxlbmRzIEppaS5iYXNlLkh0dHBSZXF1ZXN0LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLlJlcXVlc3QsXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRnZXRNZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gJ0dFVCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGEgR0VUIHJlcXVlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc0dldDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGhvZCgpID09PSAnR0VUJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYSBPUFRJT05TIHJlcXVlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc09wdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRob2QoKSA9PT0gJ09QVElPTlMnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBpcyBhIEhFQUQgcmVxdWVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzSGVhZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGhvZCgpID09PSAnSEVBRCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGEgUE9TVCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNQb3N0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0aG9kKCkgPT09ICdQT1NUJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYSBERUxFVEUgcmVxdWVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRGVsZXRlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0aG9kKCkgPT09ICdERUxFVEUnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBpcyBhIFBVVCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNQdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRob2QoKSA9PT0gJ1BVVCc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGEgUEFUQ0ggcmVxdWVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzUGF0Y2g6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRob2QoKSA9PT0gJ1BBVENIJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYW4gQUpBWCAoWE1MSHR0cFJlcXVlc3QpIHJlcXVlc3QuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoaXMgaXMgYW4gQUpBWCAoWE1MSHR0cFJlcXVlc3QpIHJlcXVlc3QuXG5cdCAqL1xuXHRpc0FqYXg6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGFuIEFkb2JlIEZsYXNoIG9yIEZsZXggcmVxdWVzdC5cblx0ICogQHJldHVybiBib29sZWFuIHdoZXRoZXIgdGhpcyBpcyBhbiBBZG9iZSBGbGFzaCBvciBBZG9iZSBGbGV4IHJlcXVlc3QuXG5cdCAqL1xuXHRpc0ZsYXNoOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lZCByZXF1ZXN0IGJvZHkgcGFyYW1ldGVyIHZhbHVlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcGFyYW1ldGVyIG5hbWVcblx0ICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgaWYgdGhlIHBhcmFtZXRlciBkb2VzIG5vdCBleGlzdC5cblx0ICogQHJldHVybiB7Kn0gdGhlIHBhcmFtZXRlciB2YWx1ZVxuXHQgKi9cblx0Z2V0Qm9keVBhcmFtOiBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0ZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG5cblx0XHR2YXIgYm9keVBhcmFtcyA9IHRoaXMuZ2V0Qm9keVBhcmFtcygpO1xuXHRcdHJldHVybiBKaWkuXy5oYXMoYm9keVBhcmFtcywgbmFtZSkgPyBib2R5UGFyYW1zW25hbWVdIDogZGVmYXVsdFZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIFBPU1QgcGFyYW1ldGVyIHdpdGggYSBnaXZlbiBuYW1lLiBJZiBuYW1lIGlzbid0IHNwZWNpZmllZCwgcmV0dXJucyBhbiBhcnJheSBvZiBhbGwgUE9TVCBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdIHRoZSBwYXJhbWV0ZXIgbmFtZVxuXHQgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIHRoZSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSBpZiB0aGUgcGFyYW1ldGVyIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcmV0dXJuIHsqfSBUaGUgUE9TVCBwYXJhbWV0ZXIgdmFsdWVcblx0ICovXG5cdHBvc3Q6IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRuYW1lID0gbmFtZSB8fCBudWxsO1xuXHRcdGRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuXG5cdFx0cmV0dXJuIG5hbWUgPT09IG51bGwgPyB0aGlzLmdldEJvZHlQYXJhbXMoKSA6IHRoaXMuZ2V0Qm9keVBhcmFtKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG5cdH0sXG5cblx0X3F1ZXJ5UGFyYW1zOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByZXF1ZXN0IHBhcmFtZXRlcnMgZ2l2ZW4gaW4gdGhlIFtbcXVlcnlTdHJpbmddXS5cblx0ICogQHJldHVybiB7b2JqZWN0fSB0aGUgcmVxdWVzdCBHRVQgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICovXG5cdGdldFF1ZXJ5UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3F1ZXJ5UGFyYW1zID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9xdWVyeVBhcmFtcyA9IHRoaXMuX3BhcnNlUXVlcnlQYXJhbXMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3F1ZXJ5UGFyYW1zO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSByZXF1ZXN0IFtbcXVlcnlTdHJpbmddXSBwYXJhbWV0ZXJzLlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIHRoZSByZXF1ZXN0IHF1ZXJ5IHBhcmFtZXRlcnMgKG5hbWUtdmFsdWUgcGFpcnMpXG5cdCAqL1xuXHRzZXRRdWVyeVBhcmFtczogZnVuY3Rpb24gKHZhbHVlcykge1xuXHRcdHRoaXMuX3F1ZXJ5UGFyYW1zID0gdmFsdWVzO1xuXHR9LFxuXG5cdF9wYXJzZVF1ZXJ5UGFyYW1zOiBmdW5jdGlvbiAoKSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWVkIEdFVCBwYXJhbWV0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXJhbWV0ZXIgbmFtZVxuXHQgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIHRoZSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSBpZiB0aGUgcGFyYW1ldGVyIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcmV0dXJuIHsqfSB0aGUgcGFyYW1ldGVyIHZhbHVlXG5cdCAqL1xuXHRnZXRRdWVyeVBhcmFtOiBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0ZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG5cblx0XHR2YXIgcXVlcnlQYXJhbXMgPSB0aGlzLmdldFF1ZXJ5UGFyYW1zKCk7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyhxdWVyeVBhcmFtcywgbmFtZSkgPyBxdWVyeVBhcmFtc1tuYW1lXSA6IGRlZmF1bHRWYWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZWQgR0VUIHBhcmFtZXRlciB2YWx1ZS5cblx0ICogSWYgdGhlIEdFVCBwYXJhbWV0ZXIgZG9lcyBub3QgZXhpc3QsIHRoZSBzZWNvbmQgcGFyYW1ldGVyIHRvIHRoaXMgbWV0aG9kIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gdGhlIEdFVCBwYXJhbWV0ZXIgbmFtZS4gSWYgbm90IHNwZWNpZmllZCwgd2hvbGUgYWxsIGdldCBwYXJhbXMgaXMgcmV0dXJuZWQuXG5cdCAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gdGhlIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIGlmIHRoZSBHRVQgcGFyYW1ldGVyIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcmV0dXJuIHsqfSB0aGUgR0VUIHBhcmFtZXRlciB2YWx1ZVxuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbiAobmFtZSwgZGVmYXVsdFZhbHVlKSB7XG5cdFx0bmFtZSA9IG5hbWUgfHwgbnVsbDtcblx0XHRkZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcblxuXHRcdHJldHVybiBuYW1lID09PSBudWxsID8gdGhpcy5nZXRRdWVyeVBhcmFtcygpIDogdGhpcy5nZXRRdWVyeVBhcmFtKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG5cdH0sXG5cblx0X3BhdGhJbmZvOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwYXRoIGluZm8gb2YgdGhlIGN1cnJlbnRseSByZXF1ZXN0ZWQgVVJMLlxuXHQgKiBBIHBhdGggaW5mbyByZWZlcnMgdG8gdGhlIHBhcnQgdGhhdCBpcyBhZnRlciB0aGUgZW50cnkgc2NyaXB0IGFuZCBiZWZvcmUgdGhlIHF1ZXN0aW9uIG1hcmsgKHF1ZXJ5IHN0cmluZykuXG5cdCAqIFRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHNsYXNoZXMgYXJlIGJvdGggcmVtb3ZlZC5cblx0ICogQHJldHVybiB7c3RyaW5nfSBQYXJ0IG9mIHRoZSByZXF1ZXN0IFVSTCB0aGF0IGlzIGFmdGVyIHRoZSBlbnRyeSBzY3JpcHQgYW5kIGJlZm9yZSB0aGUgcXVlc3Rpb24gbWFyay5cblx0ICogTm90ZSwgdGhlIHJldHVybmVkIHBhdGggaW5mbyBpcyBhbHJlYWR5IFVSTC1kZWNvZGVkLlxuXHQgKi9cblx0Z2V0UGF0aEluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcGF0aEluZm8gPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3BhdGhJbmZvID0gdGhpcy5fcGFyc2VQYXRoSW5mbygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcGF0aEluZm87XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHBhdGggaW5mbyBvZiB0aGUgY3VycmVudCByZXF1ZXN0LlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgcHJvdmlkZWQgZm9yIHRlc3RpbmcgcHVycG9zZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBwYXRoIGluZm8gb2YgdGhlIGN1cnJlbnQgcmVxdWVzdFxuXHQgKi9cblx0c2V0UGF0aEluZm86IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX3BhdGhJbmZvID0gSmlpLl9zLmx0cmltKHZhbHVlLCAnLycpO1xuXHR9LFxuXG5cdF9wYXJzZVBhdGhJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdH0sXG5cblx0X2hvc3RJbmZvOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgY3VycmVudCByZXF1ZXN0IFVSTC5cblx0ICogVGhlIHJldHVybmVkIFVSTCBkb2VzIG5vdCBoYXZlIGFuIGVuZGluZyBzbGFzaC5cblx0ICogQnkgZGVmYXVsdCB0aGlzIGlzIGRldGVybWluZWQgYmFzZWQgb24gdGhlIHVzZXIgcmVxdWVzdCBpbmZvcm1hdGlvbi5cblx0ICogWW91IG1heSBleHBsaWNpdGx5IHNwZWNpZnkgaXQgYnkgc2V0dGluZyB0aGUgc2V0SG9zdEluZm8oKS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBTY2hlbWEgYW5kIGhvc3RuYW1lIHBhcnQgKHdpdGggcG9ydCBudW1iZXIgaWYgbmVlZGVkKSBvZiB0aGUgcmVxdWVzdCBVUkxcblx0ICovXG5cdGdldEhvc3RJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2hvc3RJbmZvID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9ob3N0SW5mbyA9IHRoaXMuX3BhcnNlSG9zdEluZm8oKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2hvc3RJbmZvO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgYXBwbGljYXRpb24gVVJMLlxuXHQgKiBUaGlzIHNldHRlciBpcyBwcm92aWRlZCBpbiBjYXNlIHRoZSBzY2hlbWEgYW5kIGhvc3RuYW1lIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cdCAqIG9uIGNlcnRhaW4gV2ViIHNlcnZlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc2NoZW1hIGFuZCBob3N0IHBhcnQgb2YgdGhlIGFwcGxpY2F0aW9uIFVSTC4gVGhlIHRyYWlsaW5nIHNsYXNoZXMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKi9cblx0c2V0SG9zdEluZm86IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX2hvc3RJbmZvID0gSmlpLl9zLnJ0cmltKHZhbHVlLCAnLycpO1xuXHRcdHJldHVybiB0aGlzLl9ob3N0SW5mbztcblx0fSxcblxuXHRfcGFyc2VIb3N0SW5mbzogZnVuY3Rpb24gKCkge1xuXHR9XG5cbn0pO1xuXG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9SZXF1ZXN0XCI6MTM5fV0sMTM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9FdmVudCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Nb2RlbEV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk1vZGVsRXZlbnQnLCAvKiogQGxlbmRzIEppaS5iYXNlLk1vZGVsRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqIEEgbW9kZWwgaXMgaW4gdmFsaWQgc3RhdHVzIGlmIGl0IHBhc3NlcyB2YWxpZGF0aW9ucyBvciBjZXJ0YWluIGNoZWNrcy5cblx0ICogQHR5cGUge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG1vZGVsIGlzIGluIHZhbGlkIHN0YXR1cy4gRGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICovXG5cdGlzVmFsaWQ6IHRydWVcblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9FdmVudFwiOjEzNH1dLDEzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQ29udGV4dCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Nb2R1bGVcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbnRleHRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5Nb2R1bGUnLCAvKiogQGxlbmRzIEppaS5iYXNlLk1vZHVsZS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db250ZXh0LFxuXG4gICAgX19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmJhc2UuTW9kdWxlICove1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuTW9kdWxlI2JlZm9yZUFjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLkFjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQkVGT1JFX0FDVElPTjogJ2JlZm9yZUFjdGlvbicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Nb2R1bGUjYWZ0ZXJBY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5BY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX0FGVEVSX0FDVElPTjogJ2FmdGVyQWN0aW9uJ1xuXG4gICAgfSxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGlkOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgcGFyZW50IG1vZHVsZSBvZiB0aGlzIG1vZHVsZS4gTnVsbCBpZiB0aGlzIG1vZHVsZSBkb2VzIG5vdCBoYXZlIGEgcGFyZW50LlxuXHQgKiBAdHlwZSB7SmlpLmJhc2UuTW9kdWxlfVxuXHQgKi9cblx0bW9kdWxlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3tzdHJpbmc6IGZ1bmN0aW9ufX1cbiAgICAgKi9cbiAgICBpbmxpbmVBY3Rpb25zOiB7fSxcblxuXHQvKipcblx0ICogTWFwcGluZyBmcm9tIGNvbnRyb2xsZXIgSUQgdG8gY29udHJvbGxlciBjb25maWd1cmF0aW9ucy5cblx0ICogRWFjaCBuYW1lLXZhbHVlIHBhaXIgc3BlY2lmaWVzIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgc2luZ2xlIGNvbnRyb2xsZXIuXG5cdCAqIEEgY29udHJvbGxlciBjb25maWd1cmF0aW9uIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gYXJyYXkuXG5cdCAqIElmIHRoZSBmb3JtZXIsIHRoZSBzdHJpbmcgc2hvdWxkIGJlIHRoZSBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSBvZiB0aGUgY29udHJvbGxlci5cblx0ICogSWYgdGhlIGxhdHRlciwgdGhlIGFycmF5IG11c3QgY29udGFpbiBhICdjbGFzcycgZWxlbWVudCB3aGljaCBzcGVjaWZpZXNcblx0ICogdGhlIGNvbnRyb2xsZXIncyBmdWxseSBxdWFsaWZpZWQgY2xhc3MgbmFtZSwgYW5kIHRoZSByZXN0IG9mIHRoZSBuYW1lLXZhbHVlIHBhaXJzXG5cdCAqIGluIHRoZSBhcnJheSBhcmUgdXNlZCB0byBpbml0aWFsaXplIHRoZSBjb3JyZXNwb25kaW5nIGNvbnRyb2xsZXIgcHJvcGVydGllcy4gRm9yIGV4YW1wbGUsXG5cdCAqXG5cdCAqIH5+flxuXHQgKiB7XG4gICAgICogICBhY2NvdW50OiAnYXBwLmNvbnRyb2xsZXJzLlVzZXJDb250cm9sbGVyJyxcbiAgICAgKiAgIGFydGljbGU6IHtcbiAgICAgKiAgICAgIGNsYXNzTmFtZTogJ2FwcC5jb250cm9sbGVycy5Qb3N0Q29udHJvbGxlcicsXG4gICAgICogICAgICBwYWdlVGl0bGU6ICdzb21ldGhpbmcgbmV3J1xuICAgICAqICAgfVxuICAgICAqIH1cblx0ICogfn5+XG5cdCAqIEB0eXBlIHtvYmplY3R9XG5cdCAqL1xuXHRjb250cm9sbGVyTWFwOiB7fSxcblxuXHQvKipcblx0ICogU3RyaW5nIHRoZSBuYW1lc3BhY2UgdGhhdCBjb250cm9sbGVyIGNsYXNzZXMgYXJlIGluLiBJZiBub3Qgc2V0LFxuXHQgKiBpdCB3aWxsIHVzZSB0aGUgXCJjb250cm9sbGVyc1wiIHN1Yi1uYW1lc3BhY2UgdW5kZXIgdGhlIG5hbWVzcGFjZSBvZiB0aGlzIG1vZHVsZS5cblx0ICogRm9yIGV4YW1wbGUsIGlmIHRoZSBuYW1lc3BhY2Ugb2YgdGhpcyBtb2R1bGUgaXMgXCJmb29cXGJhclwiLCB0aGVuIHRoZSBkZWZhdWx0XG5cdCAqIGNvbnRyb2xsZXIgbmFtZXNwYWNlIHdvdWxkIGJlIFwiZm9vXFxiYXJcXGNvbnRyb2xsZXJzXCIuXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRjb250cm9sbGVyTmFtZXNwYWNlOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgZGVmYXVsdCByb3V0ZSBvZiB0aGlzIG1vZHVsZS4gRGVmYXVsdHMgdG8gJ2RlZmF1bHQnLlxuXHQgKiBUaGUgcm91dGUgbWF5IGNvbnNpc3Qgb2YgY2hpbGQgbW9kdWxlIElELCBjb250cm9sbGVyIElELCBhbmQvb3IgYWN0aW9uIElELlxuXHQgKiBGb3IgZXhhbXBsZSwgYGhlbHBgLCBgcG9zdC9jcmVhdGVgLCBgYWRtaW4vcG9zdC9jcmVhdGVgLlxuXHQgKiBJZiBhY3Rpb24gSUQgaXMgbm90IGdpdmVuLCBpdCB3aWxsIHRha2UgdGhlIGRlZmF1bHQgdmFsdWUgYXMgc3BlY2lmaWVkIGluIGRlZmF1bHRBY3Rpb24uXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRkZWZhdWx0Um91dGU6ICdkZWZhdWx0JyxcblxuXHQvKipcblx0ICogVGhlIGxheW91dCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGZvciB2aWV3cyB3aXRoaW4gdGhpcyBtb2R1bGUuIFRoaXMgcmVmZXJzIHRvIGEgdmlldyBuYW1lXG5cdCAqIHJlbGF0aXZlIHRvIFtbbGF5b3V0UGF0aF1dLiBJZiB0aGlzIGlzIG5vdCBzZXQsIGl0IG1lYW5zIHRoZSBsYXlvdXQgdmFsdWUgb2YgdGhlIFtbbW9kdWxlfHBhcmVudCBtb2R1bGVdXVxuXHQgKiB3aWxsIGJlIHRha2VuLiBJZiB0aGlzIGlzIGZhbHNlLCBsYXlvdXQgd2lsbCBiZSBkaXNhYmxlZCB3aXRoaW4gdGhpcyBtb2R1bGUuXG5cdCAqIEB0eXBlIHtzdHJpbmd8Ym9vbGVhbn1cblx0ICovXG5cdGxheW91dDogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge29iamVjdH1cblx0ICovXG5cdF9tb2R1bGVzOiBudWxsLFxuXG5cdC8qKlxuICAgICAqIFN0b3JlZCBjb250cm9sbGVyIGluc3RhbmNlc1xuXHQgKiBAdHlwZSB7b2JqZWN0fVxuXHQgKi9cbiAgICBfY29udHJvbGxlcnM6IHt9LFxuXG5cdC8qKlxuXHQgKi9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChpZCwgbW9kdWxlT2JqZWN0LCBjb25maWcpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5tb2R1bGUgPSBtb2R1bGVPYmplY3Q7XG5cdFx0dGhpcy5fbW9kdWxlcyA9IHt9O1xuXG5cdFx0dGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cdH0sXG5cblx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmNvbnRyb2xsZXJOYW1lc3BhY2UgPT09IG51bGwpIHtcblx0XHRcdHZhciBpbmRleCA9IEppaS5fLmxhc3RJbmRleE9mKHRoaXMuY2xhc3NOYW1lKCksICcuJyk7XG5cdFx0XHR0aGlzLmNvbnRyb2xsZXJOYW1lc3BhY2UgPSB0aGlzLmNsYXNzTmFtZSgpLnN1YnN0cigwLCBpbmRleCk7XG5cdFx0fVxuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzdGFydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwcm9taXNlcyA9IFtdO1xuICAgICAgICBKaWkuXy5lYWNoKHRoaXMuX2NvbXBvbmVudHMsIGZ1bmN0aW9uKGNvbXBvbmVudCkge1xuICAgICAgICAgICAgaWYgKEppaS5fLmlzRnVuY3Rpb24oY29tcG9uZW50LnN0YXJ0KSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY29tcG9uZW50LnN0YXJ0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIEppaS5fLmVhY2godGhpcy5fY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaXNGdW5jdGlvbihjb21wb25lbnQuc3RvcCkpIHtcbiAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKGNvbXBvbmVudC5zdG9wKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICB9LFxuXG5cdGdldFVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMubW9kdWxlKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzLm1vZHVsZS5nZXRVbmlxdWVJZCgpICsgJy8nICsgdGhpcy5pZDtcblx0XHRcdHJldHVybiBKaWkuX3MubHRyaW0oaWQsICcvJyk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIG1vZHVsZS5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdF9iYXNlUGF0aDogbnVsbCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIG1vZHVsZS5cblx0ICogSXQgZGVmYXVsdHMgdG8gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSBtb2R1bGUgY2xhc3MgZmlsZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIG1vZHVsZS5cblx0ICovXG5cdGdldEJhc2VQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2Jhc2VQYXRoID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9iYXNlUGF0aCA9IEppaS5nZXRBbGlhcygnQCcgKyB0aGlzLmNsYXNzTmFtZSgpLnJlcGxhY2UoL1xcLlteLl0rJC8sICcnKSlcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5fYmFzZVBhdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBtb2R1bGUuXG5cdCAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIGludm9rZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIG1vZHVsZS4gVGhpcyBjYW4gYmUgZWl0aGVyIGEgZGlyZWN0b3J5IG5hbWUgb3IgYSBwYXRoIGFsaWFzLlxuXHQgKi9cblx0c2V0QmFzZVBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dGhpcy5fYmFzZVBhdGggPSBKaWkuZ2V0QWxpYXMocGF0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBjb250cm9sbGVyIGNsYXNzZXMgYWNjb3JkaW5nIHRvIFtbY29udHJvbGxlck5hbWVzcGFjZV1dLlxuXHQgKiBOb3RlIHRoYXQgaW4gb3JkZXIgZm9yIHRoaXMgbWV0aG9kIHRvIHJldHVybiBhIHZhbHVlLCB5b3UgbXVzdCBkZWZpbmVcblx0ICogYW4gYWxpYXMgZm9yIHRoZSByb290IG5hbWVzcGFjZSBvZiBbW2NvbnRyb2xsZXJOYW1lc3BhY2VdXS5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2xsZXIgY2xhc3Nlcy5cblx0ICovXG5cdGdldENvbnRyb2xsZXJQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEppaS5nZXRBbGlhcygnQCcgKyB0aGlzLmNvbnRyb2xsZXJOYW1lc3BhY2UucmVwbGFjZSgnLicsICcvJykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgcm9vdCBkaXJlY3RvcnkgdGhhdCBjb250YWlucyB2aWV3IGZpbGVzIGZvciB0aGlzIG1vZHVsZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0X3ZpZXdQYXRoOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyB0aGUgdmlldyBmaWxlcyBmb3IgdGhpcyBtb2R1bGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHZpZXcgZmlsZXMuIERlZmF1bHRzIHRvIFwiW1tiYXNlUGF0aF1dL3ZpZXdcIi5cblx0ICovXG5cdGdldFZpZXdQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3ZpZXdQYXRoID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl92aWV3UGF0aCA9IHRoaXMuZ2V0QmFzZVBhdGgoKSArICcvdmlld3MnO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fdmlld1BhdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSB2aWV3IGZpbGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdmlldyBmaWxlcy5cblx0ICovXG5cdHNldFZpZXdQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdHRoaXMuX3ZpZXdQYXRoID0gSmlpLmdldEFsaWFzKHBhdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGUgcm9vdCBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBsYXlvdXQgdmlldyBmaWxlcyBmb3IgdGhpcyBtb2R1bGUuXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRfbGF5b3V0UGF0aDogbnVsbCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgbGF5b3V0IHZpZXcgZmlsZXMgZm9yIHRoaXMgbW9kdWxlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByb290IGRpcmVjdG9yeSBvZiBsYXlvdXQgZmlsZXMuIERlZmF1bHRzIHRvIFwiW1t2aWV3UGF0aF1dL2xheW91dHNcIi5cblx0ICovXG5cdGdldExheW91dFBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbGF5b3V0UGF0aCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fbGF5b3V0UGF0aCA9IHRoaXMuZ2V0Vmlld1BhdGgoKSArICcvbGF5b3V0cyc7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sYXlvdXRQYXRoO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyB0aGUgbGF5b3V0IGZpbGVzLlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHBhdGggdGhlIHJvb3QgZGlyZWN0b3J5IG9mIGxheW91dCBmaWxlcy5cblx0ICovXG5cdHNldExheW91dFBhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dGhpcy5fbGF5b3V0UGF0aCA9IEppaS5nZXRBbGlhcyhwYXRoKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNoaWxkIG1vZHVsZSBvZiB0aGUgc3BlY2lmaWVkIElEIGV4aXN0cy5cblx0ICogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY2hlY2tpbmcgdGhlIGV4aXN0ZW5jZSBvZiBib3RoIGNoaWxkIGFuZCBncmFuZCBjaGlsZCBtb2R1bGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgbW9kdWxlIElELiBGb3IgZ3JhbmQgY2hpbGQgbW9kdWxlcywgdXNlIElEIHBhdGggcmVsYXRpdmUgdG8gdGhpcyBtb2R1bGUgKGUuZy4gYGFkbWluL2NvbnRlbnRgKS5cblx0ICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGUgbmFtZWQgbW9kdWxlIGV4aXN0cy4gQm90aCBsb2FkZWQgYW5kIHVubG9hZGVkIG1vZHVsZXNcblx0ICogYXJlIGNvbnNpZGVyZWQuXG5cdCAqL1xuXHRoYXNNb2R1bGU6IGZ1bmN0aW9uIChpZCkge1xuXHRcdHZhciBpbmRleCA9IEppaS5fLmluZGV4T2YoaWQsICcuJyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gaWQuc3Vic3RyKDAsIGluZGV4KTtcblx0XHRcdHZhciBjaGlsZE1vZHVsZUlkID0gaWQuc3Vic3RyKGluZGV4ICsgMSk7XG5cblx0XHRcdC8vIENoZWNrIHN1Yi1tb2R1bGVcblx0XHRcdHZhciBtb2R1bGVPYmplY3QgPSB0aGlzLmdldE1vZHVsZShtb2R1bGVJZCk7XG5cdFx0XHRyZXR1cm4gbW9kdWxlT2JqZWN0ICE9PSBudWxsID8gbW9kdWxlT2JqZWN0Lmhhc01vZHVsZShjaGlsZE1vZHVsZUlkKSA6IGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBKaWkuXy5oYXModGhpcy5fbW9kdWxlc1tpZF0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXRyaWV2ZXMgdGhlIGNoaWxkIG1vZHVsZSBvZiB0aGUgc3BlY2lmaWVkIElELlxuXHQgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyByZXRyaWV2aW5nIGJvdGggY2hpbGQgbW9kdWxlcyBhbmQgZ3JhbmQgY2hpbGQgbW9kdWxlcy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIG1vZHVsZSBJRCAoY2FzZS1zZW5zaXRpdmUpLiBUbyByZXRyaWV2ZSBncmFuZCBjaGlsZCBtb2R1bGVzLFxuXHQgKiB1c2UgSUQgcGF0aCByZWxhdGl2ZSB0byB0aGlzIG1vZHVsZSAoZS5nLiBgYWRtaW4vY29udGVudGApLlxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5Nb2R1bGV9IHRoZSBtb2R1bGUgaW5zdGFuY2UsIG51bGwgaWYgdGhlIG1vZHVsZSBkb2VzIG5vdCBleGlzdC5cblx0ICovXG5cdGdldE1vZHVsZTogZnVuY3Rpb24gKGlkKSB7XG5cdFx0Ly8gR2V0IHN1Yi1tb2R1bGVcblx0XHR2YXIgaW5kZXggPSBKaWkuXy5pbmRleE9mKGlkLCAnLicpO1xuXHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdHZhciBtb2R1bGVJZCA9IGlkLnN1YnN0cigwLCBpbmRleCk7XG5cdFx0XHR2YXIgY2hpbGRNb2R1bGVJZCA9IGlkLnN1YnN0cihpbmRleCArIDEpO1xuXG5cdFx0XHR2YXIgbW9kdWxlT2JqZWN0ID0gdGhpcy5nZXRNb2R1bGUobW9kdWxlSWQpO1xuXHRcdFx0cmV0dXJuIG1vZHVsZU9iamVjdCAhPT0gbnVsbCA/IG1vZHVsZU9iamVjdC5nZXRNb2R1bGUoY2hpbGRNb2R1bGVJZCkgOiBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9tb2R1bGVzW2lkXSB8fCBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBZGRzIGEgc3ViLW1vZHVsZSB0byB0aGlzIG1vZHVsZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIG1vZHVsZSBJRFxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLk1vZHVsZXxhcnJheXxudWxsfSBtb2R1bGVPYmplY3QgdGhlIHN1Yi1tb2R1bGUgdG8gYmUgYWRkZWQgdG8gdGhpcyBtb2R1bGUuIFRoaXMgY2FuXG5cdCAqIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nczpcblx0ICpcblx0ICogLSBhIFtbSmlpLmJhc2UuTW9kdWxlXV0gb2JqZWN0XG5cdCAqIC0gYSBjb25maWd1cmF0aW9uIGFycmF5OiB3aGVuIFtbZ2V0TW9kdWxlKCldXSBpcyBjYWxsZWQgaW5pdGlhbGx5LCB0aGUgYXJyYXlcblx0ICogICB3aWxsIGJlIHVzZWQgdG8gaW5zdGFudGlhdGUgdGhlIHN1Yi1tb2R1bGVcblx0ICogLSBudWxsOiB0aGUgbmFtZWQgc3ViLW1vZHVsZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGlzIG1vZHVsZVxuXHQgKi9cblx0c2V0TW9kdWxlOiBmdW5jdGlvbiAoaWQsIG1vZHVsZU9iamVjdCkge1xuXHRcdGlmIChtb2R1bGVPYmplY3QgPT09IG51bGwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tb2R1bGVzW2lkXTtcbiAgICAgICAgfSBlbHNlIHtcblx0XHRcdC8vIENyZWF0ZSBtb2R1bGUgaW5zdGFuY2VcbiAgICAgICAgICAgIGlmICghKG1vZHVsZU9iamVjdCBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZHVsZSkpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVPYmplY3QgPSBKaWkuY3JlYXRlT2JqZWN0KG1vZHVsZU9iamVjdCwgaWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuXG5cdFx0XHQvLyBBZGQgbGlua1xuXHRcdFx0dGhpcy5fbW9kdWxlc1tpZF0gPSBtb2R1bGVPYmplY3Q7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzdWItbW9kdWxlcyBpbiB0aGlzIG1vZHVsZS5cblx0ICogQHJldHVybiB7SmlpLmJhc2UuTW9kdWxlW119IHRoZSBtb2R1bGVzIChpbmRleGVkIGJ5IHRoZWlyIElEcylcblx0ICovXG5cdGdldE1vZHVsZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fbW9kdWxlcztcblx0fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIHN1Yi1tb2R1bGVzIGluIHRoZSBjdXJyZW50IG1vZHVsZS5cblx0ICpcblx0ICogRWFjaCBzdWItbW9kdWxlIHNob3VsZCBiZSBzcGVjaWZpZWQgYXMgYSBuYW1lLXZhbHVlIHBhaXIsIHdoZXJlXG5cdCAqIG5hbWUgcmVmZXJzIHRvIHRoZSBJRCBvZiB0aGUgbW9kdWxlIGFuZCB2YWx1ZSB0aGUgbW9kdWxlIG9yIGEgY29uZmlndXJhdGlvblxuXHQgKiBhcnJheSB0aGF0IGNhbiBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgbW9kdWxlLiBJbiB0aGUgbGF0dGVyIGNhc2UsIFtbSmlpLmNyZWF0ZU9iamVjdCgpXV1cblx0ICogd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgbW9kdWxlLlxuXHQgKlxuXHQgKiBJZiBhIG5ldyBzdWItbW9kdWxlIGhhcyB0aGUgc2FtZSBJRCBhcyBhbiBleGlzdGluZyBvbmUsIHRoZSBleGlzdGluZyBvbmUgd2lsbCBiZSBvdmVyd3JpdHRlbiBzaWxlbnRseS5cblx0ICpcblx0ICogVGhlIGZvbGxvd2luZyBpcyBhbiBleGFtcGxlIGZvciByZWdpc3RlcmluZyB0d28gc3ViLW1vZHVsZXM6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBbXG5cdCAqICAgICAnY29tbWVudCcgPT4gW1xuXHQgKiAgICAgICAgICdjbGFzcycgPT4gJ2FwcFxcbW9kdWxlc1xcY29tbWVudFxcQ29tbWVudE1vZHVsZScsXG5cdCAqICAgICAgICAgJ2RiJyA9PiAnZGInLFxuXHQgKiAgICAgXSxcblx0ICogICAgICdib29raW5nJyA9PiBbJ2NsYXNzJyA9PiAnYXBwXFxtb2R1bGVzXFxib29raW5nXFxCb29raW5nTW9kdWxlJ10sXG5cdCAqIF1cblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBtb2R1bGVzIG1vZHVsZXMgKGlkID0+IG1vZHVsZSBjb25maWd1cmF0aW9uIG9yIGluc3RhbmNlcylcblx0ICovXG5cdHNldE1vZHVsZXM6IGZ1bmN0aW9uIChtb2R1bGVzKSB7XG5cdFx0SmlpLl8uZWFjaChtb2R1bGVzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uIChtb2R1bGVPYmplY3QsIGlkKSB7XG5cdFx0XHR0aGlzLnNldE1vZHVsZShpZCwgbW9kdWxlT2JqZWN0KTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1bnMgYSBjb250cm9sbGVyIGFjdGlvbiBzcGVjaWZpZWQgYnkgYSByb3V0ZS5cblx0ICogVGhpcyBtZXRob2QgcGFyc2VzIHRoZSBzcGVjaWZpZWQgcm91dGUgYW5kIGNyZWF0ZXMgdGhlIGNvcnJlc3BvbmRpbmcgY2hpbGQgbW9kdWxlKHMpLCBjb250cm9sbGVyIGFuZCBhY3Rpb25cblx0ICogaW5zdGFuY2VzLiBJdCB0aGVuIGNhbGxzIFtbSmlpLmJhc2UuQ29udHJvbGxlcjo6cnVuQWN0aW9uKCldXSB0byBydW4gdGhlIGFjdGlvbiB3aXRoIHRoZSBnaXZlbiBwYXJhbWV0ZXJzLlxuXHQgKiBJZiB0aGUgcm91dGUgaXMgZW1wdHksIHRoZSBtZXRob2Qgd2lsbCB1c2UgW1tkZWZhdWx0Um91dGVdXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlIHRoZSByb3V0ZSB0aGF0IHNwZWNpZmllcyB0aGUgYWN0aW9uLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcblx0ICogQHJldHVybiB7UHJvbWlzZX0gdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uLlxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUm91dGVFeGNlcHRpb259IGlmIHRoZSByZXF1ZXN0ZWQgcm91dGUgY2Fubm90IGJlIHJlc29sdmVkIGludG8gYW4gYWN0aW9uIHN1Y2Nlc3NmdWxseVxuXHQgKi9cblx0cnVuQWN0aW9uOiBmdW5jdGlvbiAocm91dGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gdGhpcy5fcGFyc2VSb3V0ZShyb3V0ZSk7XG5cbiAgICAgICAgdmFyIGZ1bGxSb3V0ZSA9IHJvdXRlUGFyYW1zLmlkICsgJy8nICsgKHJvdXRlUGFyYW1zLnJvdXRlIHx8ICdpbmRleCcpO1xuICAgICAgICBpZiAoSmlpLl8uaGFzKHRoaXMuaW5saW5lQWN0aW9ucywgZnVsbFJvdXRlKSkge1xuICAgICAgICAgICAgdmFyIGFjdGlvbiA9IHRoaXMuaW5saW5lQWN0aW9uc1tmdWxsUm91dGVdIGluc3RhbmNlb2YgSmlpLmJhc2UuQWN0aW9uID9cbiAgICAgICAgICAgICAgICB0aGlzLmlubGluZUFjdGlvbnNbZnVsbFJvdXRlXSA6XG4gICAgICAgICAgICAgICAgbmV3IEppaS5yZXF1ZXN0LkFub255bW91c0FjdGlvbihmdWxsUm91dGUsIHRoaXMsIHRoaXMuaW5saW5lQWN0aW9uc1tmdWxsUm91dGVdKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlQWN0aW9uKGFjdGlvbiwgY29udGV4dCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24ucnVuV2l0aFBhcmFtcyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFKaWkuXy5pc1VuZGVmaW5lZChkYXRhKSAmJiBjb250ZXh0LnJlc3BvbnNlIGluc3RhbmNlb2YgSmlpLmJhc2UuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnJlc3BvbnNlLnNlbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmJlZm9yZUFjdGlvbihhY3Rpb24sIGNvbnRleHQpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSkuY2F0Y2goSmlpLmNhdGNoSGFuZGxlcik7XG4gICAgICAgIH1cblxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuY3JlYXRlQ29udHJvbGxlcihyb3V0ZSk7XG5cdFx0aWYgKHBhcnRzICE9PSBudWxsKSB7XG5cdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkNvbnRyb2xsZXJ9ICovXG5cdFx0XHR2YXIgY29udHJvbGxlciA9IHBhcnRzWzBdO1xuXHRcdFx0dmFyIGFjdGlvbklkID0gcGFydHNbMV07XG5cblx0XHRcdHJldHVybiBjb250cm9sbGVyLnJ1bkFjdGlvbihhY3Rpb25JZCwgY29udGV4dCk7XG5cdFx0fVxuXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRVbmlxdWVJZCgpO1xuXHRcdHZhciByZXF1ZXN0TmFtZSA9IGlkID8gaWQgKyAnLycgKyByb3V0ZSA6IHJvdXRlO1xuXHRcdC8vdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvbignVW5hYmxlIHRvIHJlc29sdmUgdGhlIHJlcXVlc3QgYCcgKyByZXF1ZXN0TmFtZSArICdgLicpO1xuXHRcdEppaS5pbmZvKCdVbmFibGUgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCBgJyArIHJlcXVlc3ROYW1lICsgJ2AuJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0ZXhpc3RzUm91dGU6IGZ1bmN0aW9uKHJvdXRlKSB7XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9IHRoaXMuX3BhcnNlUm91dGUocm91dGUpO1xuICAgICAgICB2YXIgaWQgPSByb3V0ZVBhcmFtcy5pZDtcbiAgICAgICAgcm91dGUgPSByb3V0ZVBhcmFtcy5yb3V0ZTtcblxuICAgICAgICBpZiAoSmlpLl8uaGFzKHRoaXMuaW5saW5lQWN0aW9ucywgaWQgKyAnLycgKyAocm91dGUgfHwgJ2luZGV4JykpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG5cdFx0aWYgKEppaS5fLmhhcyh0aGlzLmNvbnRyb2xsZXJNYXAsIGlkKSkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0dmFyIG1vZHVsZU9iamVjdCA9IHRoaXMuZ2V0TW9kdWxlKGlkKTtcblx0XHRpZiAobW9kdWxlT2JqZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbW9kdWxlT2JqZWN0LmV4aXN0c1JvdXRlKHJvdXRlKTtcblx0XHR9XG5cblx0XHRpZiAoL15bYS16MC05XFxcXC1fXSskLy50ZXN0KGlkKSkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IGlkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaWQuc2xpY2UoMSk7XG5cdFx0XHRjbGFzc05hbWUgPSBjbGFzc05hbWUucmVwbGFjZSgnLScsICcnKSArICdDb250cm9sbGVyJztcblx0XHRcdGNsYXNzTmFtZSA9IHRoaXMuY29udHJvbGxlck5hbWVzcGFjZSArICcuJyArIGNsYXNzTmFtZTtcblxuXHRcdFx0dmFyIGNvbnRyb2xsZXJDbGFzcyA9IEppaS5uYW1lc3BhY2UoY2xhc3NOYW1lKTtcblx0XHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJDbGFzcykpIHtcblx0XHRcdFx0dmFyIGNvbnRyb2xsZXIgPSBuZXcgY29udHJvbGxlckNsYXNzKGlkLCB0aGlzKTtcblx0XHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIuaGFzQWN0aW9uKHJvdXRlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBjb250cm9sbGVyIGluc3RhbmNlIGJhc2VkIG9uIHRoZSBjb250cm9sbGVyIElELlxuXHQgKlxuXHQgKiBUaGUgY29udHJvbGxlciBpcyBjcmVhdGVkIHdpdGhpbiB0aGlzIG1vZHVsZS4gVGhlIG1ldGhvZCBmaXJzdCBhdHRlbXB0cyB0b1xuXHQgKiBjcmVhdGUgdGhlIGNvbnRyb2xsZXIgYmFzZWQgb24gdGhlIFtbY29udHJvbGxlck1hcF1dIG9mIHRoZSBtb2R1bGUuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZSB0aGUgcm91dGUgY29uc2lzdGluZyBvZiBtb2R1bGUsIGNvbnRyb2xsZXIgYW5kIGFjdGlvbiBJRHMuXG5cdCAqIEByZXR1cm4ge1tdfG51bGx9IElmIHRoZSBjb250cm9sbGVyIGlzIGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LCBpdCB3aWxsIGJlIHJldHVybmVkIHRvZ2V0aGVyXG5cdCAqIHdpdGggdGhlIHJlcXVlc3RlZCBhY3Rpb24gSUQuIE90aGVyd2lzZSBmYWxzZSB3aWxsIGJlIHJldHVybmVkLlxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9ufSBpZiB0aGUgY29udHJvbGxlciBjbGFzcyBhbmQgaXRzIGZpbGUgZG8gbm90IG1hdGNoLlxuXHQgKi9cblx0Y3JlYXRlQ29udHJvbGxlcjogZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICAgIHZhciByb3V0ZVBhcmFtcyA9IHRoaXMuX3BhcnNlUm91dGUocm91dGUpO1xuICAgICAgICB2YXIgaWQgPSByb3V0ZVBhcmFtcy5pZDtcbiAgICAgICAgcm91dGUgPSByb3V0ZVBhcmFtcy5yb3V0ZTtcblxuXHRcdHZhciBjb250cm9sbGVyID0gbnVsbDtcblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuY29udHJvbGxlck1hcCwgaWQpKSB7XG5cdFx0XHRjb250cm9sbGVyID0gSmlpLmNyZWF0ZU9iamVjdCh0aGlzLmNvbnRyb2xsZXJNYXBbaWRdLCBpZCwgdGhpcyk7XG5cdFx0XHRyZXR1cm4gY29udHJvbGxlciAhPT0gbnVsbCA/IFtjb250cm9sbGVyLCByb3V0ZV0gOiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciBtb2R1bGVPYmplY3QgPSB0aGlzLmdldE1vZHVsZShpZCk7XG5cdFx0aWYgKG1vZHVsZU9iamVjdCAhPT0gbnVsbCkge1xuXHRcdFx0cmV0dXJuIG1vZHVsZU9iamVjdC5jcmVhdGVDb250cm9sbGVyKHJvdXRlKTtcblx0XHR9XG5cblx0XHRpZiAoL15bYS16MC05XFxcXC1fXSskLy50ZXN0KGlkKSkge1xuXG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gaWQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpZC5zbGljZSgxKTtcblx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKCctJywgJycpICsgJ0NvbnRyb2xsZXInO1xuXHRcdFx0Y2xhc3NOYW1lID0gdGhpcy5jb250cm9sbGVyTmFtZXNwYWNlICsgJy4nICsgY2xhc3NOYW1lO1xuXG4gICAgICAgICAgICAvLyBDYWNoZSBjb250cm9sbGVyIGluc3RhbmNlc1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jb250cm9sbGVyc1tjbGFzc05hbWVdKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgY29udHJvbGxlckNsYXNzID0gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChKaWkuXy5pc0Z1bmN0aW9uKGNvbnRyb2xsZXJDbGFzcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udHJvbGxlcnNbY2xhc3NOYW1lXSA9IG5ldyBjb250cm9sbGVyQ2xhc3MoaWQsIHRoaXMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHRoaXMuX2NvbnRyb2xsZXJzW2NsYXNzTmFtZV0gaW5zdGFuY2VvZiBKaWkuYmFzZS5Db250cm9sbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oXCJDb250cm9sbGVyIGNsYXNzIG11c3QgZXh0ZW5kIGZyb20gSmlpLmJhc2UuQ29udHJvbGxlci5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cdFx0XHR9XG4gICAgICAgICAgICBjb250cm9sbGVyID0gdGhpcy5fY29udHJvbGxlcnNbY2xhc3NOYW1lXSB8fCBudWxsO1xuXHRcdH1cblxuXHRcdHJldHVybiBjb250cm9sbGVyICE9PSBudWxsID8gW2NvbnRyb2xsZXIsIHJvdXRlXSA6IG51bGw7XG5cdH0sXG5cbiAgICBfcGFyc2VSb3V0ZTogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgaWYgKHJvdXRlID09PSAnJykge1xuICAgICAgICAgICAgcm91dGUgPSB0aGlzLmRlZmF1bHRSb3V0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJvdXRlID0gSmlpLl9zLnRyaW0ocm91dGUsICcvJyk7XG5cbiAgICAgICAgdmFyIGluZGV4ID0gcm91dGUuaW5kZXhPZignLycpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlkOiByb3V0ZS5zdWJzdHIoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgIHJvdXRlOiByb3V0ZS5zdWJzdHIoaW5kZXggKyAxKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHJvdXRlLFxuICAgICAgICAgICAgcm91dGU6ICcnXG4gICAgICAgIH1cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHJpZ2h0IGJlZm9yZSBhbiBhY3Rpb24gb2YgdGhpcyBtb2R1bGUgaXMgdG8gYmUgZXhlY3V0ZWQgKGFmdGVyIGFsbCBwb3NzaWJsZSBmaWx0ZXJzLilcblx0ICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkbyBsYXN0LW1pbnV0ZSBwcmVwYXJhdGlvbiBmb3IgdGhlIGFjdGlvbi5cblx0ICogTWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgcmVsZXZhbnQgZXZlbnQgaXMgdHJpZ2dlcmVkLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGlvbn0gYWN0aW9uIHRoZSBhY3Rpb24gdG8gYmUgZXhlY3V0ZWQuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHQgKi9cblx0YmVmb3JlQWN0aW9uOiBmdW5jdGlvbiAoYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0JFRk9SRV9BQ1RJT04sIG5ldyBKaWkuYmFzZS5BY3Rpb25FdmVudCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIHJpZ2h0IGFmdGVyIGFuIGFjdGlvbiBvZiB0aGlzIG1vZHVsZSBoYXMgYmVlbiBleGVjdXRlZC5cblx0ICogWW91IG1heSBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBkbyBzb21lIHBvc3Rwcm9jZXNzaW5nIGZvciB0aGUgYWN0aW9uLlxuXHQgKiBNYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHRoZSByZWxldmFudCBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aW9ufSBhY3Rpb24gdGhlIGFjdGlvbiBqdXN0IGV4ZWN1dGVkLlxuICAgICAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRhZnRlckFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9BQ1RJT04sIG5ldyBKaWkuYmFzZS5BY3Rpb25FdmVudCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9Db250ZXh0XCI6MTMyfV0sMTM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxuLyoqXG4gKlxuICogQGNsYXNzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk9iamVjdCcsIC8qKiBAbGVuZHMgSmlpLmJhc2UuT2JqZWN0LnByb3RvdHlwZSAqL3tcblxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5PYmplY3QgKi97XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gZnVsbCBjbGFzcyBuYW1lIHdpdGggbmFtZXNwYWNlXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHRjbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9fY2xhc3NOYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm4gZXh0ZW5kZWQgY2xhc3MgbmFtZSB3aXRoIG5hbWVzcGFjZVxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0cGFyZW50Q2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fX3BhcmVudENsYXNzTmFtZTtcblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtIHtvYmplY3R9IFtjb25maWddXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChjb25maWcpIHtcblx0XHR0aGlzLl9fc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuXHRcdC8vIEFwcGx5IGNvbmZpZ3VyYXRpb24gdG8gaW5zdGFuY2Vcblx0XHRpZiAoSmlpLl8uaXNPYmplY3QoY29uZmlnKSkge1xuXHRcdFx0SmlpLmNvbmZpZ3VyZSh0aGlzLCBjb25maWcpO1xuXHRcdH1cblxuXHRcdC8vIFJ1biBjdXN0b20gaW5pdCBtZXRob2Rcblx0XHR0aGlzLmluaXQoKTtcblx0fSxcblxuXHQvKipcblx0ICogQ3VzdG9taXplZCBpbml0aWFsaXplIG1ldGhvZFxuXHQgKi9cblx0aW5pdDogZnVuY3Rpb24gKCkge1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNZXRob2QgZGVmaW5lZCBqc2RvYyBmb3IgaGlkZSBlcnJvcnMgaW4gSURFXG5cdCAqIEBwYXJhbSB7Li4uKn0gW3BhcmFtc11cblx0ICogQHByb3RlY3RlZFxuXHQgKi9cblx0X19zdXBlcjogZnVuY3Rpb24gKHBhcmFtcykge1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZnVsbCBjbGFzcyBuYW1lIHdpdGggbmFtZXNwYWNlXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdCAqL1xuXHRjbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fX2NsYXNzTmFtZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIGV4dGVuZGVkIGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdHBhcmVudENsYXNzTmFtZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9fcGFyZW50Q2xhc3NOYW1lO1xuXHR9XG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNX1dLDEzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5SZXF1ZXN0XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5SZXF1ZXN0JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5SZXF1ZXN0LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMge3N0cmluZ3xudWxsfVxuXHQgKi9cblx0Z2V0TWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlc29sdmVzIHRoZSBjdXJyZW50IHJlcXVlc3QgaW50byBhIHJvdXRlIGFuZCB0aGUgYXNzb2NpYXRlZCBwYXJhbWV0ZXJzLlxuXHQgKiBAcmV0dXJucyB7YXJyYXl8bnVsbH0gdGhlIGZpcnN0IGVsZW1lbnQgaXMgdGhlIHJvdXRlLCBhbmQgdGhlIHNlY29uZCBpcyB0aGUgYXNzb2NpYXRlZCBwYXJhbWV0ZXJzLlxuXHQgKi9cblx0cmVzb2x2ZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF9wYXRoSW5mbzogbnVsbCxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcGF0aCBpbmZvIG9mIHRoZSBjdXJyZW50bHkgcmVxdWVzdGVkIFVSTC5cblx0ICogQSBwYXRoIGluZm8gcmVmZXJzIHRvIHRoZSBwYXJ0IHRoYXQgaXMgYWZ0ZXIgdGhlIGVudHJ5IHNjcmlwdCBhbmQgYmVmb3JlIHRoZSBxdWVzdGlvbiBtYXJrIChxdWVyeSBzdHJpbmcpLlxuXHQgKiBUaGUgc3RhcnRpbmcgYW5kIGVuZGluZyBzbGFzaGVzIGFyZSBib3RoIHJlbW92ZWQuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IFBhcnQgb2YgdGhlIHJlcXVlc3QgVVJMIHRoYXQgaXMgYWZ0ZXIgdGhlIGVudHJ5IHNjcmlwdCBhbmQgYmVmb3JlIHRoZSBxdWVzdGlvbiBtYXJrLlxuXHQgKiBOb3RlLCB0aGUgcmV0dXJuZWQgcGF0aCBpbmZvIGlzIGFscmVhZHkgVVJMLWRlY29kZWQuXG5cdCAqL1xuXHRnZXRQYXRoSW5mbzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wYXRoSW5mbyA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcGF0aEluZm8gPSB0aGlzLl9wYXJzZVBhdGhJbmZvKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wYXRoSW5mbztcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGF0aCBpbmZvIG9mIHRoZSBjdXJyZW50IHJlcXVlc3QuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG1haW5seSBwcm92aWRlZCBmb3IgdGVzdGluZyBwdXJwb3NlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHBhdGggaW5mbyBvZiB0aGUgY3VycmVudCByZXF1ZXN0XG5cdCAqL1xuXHRzZXRQYXRoSW5mbzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF0aEluZm8gPSBKaWkuX3MubHRyaW0odmFsdWUsICcvJyk7XG5cdH0sXG5cblx0X3BhcnNlUGF0aEluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gJyc7XG5cdH0sXG5cblx0X2hvc3RJbmZvOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgY3VycmVudCByZXF1ZXN0IFVSTC5cblx0ICogVGhlIHJldHVybmVkIFVSTCBkb2VzIG5vdCBoYXZlIGFuIGVuZGluZyBzbGFzaC5cblx0ICogQnkgZGVmYXVsdCB0aGlzIGlzIGRldGVybWluZWQgYmFzZWQgb24gdGhlIHVzZXIgcmVxdWVzdCBpbmZvcm1hdGlvbi5cblx0ICogWW91IG1heSBleHBsaWNpdGx5IHNwZWNpZnkgaXQgYnkgc2V0dGluZyB0aGUgc2V0SG9zdEluZm8oKS5cblx0ICogQHJldHVybiB7c3RyaW5nfSBTY2hlbWEgYW5kIGhvc3RuYW1lIHBhcnQgKHdpdGggcG9ydCBudW1iZXIgaWYgbmVlZGVkKSBvZiB0aGUgcmVxdWVzdCBVUkxcblx0ICovXG5cdGdldEhvc3RJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2hvc3RJbmZvID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9ob3N0SW5mbyA9IHRoaXMuX3BhcnNlSG9zdEluZm8oKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2hvc3RJbmZvO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgYXBwbGljYXRpb24gVVJMLlxuXHQgKiBUaGlzIHNldHRlciBpcyBwcm92aWRlZCBpbiBjYXNlIHRoZSBzY2hlbWEgYW5kIGhvc3RuYW1lIGNhbm5vdCBiZSBkZXRlcm1pbmVkXG5cdCAqIG9uIGNlcnRhaW4gV2ViIHNlcnZlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgc2NoZW1hIGFuZCBob3N0IHBhcnQgb2YgdGhlIGFwcGxpY2F0aW9uIFVSTC4gVGhlIHRyYWlsaW5nIHNsYXNoZXMgd2lsbCBiZSByZW1vdmVkLlxuXHQgKi9cblx0c2V0SG9zdEluZm86IGZ1bmN0aW9uICh2YWx1ZSkge1xuXHRcdHRoaXMuX2hvc3RJbmZvID0gSmlpLl9zLnJ0cmltKHZhbHVlLCAnLycpO1xuXHRcdHJldHVybiB0aGlzLl9ob3N0SW5mbztcblx0fSxcblxuXHRfcGFyc2VIb3N0SW5mbzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjV9XSwxNDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuUmVzcG9uc2VcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLlJlc3BvbnNlJywge1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtib29sZWFufSB3aGV0aGVyIHRoZSByZXNwb25zZSBoYXMgYmVlbiBzZW50LiBJZiB0aGlzIGlzIHRydWUsIGNhbGxpbmcgW1tzZW5kKCldXSB3aWxsIGRvIG5vdGhpbmcuXG5cdCAqL1xuXHRpc1NlbnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIG9yaWdpbmFsIHJlc3BvbnNlIGRhdGFcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICBkYXRhOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBTZW5kcyB0aGUgcmVzcG9uc2UgdG8gY2xpZW50LlxuXHQgKi9cblx0c2VuZDogZnVuY3Rpb24gKCkge1xuXHR9XG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNX1dLDE0MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBFcnJvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uJywgLyoqIEBsZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbi5wcm90b3R5cGUgKi8ge1xuXG5cdF9fZXh0ZW5kczogRXJyb3IsXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG5cdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLl9fc3RhdGljKTtcblx0XHR9XG5cdFx0dGhpcy5uYW1lID0gdGhpcy5fX2NsYXNzTmFtZTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuXHR9XG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjV9XSwxNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0FwcGxpY2F0aW9uRXhjZXB0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9uJywgLyoqIEBsZW5kcyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0FwcGxpY2F0aW9uRXhjZXB0aW9uXCI6MTQxfV0sMTQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9BcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24nLCAvKiogQGxlbmRzIEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24ucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9BcHBsaWNhdGlvbkV4Y2VwdGlvblwiOjE0MX1dLDE0NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQXBwbGljYXRpb25FeGNlcHRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbicsIC8qKiBAbGVuZHMgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vQXBwbGljYXRpb25FeGNlcHRpb25cIjoxNDF9XSwxNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0FwcGxpY2F0aW9uRXhjZXB0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvblxuICogQGV4dGVuZHMgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUm91dGVFeGNlcHRpb24nLCAvKiogQGxlbmRzIEppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0FwcGxpY2F0aW9uRXhjZXB0aW9uXCI6MTQxfV0sMTQ2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9BcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb25cbiAqIEBleHRlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uJywgLyoqIEBsZW5kcyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24ucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9BcHBsaWNhdGlvbkV4Y2VwdGlvblwiOjE0MX1dLDE0NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQXBwbGljYXRpb25FeGNlcHRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLlVua25vd25Qcm9wZXJ0eUV4Y2VwdGlvbicsIC8qKiBAbGVuZHMgSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vQXBwbGljYXRpb25FeGNlcHRpb25cIjoxNDF9XSwxNDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuLi9iYXNlL09iamVjdCcpO1xuXG4vKipcbiAqIEJhc2VGaWxlSGVscGVyIHByb3ZpZGVzIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIGZvciBbW0ZpbGVIZWxwZXJdXS5cbiAqXG4gKiBEbyBub3QgdXNlIEJhc2VGaWxlSGVscGVyLiBVc2UgW1tGaWxlSGVscGVyXV0gaW5zdGVhZC5cbiAqXG4gKiBAY2xhc3MgSmlpLmhlbHBlcnMuRmlsZVxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmhlbHBlcnMuRmlsZScsIC8qKiBAbGVuZHMgSmlpLmhlbHBlcnMuRmlsZS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmhlbHBlcnMuRmlsZSAqL3tcblxuXHRcdFBBVFRFUk5fTk9ESVI6IDEsXG5cdFx0UEFUVEVSTl9FTkRTV0lUSDogNCxcblx0XHRQQVRURVJOX01VU1RCRURJUjogOCxcblx0XHRQQVRURVJOX05FR0FUSVZFOiAxNixcblx0XHRQQVRURVJOX0NBU0VfSU5TRU5TSVRJVkU6IDMyLFxuXG5cdFx0LyoqXG5cdFx0ICogQHR5cGUge3N0cmluZ30gdGhlIHBhdGggKG9yIGFsaWFzKSBvZiBhIFBIUCBmaWxlIGNvbnRhaW5pbmcgTUlNRSB0eXBlIGluZm9ybWF0aW9uLlxuXHRcdCAqL1xuXHRcdG1pbWVNYWdpY0ZpbGU6ICdAamlpL2hlbHBlcnMvbWltZVR5cGVzLnBocCcsXG5cblx0XHRnZXRGaWxlRGlyZWN0b3J5OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC9cXC8/W15cXC9dKyQvLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldEZpbGVOYW1lOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5yZXBsYWNlKC8oLipcXC8pPyhbXlxcL10rKSQvLCAnJDInKTtcblx0XHR9LFxuXG5cdFx0Z2V0RmlsZUV4dGVuc2lvbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSAvXFwuKFthLXpdKykkLy5leGVjKHBhdGgpO1xuXHRcdFx0cmV0dXJuIG1hdGNoZXMgIT09IG51bGwgPyBtYXRjaGVzWzFdIDogJyc7XG5cdFx0fSxcblxuXHRcdGlzRmlsZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGgubWF0Y2goL1teXFwvXStcXC5bXlxcL10rJC8pICE9PSBudWxsO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBOb3JtYWxpemVzIGEgZmlsZS9kaXJlY3RvcnkgcGF0aC5cblx0XHQgKiBUaGUgbm9ybWFsaXphdGlvbiBkb2VzIHRoZSBmb2xsb3dpbmcgd29yazpcblx0XHQgKlxuXHRcdCAqIC0gQ29udmVydCBhbGwgZGlyZWN0b3J5IHNlcGFyYXRvcnMgaW50byBgRElSRUNUT1JZX1NFUEFSQVRPUmAgKGUuZy4gXCJcXGEvYlxcY1wiIGJlY29tZXMgXCIvYS9iL2NcIilcblx0XHQgKiAtIFJlbW92ZSB0cmFpbGluZyBkaXJlY3Rvcnkgc2VwYXJhdG9ycyAoZS5nLiBcIi9hL2IvYy9cIiBiZWNvbWVzIFwiL2EvYi9jXCIpXG5cdFx0ICogLSBUdXJuIG11bHRpcGxlIGNvbnNlY3V0aXZlIHNsYXNoZXMgaW50byBhIHNpbmdsZSBvbmUgKGUuZy4gXCIvYS8vL2IvY1wiIGJlY29tZXMgXCIvYS9iL2NcIilcblx0XHQgKiAtIFJlbW92ZSBcIi4uXCIgYW5kIFwiLlwiIGJhc2VkIG9uIHRoZWlyIG1lYW5pbmdzIChlLmcuIFwiL2EvLi9iLy4uL2NcIiBiZWNvbWVzIFwiL2EvY1wiKVxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIGZpbGUvZGlyZWN0b3J5IHBhdGggdG8gYmUgbm9ybWFsaXplZFxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbZHNdIHRoZSBkaXJlY3Rvcnkgc2VwYXJhdG9yIHRvIGJlIHVzZWQgaW4gdGhlIG5vcm1hbGl6ZWQgcmVzdWx0LiBEZWZhdWx0cyB0byBgRElSRUNUT1JZX1NFUEFSQVRPUmAuXG5cdFx0ICogQHJldHVybnMge3N0cmluZ30gdGhlIG5vcm1hbGl6ZWQgZmlsZS9kaXJlY3RvcnkgcGF0aFxuXHRcdCAqL1xuXHRcdG5vcm1hbGl6ZVBhdGg6IGZ1bmN0aW9uIChwYXRoLCBkcykge1xuXHRcdFx0ZHMgPSBkcyB8fCAnLyc7XG5cblx0XHRcdHBhdGggPSBKaWkuX3MucnRyaW0ocGF0aC5yZXBsYWNlKC9cXC9cXFxcL2csIGRzICsgZHMpLCBkcyk7XG5cdFx0XHRpZiAoKGRzICsgcGF0aCkuaW5kZXhPZihkcyArICcuJykgPT09IC0xICYmIHBhdGguaW5kZXhPZihkcyArIGRzKSA9PT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHRoZSBwYXRoIG1heSBjb250YWluIFwiLlwiLCBcIi4uXCIgb3IgZG91YmxlIHNsYXNoZXMsIG5lZWQgdG8gY2xlYW4gdGhlbSB1cFxuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRKaWkuXy5lYWNoKHBhdGguc3BsaXQoZHMpLCBmdW5jdGlvbihwYXJ0KSB7XG5cdFx0XHRcdGlmIChwYXJ0ID09PSAnLi4nICYmIHBhcnRzLmxlbmd0aCA+IDAgJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gIT09ICcuLicpIHtcblx0XHRcdFx0XHRwYXJ0cy5wb3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAocGFydCA9PT0gJy4nIHx8IChwYXJ0ID09PSAnJyAmJiBwYXJ0cy5sZW5ndGggPiAwKSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHBhcnRzLnB1c2gocGFydCk7XG5cdFx0XHR9KTtcblxuXHRcdFx0cGF0aCA9IHBhcnRzLmpvaW4oZHMpO1xuXHRcdFx0cmV0dXJuIHBhdGggPT09ICcnID8gJy4nIDogcGF0aDtcblx0XHR9XG5cdH1cblxufSk7XG59LHtcIi4uL0ppaVwiOjEyNSxcIi4uL2Jhc2UvT2JqZWN0XCI6MTM4fV0sMTQ5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi4vYmFzZS9PYmplY3QnKTtcblxuLyoqXG4gKiBCYXNlRmlsZUhlbHBlciBwcm92aWRlcyBjb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBmb3IgW1tGaWxlSGVscGVyXV0uXG4gKlxuICogRG8gbm90IHVzZSBCYXNlRmlsZUhlbHBlci4gVXNlIFtbRmlsZUhlbHBlcl1dIGluc3RlYWQuXG4gKlxuICogQGNsYXNzIEppaS5oZWxwZXJzLlN0cmluZ1xuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmhlbHBlcnMuU3RyaW5nJywgLyoqIEBsZW5kcyBKaWkuaGVscGVycy5TdHJpbmcucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5oZWxwZXJzLlN0cmluZyAqL3tcblxuXHRcdC8qKlxuXHRcdCAqIEdlbmVyYXRlIHVuaXF1ZSBoYXNoIGZvciBzdHJpbmcuIGh0dHA6Ly9qc3BlcmYuY29tL2hhc2hjb2RlbG9yZHZsYWRcblx0XHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG5cdFx0ICogQHJldHVybnMge1N0cmluZ31cblx0XHQgKi9cblx0XHRoYXNoQ29kZTogZnVuY3Rpb24oc3RyKXtcblx0XHRcdHJldHVybiBzdHIuc3BsaXQoXCJcIikucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG5cdFx0XHRcdGEgPSAoKGEgPDwgNSkgLSBhKSArIGIuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0cmV0dXJuIGEgJiBhO1xuXHRcdFx0fSwgMCkudG9TdHJpbmcoKS5yZXBsYWNlKC8tL2csICcxJyk7XG5cdFx0fSxcblxuXHRcdGdlbmVyYXRlVWlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCBmdW5jdGlvbihjKSB7XG5cdFx0XHRcdHZhciByID0gTWF0aC5yYW5kb20oKSoxNnwwO1xuXHRcdFx0XHR2YXIgdiA9IGMgPT0gJ3gnID8gciA6IChyJjB4M3wweDgpO1xuXG5cdFx0XHRcdHJldHVybiB2LnRvU3RyaW5nKDE2KTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHR9XG5cbn0pO1xufSx7XCIuLi9KaWlcIjoxMjUsXCIuLi9iYXNlL09iamVjdFwiOjEzOH1dLDE1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4uL2Jhc2UvT2JqZWN0Jyk7XG5cbi8qKlxuICpcbiAqIEBjbGFzcyBKaWkuaGVscGVycy5VcmxcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5oZWxwZXJzLlVybCcsIC8qKiBAbGVuZHMgSmlpLmhlbHBlcnMuVXJsLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuaGVscGVycy5VcmwgKi97XG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIGEgVVJMIGlzIHJlbGF0aXZlLlxuXHRcdCAqIEEgcmVsYXRpdmUgVVJMIGRvZXMgbm90IGhhdmUgaG9zdCBpbmZvIHBhcnQuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHVybCB0aGUgVVJMIHRvIGJlIGNoZWNrZWRcblx0XHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgVVJMIGlzIHJlbGF0aXZlXG5cdFx0ICovXG5cdFx0aXNSZWxhdGl2ZTogZnVuY3Rpb24gKHVybCkge1xuXHRcdFx0cmV0dXJuIHVybC5pbmRleE9mKCcvLycpICE9PSAwICYmIHVybC5pbmRleE9mKCc6Ly8nKSA9PT0gLTE7XG5cdFx0fVxuXHR9XG5cbn0pO1xufSx7XCIuLi9KaWlcIjoxMjUsXCIuLi9iYXNlL09iamVjdFwiOjEzOH1dLDE1MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcclxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcclxuXHJcbnJlcXVpcmUoJy4uL2Jhc2UvQWN0aW9uJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEppaS5yZXF1ZXN0LkFub255bW91c0FjdGlvblxyXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5BY3Rpb25cclxuICovXHJcbkppaS5kZWZpbmVDbGFzcygnSmlpLnJlcXVlc3QuQW5vbnltb3VzQWN0aW9uJywgLyoqIEBsZW5kcyBKaWkucmVxdWVzdC5Bbm9ueW1vdXNBY3Rpb24ucHJvdG90eXBlICove1xyXG5cclxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkFjdGlvbixcclxuXHJcblx0LyoqXHJcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIGNvbnRyb2xsZXIgbWV0aG9kIHRoYXQgIHRoaXMgaW5saW5lIGFjdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGhcclxuXHQgKi9cclxuXHRyb3V0ZTogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtmdW5jdGlvbn1cclxuICAgICAqL1xyXG4gICAgaGFuZGxlcjogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtKaWkuYmFzZS5Nb2R1bGV9XHJcbiAgICAgKi9cclxuICAgIG1vZHVsZTogbnVsbCxcclxuXHJcblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChyb3V0ZSwgbW9kdWxlLCBoYW5kbGVyLCBjb25maWcpIHtcclxuXHRcdHRoaXMucm91dGUgPSByb3V0ZTtcclxuXHRcdHRoaXMuaGFuZGxlciA9IGhhbmRsZXI7XHJcblx0XHR0aGlzLm1vZHVsZSA9IG1vZHVsZTtcclxuXHJcbiAgICAgICAgdmFyIGlkID0gcm91dGUuc3BsaXQoJy8nKS5wb3AoKTtcclxuXHRcdHRoaXMuX19zdXBlcihpZCwgbnVsbCwgY29uZmlnKTtcclxuXHR9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgdW5pcXVlIElEIG9mIHRoaXMgYWN0aW9uIGFtb25nIHRoZSB3aG9sZSBhcHBsaWNhdGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB1bmlxdWUgSUQgb2YgdGhpcyBhY3Rpb24gYW1vbmcgdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxyXG4gICAgICovXHJcbiAgICBnZXRVbmlxdWVJZDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlO1xyXG4gICAgfSxcclxuXHJcblx0LyoqXHJcblx0ICogUnVucyB0aGlzIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cclxuXHQgKiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgaW52b2tlZCBieSB0aGUgY29udHJvbGxlci5cclxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcclxuXHQgKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uXHJcblx0ICovXHJcblx0cnVuV2l0aFBhcmFtczogZnVuY3Rpb24gKGNvbnRleHQpIHtcclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlci5jYWxsKHRoaXMubW9kdWxlLCBjb250ZXh0KTtcclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cdH1cclxufSk7XHJcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuLi9iYXNlL0FjdGlvblwiOjEyN31dLDE1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG4vKipcbiAqIEhlYWRlckNvbGxlY3Rpb24gaXMgdXNlZCBieSBbW0ppaS5iYXNlLlJlc3BvbnNlXV0gdG8gbWFpbnRhaW4gdGhlIGN1cnJlbnRseSByZWdpc3RlcmVkIEhUVFAgaGVhZGVycy5cbiAqXG4gKiBAY2xhc3MgSmlpLnJlcXVlc3QuSGVhZGVyQ29sbGVjdGlvblxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnJlcXVlc3QuSGVhZGVyQ29sbGVjdGlvbicsIC8qKiBAbGVuZHMgSmlpLnJlcXVlc3QuSGVhZGVyQ29sbGVjdGlvbiAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuICAgIF9oZWFkZXJzOiBudWxsLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbmFtZWQgaGVhZGVyKHMpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXIgdG8gcmV0dXJuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSB0aGUgdmFsdWUgdG8gcmV0dXJuIGluIGNhc2UgdGhlIG5hbWVkIGhlYWRlciBkb2VzIG5vdCBleGlzdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRmlyc3RdIHdoZXRoZXIgdG8gb25seSByZXR1cm4gdGhlIGZpcnN0IGhlYWRlciBvZiB0aGUgc3BlY2lmaWVkIG5hbWUuXG4gICAgICogSWYgZmFsc2UsIGFsbCBoZWFkZXJzIG9mIHRoZSBzcGVjaWZpZWQgbmFtZSB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEByZXR1cm4gW3N0cmluZ3xhcnJheV0gdGhlIG5hbWVkIGhlYWRlcihzKS4gSWYgYGZpcnN0YCBpcyB0cnVlLCBhIHN0cmluZyB3aWxsIGJlIHJldHVybmVkO1xuICAgICAqIElmIGBmaXJzdGAgaXMgZmFsc2UsIGFuIGFycmF5IHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICovXG4gICAgZ2V0OiBmdW5jdGlvbihuYW1lLCBkZWZhdWx0VmFsdWUsIGlzRmlyc3QpIHtcbiAgICAgICAgZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG4gICAgICAgIGlmIChKaWkuXy5pc1VuZGVmaW5lZChpc0ZpcnN0KSkge1xuICAgICAgICAgICAgaXNGaXJzdCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoSmlpLl8uaGFzKHRoaXMuX2hlYWRlcnMsIG5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNGaXJzdCA/IEppaS5fLmZpcnN0KHRoaXMuX2hlYWRlcnNbbmFtZV0pIDogdGhpcy5faGVhZGVyc1tuYW1lXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgaGVhZGVyLlxuICAgICAqIElmIHRoZXJlIGlzIGFscmVhZHkgYSBoZWFkZXIgd2l0aCB0aGUgc2FtZSBuYW1lLCBpdCB3aWxsIGJlIHJlcGxhY2VkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4ge3N0YXRpY30gdGhlIGNvbGxlY3Rpb24gb2JqZWN0IGl0c2VsZlxuICAgICAqL1xuICAgIHNldDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSB8fCAnJztcblxuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB0aGlzLl9oZWFkZXJzW25hbWVdID0gSmlpLl8uaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZSA6IFt2YWx1ZV07XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgaGVhZGVyLlxuICAgICAqIElmIHRoZXJlIGlzIGFscmVhZHkgYSBoZWFkZXIgd2l0aCB0aGUgc2FtZSBuYW1lLCB0aGUgbmV3IG9uZSB3aWxsXG4gICAgICogYmUgYXBwZW5kZWQgdG8gaXQgaW5zdGVhZCBvZiByZXBsYWNpbmcgaXQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4ge3N0YXRpY30gdGhlIGNvbGxlY3Rpb24gb2JqZWN0IGl0c2VsZlxuICAgICAqL1xuICAgIGFkZDogZnVuY3Rpb24obmFtZSwgdmFsdWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkodGhpcy5faGVhZGVyc1tuYW1lXSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hlYWRlcnNbbmFtZV0gPSB0aGlzLl9oZWFkZXJzW25hbWVdLmNvbmNhdCh2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyBhIG5ldyBoZWFkZXIgb25seSBpZiBpdCBkb2VzIG5vdCBleGlzdCB5ZXQuXG4gICAgICogSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSBuZXcgb25lIHdpbGwgYmUgaWdub3JlZC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFt2YWx1ZV0gdGhlIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAgICAgKiBAcmV0dXJuIHtzdGF0aWN9IHRoZSBjb2xsZWN0aW9uIG9iamVjdCBpdHNlbGZcbiAgICAgKi9cbiAgICBzZXREZWZhdWx0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xuXG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBuYW1lZCBoZWFkZXIgZXhpc3RzLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXJcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBuYW1lZCBoZWFkZXIgZXhpc3RzXG4gICAgICovXG4gICAgaGFzOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBKaWkuXy5oYXModGhpcy5faGVhZGVycywgbmFtZSkgJiYgdGhpcy5faGVhZGVyc1tuYW1lXS5sZW5ndGggPiAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgaGVhZGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXIgdG8gYmUgcmVtb3ZlZC5cbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH0gdGhlIHZhbHVlIG9mIHRoZSByZW1vdmVkIGhlYWRlci4gTnVsbCBpcyByZXR1cm5lZCBpZiB0aGUgaGVhZGVyIGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIHJlbW92ZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoSmlpLl8uaGFzKHRoaXMuX2hlYWRlcnMsIG5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLl9oZWFkZXJzW25hbWVdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2hlYWRlcnNbbmFtZV07XG5cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwgaGVhZGVycy5cbiAgICAgKi9cbiAgICByZW1vdmVBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9oZWFkZXJzID0ge307XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNvbGxlY3Rpb24gYXMgYSBrZXktdmFsdWUgb2JqZWN0LlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgICB0b09iamVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWFkZXJzID0ge307XG4gICAgICAgIEppaS5fLmVhY2godGhpcy5faGVhZGVycywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleV0gPSBKaWkuXy5maXJzdCh2YWx1ZSk7XG4gICAgICAgIH0sIHRoaXMpKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjV9XSwxNTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi4vYmFzZS9BY3Rpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnJlcXVlc3QuSW5saW5lQWN0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5BY3Rpb25cbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkucmVxdWVzdC5JbmxpbmVBY3Rpb24nLCAvKiogQGxlbmRzIEppaS5yZXF1ZXN0LklubGluZUFjdGlvbiAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkFjdGlvbixcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIGNvbnRyb2xsZXIgbWV0aG9kIHRoYXQgIHRoaXMgaW5saW5lIGFjdGlvbiBpcyBhc3NvY2lhdGVkIHdpdGhcblx0ICovXG5cdGFjdGlvbk1ldGhvZDogbnVsbCxcblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGlkLCBjb250cm9sbGVyLCBhY3Rpb25NZXRob2QsIGNvbmZpZykge1xuXHRcdHRoaXMuYWN0aW9uTWV0aG9kID0gYWN0aW9uTWV0aG9kO1xuXHRcdHRoaXMuX19zdXBlcihpZCwgY29udHJvbGxlciwgY29uZmlnKTtcblx0fSxcblxuXHQvKipcblx0ICogUnVucyB0aGlzIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cblx0ICogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGludm9rZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuXHQgKiBAcmV0dXJucyB7Kn0gdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uXG5cdCAqL1xuXHRydW5XaXRoUGFyYW1zOiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJbdGhpcy5hY3Rpb25NZXRob2RdLmNhbGwodGhpcy5jb250cm9sbGVyLCBjb250ZXh0KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0fVxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi4vYmFzZS9BY3Rpb25cIjoxMjd9XSwxNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3NyYy9OZWF0bmVzcycpO1xufSx7XCIuL3NyYy9OZWF0bmVzc1wiOjE1N31dLDE1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oTmVhdG5lc3MpIHtcblxuXHRyZXR1cm4gTmVhdG5lc3MuY3JlYXRlQ2xhc3MoJ05lYXRuZXNzLkV4Y2VwdGlvbicsIC8qKiBAbGVuZHMgTmVhdG5lc3MuRXhjZXB0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRcdF9fZXh0ZW5kczogRXJyb3IsXG5cblx0XHQvKipcblx0XHQgKiBUZXh0IG1lc3NhZ2Vcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdG1lc3NhZ2U6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBFeHRyYSBpbmZvcm1hdGlvbiBkdW1wc1xuXHRcdCAqIEB0eXBlIHtBcnJheX1cblx0XHQgKi9cblx0XHRleHRyYTogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEJhc2UgY2xhc3MgZm9yIGltcGxlbWVudCBleGNlcHRpb24uIFRoaXMgY2xhc3MgZXh0ZW5kIGZyb20gbmF0aXZlIEVycm9yIGFuZCBzdXBwb3J0XG5cdFx0ICogc3RhY2sgdHJhY2UgYW5kIG1lc3NhZ2UuXG5cdFx0ICogQGNvbnN0cnVjdHNcblx0XHQgKiBAZXh0ZW5kcyBFcnJvclxuXHRcdCAqL1xuXHRcdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuXHRcdFx0aWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG5cdFx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IgfHwgdGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblx0XHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG5cblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuXHRcdFx0XHR0aGlzLmV4dHJhID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fX3N1cGVyKCk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMubWVzc2FnZTtcblx0XHR9XG5cblx0fSk7XG5cbn07XG59LHt9XSwxNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5lYXRuZXNzKSB7XG5cblx0LyoqXG5cdCAqIEJhc2UgY2xhc3MuIEV4dGVuZCBhbGwgeW91IGJhc2UgY2xhc3NlcyBmcm9tIHRoaXMgY2xhc3MgZm9yIHRydWUgbmF2aWdhdGlvbiBpbiBJREVcblx0ICogYW5kIHN1cHBvcnQgbWV0aG9kcyBzdWNoIGFzIHtAbGluayBOZWF0bmVzcy5PYmplY3QjY2xhc3NOYW1lfVxuXHQgKiBAY2xhc3MgTmVhdG5lc3MuT2JqZWN0XG5cdCAqL1xuXHRyZXR1cm4gTmVhdG5lc3MuY3JlYXRlQ2xhc3MoJ05lYXRuZXNzLk9iamVjdCcsIHtcblxuXHRcdC8qKlxuXHRcdCAqIExpbmsgdG8gdXNlZCBjbGFzcy4gSWYgeW91IGFjY2VzcyB0byB0aGlzIHByb3BlcnR5IGluIGV4dGVuZHMgY2xhc3NlcywgdGhlbiB5b3UgZ2l2ZSB0b3AtbGV2ZWwgY2xhc3MuXG5cdFx0ICogQHR5cGUgeyp9XG5cdFx0ICovXG5cdFx0X19zdGF0aWM6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBGdWxsIGN1cnJlbnQgY2xhc3MgbmFtZSB3aXRoIG5hbWVzcGFjZVxuXHRcdCAqIEBleGFtcGxlIFJldHVybnMgdmFsdWUgZXhhbXBsZVxuXHRcdCAqICBhcHAuTXlDbGFzc1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9fY2xhc3NOYW1lOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogVW5pcXVlIGluc3RhbmNlIG5hbWVcblx0XHQgKiBAZXhhbXBsZSBSZXR1cm5zIHZhbHVlIGV4YW1wbGVcblx0XHQgKiAgYXBwLk15Q2xhc3M1MFxuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9faW5zdGFuY2VOYW1lOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRnVsbCBwYXJlbnQgKGV4dGVuZHMpIGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0XHQgKiBAZXhhbXBsZSBSZXR1cm5zIHZhbHVlIGV4YW1wbGVcblx0XHQgKiAgYXBwLk15QmFzZUNsYXNzXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X19wYXJlbnRDbGFzc05hbWU6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgY2xhc3MgbmFtZSB3aXRoIG5hbWVzcGFjZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogIGFwcC5NeUNsYXNzXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHRjbGFzc05hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX19jbGFzc05hbWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgdW5pcXVlIGluc3RhbmNlIG5hbWVcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICBhcHAuTXlDbGFzc1xuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0Y2xhc3NJbnN0YW5jZU5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX19pbnN0YW5jZU5hbWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgZnVsbCBwYXJlbnQgY2xhc3MgbmFtZSB3aXRoIG5hbWVzcGFjZVxuXHRcdCAqIEBleGFtcGxlXG5cdFx0ICogIGFwcC5NeUJhc2VDbGFzc1xuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0cGFyZW50Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9fcGFyZW50Q2xhc3NOYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDYWxsIHBhcmVudCBjbGFzcyBtZXRob2RzIHRocm91Z2ggdGhpcyBtZXRob2QuIFRoaXMgbWV0aG9kIHN1cHBvcnQgb25seSBzeW5jaHJvbm91cyBuZXN0ZWQgY2FsbHMuXG5cdFx0ICogQHBhcmFtIHsuLi4qfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfX3N1cGVyOiBmdW5jdGlvbiAoKSB7XG5cdFx0fVxuXG5cdH0pO1xuXG59O1xuXG59LHt9XSwxNTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG52YXIgZXh0ZW5kQ2xhc3MgPSByZXF1aXJlKCcuL2V4dGVuZENsYXNzJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG4vLyBGb3IgLm5vQ29uZmxpY3QoKSBpbXBsZW1lbnRhdGlvblxudmFyIGhhc1ByZXZpb3VzTmVhdG5lc3MgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaGFzT3duUHJvcGVydHkoJ05lYXRuZXNzJyk7XG52YXIgcHJldmlvdXNOZWF0bmVzcyA9IGhhc1ByZXZpb3VzTmVhdG5lc3MgPyB3aW5kb3cuTmVhdG5lc3MgOiBudWxsO1xuXG4vKipcbiAqIE5lYXRuZXNzIGNsYXNzXG4gKiBAZnVuY3Rpb24gTmVhdG5lc3NcbiAqL1xudmFyIE5lYXRuZXNzID0gZnVuY3Rpb24oKSB7XG5cblx0LyoqXG5cdCAqXG5cdCAqIEB0eXBlIHtvYmplY3R9XG5cdCAqL1xuXHR0aGlzLl9jb250ZXh0ID0ge307XG5cblx0dGhpcy5fY29udGV4dEtleXMgPSB7fTtcbn07XG5cbi8qKlxuICogQGZ1bmN0aW9uIE5lYXRuZXNzLnByb3RvdHlwZS5uZXdDb250ZXh0XG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVHbG9iYWxdIFNldCB0cnVlIGZvciByZW1vdmUgTmVhdG5lc3Mgb2JqZWN0IGZyb20gd2luZG93IChicm93c2VyIGdsb2JhbCBvYmplY3QpXG4gKiBAcmV0dXJucyB7TmVhdG5lc3N9XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5uZXdDb250ZXh0ID0gZnVuY3Rpb24ocmVtb3ZlR2xvYmFsKSB7XG5cdHJlbW92ZUdsb2JhbCA9IHJlbW92ZUdsb2JhbCB8fCBmYWxzZTtcblxuXHRpZiAocmVtb3ZlR2xvYmFsKSB7XG5cdFx0dGhpcy5ub0NvbmZsaWN0KCk7XG5cdH1cblxuXHRyZXR1cm4gbmV3IE5lYXRuZXNzKCk7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUubW92ZUNvbnRleHRcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV3Q29udGV4dCBOZXcgY29udGV4dCBvYmplY3RcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbW92ZUZyb21PbGRdIFNldCB0cnVlIGZvciByZW1vdmUga2V5cyBmcm9tIG9sZCBjb250ZXh0XG4gKiBAcmV0dXJucyB7TmVhdG5lc3N9XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5tb3ZlQ29udGV4dCA9IGZ1bmN0aW9uKG5ld0NvbnRleHQsIHJlbW92ZUZyb21PbGQpIHtcblx0cmVtb3ZlRnJvbU9sZCA9IHJlbW92ZUZyb21PbGQgfHwgZmFsc2U7XG5cblx0Zm9yICh2YXIga2V5IGluIHRoaXMuX2NvbnRleHRLZXlzKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRleHRLZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdG5ld0NvbnRleHRba2V5XSA9IHRoaXMuX2NvbnRleHRba2V5XTtcblx0XHRcdGlmIChyZW1vdmVGcm9tT2xkKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jb250ZXh0W2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cdHRoaXMuX2NvbnRleHQgPSBuZXdDb250ZXh0O1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb24gTmVhdG5lc3MucHJvdG90eXBlLm5vQ29uZmxpY3RcbiAqIEByZXR1cm5zIHtOZWF0bmVzc31cbiAqL1xuTmVhdG5lc3MucHJvdG90eXBlLm5vQ29uZmxpY3QgPSBmdW5jdGlvbigpIHtcblx0Ly8gUm9vdCBuYW1lc3BhY2Ugb2JqZWN0XG5cdHZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcblxuXHRpZiAoaGFzUHJldmlvdXNOZWF0bmVzcykge1xuXHRcdHJvb3QuTmVhdG5lc3MgPSBwcmV2aW91c05lYXRuZXNzO1xuXHR9IGVsc2Uge1xuXHRcdGRlbGV0ZSByb290Lk5lYXRuZXNzO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUubmFtZXNwYWNlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBGdWxsIG5hbWVzcGFjZSBuYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5OZWF0bmVzcy5wcm90b3R5cGUubmFtZXNwYWNlID0gZnVuY3Rpb24gKG5hbWUpIHtcblx0bmFtZSA9IG5hbWUgfHwgJyc7XG5cblx0dmFyIG5hbWVQYXJ0cyA9IG5hbWUuc3BsaXQoJy4nKTtcblx0dmFyIGN1cnJlbnRTY29wZSA9IHRoaXMuX2NvbnRleHQ7XG5cblx0aWYgKCFuYW1lKSB7XG5cdFx0cmV0dXJuIGN1cnJlbnRTY29wZTtcblx0fVxuXG5cdC8vIEZpbmQgb3IgY3JlYXRlXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIHNjb3BlTmFtZSA9IG5hbWVQYXJ0c1tpXTtcblx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0dGhpcy5fY29udGV4dEtleXNbc2NvcGVOYW1lXSA9IHRydWU7XG5cdFx0fVxuXG5cdFx0aWYgKCFjdXJyZW50U2NvcGVbc2NvcGVOYW1lXSkge1xuXHRcdFx0Y3VycmVudFNjb3BlW3Njb3BlTmFtZV0gPSB7XG5cdFx0XHRcdF9fY2xhc3NOYW1lOiBuYW1lUGFydHMuc2xpY2UoMCwgaSkuam9pbignLicpLFxuXHRcdFx0XHRfX3BhcmVudENsYXNzTmFtZTogbnVsbFxuXHRcdFx0fTtcblx0XHR9XG5cdFx0Y3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlW3Njb3BlTmFtZV07XG5cdH1cblxuXHRyZXR1cm4gY3VycmVudFNjb3BlO1xufTtcblxuLyoqXG4gKiBNZXRob2QgZm9yIGRlZmluZSBjbGFzc1xuICogQGZ1bmN0aW9uIE5lYXRuZXNzLnByb3RvdHlwZS5jcmVhdGVDbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGdsb2JhbE5hbWVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9ufG9iamVjdHxudWxsKX0gb3B0aW9uc09yRXh0ZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3RvdHlwZVByb3BlcnRpZXNdXG4gKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BlcnRpZXNdXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uIChnbG9iYWxOYW1lLCBvcHRpb25zT3JFeHRlbmQsIHByb3RvdHlwZVByb3BlcnRpZXMsIHN0YXRpY1Byb3BlcnRpZXMpIHtcblx0dmFyIHBhcmFtcyA9IGZvcm1hdHMucGFyc2VGb3JtYXQoZ2xvYmFsTmFtZSwgb3B0aW9uc09yRXh0ZW5kLCBwcm90b3R5cGVQcm9wZXJ0aWVzLCBzdGF0aWNQcm9wZXJ0aWVzKTtcblxuXHQvLyBTdXBwb3J0IGV4dGVuZHMgYW5kIG1peGlucyBhcyBzdHJpbmdzIGNsYXNzIG5hbWVzXG5cdGlmICh0eXBlb2YgcGFyYW1zWzJdID09PSAnc3RyaW5nJykge1xuXHRcdHBhcmFtc1syXSA9IHRoaXMubmFtZXNwYWNlKHBhcmFtc1syXSk7XG5cdH1cblx0dmFyIG1peGlucyA9IHBhcmFtc1s2XTtcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtaXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0aWYgKHR5cGVvZiBtaXhpbnNbaV0gPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRtaXhpbnNbaV0gPSB0aGlzLm5hbWVzcGFjZShtaXhpbnNbaV0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIFNob3cgZXJyb3IgaWYgbm90IGRlZmluZWQgZXh0ZW5kZWQgY2xhc3Ncblx0aWYgKHBhcmFtc1syXSAhPT0gbnVsbCAmJiB0eXBlb2YgcGFyYW1zWzJdICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdOb3QgZm91bmQgZXh0ZW5kIGNsYXNzIGZvciBgJyArIGdsb2JhbE5hbWUgKyAnYC4nKTtcblx0fVxuXG5cdHZhciBuZXdDbGFzcyA9IGV4dGVuZENsYXNzKHBhcmFtc1swXSwgcGFyYW1zWzFdLCBwYXJhbXNbMl0sIHBhcmFtc1s2XSwgcGFyYW1zWzNdLCBwYXJhbXNbNF0sIHBhcmFtc1s3XSk7XG5cdGZvcm1hdHMuYXBwbHlDbGFzc0NvbmZpZyhuZXdDbGFzcywgcGFyYW1zWzVdLCBwYXJhbXNbMF0sIHBhcmFtc1sxXSk7XG5cblx0cmV0dXJuIG5ld0NsYXNzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgZm9yIGRlZmluZSBjbGFzc1xuICogQGZ1bmN0aW9uIE5lYXRuZXNzLnByb3RvdHlwZS5kZWZpbmVDbGFzc1xuICogQHBhcmFtIHtzdHJpbmd9IGdsb2JhbE5hbWVcbiAqIEBwYXJhbSB7KGZ1bmN0aW9ufG9iamVjdHxudWxsKX0gb3B0aW9uc09yRXh0ZW5kXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3RvdHlwZVByb3BlcnRpZXNdXG4gKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BlcnRpZXNdXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5kZWZpbmVDbGFzcyA9IGZ1bmN0aW9uIChnbG9iYWxOYW1lLCBvcHRpb25zT3JFeHRlbmQsIHByb3RvdHlwZVByb3BlcnRpZXMsIHN0YXRpY1Byb3BlcnRpZXMpIHtcblx0dmFyIG5ld0NsYXNzID0gdGhpcy5jcmVhdGVDbGFzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR2YXIgbmFtZU9iamVjdCA9IGZvcm1hdHMucGFyc2VGdWxsTmFtZShnbG9iYWxOYW1lKTtcblxuXHR0aGlzLm5hbWVzcGFjZShuYW1lT2JqZWN0Lm5hbWVzcGFjZSlbbmFtZU9iamVjdC5uYW1lXSA9IG5ld0NsYXNzO1xuXHRyZXR1cm4gbmV3Q2xhc3M7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBmb3IgZGVmaW5lIGVudW1cbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUuZGVmaW5lQ2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nfSBnbG9iYWxOYW1lXG4gKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BlcnRpZXNdXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5kZWZpbmVFbnVtID0gZnVuY3Rpb24gKGdsb2JhbE5hbWUsIHN0YXRpY1Byb3BlcnRpZXMpIHtcblx0dmFyIG5ld0NsYXNzID0gdGhpcy5jcmVhdGVDbGFzcyhnbG9iYWxOYW1lLCBudWxsLCB7fSwgc3RhdGljUHJvcGVydGllcyk7XG5cdHZhciBuYW1lT2JqZWN0ID0gZm9ybWF0cy5wYXJzZUZ1bGxOYW1lKGdsb2JhbE5hbWUpO1xuXG5cdHRoaXMubmFtZXNwYWNlKG5hbWVPYmplY3QubmFtZXNwYWNlKVtuYW1lT2JqZWN0Lm5hbWVdID0gbmV3Q2xhc3M7XG5cdHJldHVybiBuZXdDbGFzcztcbn07XG5cbnZhciBuZWF0bmVzcyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IE5lYXRuZXNzKCk7XG5cbi8vIFdlYiBicm93c2VyIGV4cG9ydFxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG5cdHdpbmRvdy5OZWF0bmVzcyA9IG5lYXRuZXNzO1xufVxuXG4vKipcbiAqIEB0eXBlIHtOZWF0bmVzcy5wcm90b3R5cGUuT2JqZWN0fVxuICovXG5OZWF0bmVzcy5wcm90b3R5cGUuT2JqZWN0ID0gcmVxdWlyZSgnLi9OZWF0bmVzcy5PYmplY3QnKShuZWF0bmVzcyk7XG5cbi8qKlxuICogQHR5cGUge05lYXRuZXNzLnByb3RvdHlwZS5FeGNlcHRpb259XG4gKi9cbk5lYXRuZXNzLnByb3RvdHlwZS5FeGNlcHRpb24gPSByZXF1aXJlKCcuL05lYXRuZXNzLkV4Y2VwdGlvbicpKG5lYXRuZXNzKTtcblxuLyoqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5OZWF0bmVzcy5wcm90b3R5cGUudmVyc2lvbiA9ICclSk9JTlRTX0NVUlJFTlRfVkVSU0lPTiUnO1xuXG59LHtcIi4vTmVhdG5lc3MuRXhjZXB0aW9uXCI6MTU1LFwiLi9OZWF0bmVzcy5PYmplY3RcIjoxNTYsXCIuL2V4dGVuZENsYXNzXCI6MTU4LFwiLi9mb3JtYXRzXCI6MTU5fV0sMTU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0V2YWxFbmFibGUgPSB0cnVlO1xudmFyIGluc3RhbmNlQ291bnRlciA9IDA7XG5cbnZhciBfbm9vcCA9IGZ1bmN0aW9uKCkge1xufTtcblxudmFyIF9jcmVhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWVPYmplY3QsIGNvbnN0cnVjdG9yKSB7XG5cdGlmICghaXNFdmFsRW5hYmxlIHx8ICFuYW1lT2JqZWN0KSB7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH1cblx0fVxuXG5cdHZhciBuYW1lUmVnRXhwID0gL1teYS16JF9cXC5dL2k7XG5cdHZhciBuYW1lID0gbmFtZU9iamVjdC5uYW1lIHx8ICdGdW5jdGlvbic7XG5cdHZhciBuYW1lUGFydHMgPSBuYW1lT2JqZWN0Lmdsb2JhbE5hbWUuc3BsaXQoJy4nKTtcblxuXHQvLyBDcmVhdGUgcm9vdCBvYmplY3Rcblx0dmFyIHJvb3ROYW1lID0gbmFtZVBhcnRzLnNoaWZ0KCk7XG5cdHZhciBjcztcblxuXHRyb290TmFtZSA9IHJvb3ROYW1lLnJlcGxhY2UobmFtZVJlZ0V4cCwgJycpO1xuXHRldmFsKCd2YXIgJyArIHJvb3ROYW1lICsgJyA9IGNzID0ge307Jyk7XG5cblx0Ly8gQ3JlYXRlIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuXHRmb3IgKHZhciBpID0gMDsgaSA8IG5hbWVQYXJ0cy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBzY29wZU5hbWUgPSBuYW1lUGFydHNbaV07XG5cdFx0aWYgKCFjc1tzY29wZU5hbWVdKSB7XG5cdFx0XHRjc1tzY29wZU5hbWVdID0ge307XG5cdFx0fVxuXHRcdGNzID0gY3Nbc2NvcGVOYW1lXTtcblx0fVxuXG5cdHZhciBmdW5jO1xuXHR2YXIgZnVsbE5hbWUgPSAobmFtZU9iamVjdC5uYW1lc3BhY2UgPyBuYW1lT2JqZWN0Lm5hbWVzcGFjZSArICcuJyA6ICcnKSArIG5hbWU7XG5cblx0ZnVsbE5hbWUgPSBmdWxsTmFtZS5yZXBsYWNlKG5hbWVSZWdFeHAsICcnKTtcblx0ZXZhbCgnZnVuYyA9ICcgKyBmdWxsTmFtZSArICcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9Jyk7XG5cblx0cmV0dXJuIGZ1bmM7XG59O1xuXG52YXIgX2lzU3RyaWN0T2JqZWN0ID0gZnVuY3Rpb24gKG9iaikge1xuXHRpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCBvYmogaW5zdGFuY2VvZiBSZWdFeHAgfHwgb2JqIGluc3RhbmNlb2YgRGF0ZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHZhciBib29sID0gdHJ1ZTtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGJvb2wgPSBib29sICYmIG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpO1xuXHR9XG5cdHJldHVybiBib29sO1xufTtcblxudmFyIF9jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuXHRpZiAoIV9pc1N0cmljdE9iamVjdChvYmopKSB7XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHZhciBjb3B5ID0gb2JqLmNvbnN0cnVjdG9yKCk7XG5cdGZvciAodmFyIGtleSBpbiBvYmopIHtcblx0XHRpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGNvcHlba2V5XSA9IF9jbG9uZShvYmpba2V5XSk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBjb3B5O1xufTtcblxudmFyIF9jbG9uZU9iakluUHJvdG8gPSBmdW5jdGlvbihvYmopIHtcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xuXHRcdGlmICh0eXBlb2Ygb2JqID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHRvYmpba2V5XSA9IF9jbG9uZShvYmpba2V5XSk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgX2NvdmVyVmlydHVhbCA9IGZ1bmN0aW9uIChjaGlsZE1ldGhvZCwgcGFyZW50TWV0aG9kLCBzdXBlck5hbWUpIHtcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY3VycmVudFN1cGVyID0gdGhpc1tzdXBlck5hbWVdO1xuXHRcdHRoaXNbc3VwZXJOYW1lXSA9IHBhcmVudE1ldGhvZDtcblx0XHR2YXIgciA9IGNoaWxkTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0dGhpc1tzdXBlck5hbWVdID0gY3VycmVudFN1cGVyO1xuXHRcdHJldHVybiByO1xuXHR9O1xufTtcblxudmFyIF9leHRlbmRXaXRoU3VwZXIgPSBmdW5jdGlvbiAoY2hpbGRDbGFzcywgbmV3UHJvcGVydGllcywgc3VwZXJOYW1lKSB7XG5cdGlmICghbmV3UHJvcGVydGllcykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIEV4dGVuZCBhbmQgc2V0dXAgdmlydHVhbCBtZXRob2RzXG5cdGZvciAodmFyIGtleSBpbiBuZXdQcm9wZXJ0aWVzKSB7XG5cdFx0aWYgKCFuZXdQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZSA9IG5ld1Byb3BlcnRpZXNba2V5XTtcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkQ2xhc3Nba2V5XSA9PSAnZnVuY3Rpb24nICYmIGNoaWxkQ2xhc3Nba2V5XSAhPT0gX25vb3ApIHtcblx0XHRcdGNoaWxkQ2xhc3Nba2V5XSA9IF9jb3ZlclZpcnR1YWwodmFsdWUsIGNoaWxkQ2xhc3Nba2V5XSwgc3VwZXJOYW1lKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2hpbGRDbGFzc1trZXldID0gX2Nsb25lKHZhbHVlKTtcblx0XHR9XG5cdH1cblxuXHQvLyBEZWZhdWx0IHN0YXRlXG5cdGlmICghY2hpbGRDbGFzc1tzdXBlck5hbWVdKSB7XG5cdFx0Y2hpbGRDbGFzc1tzdXBlck5hbWVdID0gX25vb3A7XG5cdH1cbn07XG5cbi8qKlxuICogRXh0ZW5kIGNsYXNzXG4gKiBAcGFyYW0ge29iamVjdH0gbmFtZU9iamVjdFxuICogQHBhcmFtIHtvYmplY3R9IHBhcmVudE5hbWVPYmplY3RcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwYXJlbnRDbGFzc11cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFttaXhpbnNdXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3RvdHlwZVByb3BlcnRpZXNdXG4gKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BlcnRpZXNdXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IE5ldyBjbGFzc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lT2JqZWN0LCBwYXJlbnROYW1lT2JqZWN0LCBwYXJlbnRDbGFzcywgbWl4aW5zLCBwcm90b3R5cGVQcm9wZXJ0aWVzLCBzdGF0aWNQcm9wZXJ0aWVzLCBzdXBlck5hbWUpIHtcblx0cGFyZW50Q2xhc3MgPSBwYXJlbnRDbGFzcyB8fCBfbm9vcDtcblx0bWl4aW5zID0gbWl4aW5zIHx8IFtdO1xuXG5cdC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3Vcblx0Ly8gKHRoZSBcImNvbnN0cnVjdG9yXCIgcHJvcGVydHkgaW4geW91ciBgZXh0ZW5kYCBkZWZpbml0aW9uKSwgb3IgZGVmYXVsdGVkXG5cdC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQncyBjb25zdHJ1Y3Rvci5cblx0dmFyIGNvbnN0cnVjdG9yID0gcHJvdG90eXBlUHJvcGVydGllcyAmJiBwcm90b3R5cGVQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID9cblx0XHRfY292ZXJWaXJ0dWFsKHByb3RvdHlwZVByb3BlcnRpZXMuY29uc3RydWN0b3IsIHBhcmVudENsYXNzLCBzdXBlck5hbWUpIDpcblx0XHRwYXJlbnRDbGFzcztcblx0dmFyIGNoaWxkQ2xhc3MgPSBfY3JlYXRlRnVuY3Rpb24obmFtZU9iamVjdCwgZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9faW5zdGFuY2VOYW1lKSB7XG5cdFx0XHRfY2xvbmVPYmpJblByb3RvKHRoaXMpO1xuXHRcdFx0dGhpcy5fX2luc3RhbmNlTmFtZSAgPSBuYW1lT2JqZWN0Lmdsb2JhbE5hbWUgKyBpbnN0YW5jZUNvdW50ZXIrKztcblx0XHR9XG5cdFx0Y29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSk7XG5cblx0Ly8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXG5cdGZvciAodmFyIHByb3AgaW4gcGFyZW50Q2xhc3MpIHtcblx0XHRjaGlsZENsYXNzW3Byb3BdID0gcGFyZW50Q2xhc3NbcHJvcF07XG5cdH1cblx0X2V4dGVuZFdpdGhTdXBlcihjaGlsZENsYXNzLCBzdGF0aWNQcm9wZXJ0aWVzLCBzdXBlck5hbWUpO1xuXG5cdC8vIFNldCB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGluaGVyaXQgZnJvbSBgcGFyZW50YCwgd2l0aG91dCBjYWxsaW5nXG5cdC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG5cdHZhciBTdXJyb2dhdGUgPSBfY3JlYXRlRnVuY3Rpb24ocGFyZW50TmFtZU9iamVjdCwgX25vb3ApO1xuXHRTdXJyb2dhdGUucHJvdG90eXBlID0gcGFyZW50Q2xhc3MucHJvdG90eXBlO1xuXG5cdGNoaWxkQ2xhc3MucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZSgpO1xuXG5cdC8vIENvcHkgb2JqZWN0cyBmcm9tIGNoaWxkIHByb3RvdHlwZVxuXHRmb3IgKHZhciBwcm9wMiBpbiBwYXJlbnRDbGFzcy5wcm90b3R5cGUpIHtcblx0XHRpZiAocGFyZW50Q2xhc3MucHJvdG90eXBlLmhhc093blByb3BlcnR5KHByb3AyKSAmJiBwcm9wMiAhPT0gJ2NvbnN0cnVjdG9yJykge1xuXHRcdFx0Y2hpbGRDbGFzcy5wcm90b3R5cGVbcHJvcDJdID0gX2Nsb25lKHBhcmVudENsYXNzLnByb3RvdHlwZVtwcm9wMl0pO1xuXHRcdH1cblx0fVxuXG5cdC8vIEFkZCBwcm90b3R5cGUgcHJvcGVydGllcyAoaW5zdGFuY2UgcHJvcGVydGllcykgdG8gdGhlIHN1YmNsYXNzLFxuXHQvLyBpZiBzdXBwbGllZC5cblx0aWYgKHByb3RvdHlwZVByb3BlcnRpZXMpIHtcblx0XHRfZXh0ZW5kV2l0aFN1cGVyKGNoaWxkQ2xhc3MucHJvdG90eXBlLCBwcm90b3R5cGVQcm9wZXJ0aWVzLCBzdXBlck5hbWUpO1xuXHR9XG5cblx0Ly8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZyb20gbWl4aW5zXG5cdGZvciAodmFyIGkgPSAwLCBsID0gbWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdGZvciAodmFyIG1peGluUHJvcCBpbiBtaXhpbnNbaV0ucHJvdG90eXBlKSB7XG5cdFx0XHQvLyBTa2lwIHByaXZhdGVcblx0XHRcdGlmIChtaXhpblByb3Auc3Vic3RyKDAsIDIpID09PSAnX18nKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RzIHByb3BlcnR5IG9yIG1ldGhvZC4gTWl4aW4gY2FuIG9ubHkgYWRkIHByb3BlcnRpZXMsIGJ1dCBubyByZXBsYWNlIGl0XG5cdFx0XHRpZiAodHlwZW9mIGNoaWxkQ2xhc3MucHJvdG90eXBlW21peGluUHJvcF0gPT09ICdmdW5jdGlvbicgfHwgY2hpbGRDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobWl4aW5Qcm9wKSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1RyeSB0byByZXBsYWNlIHByb3RvdHlwZSBwcm9wZXJ0eSBgJyArIG1peGluUHJvcCArICdgIGluIGNsYXNzIGAnICsgY2hpbGRDbGFzcy5fX2NsYXNzTmFtZSArICdgIGJ5IG1peGluIGAnICsgbWl4aW5zW2ldLl9fY2xhc3NOYW1lICsgJ2AnKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkQ2xhc3MucHJvdG90eXBlW21peGluUHJvcF0gPSBtaXhpbnNbaV0ucHJvdG90eXBlW21peGluUHJvcF07XG5cdFx0fVxuXHR9XG5cdC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcyBmcm9tIG1peGluc1xuXHRmb3IgKHZhciBpID0gMCwgbCA9IG1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRmb3IgKHZhciBtaXhpblByb3AgaW4gbWl4aW5zW2ldKSB7XG5cdFx0XHQvLyBTa2lwIHByaXZhdGVcblx0XHRcdGlmIChtaXhpblByb3Auc3Vic3RyKDAsIDIpID09PSAnX18nKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RzIHByb3BlcnR5IG9yIG1ldGhvZC4gTWl4aW4gY2FuIG9ubHkgYWRkIHByb3BlcnRpZXMsIGJ1dCBubyByZXBsYWNlIGl0XG5cdFx0XHRpZiAodHlwZW9mIGNoaWxkQ2xhc3NbbWl4aW5Qcm9wXSA9PT0gJ2Z1bmN0aW9uJyB8fCBjaGlsZENsYXNzLmhhc093blByb3BlcnR5KG1peGluUHJvcCkpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUcnkgdG8gcmVwbGFjZSBzdGF0aWMgcHJvcGVydHkgYCcgKyBtaXhpblByb3AgKyAnYCBpbiBjbGFzcyBgJyArIGNoaWxkQ2xhc3MuX19jbGFzc05hbWUgKyAnYCBieSBtaXhpbiBgJyArIG1peGluc1tpXS5fX2NsYXNzTmFtZSArICdgJyk7XG5cdFx0XHR9XG5cdFx0XHRjaGlsZENsYXNzW21peGluUHJvcF0gPSBtaXhpbnNbaV1bbWl4aW5Qcm9wXTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hpbGRDbGFzcztcbn07XG5cbn0se31dLDE1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG52YXIgRk9STUFUX0pPSU5UU19WMDIgPSAnbmVhdG5lc3NfdjAyJztcbnZhciBGT1JNQVRfSk9JTlRTX1YxMCA9ICduZWF0bmVzc192MTAnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcblxuXHQvKipcblx0ICogRGV0ZWN0IGZvcm1hdCBhbmQgcmV0dXJuIGNsYXNzIHBhcmFtc1xuXHQgKiBAcGFyYW0ge3N0cmluZ30gZ2xvYmFsTmFtZVxuXHQgKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3R8bnVsbCl9IG9wdGlvbnNPckV4dGVuZFxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3Byb3RvUHJvcHNdXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbc3RhdGljUHJvcHNdXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XG5cdCAqL1xuXHRwYXJzZUZvcm1hdDogZnVuY3Rpb24gKGdsb2JhbE5hbWUsIG9wdGlvbnNPckV4dGVuZCwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcblx0XHR2YXIgbmFtZU9iamVjdCA9IHRoaXMucGFyc2VGdWxsTmFtZShnbG9iYWxOYW1lKTtcblx0XHR2YXIgcGFyZW50TmFtZU9iamVjdCA9IG51bGw7XG5cdFx0dmFyIHBhcmVudENsYXNzID0gbnVsbDtcblx0XHR2YXIgcHJvdG90eXBlUHJvcGVydGllcyA9IG51bGw7XG5cdFx0dmFyIHN0YXRpY1Byb3BlcnRpZXMgPSBudWxsO1xuXHRcdHZhciBmb3JtYXQgPSBudWxsO1xuXHRcdHZhciBtaXhpbnMgPSBbXTtcblxuXHRcdC8vIE5lYXRuZXNzIHYwLjIgKG9sZCkgZm9ybWF0XG5cdFx0aWYgKG9wdGlvbnNPckV4dGVuZCA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9uc09yRXh0ZW5kID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRwYXJlbnRDbGFzcyA9IG9wdGlvbnNPckV4dGVuZDtcblx0XHRcdHByb3RvdHlwZVByb3BlcnRpZXMgPSBwcm90b1Byb3BzO1xuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHN0YXRpY1Byb3BzO1xuXHRcdFx0Zm9ybWF0ID0gRk9STUFUX0pPSU5UU19WMDI7XG5cblx0XHRcdGlmIChwYXJlbnRDbGFzcyAmJiB0eXBlb2YgcGFyZW50Q2xhc3MuZGVidWdDbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHBhcmVudE5hbWVPYmplY3QgPSB0aGlzLnBhcnNlRnVsbE5hbWUocGFyZW50Q2xhc3MuZGVidWdDbGFzc05hbWUpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOZWF0bmVzcyB2MS4wIGZvcm1hdFxuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnNPckV4dGVuZCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGlmIChvcHRpb25zT3JFeHRlbmQuaGFzT3duUHJvcGVydHkoJ19fZXh0ZW5kcycpKSB7XG5cdFx0XHRcdHBhcmVudENsYXNzID0gb3B0aW9uc09yRXh0ZW5kLl9fZXh0ZW5kcztcblx0XHRcdFx0ZGVsZXRlIG9wdGlvbnNPckV4dGVuZC5fX2V4dGVuZHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChvcHRpb25zT3JFeHRlbmQuaGFzT3duUHJvcGVydHkoJ19fc3RhdGljJykpIHtcblx0XHRcdFx0c3RhdGljUHJvcGVydGllcyA9IG9wdGlvbnNPckV4dGVuZC5fX3N0YXRpYztcblx0XHRcdFx0ZGVsZXRlIG9wdGlvbnNPckV4dGVuZC5fX3N0YXRpYztcblx0XHRcdH1cblxuXHRcdFx0aWYgKG9wdGlvbnNPckV4dGVuZC5oYXNPd25Qcm9wZXJ0eSgnX19taXhpbnMnKSkge1xuXHRcdFx0XHRtaXhpbnMgPSBtaXhpbnMuY29uY2F0KG9wdGlvbnNPckV4dGVuZC5fX21peGlucyk7XG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zT3JFeHRlbmQuX19taXhpbnM7XG5cdFx0XHR9XG5cdFx0XHRpZiAob3B0aW9uc09yRXh0ZW5kLmhhc093blByb3BlcnR5KCdfX21peGluJykpIHtcblx0XHRcdFx0bWl4aW5zID0gbWl4aW5zLmNvbmNhdChvcHRpb25zT3JFeHRlbmQuX19taXhpbik7XG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zT3JFeHRlbmQuX19taXhpbjtcblx0XHRcdH1cblxuXHRcdFx0Zm9ybWF0ID0gRk9STUFUX0pPSU5UU19WMTA7XG5cdFx0XHRwcm90b3R5cGVQcm9wZXJ0aWVzID0gb3B0aW9uc09yRXh0ZW5kO1xuXG5cdFx0XHRpZiAocGFyZW50Q2xhc3MgJiYgdHlwZW9mIHBhcmVudENsYXNzLl9fY2xhc3NOYW1lID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRwYXJlbnROYW1lT2JqZWN0ID0gdGhpcy5wYXJzZUZ1bGxOYW1lKHBhcmVudENsYXNzLl9fY2xhc3NOYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0bmFtZU9iamVjdCxcblx0XHRcdHBhcmVudE5hbWVPYmplY3QsXG5cdFx0XHRwYXJlbnRDbGFzcyxcblx0XHRcdHByb3RvdHlwZVByb3BlcnRpZXMsXG5cdFx0XHRzdGF0aWNQcm9wZXJ0aWVzLFxuXHRcdFx0Zm9ybWF0LFxuXHRcdFx0bWl4aW5zLFxuXHRcdFx0Zm9ybWF0ID09PSBGT1JNQVRfSk9JTlRTX1YwMiA/ICdfc3VwZXInIDogJ19fc3VwZXInXG5cdFx0XTtcblx0fSxcblxuXHRhcHBseUNsYXNzQ29uZmlnOiBmdW5jdGlvbihuZXdDbGFzcywgZm9ybWF0LCBuYW1lT2JqZWN0LCBwYXJlbnROYW1lT2JqZWN0KSB7XG5cdFx0Ly8gU2V0IF9fY2xhc3NOYW1lIGZvciBhbGwgZm9ybWF0c1xuXHRcdG5ld0NsYXNzLl9fY2xhc3NOYW1lID0gbmV3Q2xhc3MucHJvdG90eXBlLl9fY2xhc3NOYW1lID0gbmFtZU9iamVjdC5nbG9iYWxOYW1lO1xuXG5cdFx0dmFyIGNsYXNzTmFtZUtleSA9IGZvcm1hdCA9PT0gRk9STUFUX0pPSU5UU19WMDIgPyAnZGVidWdDbGFzc05hbWUnIDogJ19fY2xhc3NOYW1lJztcblx0XHR2YXIgcGFyZW50Q2xhc3NOYW1lS2V5ID0gZm9ybWF0ID09PSBGT1JNQVRfSk9JTlRTX1YwMiA/ICcnIDogJ19fcGFyZW50Q2xhc3NOYW1lJztcblx0XHR2YXIgc3RhdGljTmFtZUtleSA9IGZvcm1hdCA9PT0gRk9STUFUX0pPSU5UU19WMDIgPyAnX3N0YXRpYycgOiAnX19zdGF0aWMnO1xuXG5cdFx0bmV3Q2xhc3NbY2xhc3NOYW1lS2V5XSA9IG5ld0NsYXNzLnByb3RvdHlwZVtjbGFzc05hbWVLZXldID0gbmFtZU9iamVjdC5nbG9iYWxOYW1lO1xuXHRcdGlmIChwYXJlbnRDbGFzc05hbWVLZXkpIHtcblx0XHRcdG5ld0NsYXNzW3BhcmVudENsYXNzTmFtZUtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbcGFyZW50Q2xhc3NOYW1lS2V5XSA9IHBhcmVudE5hbWVPYmplY3QgPyAocGFyZW50TmFtZU9iamVjdC5nbG9iYWxOYW1lIHx8IG51bGwpIDogbnVsbDtcblx0XHR9XG5cdFx0bmV3Q2xhc3Nbc3RhdGljTmFtZUtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbc3RhdGljTmFtZUtleV0gPSBuZXdDbGFzcztcblxuXHRcdHJldHVybiBuZXdDbGFzcztcblx0fSxcblxuXHRwYXJzZUZ1bGxOYW1lOiBmdW5jdGlvbihnbG9iYWxOYW1lKSB7XG5cdFx0Ly8gU3BsaXQgbmFtZXNwYWNlXG5cdFx0dmFyIHBvcyA9IGdsb2JhbE5hbWUubGFzdEluZGV4T2YoJy4nKTtcblxuXHRcdHJldHVybiB7XG5cdFx0XHRnbG9iYWxOYW1lOiBnbG9iYWxOYW1lLFxuXHRcdFx0bmFtZTogcG9zICE9PSAtMSA/IGdsb2JhbE5hbWUuc3Vic3RyKHBvcyArIDEpIDogZ2xvYmFsTmFtZSxcblx0XHRcdG5hbWVzcGFjZTogcG9zICE9PSAtMSA/IGdsb2JhbE5hbWUuc3Vic3RyKDAsIHBvcykgOiAnJ1xuXHRcdH07XG5cdH1cblxufTtcblxufSx7fV0sMTYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vICBVbmRlcnNjb3JlLnN0cmluZ1xuLy8gIChjKSAyMDEwIEVzYS1NYXR0aSBTdXVyb25lbiA8ZXNhLW1hdHRpIGFldCBzdXVyb25lbiBkb3Qgb3JnPlxuLy8gIFVuZGVyc2NvcmUuc3RyaW5nIGlzIGZyZWVseSBkaXN0cmlidXRhYmxlIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgTUlUIGxpY2Vuc2UuXG4vLyAgRG9jdW1lbnRhdGlvbjogaHR0cHM6Ly9naXRodWIuY29tL2VwZWxpL3VuZGVyc2NvcmUuc3RyaW5nXG4vLyAgU29tZSBjb2RlIGlzIGJvcnJvd2VkIGZyb20gTW9vVG9vbHMgYW5kIEFsZXhhbmRydSBNYXJhc3RlYW51LlxuLy8gIFZlcnNpb24gJzIuNC4wJ1xuXG4hZnVuY3Rpb24ocm9vdCwgU3RyaW5nKXtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIERlZmluaW5nIGhlbHBlciBmdW5jdGlvbnMuXG5cbiAgdmFyIG5hdGl2ZVRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW07XG4gIHZhciBuYXRpdmVUcmltUmlnaHQgPSBTdHJpbmcucHJvdG90eXBlLnRyaW1SaWdodDtcbiAgdmFyIG5hdGl2ZVRyaW1MZWZ0ID0gU3RyaW5nLnByb3RvdHlwZS50cmltTGVmdDtcblxuICB2YXIgcGFyc2VOdW1iZXIgPSBmdW5jdGlvbihzb3VyY2UpIHsgcmV0dXJuIHNvdXJjZSAqIDEgfHwgMDsgfTtcblxuICB2YXIgc3RyUmVwZWF0ID0gZnVuY3Rpb24oc3RyLCBxdHkpe1xuICAgIGlmIChxdHkgPCAxKSByZXR1cm4gJyc7XG4gICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgIHdoaWxlIChxdHkgPiAwKSB7XG4gICAgICBpZiAocXR5ICYgMSkgcmVzdWx0ICs9IHN0cjtcbiAgICAgIHF0eSA+Pj0gMSwgc3RyICs9IHN0cjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgc2xpY2UgPSBbXS5zbGljZTtcblxuICB2YXIgZGVmYXVsdFRvV2hpdGVTcGFjZSA9IGZ1bmN0aW9uKGNoYXJhY3RlcnMpIHtcbiAgICBpZiAoY2hhcmFjdGVycyA9PSBudWxsKVxuICAgICAgcmV0dXJuICdcXFxccyc7XG4gICAgZWxzZSBpZiAoY2hhcmFjdGVycy5zb3VyY2UpXG4gICAgICByZXR1cm4gY2hhcmFjdGVycy5zb3VyY2U7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuICdbJyArIF9zLmVzY2FwZVJlZ0V4cChjaGFyYWN0ZXJzKSArICddJztcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIHRvQm9vbGVhblxuICBmdW5jdGlvbiBib29sTWF0Y2gocywgbWF0Y2hlcnMpIHtcbiAgICB2YXIgaSwgbWF0Y2hlciwgZG93biA9IHMudG9Mb3dlckNhc2UoKTtcbiAgICBtYXRjaGVycyA9IFtdLmNvbmNhdChtYXRjaGVycyk7XG4gICAgZm9yIChpID0gMDsgaSA8IG1hdGNoZXJzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBtYXRjaGVyID0gbWF0Y2hlcnNbaV07XG4gICAgICBpZiAoIW1hdGNoZXIpIGNvbnRpbnVlO1xuICAgICAgaWYgKG1hdGNoZXIudGVzdCAmJiBtYXRjaGVyLnRlc3QocykpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKG1hdGNoZXIudG9Mb3dlckNhc2UoKSA9PT0gZG93bikgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGVzY2FwZUNoYXJzID0ge1xuICAgIGx0OiAnPCcsXG4gICAgZ3Q6ICc+JyxcbiAgICBxdW90OiAnXCInLFxuICAgIGFtcDogJyYnLFxuICAgIGFwb3M6IFwiJ1wiXG4gIH07XG5cbiAgdmFyIHJldmVyc2VkRXNjYXBlQ2hhcnMgPSB7fTtcbiAgZm9yKHZhciBrZXkgaW4gZXNjYXBlQ2hhcnMpIHJldmVyc2VkRXNjYXBlQ2hhcnNbZXNjYXBlQ2hhcnNba2V5XV0gPSBrZXk7XG4gIHJldmVyc2VkRXNjYXBlQ2hhcnNbXCInXCJdID0gJyMzOSc7XG5cbiAgLy8gc3ByaW50ZigpIGZvciBKYXZhU2NyaXB0IDAuNy1iZXRhMVxuICAvLyBodHRwOi8vd3d3LmRpdmVpbnRvamF2YXNjcmlwdC5jb20vcHJvamVjdHMvamF2YXNjcmlwdC1zcHJpbnRmXG4gIC8vXG4gIC8vIENvcHlyaWdodCAoYykgQWxleGFuZHJ1IE1hcmFzdGVhbnUgPGFsZXhhaG9saWMgW2F0KSBnbWFpbCAoZG90XSBjb20+XG4gIC8vIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5cbiAgdmFyIHNwcmludGYgPSAoZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gZ2V0X3R5cGUodmFyaWFibGUpIHtcbiAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFyaWFibGUpLnNsaWNlKDgsIC0xKS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIHZhciBzdHJfcmVwZWF0ID0gc3RyUmVwZWF0O1xuXG4gICAgdmFyIHN0cl9mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghc3RyX2Zvcm1hdC5jYWNoZS5oYXNPd25Qcm9wZXJ0eShhcmd1bWVudHNbMF0pKSB7XG4gICAgICAgIHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSA9IHN0cl9mb3JtYXQucGFyc2UoYXJndW1lbnRzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJfZm9ybWF0LmZvcm1hdC5jYWxsKG51bGwsIHN0cl9mb3JtYXQuY2FjaGVbYXJndW1lbnRzWzBdXSwgYXJndW1lbnRzKTtcbiAgICB9O1xuXG4gICAgc3RyX2Zvcm1hdC5mb3JtYXQgPSBmdW5jdGlvbihwYXJzZV90cmVlLCBhcmd2KSB7XG4gICAgICB2YXIgY3Vyc29yID0gMSwgdHJlZV9sZW5ndGggPSBwYXJzZV90cmVlLmxlbmd0aCwgbm9kZV90eXBlID0gJycsIGFyZywgb3V0cHV0ID0gW10sIGksIGssIG1hdGNoLCBwYWQsIHBhZF9jaGFyYWN0ZXIsIHBhZF9sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdHJlZV9sZW5ndGg7IGkrKykge1xuICAgICAgICBub2RlX3R5cGUgPSBnZXRfdHlwZShwYXJzZV90cmVlW2ldKTtcbiAgICAgICAgaWYgKG5vZGVfdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBvdXRwdXQucHVzaChwYXJzZV90cmVlW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlX3R5cGUgPT09ICdhcnJheScpIHtcbiAgICAgICAgICBtYXRjaCA9IHBhcnNlX3RyZWVbaV07IC8vIGNvbnZlbmllbmNlIHB1cnBvc2VzIG9ubHlcbiAgICAgICAgICBpZiAobWF0Y2hbMl0pIHsgLy8ga2V5d29yZCBhcmd1bWVudFxuICAgICAgICAgICAgYXJnID0gYXJndltjdXJzb3JdO1xuICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IG1hdGNoWzJdLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgIGlmICghYXJnLmhhc093blByb3BlcnR5KG1hdGNoWzJdW2tdKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpbnRmKCdbXy5zcHJpbnRmXSBwcm9wZXJ0eSBcIiVzXCIgZG9lcyBub3QgZXhpc3QnLCBtYXRjaFsyXVtrXSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZyA9IGFyZ1ttYXRjaFsyXVtrXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsxXSkgeyAvLyBwb3NpdGlvbmFsIGFyZ3VtZW50IChleHBsaWNpdClcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbbWF0Y2hbMV1dO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoaW1wbGljaXQpXG4gICAgICAgICAgICBhcmcgPSBhcmd2W2N1cnNvcisrXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoL1tec10vLnRlc3QobWF0Y2hbOF0pICYmIChnZXRfdHlwZShhcmcpICE9ICdudW1iZXInKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHNwcmludGYoJ1tfLnNwcmludGZdIGV4cGVjdGluZyBudW1iZXIgYnV0IGZvdW5kICVzJywgZ2V0X3R5cGUoYXJnKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzhdKSB7XG4gICAgICAgICAgICBjYXNlICdiJzogYXJnID0gYXJnLnRvU3RyaW5nKDIpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2MnOiBhcmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGFyZyk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZCc6IGFyZyA9IHBhcnNlSW50KGFyZywgMTApOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2UnOiBhcmcgPSBtYXRjaFs3XSA/IGFyZy50b0V4cG9uZW50aWFsKG1hdGNoWzddKSA6IGFyZy50b0V4cG9uZW50aWFsKCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZic6IGFyZyA9IG1hdGNoWzddID8gcGFyc2VGbG9hdChhcmcpLnRvRml4ZWQobWF0Y2hbN10pIDogcGFyc2VGbG9hdChhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ28nOiBhcmcgPSBhcmcudG9TdHJpbmcoOCk7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncyc6IGFyZyA9ICgoYXJnID0gU3RyaW5nKGFyZykpICYmIG1hdGNoWzddID8gYXJnLnN1YnN0cmluZygwLCBtYXRjaFs3XSkgOiBhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3UnOiBhcmcgPSBNYXRoLmFicyhhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1gnOiBhcmcgPSBhcmcudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhcmcgPSAoL1tkZWZdLy50ZXN0KG1hdGNoWzhdKSAmJiBtYXRjaFszXSAmJiBhcmcgPj0gMCA/ICcrJysgYXJnIDogYXJnKTtcbiAgICAgICAgICBwYWRfY2hhcmFjdGVyID0gbWF0Y2hbNF0gPyBtYXRjaFs0XSA9PSAnMCcgPyAnMCcgOiBtYXRjaFs0XS5jaGFyQXQoMSkgOiAnICc7XG4gICAgICAgICAgcGFkX2xlbmd0aCA9IG1hdGNoWzZdIC0gU3RyaW5nKGFyZykubGVuZ3RoO1xuICAgICAgICAgIHBhZCA9IG1hdGNoWzZdID8gc3RyX3JlcGVhdChwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoKSA6ICcnO1xuICAgICAgICAgIG91dHB1dC5wdXNoKG1hdGNoWzVdID8gYXJnICsgcGFkIDogcGFkICsgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgICB9O1xuXG4gICAgc3RyX2Zvcm1hdC5jYWNoZSA9IHt9O1xuXG4gICAgc3RyX2Zvcm1hdC5wYXJzZSA9IGZ1bmN0aW9uKGZtdCkge1xuICAgICAgdmFyIF9mbXQgPSBmbXQsIG1hdGNoID0gW10sIHBhcnNlX3RyZWUgPSBbXSwgYXJnX25hbWVzID0gMDtcbiAgICAgIHdoaWxlIChfZm10KSB7XG4gICAgICAgIGlmICgobWF0Y2ggPSAvXlteXFx4MjVdKy8uZXhlYyhfZm10KSkgIT09IG51bGwpIHtcbiAgICAgICAgICBwYXJzZV90cmVlLnB1c2gobWF0Y2hbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjV7Mn0vLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKCclJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gL15cXHgyNSg/OihbMS05XVxcZCopXFwkfFxcKChbXlxcKV0rKVxcKSk/KFxcKyk/KDB8J1teJF0pPygtKT8oXFxkKyk/KD86XFwuKFxcZCspKT8oW2ItZm9zdXhYXSkvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKG1hdGNoWzJdKSB7XG4gICAgICAgICAgICBhcmdfbmFtZXMgfD0gMTtcbiAgICAgICAgICAgIHZhciBmaWVsZF9saXN0ID0gW10sIHJlcGxhY2VtZW50X2ZpZWxkID0gbWF0Y2hbMl0sIGZpZWxkX21hdGNoID0gW107XG4gICAgICAgICAgICBpZiAoKGZpZWxkX21hdGNoID0gL14oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgZmllbGRfbGlzdC5wdXNoKGZpZWxkX21hdGNoWzFdKTtcbiAgICAgICAgICAgICAgd2hpbGUgKChyZXBsYWNlbWVudF9maWVsZCA9IHJlcGxhY2VtZW50X2ZpZWxkLnN1YnN0cmluZyhmaWVsZF9tYXRjaFswXS5sZW5ndGgpKSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICBpZiAoKGZpZWxkX21hdGNoID0gL15cXC4oW2Etel9dW2Etel9cXGRdKikvaS5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFxbKFxcZCspXFxdLy5leGVjKHJlcGxhY2VtZW50X2ZpZWxkKSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbXy5zcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbXy5zcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRjaFsyXSA9IGZpZWxkX2xpc3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYXJnX25hbWVzIHw9IDI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhcmdfbmFtZXMgPT09IDMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW18uc3ByaW50Zl0gbWl4aW5nIHBvc2l0aW9uYWwgYW5kIG5hbWVkIHBsYWNlaG9sZGVycyBpcyBub3QgKHlldCkgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcnNlX3RyZWUucHVzaChtYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdbXy5zcHJpbnRmXSBodWg/Jyk7XG4gICAgICAgIH1cbiAgICAgICAgX2ZtdCA9IF9mbXQuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VfdHJlZTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHN0cl9mb3JtYXQ7XG4gIH0pKCk7XG5cblxuXG4gIC8vIERlZmluaW5nIHVuZGVyc2NvcmUuc3RyaW5nXG5cbiAgdmFyIF9zID0ge1xuXG4gICAgVkVSU0lPTjogJzIuNC4wJyxcblxuICAgIGlzQmxhbms6IGZ1bmN0aW9uKHN0cil7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHN0ciA9ICcnO1xuICAgICAgcmV0dXJuICgvXlxccyokLykudGVzdChzdHIpO1xuICAgIH0sXG5cbiAgICBzdHJpcFRhZ3M6IGZ1bmN0aW9uKHN0cil7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC88XFwvP1tePl0rPi9nLCAnJyk7XG4gICAgfSxcblxuICAgIGNhcGl0YWxpemUgOiBmdW5jdGlvbihzdHIpe1xuICAgICAgc3RyID0gc3RyID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHIpO1xuICAgICAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbiAgICB9LFxuXG4gICAgY2hvcDogZnVuY3Rpb24oc3RyLCBzdGVwKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuIFtdO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICBzdGVwID0gfn5zdGVwO1xuICAgICAgcmV0dXJuIHN0ZXAgPiAwID8gc3RyLm1hdGNoKG5ldyBSZWdFeHAoJy57MSwnICsgc3RlcCArICd9JywgJ2cnKSkgOiBbc3RyXTtcbiAgICB9LFxuXG4gICAgY2xlYW46IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gX3Muc3RyaXAoc3RyKS5yZXBsYWNlKC9cXHMrL2csICcgJyk7XG4gICAgfSxcblxuICAgIGNvdW50OiBmdW5jdGlvbihzdHIsIHN1YnN0cil7XG4gICAgICBpZiAoc3RyID09IG51bGwgfHwgc3Vic3RyID09IG51bGwpIHJldHVybiAwO1xuXG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgIHN1YnN0ciA9IFN0cmluZyhzdWJzdHIpO1xuXG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICBwb3MgPSAwLFxuICAgICAgICBsZW5ndGggPSBzdWJzdHIubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBwb3MgPSBzdHIuaW5kZXhPZihzdWJzdHIsIHBvcyk7XG4gICAgICAgIGlmIChwb3MgPT09IC0xKSBicmVhaztcbiAgICAgICAgY291bnQrKztcbiAgICAgICAgcG9zICs9IGxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICBjaGFyczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdCgnJyk7XG4gICAgfSxcblxuICAgIHN3YXBDYXNlOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoL1xcUy9nLCBmdW5jdGlvbihjKXtcbiAgICAgICAgcmV0dXJuIGMgPT09IGMudG9VcHBlckNhc2UoKSA/IGMudG9Mb3dlckNhc2UoKSA6IGMudG9VcHBlckNhc2UoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBlc2NhcGVIVE1MOiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoL1smPD5cIiddL2csIGZ1bmN0aW9uKG0peyByZXR1cm4gJyYnICsgcmV2ZXJzZWRFc2NhcGVDaGFyc1ttXSArICc7JzsgfSk7XG4gICAgfSxcblxuICAgIHVuZXNjYXBlSFRNTDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9cXCYoW147XSspOy9nLCBmdW5jdGlvbihlbnRpdHksIGVudGl0eUNvZGUpe1xuICAgICAgICB2YXIgbWF0Y2g7XG5cbiAgICAgICAgaWYgKGVudGl0eUNvZGUgaW4gZXNjYXBlQ2hhcnMpIHtcbiAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcnNbZW50aXR5Q29kZV07XG4gICAgICAgIH0gZWxzZSBpZiAobWF0Y2ggPSBlbnRpdHlDb2RlLm1hdGNoKC9eI3goW1xcZGEtZkEtRl0rKSQvKSkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG1hdGNoWzFdLCAxNikpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gZW50aXR5Q29kZS5tYXRjaCgvXiMoXFxkKykkLykpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh+fm1hdGNoWzFdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZW50aXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZXNjYXBlUmVnRXhwOiBmdW5jdGlvbihzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvKFsuKis/Xj0hOiR7fSgpfFtcXF1cXC9cXFxcXSkvZywgJ1xcXFwkMScpO1xuICAgIH0sXG5cbiAgICBzcGxpY2U6IGZ1bmN0aW9uKHN0ciwgaSwgaG93bWFueSwgc3Vic3RyKXtcbiAgICAgIHZhciBhcnIgPSBfcy5jaGFycyhzdHIpO1xuICAgICAgYXJyLnNwbGljZSh+fmksIH5+aG93bWFueSwgc3Vic3RyKTtcbiAgICAgIHJldHVybiBhcnIuam9pbignJyk7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24oc3RyLCBpLCBzdWJzdHIpe1xuICAgICAgcmV0dXJuIF9zLnNwbGljZShzdHIsIGksIDAsIHN1YnN0cik7XG4gICAgfSxcblxuICAgIGluY2x1ZGU6IGZ1bmN0aW9uKHN0ciwgbmVlZGxlKXtcbiAgICAgIGlmIChuZWVkbGUgPT09ICcnKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLmluZGV4T2YobmVlZGxlKSAhPT0gLTE7XG4gICAgfSxcblxuICAgIGpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyksXG4gICAgICAgIHNlcGFyYXRvciA9IGFyZ3Muc2hpZnQoKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PSBudWxsKSBzZXBhcmF0b3IgPSAnJztcblxuICAgICAgcmV0dXJuIGFyZ3Muam9pbihzZXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBsaW5lczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5zcGxpdChcIlxcblwiKTtcbiAgICB9LFxuXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHJldHVybiBfcy5jaGFycyhzdHIpLnJldmVyc2UoKS5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgc3RhcnRzV2l0aDogZnVuY3Rpb24oc3RyLCBzdGFydHMpe1xuICAgICAgaWYgKHN0YXJ0cyA9PT0gJycpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0ciA9PSBudWxsIHx8IHN0YXJ0cyA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTsgc3RhcnRzID0gU3RyaW5nKHN0YXJ0cyk7XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSBzdGFydHMubGVuZ3RoICYmIHN0ci5zbGljZSgwLCBzdGFydHMubGVuZ3RoKSA9PT0gc3RhcnRzO1xuICAgIH0sXG5cbiAgICBlbmRzV2l0aDogZnVuY3Rpb24oc3RyLCBlbmRzKXtcbiAgICAgIGlmIChlbmRzID09PSAnJykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RyID09IG51bGwgfHwgZW5kcyA9PSBudWxsKSByZXR1cm4gZmFsc2U7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTsgZW5kcyA9IFN0cmluZyhlbmRzKTtcbiAgICAgIHJldHVybiBzdHIubGVuZ3RoID49IGVuZHMubGVuZ3RoICYmIHN0ci5zbGljZShzdHIubGVuZ3RoIC0gZW5kcy5sZW5ndGgpID09PSBlbmRzO1xuICAgIH0sXG5cbiAgICBzdWNjOiBmdW5jdGlvbihzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgICAgIHJldHVybiBzdHIuc2xpY2UoMCwgLTEpICsgU3RyaW5nLmZyb21DaGFyQ29kZShzdHIuY2hhckNvZGVBdChzdHIubGVuZ3RoLTEpICsgMSk7XG4gICAgfSxcblxuICAgIHRpdGxlaXplOiBmdW5jdGlvbihzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBzdHIgID0gU3RyaW5nKHN0cikudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiBzdHIucmVwbGFjZSgvKD86XnxcXHN8LSlcXFMvZywgZnVuY3Rpb24oYyl7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pO1xuICAgIH0sXG5cbiAgICBjYW1lbGl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHJldHVybiBfcy50cmltKHN0cikucmVwbGFjZSgvWy1fXFxzXSsoLik/L2csIGZ1bmN0aW9uKG1hdGNoLCBjKXsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiBcIlwiOyB9KTtcbiAgICB9LFxuXG4gICAgdW5kZXJzY29yZWQ6IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gX3MudHJpbShzdHIpLnJlcGxhY2UoLyhbYS16XFxkXSkoW0EtWl0rKS9nLCAnJDFfJDInKS5yZXBsYWNlKC9bLVxcc10rL2csICdfJykudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuXG4gICAgZGFzaGVyaXplOiBmdW5jdGlvbihzdHIpe1xuICAgICAgcmV0dXJuIF9zLnRyaW0oc3RyKS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS5yZXBsYWNlKC9bLV9cXHNdKy9nLCAnLScpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIGNsYXNzaWZ5OiBmdW5jdGlvbihzdHIpe1xuICAgICAgcmV0dXJuIF9zLmNhcGl0YWxpemUoX3MuY2FtZWxpemUoU3RyaW5nKHN0cikucmVwbGFjZSgvW1xcV19dL2csICcgJykpLnJlcGxhY2UoL1xccy9nLCAnJykpO1xuICAgIH0sXG5cbiAgICBodW1hbml6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHJldHVybiBfcy5jYXBpdGFsaXplKF9zLnVuZGVyc2NvcmVkKHN0cikucmVwbGFjZSgvX2lkJC8sJycpLnJlcGxhY2UoL18vZywgJyAnKSk7XG4gICAgfSxcblxuICAgIHRyaW06IGZ1bmN0aW9uKHN0ciwgY2hhcmFjdGVycyl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIGlmICghY2hhcmFjdGVycyAmJiBuYXRpdmVUcmltKSByZXR1cm4gbmF0aXZlVHJpbS5jYWxsKHN0cik7XG4gICAgICBjaGFyYWN0ZXJzID0gZGVmYXVsdFRvV2hpdGVTcGFjZShjaGFyYWN0ZXJzKTtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKG5ldyBSZWdFeHAoJ14nICsgY2hhcmFjdGVycyArICcrfCcgKyBjaGFyYWN0ZXJzICsgJyskJywgJ2cnKSwgJycpO1xuICAgIH0sXG5cbiAgICBsdHJpbTogZnVuY3Rpb24oc3RyLCBjaGFyYWN0ZXJzKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgaWYgKCFjaGFyYWN0ZXJzICYmIG5hdGl2ZVRyaW1MZWZ0KSByZXR1cm4gbmF0aXZlVHJpbUxlZnQuY2FsbChzdHIpO1xuICAgICAgY2hhcmFjdGVycyA9IGRlZmF1bHRUb1doaXRlU3BhY2UoY2hhcmFjdGVycyk7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGNoYXJhY3RlcnMgKyAnKycpLCAnJyk7XG4gICAgfSxcblxuICAgIHJ0cmltOiBmdW5jdGlvbihzdHIsIGNoYXJhY3RlcnMpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBpZiAoIWNoYXJhY3RlcnMgJiYgbmF0aXZlVHJpbVJpZ2h0KSByZXR1cm4gbmF0aXZlVHJpbVJpZ2h0LmNhbGwoc3RyKTtcbiAgICAgIGNoYXJhY3RlcnMgPSBkZWZhdWx0VG9XaGl0ZVNwYWNlKGNoYXJhY3RlcnMpO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UobmV3IFJlZ0V4cChjaGFyYWN0ZXJzICsgJyskJyksICcnKTtcbiAgICB9LFxuXG4gICAgdHJ1bmNhdGU6IGZ1bmN0aW9uKHN0ciwgbGVuZ3RoLCB0cnVuY2F0ZVN0cil7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpOyB0cnVuY2F0ZVN0ciA9IHRydW5jYXRlU3RyIHx8ICcuLi4nO1xuICAgICAgbGVuZ3RoID0gfn5sZW5ndGg7XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aCA+IGxlbmd0aCA/IHN0ci5zbGljZSgwLCBsZW5ndGgpICsgdHJ1bmNhdGVTdHIgOiBzdHI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIF9zLnBydW5lOiBhIG1vcmUgZWxlZ2FudCB2ZXJzaW9uIG9mIHRydW5jYXRlXG4gICAgICogcHJ1bmUgZXh0cmEgY2hhcnMsIG5ldmVyIGxlYXZpbmcgYSBoYWxmLWNob3BwZWQgd29yZC5cbiAgICAgKiBAYXV0aG9yIGdpdGh1Yi5jb20vcnd6XG4gICAgICovXG4gICAgcHJ1bmU6IGZ1bmN0aW9uKHN0ciwgbGVuZ3RoLCBwcnVuZVN0cil7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcblxuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IGxlbmd0aCA9IH5+bGVuZ3RoO1xuICAgICAgcHJ1bmVTdHIgPSBwcnVuZVN0ciAhPSBudWxsID8gU3RyaW5nKHBydW5lU3RyKSA6ICcuLi4nO1xuXG4gICAgICBpZiAoc3RyLmxlbmd0aCA8PSBsZW5ndGgpIHJldHVybiBzdHI7XG5cbiAgICAgIHZhciB0bXBsID0gZnVuY3Rpb24oYyl7IHJldHVybiBjLnRvVXBwZXJDYXNlKCkgIT09IGMudG9Mb3dlckNhc2UoKSA/ICdBJyA6ICcgJzsgfSxcbiAgICAgICAgdGVtcGxhdGUgPSBzdHIuc2xpY2UoMCwgbGVuZ3RoKzEpLnJlcGxhY2UoLy4oPz1cXFcqXFx3KiQpL2csIHRtcGwpOyAvLyAnSGVsbG8sIHdvcmxkJyAtPiAnSGVsbEFBIEFBQUFBJ1xuXG4gICAgICBpZiAodGVtcGxhdGUuc2xpY2UodGVtcGxhdGUubGVuZ3RoLTIpLm1hdGNoKC9cXHdcXHcvKSlcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5yZXBsYWNlKC9cXHMqXFxTKyQvLCAnJyk7XG4gICAgICBlbHNlXG4gICAgICAgIHRlbXBsYXRlID0gX3MucnRyaW0odGVtcGxhdGUuc2xpY2UoMCwgdGVtcGxhdGUubGVuZ3RoLTEpKTtcblxuICAgICAgcmV0dXJuICh0ZW1wbGF0ZStwcnVuZVN0cikubGVuZ3RoID4gc3RyLmxlbmd0aCA/IHN0ciA6IHN0ci5zbGljZSgwLCB0ZW1wbGF0ZS5sZW5ndGgpK3BydW5lU3RyO1xuICAgIH0sXG5cbiAgICB3b3JkczogZnVuY3Rpb24oc3RyLCBkZWxpbWl0ZXIpIHtcbiAgICAgIGlmIChfcy5pc0JsYW5rKHN0cikpIHJldHVybiBbXTtcbiAgICAgIHJldHVybiBfcy50cmltKHN0ciwgZGVsaW1pdGVyKS5zcGxpdChkZWxpbWl0ZXIgfHwgL1xccysvKTtcbiAgICB9LFxuXG4gICAgcGFkOiBmdW5jdGlvbihzdHIsIGxlbmd0aCwgcGFkU3RyLCB0eXBlKSB7XG4gICAgICBzdHIgPSBzdHIgPT0gbnVsbCA/ICcnIDogU3RyaW5nKHN0cik7XG4gICAgICBsZW5ndGggPSB+fmxlbmd0aDtcblxuICAgICAgdmFyIHBhZGxlbiAgPSAwO1xuXG4gICAgICBpZiAoIXBhZFN0cilcbiAgICAgICAgcGFkU3RyID0gJyAnO1xuICAgICAgZWxzZSBpZiAocGFkU3RyLmxlbmd0aCA+IDEpXG4gICAgICAgIHBhZFN0ciA9IHBhZFN0ci5jaGFyQXQoMCk7XG5cbiAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgICAgICBwYWRsZW4gPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBzdHIgKyBzdHJSZXBlYXQocGFkU3RyLCBwYWRsZW4pO1xuICAgICAgICBjYXNlICdib3RoJzpcbiAgICAgICAgICBwYWRsZW4gPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBzdHJSZXBlYXQocGFkU3RyLCBNYXRoLmNlaWwocGFkbGVuLzIpKSArIHN0clxuICAgICAgICAgICAgICAgICAgKyBzdHJSZXBlYXQocGFkU3RyLCBNYXRoLmZsb29yKHBhZGxlbi8yKSk7XG4gICAgICAgIGRlZmF1bHQ6IC8vICdsZWZ0J1xuICAgICAgICAgIHBhZGxlbiA9IGxlbmd0aCAtIHN0ci5sZW5ndGg7XG4gICAgICAgICAgcmV0dXJuIHN0clJlcGVhdChwYWRTdHIsIHBhZGxlbikgKyBzdHI7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgbHBhZDogZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHBhZFN0cikge1xuICAgICAgcmV0dXJuIF9zLnBhZChzdHIsIGxlbmd0aCwgcGFkU3RyKTtcbiAgICB9LFxuXG4gICAgcnBhZDogZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHBhZFN0cikge1xuICAgICAgcmV0dXJuIF9zLnBhZChzdHIsIGxlbmd0aCwgcGFkU3RyLCAncmlnaHQnKTtcbiAgICB9LFxuXG4gICAgbHJwYWQ6IGZ1bmN0aW9uKHN0ciwgbGVuZ3RoLCBwYWRTdHIpIHtcbiAgICAgIHJldHVybiBfcy5wYWQoc3RyLCBsZW5ndGgsIHBhZFN0ciwgJ2JvdGgnKTtcbiAgICB9LFxuXG4gICAgc3ByaW50Zjogc3ByaW50ZixcblxuICAgIHZzcHJpbnRmOiBmdW5jdGlvbihmbXQsIGFyZ3Ype1xuICAgICAgYXJndi51bnNoaWZ0KGZtdCk7XG4gICAgICByZXR1cm4gc3ByaW50Zi5hcHBseShudWxsLCBhcmd2KTtcbiAgICB9LFxuXG4gICAgdG9OdW1iZXI6IGZ1bmN0aW9uKHN0ciwgZGVjaW1hbHMpIHtcbiAgICAgIGlmICghc3RyKSByZXR1cm4gMDtcbiAgICAgIHN0ciA9IF9zLnRyaW0oc3RyKTtcbiAgICAgIGlmICghc3RyLm1hdGNoKC9eLT9cXGQrKD86XFwuXFxkKyk/JC8pKSByZXR1cm4gTmFOO1xuICAgICAgcmV0dXJuIHBhcnNlTnVtYmVyKHBhcnNlTnVtYmVyKHN0cikudG9GaXhlZCh+fmRlY2ltYWxzKSk7XG4gICAgfSxcblxuICAgIG51bWJlckZvcm1hdCA6IGZ1bmN0aW9uKG51bWJlciwgZGVjLCBkc2VwLCB0c2VwKSB7XG4gICAgICBpZiAoaXNOYU4obnVtYmVyKSB8fCBudW1iZXIgPT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICBudW1iZXIgPSBudW1iZXIudG9GaXhlZCh+fmRlYyk7XG4gICAgICB0c2VwID0gdHlwZW9mIHRzZXAgPT0gJ3N0cmluZycgPyB0c2VwIDogJywnO1xuXG4gICAgICB2YXIgcGFydHMgPSBudW1iZXIuc3BsaXQoJy4nKSwgZm51bXMgPSBwYXJ0c1swXSxcbiAgICAgICAgZGVjaW1hbHMgPSBwYXJ0c1sxXSA/IChkc2VwIHx8ICcuJykgKyBwYXJ0c1sxXSA6ICcnO1xuXG4gICAgICByZXR1cm4gZm51bXMucmVwbGFjZSgvKFxcZCkoPz0oPzpcXGR7M30pKyQpL2csICckMScgKyB0c2VwKSArIGRlY2ltYWxzO1xuICAgIH0sXG5cbiAgICBzdHJSaWdodDogZnVuY3Rpb24oc3RyLCBzZXApe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTsgc2VwID0gc2VwICE9IG51bGwgPyBTdHJpbmcoc2VwKSA6IHNlcDtcbiAgICAgIHZhciBwb3MgPSAhc2VwID8gLTEgOiBzdHIuaW5kZXhPZihzZXApO1xuICAgICAgcmV0dXJuIH5wb3MgPyBzdHIuc2xpY2UocG9zK3NlcC5sZW5ndGgsIHN0ci5sZW5ndGgpIDogc3RyO1xuICAgIH0sXG5cbiAgICBzdHJSaWdodEJhY2s6IGZ1bmN0aW9uKHN0ciwgc2VwKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IHNlcCA9IHNlcCAhPSBudWxsID8gU3RyaW5nKHNlcCkgOiBzZXA7XG4gICAgICB2YXIgcG9zID0gIXNlcCA/IC0xIDogc3RyLmxhc3RJbmRleE9mKHNlcCk7XG4gICAgICByZXR1cm4gfnBvcyA/IHN0ci5zbGljZShwb3Mrc2VwLmxlbmd0aCwgc3RyLmxlbmd0aCkgOiBzdHI7XG4gICAgfSxcblxuICAgIHN0ckxlZnQ6IGZ1bmN0aW9uKHN0ciwgc2VwKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IHNlcCA9IHNlcCAhPSBudWxsID8gU3RyaW5nKHNlcCkgOiBzZXA7XG4gICAgICB2YXIgcG9zID0gIXNlcCA/IC0xIDogc3RyLmluZGV4T2Yoc2VwKTtcbiAgICAgIHJldHVybiB+cG9zID8gc3RyLnNsaWNlKDAsIHBvcykgOiBzdHI7XG4gICAgfSxcblxuICAgIHN0ckxlZnRCYWNrOiBmdW5jdGlvbihzdHIsIHNlcCl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHN0ciArPSAnJzsgc2VwID0gc2VwICE9IG51bGwgPyAnJytzZXAgOiBzZXA7XG4gICAgICB2YXIgcG9zID0gc3RyLmxhc3RJbmRleE9mKHNlcCk7XG4gICAgICByZXR1cm4gfnBvcyA/IHN0ci5zbGljZSgwLCBwb3MpIDogc3RyO1xuICAgIH0sXG5cbiAgICB0b1NlbnRlbmNlOiBmdW5jdGlvbihhcnJheSwgc2VwYXJhdG9yLCBsYXN0U2VwYXJhdG9yLCBzZXJpYWwpIHtcbiAgICAgIHNlcGFyYXRvciA9IHNlcGFyYXRvciB8fCAnLCAnO1xuICAgICAgbGFzdFNlcGFyYXRvciA9IGxhc3RTZXBhcmF0b3IgfHwgJyBhbmQgJztcbiAgICAgIHZhciBhID0gYXJyYXkuc2xpY2UoKSwgbGFzdE1lbWJlciA9IGEucG9wKCk7XG5cbiAgICAgIGlmIChhcnJheS5sZW5ndGggPiAyICYmIHNlcmlhbCkgbGFzdFNlcGFyYXRvciA9IF9zLnJ0cmltKHNlcGFyYXRvcikgKyBsYXN0U2VwYXJhdG9yO1xuXG4gICAgICByZXR1cm4gYS5sZW5ndGggPyBhLmpvaW4oc2VwYXJhdG9yKSArIGxhc3RTZXBhcmF0b3IgKyBsYXN0TWVtYmVyIDogbGFzdE1lbWJlcjtcbiAgICB9LFxuXG4gICAgdG9TZW50ZW5jZVNlcmlhbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgIGFyZ3NbM10gPSB0cnVlO1xuICAgICAgcmV0dXJuIF9zLnRvU2VudGVuY2UuYXBwbHkoX3MsIGFyZ3MpO1xuICAgIH0sXG5cbiAgICBzbHVnaWZ5OiBmdW5jdGlvbihzdHIpIHtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICB2YXIgZnJvbSAgPSBcIsSFw6DDocOkw6LDo8Olw6bEg8SHxJnDqMOpw6vDqsOsw63Dr8OuxYLFhMOyw7PDtsO0w7XDuMWbyJnIm8O5w7rDvMO7w7HDp8W8xbpcIixcbiAgICAgICAgICB0byAgICA9IFwiYWFhYWFhYWFhY2VlZWVlaWlpaWxub29vb29vc3N0dXV1dW5jenpcIixcbiAgICAgICAgICByZWdleCA9IG5ldyBSZWdFeHAoZGVmYXVsdFRvV2hpdGVTcGFjZShmcm9tKSwgJ2cnKTtcblxuICAgICAgc3RyID0gU3RyaW5nKHN0cikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4LCBmdW5jdGlvbihjKXtcbiAgICAgICAgdmFyIGluZGV4ID0gZnJvbS5pbmRleE9mKGMpO1xuICAgICAgICByZXR1cm4gdG8uY2hhckF0KGluZGV4KSB8fCAnLSc7XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIF9zLmRhc2hlcml6ZShzdHIucmVwbGFjZSgvW15cXHdcXHMtXS9nLCAnJykpO1xuICAgIH0sXG5cbiAgICBzdXJyb3VuZDogZnVuY3Rpb24oc3RyLCB3cmFwcGVyKSB7XG4gICAgICByZXR1cm4gW3dyYXBwZXIsIHN0ciwgd3JhcHBlcl0uam9pbignJyk7XG4gICAgfSxcblxuICAgIHF1b3RlOiBmdW5jdGlvbihzdHIsIHF1b3RlQ2hhcikge1xuICAgICAgcmV0dXJuIF9zLnN1cnJvdW5kKHN0ciwgcXVvdGVDaGFyIHx8ICdcIicpO1xuICAgIH0sXG5cbiAgICB1bnF1b3RlOiBmdW5jdGlvbihzdHIsIHF1b3RlQ2hhcikge1xuICAgICAgcXVvdGVDaGFyID0gcXVvdGVDaGFyIHx8ICdcIic7XG4gICAgICBpZiAoc3RyWzBdID09PSBxdW90ZUNoYXIgJiYgc3RyW3N0ci5sZW5ndGgtMV0gPT09IHF1b3RlQ2hhcilcbiAgICAgICAgcmV0dXJuIHN0ci5zbGljZSgxLHN0ci5sZW5ndGgtMSk7XG4gICAgICBlbHNlIHJldHVybiBzdHI7XG4gICAgfSxcblxuICAgIGV4cG9ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KHByb3ApIHx8IHByb3AubWF0Y2goL14oPzppbmNsdWRlfGNvbnRhaW5zfHJldmVyc2UpJC8pKSBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gdGhpc1twcm9wXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgcmVwZWF0OiBmdW5jdGlvbihzdHIsIHF0eSwgc2VwYXJhdG9yKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuXG4gICAgICBxdHkgPSB+fnF0eTtcblxuICAgICAgLy8gdXNpbmcgZmFzdGVyIGltcGxlbWVudGF0aW9uIGlmIHNlcGFyYXRvciBpcyBub3QgbmVlZGVkO1xuICAgICAgaWYgKHNlcGFyYXRvciA9PSBudWxsKSByZXR1cm4gc3RyUmVwZWF0KFN0cmluZyhzdHIpLCBxdHkpO1xuXG4gICAgICAvLyB0aGlzIG9uZSBpcyBhYm91dCAzMDB4IHNsb3dlciBpbiBHb29nbGUgQ2hyb21lXG4gICAgICBmb3IgKHZhciByZXBlYXQgPSBbXTsgcXR5ID4gMDsgcmVwZWF0Wy0tcXR5XSA9IHN0cikge31cbiAgICAgIHJldHVybiByZXBlYXQuam9pbihzZXBhcmF0b3IpO1xuICAgIH0sXG5cbiAgICBuYXR1cmFsQ21wOiBmdW5jdGlvbihzdHIxLCBzdHIyKXtcbiAgICAgIGlmIChzdHIxID09IHN0cjIpIHJldHVybiAwO1xuICAgICAgaWYgKCFzdHIxKSByZXR1cm4gLTE7XG4gICAgICBpZiAoIXN0cjIpIHJldHVybiAxO1xuXG4gICAgICB2YXIgY21wUmVnZXggPSAvKFxcLlxcZCspfChcXGQrKXwoXFxEKykvZyxcbiAgICAgICAgdG9rZW5zMSA9IFN0cmluZyhzdHIxKS50b0xvd2VyQ2FzZSgpLm1hdGNoKGNtcFJlZ2V4KSxcbiAgICAgICAgdG9rZW5zMiA9IFN0cmluZyhzdHIyKS50b0xvd2VyQ2FzZSgpLm1hdGNoKGNtcFJlZ2V4KSxcbiAgICAgICAgY291bnQgPSBNYXRoLm1pbih0b2tlbnMxLmxlbmd0aCwgdG9rZW5zMi5sZW5ndGgpO1xuXG4gICAgICBmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICB2YXIgYSA9IHRva2VuczFbaV0sIGIgPSB0b2tlbnMyW2ldO1xuXG4gICAgICAgIGlmIChhICE9PSBiKXtcbiAgICAgICAgICB2YXIgbnVtMSA9IHBhcnNlSW50KGEsIDEwKTtcbiAgICAgICAgICBpZiAoIWlzTmFOKG51bTEpKXtcbiAgICAgICAgICAgIHZhciBudW0yID0gcGFyc2VJbnQoYiwgMTApO1xuICAgICAgICAgICAgaWYgKCFpc05hTihudW0yKSAmJiBudW0xIC0gbnVtMilcbiAgICAgICAgICAgICAgcmV0dXJuIG51bTEgLSBudW0yO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYSA8IGIgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRva2VuczEubGVuZ3RoID09PSB0b2tlbnMyLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIHRva2VuczEubGVuZ3RoIC0gdG9rZW5zMi5sZW5ndGg7XG5cbiAgICAgIHJldHVybiBzdHIxIDwgc3RyMiA/IC0xIDogMTtcbiAgICB9LFxuXG4gICAgbGV2ZW5zaHRlaW46IGZ1bmN0aW9uKHN0cjEsIHN0cjIpIHtcbiAgICAgIGlmIChzdHIxID09IG51bGwgJiYgc3RyMiA9PSBudWxsKSByZXR1cm4gMDtcbiAgICAgIGlmIChzdHIxID09IG51bGwpIHJldHVybiBTdHJpbmcoc3RyMikubGVuZ3RoO1xuICAgICAgaWYgKHN0cjIgPT0gbnVsbCkgcmV0dXJuIFN0cmluZyhzdHIxKS5sZW5ndGg7XG5cbiAgICAgIHN0cjEgPSBTdHJpbmcoc3RyMSk7IHN0cjIgPSBTdHJpbmcoc3RyMik7XG5cbiAgICAgIHZhciBjdXJyZW50ID0gW10sIHByZXYsIHZhbHVlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBzdHIyLmxlbmd0aDsgaSsrKVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8PSBzdHIxLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgaWYgKGkgJiYgailcbiAgICAgICAgICAgIGlmIChzdHIxLmNoYXJBdChqIC0gMSkgPT09IHN0cjIuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICAgdmFsdWUgPSBwcmV2O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICB2YWx1ZSA9IE1hdGgubWluKGN1cnJlbnRbal0sIGN1cnJlbnRbaiAtIDFdLCBwcmV2KSArIDE7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFsdWUgPSBpICsgajtcblxuICAgICAgICAgIHByZXYgPSBjdXJyZW50W2pdO1xuICAgICAgICAgIGN1cnJlbnRbal0gPSB2YWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICByZXR1cm4gY3VycmVudC5wb3AoKTtcbiAgICB9LFxuXG4gICAgdG9Cb29sZWFuOiBmdW5jdGlvbihzdHIsIHRydWVWYWx1ZXMsIGZhbHNlVmFsdWVzKSB7XG4gICAgICBpZiAodHlwZW9mIHN0ciA9PT0gXCJudW1iZXJcIikgc3RyID0gXCJcIiArIHN0cjtcbiAgICAgIGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSByZXR1cm4gISFzdHI7XG4gICAgICBzdHIgPSBfcy50cmltKHN0cik7XG4gICAgICBpZiAoYm9vbE1hdGNoKHN0ciwgdHJ1ZVZhbHVlcyB8fCBbXCJ0cnVlXCIsIFwiMVwiXSkpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKGJvb2xNYXRjaChzdHIsIGZhbHNlVmFsdWVzIHx8IFtcImZhbHNlXCIsIFwiMFwiXSkpIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgLy8gQWxpYXNlc1xuXG4gIF9zLnN0cmlwICAgID0gX3MudHJpbTtcbiAgX3MubHN0cmlwICAgPSBfcy5sdHJpbTtcbiAgX3MucnN0cmlwICAgPSBfcy5ydHJpbTtcbiAgX3MuY2VudGVyICAgPSBfcy5scnBhZDtcbiAgX3Mucmp1c3QgICAgPSBfcy5scGFkO1xuICBfcy5sanVzdCAgICA9IF9zLnJwYWQ7XG4gIF9zLmNvbnRhaW5zID0gX3MuaW5jbHVkZTtcbiAgX3MucSAgICAgICAgPSBfcy5xdW90ZTtcbiAgX3MudG9Cb29sICAgPSBfcy50b0Jvb2xlYW47XG5cbiAgLy8gRXhwb3J0aW5nXG5cbiAgLy8gQ29tbW9uSlMgbW9kdWxlIGlzIGRlZmluZWRcbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cylcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gX3M7XG5cbiAgICBleHBvcnRzLl9zID0gX3M7XG4gIH1cblxuICAvLyBSZWdpc3RlciBhcyBhIG5hbWVkIG1vZHVsZSB3aXRoIEFNRC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcbiAgICBkZWZpbmUoJ3VuZGVyc2NvcmUuc3RyaW5nJywgW10sIGZ1bmN0aW9uKCl7IHJldHVybiBfczsgfSk7XG5cblxuICAvLyBJbnRlZ3JhdGUgd2l0aCBVbmRlcnNjb3JlLmpzIGlmIGRlZmluZWRcbiAgLy8gb3IgY3JlYXRlIG91ciBvd24gdW5kZXJzY29yZSBvYmplY3QuXG4gIHJvb3QuXyA9IHJvb3QuXyB8fCB7fTtcbiAgcm9vdC5fLnN0cmluZyA9IHJvb3QuXy5zdHIgPSBfcztcbn0odGhpcywgU3RyaW5nKTtcblxufSx7fV0sMTYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmFyZ3VtZW50c1s0XVsxXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcbn0se1wiZHVwXCI6MX1dLDE2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5tb2R1bGUuZXhwb3J0cz17XG4gIFwibmFtZVwiOiBcImppaVwiLFxuICBcInZlcnNpb25cIjogXCIwLjcuMVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiSmlpIC0gRnVsbC1TdGFjayBKYXZhU2NyaXB0IEZyYW1ld29ya1wiLFxuICBcIm1haW5cIjogXCJpbmRleC5qc1wiLFxuICBcImJyb3dzZXJcIjogXCJpbmRleC1jbGllbnQuanNcIixcbiAgXCJhdXRob3JcIjogXCJWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlwiLFxuICBcInNjcmlwdHNcIjoge1xuICAgIFwidGVzdFwiOiBcIm5vZGV1bml0IHRlc3RzL3VuaXRcIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ppaXNvZnQvamlpXCJcbiAgfSxcbiAgXCJrZXl3b3Jkc1wiOiBbXG4gICAgXCJ5aWlcIixcbiAgICBcInBocFwiLFxuICAgIFwiZnJhbWV3b3JrXCIsXG4gICAgXCJqYXZhc2NyaXB0XCJcbiAgXSxcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwiaG9tZXBhZ2VcIjogXCJodHRwczovL2dpdGh1Yi5jb20vamlpc29mdC9qaWlcIixcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9qaWlzb2Z0L2ppaS9pc3N1ZXNcIlxuICB9LFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJuZWF0bmVzc1wiOiBcIl4xLjEuMTBcIixcbiAgICBcInJlcXVpcmUtYWxsXCI6IFwiMC4wLjhcIixcbiAgICBcInVuZGVyc2NvcmVcIjogXCJeMS44LjNcIixcbiAgICBcInVuZGVyc2NvcmUuc3RyaW5nXCI6IFwiXjIuNC4wXCJcbiAgfSxcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibm9kZXVuaXRcIjogXCIqXCJcbiAgfVxufVxuXG59LHt9XX0se30sWzk0XSk7XG4iXSwiZmlsZSI6ImFwcC1jbGllbnQuanMiLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==
