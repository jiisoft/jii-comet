(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],2:[function(require,module,exports){
window._ = window._ || require('underscore');

require('./lib/clientBaseBrowserify');
require('./lib/Object');
require('./lib/Exception');
require('./lib/NeatCometClient');
require('./lib/router/ConnectionClient');
require('./lib/router/OpenedProfileClient');

module.exports = window.NeatComet;
},{"./lib/Exception":3,"./lib/NeatCometClient":4,"./lib/Object":5,"./lib/clientBaseBrowserify":6,"./lib/router/ConnectionClient":7,"./lib/router/OpenedProfileClient":8,"underscore":1}],3:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.Exception
 */
NeatComet.Exception = function(msg) {

    this.msg = msg;
};

NeatComet.Exception.prototype = {

    msg: null

};

NeatComet.Exception.warning = function(msg) {

    if (typeof console !== 'undefined') {
        console.error("NeatComet warning: " + msg);
    }
};

},{}],4:[function(require,module,exports){
/**
 * @callback NeatComet.NeatCometClient~createCollection
 * @param {string} profileId
 * @param {string} bindingId
 * @param {*} profilesDefinition
 * @param {NeatComet.router.OpenedProfileClient} openedProfile
 * @returns {NeatComet.api.ICollectionClient}
 */

/**
 * @class NeatComet.NeatCometClient
 * @extends NeatComet.Object
 */
NeatComet.NeatCometClient = NeatComet.Object.extend(/** @lends NeatComet.NeatCometClient.prototype */{

    /** @type {NeatComet.api.ICometClient} */
    comet: null,

    /** @type {NeatComet.NeatCometClient~createCollection} */
    createCollection: null,

    /** @type {NeatComet.NeatCometClient~callCollection} */
    callCollection: null,

    /** @type {Object.<string, Object.<string, *>>} */
    profilesDefinition: null,

    /** @type {Object} */
    _openedProfileParams: null,

    /** @type {Object.<number, NeatComet.router.OpenedProfileClient>} */
    _openedProfiles: null,

    /** @type {Object.<string, NeatComet.router.OpenedProfileClient[]>} */
    _openedProfilesByProfileId: null,

    /** @type {NeatComet.router.ConnectionClient} */
    _connection: null,

    /** @type {number} */
    _lastId: 0,

    init: function() {

        this._openedProfileParams = [];
        this._openedProfiles = {};
        this._openedProfilesByProfileId = {};
        this.callCollection = this.callCollection || this._callCollection.bind(this);

        // Setup channel
        this._connection = new NeatComet.router.ConnectionClient({
            comet: this.comet,
            onConnectionRestore: _.bind(this.refresh, this),
            onInit: _.bind(this._onRefreshResponse, this),
            onMessage: _.bind(this._onChannelMessage, this)
        });
    },

    refresh: function() {

        // Call server
        if (this._openedProfileParams.length) {
            this._connection.sendOpen(this._openedProfileParams);
        }
    },

    /**
     *
     * @param {string} profileId
     * @param {object} [params]
     * @returns {NeatComet.router.OpenedProfileClient}
     */
    openProfile: function(profileId, params) {

        var openedProfileId = ++this._lastId;

        this._openedProfileParams.push([openedProfileId, profileId, params || {}]);

        // Init openedProfile
        var openedProfile = new NeatComet.router.OpenedProfileClient();
        openedProfile.id = openedProfileId;
        openedProfile.profileId = profileId;
        openedProfile.createCollection = this.createCollection || /* legacy */ this.getCollection;
        openedProfile.profileDefinition = this.profilesDefinition[profileId];
        openedProfile.init();
        this._openedProfiles[openedProfileId] = openedProfile;

        if (!this._openedProfilesByProfileId[profileId]) {
            this._openedProfilesByProfileId[profileId] = [];
        }
        this._openedProfilesByProfileId[profileId].push(openedProfile);

        // Connect
        // TODO: optimize
        if (this._connection && this._connection.isReady) {
            this.refresh();
        }

        return openedProfile;
    },

    /**
     * @param profiles
     * @param callback
     * @deprecated
     */
    open: function(profiles, callback) {

        // Mark
        _.each(profiles, function(params, profileId) {

            var openedProfile = this.openProfile(profileId, params);

            if (callback) {
                callback(openedProfile, openedProfile.profileId, openedProfile.id);
            }

        }, this);
    },

    _onRefreshResponse: function(profileData) {

        // Setup enabled bindings
        _.each(profileData, function(profileBindings, profileId) {

            _.each(profileBindings, function(bindingId_data) {

                var bindingId = bindingId_data[0];

                _.each(this._openedProfilesByProfileId[profileId], function(openedProfile) {

                    // Init call
                    var collection = openedProfile.getCollection(bindingId);
                    this.callCollection.call(null, collection, 'reset', bindingId_data[1]);
                }, this);

            }, this);

        }, this);
    },

    _onChannelMessage: function(channel, data) {

        var regs = channel.match(/^([^:]+):([^:]+)(:.+)?/);
        this._callCollections(regs[1], regs[2], data);
    },

    _callCollections: function(profileRef, bindingId, args) {
        var callCollection = function (openedProfile) {
            var collection = openedProfile.getCollection(bindingId);
            this.callCollection.apply(null, [collection].concat(args));
        }.bind(this);

        if (profileRef.substr(0, 1) === '!') {
            callCollection(this._openedProfiles[profileRef.substr(1)]);
        }
        else {
            _.each(this._openedProfilesByProfileId[profileRef], callCollection);
        }
    },

    /**
     *
     * @param {NeatComet.api.ICollectionClient} collection
     * @param {string} method
     * @param {...*} param1
     * @protected
     */
    _callCollection: function(collection, method, param1) {
        collection[method].apply(collection, _.toArray(arguments).slice(2));
    }

});

},{}],5:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * Basic class supports two types of initialization
 *
 * I. Single operator call. Note: init() is being called internally
 * var x = new X({
 *     abc: 123
 * });
 *
 * II. Explicit initialization
 * var x = new X; // Don't pass any parameter in constructor. init() won't be called implicitly.
 * x.abc = 123;
 * x.init();
 *
 * @class NeatComet.Object
 *
 * @param {Object.<string, *>} [config]
 */
NeatComet.Object = function(config) {

    if (config) {
        _.assign(this, config);
        this.init();
    }
};

NeatComet.Object.prototype = {

    init: function() {
    }

};

/**
 * Function to define subclasses
 *
 * It is a part of Backbone.js 1.2.3 http://backbonejs.org
 * (c) 2010-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 *
 * @param {Object} protoProps
 * @param {Object} [staticProps]
 */
NeatComet.Object.extend = function(protoProps, staticProps) {

    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
        child = protoProps.constructor;
    } else {
        child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent` constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
};
},{}],6:[function(require,module,exports){
// Enough jsdoc is in serverBase.js
window.NeatComet = {
    adapters: {},
    router: {}
};

},{}],7:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.router.ConnectionClient
 * @extends NeatComet.Object
 */
NeatComet.router.ConnectionClient = NeatComet.Object.extend(/** @lends NeatComet.router.ConnectionClient.prototype */{

    /** @type {NeatComet.api.ICometClient} */
    comet: null,

    /** @type {Function} */
    onConnectionRestore: null,

    /** @type {Function} */
    onInit: null,

    /** @type {Function} */
    onMessage: null,

    isReady: false,

    _lastInitId: 0,
    _waitingFor: 1, // Lock initially. Null = not waiting
    _messageQueue: [],

    init: function() {

        // Install comet listeners
        this.comet.bindEvents({
            onConnectionRestore: _.bind(this._onCometConnectionRestore, this),
            onMessage: _.bind(this._onCometMessage, this)
        });
    },

    _onCometConnectionRestore: function() {

        this.isReady = true;
        this.onConnectionRestore();
    },

    _onCometMessage: function(channel, data) {

        if (this._waitingFor) {
            this._messageQueue.push([channel, data]);
        }
        else {
            this.onMessage(channel, data);
        }
    },

    sendOpen: function(params) {

        // Force initialization-time messages to run after initialization
        var requestId = ++this._lastInitId;
        this._waitingFor = requestId;
        this._messageQueue = [];

        this.comet.sendOpen(params, _.bind(function(data) {

            // Drop the result of a wrong call
            if (this._waitingFor != requestId) {
                return;
            }

            // Stop waiting
            this._waitingFor = null;

            // Effective init
            this.onInit(data);

            // Flush pending messages
            _.each(this._messageQueue, function(message) {
                this.onMessage.apply(this, message);
            }, this);
            this._messageQueue = [];

        }, this));
    }

});

},{}],8:[function(require,module,exports){
/**
 * @copyright Copyright 2014 <a href="http://www.extpoint.com">ExtPoint</a>
 * @author <a href="http://koryagin.com">Pavel Koryagin</a>
 * @license MIT
 */

/**
 * @class NeatComet.router.OpenedProfileClient
 * @extends NeatComet.Object
 */
NeatComet.router.OpenedProfileClient = NeatComet.Object.extend(/** @lends NeatComet.router.OpenedProfileServer.prototype */{

    /** @type {Number} */
    id: null,

    /** @type {String} */
    profileId: null,

    /** @type {NeatComet.NeatCometClient~createCollection} */
    createCollection: null,

    /** @type {Object.<string, Object.<string, *>>} */
    profileDefinition: null,

    /** @type {Object.<string, NeatComet.api.ICollectionClient>} */
    collections: null,

    init: function() {
        this.collections = {};
    },

    getCollection: function(bindingId) {

        // Lazy init
        if (!_.has(this.collections, bindingId)) {
            
            if (!_.has(this.profileDefinition, bindingId)) {
                throw new NeatComet.Exception('Wrong bindingId ' + bindingId);
            }

            this.collections[bindingId] = this.createCollection(
                this.profileId,
                bindingId,
                this.profileDefinition[bindingId],
                this
            );
        }

        return this.collections[bindingId];
    },

    /**
     * @param {Object} target
     */
    populateNamespace: function(target) {

        _.each(this.profileDefinition, function (params, bindingId) {
            target[bindingId] = this.getCollection(bindingId).getNative();
        }, this);
    }

});

},{}],9:[function(require,module,exports){
'use strict';

require('jii');
require('jii-model');

// Load framework files
require('./lib/ActiveRecord');
require('./lib/Expression');
require('./lib/AfterSaveEvent');
require('./lib/remote/Command');
require('./lib/remote/Connection');
require('./lib/remote/Schema');
require('./lib/remote/TransportInterface');
},{"./lib/ActiveRecord":10,"./lib/AfterSaveEvent":11,"./lib/Expression":12,"./lib/remote/Command":13,"./lib/remote/Connection":14,"./lib/remote/Schema":15,"./lib/remote/TransportInterface":16,"jii":124,"jii-model":96}],10:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @abstract
 * @class Jii.sql.ActiveRecord
 * @extends Jii.base.ActiveRecord
 */
Jii.defineClass('Jii.sql.ActiveRecord', /** @lends Jii.sql.ActiveRecord.prototype */{

	__extends: Jii.base.ActiveRecord,
	
	__static: /** @lends Jii.sql.ActiveRecord */{

		/**
		 * Returns the database connection used by this AR class.
		 * By default, the "db" application component is used as the database connection.
		 * You may override this method if you want to use a different database connection.
		 * @returns {Jii.sql.Connection} the database connection used by this AR class.
		 */
		getDb: function () {
			return Jii.app.getComponent('db');
		},

		/**
		 * Creates an [[ActiveQuery]] instance with a given SQL statement.
		 *
		 * Note that because the SQL statement is already specified, calling additional
		 * query modification methods (such as `where()`, `order()`) on the created [[ActiveQuery]]
		 * instance will have no effect. However, calling `with()`, `asArray()` or `indexBy()` is
		 * still fine.
		 *
		 * Below is an example:
		 *
		 * ~~~
		 * customers = Customer.findBySql('SELECT * FROM customer').all();
		 * ~~~
		 *
		 * @param {string} sql the SQL statement to be executed
		 * @param {[]} params parameters to be bound to the SQL statement during execution.
		 * @returns {Jii.sql.ActiveQuery} the newly created [[ActiveQuery]] instance
		 */
		findBySql: function (sql, params) {
			params = params || [];

			var query = this.find();
			query.setSql(sql);

			return query.params(params);
		},

		/**
		 * Updates the whole table using the provided attribute values and conditions.
		 * For example, to change the status to be 1 for all customers whose status is 2:
		 *
		 * ~~~
		 * Customer.updateAll({status: 1}, 'status = 2');
		 * ~~~
		 *
		 * @param {[]} attributes attribute values (name-value pairs) to be saved into the table
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * @returns {Promise.<number>} the number of rows updated
		 */
		updateAll: function (attributes, condition, params) {
			condition = condition || '';
			params = params || {};

			return this.getDb().createCommand().update(this.tableName(), attributes, condition, params);
		},

		/**
		 * Updates the whole table using the provided counter changes and conditions.
		 * For example, to increment all customers' age by 1,
		 *
		 * ~~~
		 * Customer.updateAllCounters({age: 1});
		 * ~~~
		 *
		 * @param {[]} counters the counters to be updated (attribute name => increment value).
		 * Use negative values if you want to decrement the counters.
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * Do not name the parameters as `:bp0`, `:bp1`, etc., because they are used internally by this method.
		 * @returns {number} the number of rows updated
		 */
		updateAllCounters: function (counters, condition, params) {
			condition = condition || '';
			params = params || {};

			var n = 0;
			Jii._.each(counters, Jii._.bind(function(value, name) {
				var params = {};
				params[':bp{' + n + '}'] = value;
				counters[name] = new Jii.sql.Expression('[[' + name + ']]+:bp{' + n + '}', params);
				n++;
			}, this));

			return this.getDb().createCommand().update(this.tableName(), counters, condition, params);
		},

		/**
		 * Deletes rows in the table using the provided conditions.
		 * WARNING: If you do not specify any condition, this method will delete ALL rows in the table.
		 *
		 * For example, to delete all customers whose status is 3:
		 *
		 * ~~~
		 * Customer.deleteAll('status = 3');
		 * ~~~
		 *
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the DELETE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {object} [params] the parameters (name => value) to be bound to the query.
		 * @returns {number} the number of rows deleted
		 */
		deleteAll: function (condition, params) {
			condition = condition || '';
			params = params || {};

			return this.getDb().createCommand().delete(this.tableName(), condition, params);
		},

		/**
		 * @inheritdoc
		 */
		find: function () {
			return new Jii.sql.ActiveQuery(this);
		},

		/**
		 * Declares the name of the database table associated with this AR class.
		 * By default this method returns the class name as the table name by calling [[Inflector.camel2id()]]
		 * with prefix [[Connection.tablePrefix]]. For example if [[Connection.tablePrefix]] is 'tbl_',
		 * 'Customer' becomes 'tbl_customer', and 'OrderItem' becomes 'tbl_order_item'. You may override this method
		 * if the table is not named after this convention.
		 * @returns {string} the table name
		 */
		tableName: function () {
			var className = this.className();
			var name = className.substr(className.lastIndexOf('.') + 1);

			return '{{%' + Jii._s.underscored(name) + '}}';
		},

		/**
		 * Returns the schema information of the DB table associated with this AR class.
		 * @returns {Jii.sql.TableSchema} the schema information of the DB table associated with this AR class.
		 * @throws {Jii.exceptions.InvalidConfigException} if the table for the AR class does not exist.
		 */
		getTableSchema: function () {
			var schema = this.getDb().getTableSchema(this.tableName());
			if (schema === null) {
				throw new Jii.exceptions.InvalidConfigException("The table does not exist: " + this.tableName());
			}

			return schema;
		},

		/**
		 * Returns the primary key name(s) for this AR class.
		 * The default implementation will return the primary key(s) as declared
		 * in the DB table that is associated with this AR class.
		 *
		 * If the DB table does not declare any primary key, you should override
		 * this method to return the attributes that you want to use as primary keys
		 * for this AR class.
		 *
		 * Note that an array should be returned even for a table with single primary key.
		 *
		 * @returns {string[]} the primary keys of the associated database table.
		 */
		primaryKey: function () {
			return this.getTableSchema().primaryKey;
		},

		populateRecord: function (record, row) {

			var columns = this.__static.getTableSchema().columns;
			Jii._.each(row, function(value, name) {
				if (Jii._.has(columns, name)) {
					row[name] = columns[name].typecast(value);
				}
			});

			this.__super(record, row);
		}

	},


	/**
	 * Loads default values from database table schema
	 *
	 * @param {boolean} [skipIfSet] if existing value should be preserved
	 * @returns {Promise} model instance
	 */
	loadDefaultValues: function (skipIfSet) {
		skipIfSet = skipIfSet !== false;

		Jii._.each(this.__static.getTableSchema().columns, function(column) {
			if (column.defaultValue !== null && (!skipIfSet || this.get(column.name) === null)) {
				this.set(column.name, column.defaultValue);
			}
		}.bind(this));
	},

	/**
	 * Returns the list of all attribute names of the model.
	 * The default implementation will return all column names of the table associated with this AR class.
	 * @returns {[]} list of attribute names.
	 */
	attributes: function () {
		return Jii._.keys(this.__static.getTableSchema().columns);
	},

	/**
	 * Inserts a row into the associated database table using the attribute values of this record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. insert the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_INSERT]], [[EVENT_AFTER_INSERT]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be inserted into database.
	 *
	 * If the table's primary key is auto-incremental and is null during insertion,
	 * it will be populated with the actual value after insertion.
	 *
	 * For example, to insert a customer record:
	 *
	 * ~~~
	 * customer = new Customer();
	 * customer.name = name;
	 * customer.email = email;
	 * customer.insert();
	 * ~~~
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {[]} attributes list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the attributes are valid and the record is inserted successfully.
	 * @throws \Exception in case insert failed.
	 */
	insert: function (runValidation, attributes) {
		runValidation = runValidation !== false;
		attributes = attributes || null;

		return Promise.resolve().then(function() {
			if (runValidation) {
				return this.validate(attributes);
			}

			return true;
		}.bind(this)).then(function(isValidate) {
			if (!isValidate) {
				Jii.info('Model not inserted due to validation error.');
				return false;
			}

			/*var db = this.__static.getDb();
			 if (this.isTransactional(self.OP_INSERT)) {
			 transaction = db.beginTransaction();
			 try {
			 result = this.insertInternal(attributes);
			 if (result === false) {
			 transaction.rollBack();
			 } else {
			 transaction.commit();
			 }
			 } catch (\Exception e) {
			 transaction.rollBack();
			 throw e;
			 }
			 } else {*/
			return this._insertInternal(attributes);
			//}
		}.bind(this));
	},

	/**
	 * Inserts an ActiveRecord into DB without considering transaction.
	 * @param {[]} attributes list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the record is inserted successfully.
	 */
	_insertInternal: function (attributes) {
		attributes = attributes || null;

		return this.beforeSave(true).then(function(bool) {
			if (!bool) {
				return false;
			}

			var values = this.getDirtyAttributes(attributes);
			if (Jii._.isEmpty(values)) {
				Jii._.each(this.getPrimaryKey(true), function(value, key) {
					values[key] = value;
				});
			}

			return this.__static.getDb().createCommand().insertModel(this, values).then(function(insertInfo) {
				if (!insertInfo) {
					return false;
				}

				var table = this.__static.getTableSchema();
				if (table.sequenceName !== null) {
					for (var i = 0, l = table.primaryKey.length; i < l; i++) {
						var name = table.primaryKey[i];
						if (this.getAttribute(name) === null) {
							var id = table.columns[name].typecast(insertInfo.insertId);
							this.setAttribute(name, id);
							values[name] = id;
							break;
						}
					}
				}

                var changedAttributes = {};
                Jii._.each(values, function(num, key) {
                    changedAttributes[key] = null;
                });
				this.setOldAttributes(values);
				return this.afterSave(true, changedAttributes).then(function() {
					return true;
				});
			}.bind(this));
		}.bind(this));
	},

	/**
	 * Saves the changes to this active record into the associated database table.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. save the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_UPDATE]], [[EVENT_AFTER_UPDATE]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be saved into database.
	 *
	 * For example, to update a customer record:
	 *
	 * ~~~
	 * customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.update();
	 * ~~~
	 *
	 * Note that it is possible the update does not affect any row in the table.
	 * In this case, this method will return 0. For this reason, you should use the following
	 * code to check if update() is successful or not:
	 *
	 * ~~~
	 * if (this.update() !== false) {
     *     // update successful
     * } else {
     *     // update failed
     * }
	 * ~~~
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {[]} attributeNames list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {number|boolean} the number of rows affected, or false if validation fails
	 * or [[beforeSave()]] stops the updating process.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being updated is outdated.
	 * @throws \Exception in case update failed.
	 */
	update: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		return Promise.resolve().then(function() {
			if (runValidation) {
				return this.validate(attributeNames);
			}

			return true;
		}.bind(this)).then(function(isValidate) {
			if (!isValidate) {
				Jii.info('Model not updated due to validation error.');
				return false;
			}

			/*db = static.getDb();
			if (this.isTransactional(self.OP_UPDATE)) {
				transaction = db.beginTransaction();
				try {
					result = this.updateInternal(attributeNames);
					if (result === false) {
						transaction.rollBack();
					} else {
						transaction.commit();
					}
				} catch (\Exception e) {
					transaction.rollBack();
					throw e;
				}
			} else {*/
				return this._updateInternal(attributeNames);
			//}

		}.bind(this));


	},

	/**
	 * Deletes the table row corresponding to this active record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeDelete()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 2. delete the record from the database;
	 * 3. call [[afterDelete()]].
	 *
	 * In the above step 1 and 3, events named [[EVENT_BEFORE_DELETE]] and [[EVENT_AFTER_DELETE]]
	 * will be raised by the corresponding methods.
	 *
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being deleted is outdated.
	 * @throws \Exception in case delete failed.
	 */
	delete: function () {
		/*db = static.getDb();
		if (this.isTransactional(self.OP_DELETE)) {
			transaction = db.beginTransaction();
			try {
				result = this.deleteInternal();
				if (result === false) {
					transaction.rollBack();
				} else {
					transaction.commit();
				}
			} catch (\Exception e) {
				transaction.rollBack();
				throw e;
			}
		} else {*/
			return this._deleteInternal();
		//}

		//return result;
	},

	/**
	 * Deletes an ActiveRecord without considering transaction.
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException
	 */
	_deleteInternal: function () {

		return this.beforeDelete().then(function(bool) {
			if (!bool) {
				return false;
			}

            return this.__static.getDb().createCommand().deleteModel(this).then(function(result) {
				/*if (lock !== null && !result) {
				 throw new StaleObjectException('The object being deleted is outdated.');
				 }*/
				this.setOldAttributes(null);

				return this.afterDelete().then(function() {
					return result;
				});
			}.bind(this));
		}.bind(this));
	},

	/**
	 * Returns a value indicating whether the given active record is the same as the current one.
	 * The comparison is made by comparing the table names and the primary key values of the two active records.
	 * If one of the records [[isNewRecord|is new]] they are also considered not equal.
	 * @param {Jii.sql.ActiveRecord} record record to compare to
	 * @returns {boolean} whether the two active records refer to the same row in the same database table.
	 */
	equals: function (record) {
		if (this.isNewRecord() || record.isNewRecord()) {
			return false;
		}

		return this.__static.tableName() === record.__static.tableName() && this.getPrimaryKey() === record.getPrimaryKey();
	}

});

},{"jii":124}],11:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.AfterSaveEvent
 * @extends Jii.base.ModelEvent
 */
Jii.defineClass('Jii.sql.AfterSaveEvent', /** @lends Jii.sql.AfterSaveEvent.prototype */{

	__extends: Jii.base.ModelEvent,

	/**
	 * The attribute values that had changed and were saved.
	 * @type {string[]}
	 */
	changedAttributes: null

});

},{"jii":124}],12:[function(require,module,exports){
/**
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * Expression represents a DB expression that does not need escaping or quoting.
 * When an Expression object is embedded within a SQL statement or fragment,
 * it will be replaced with the [[expression]] property value without any
 * DB escaping or quoting. For example,
 *
 * ~~~
 * expression = new Expression('NOW()');
 * sql = 'SELECT ' . expression;  // SELECT NOW()
 * ~~~
 *
 * An expression can also be bound with parameters specified via [[params]].
 *
 * @class Jii.sql.Expression
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.sql.Expression', /** @lends Jii.sql.Expression.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {string} the DB expression
	 */
	expression: null,

	/**
	 * @type {object} list of parameters that should be bound for this expression.
	 * The keys are placeholders appearing in [[expression]] and the values
	 * are the corresponding parameter values.
	 */
	params: null,

	/**
	 * Constructor.
	 * @param {string} expression the DB expression
	 * @param {object} params parameters
	 * @param {[]} config name-value pairs that will be used to initialize the object properties
	 * @constructor
	 */
	constructor: function (expression, params, config) {
		params = params || [];
		config = config || [];

		this.expression = expression;
		this.params = params;
		this.__super(config);
	},

	/**
	 * String magic method
	 * @returns {string} the DB expression
	 */
	toString: function() {
		return this.expression;
	}

});
},{"jii":124}],13:[function(require,module,exports){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.Command
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.Command', /** @lends Jii.sql.remote.Command.prototype */{

	__extends: Jii.base.Component,

    __static: /** @lends Jii.sql.remote.Command */{

        METHOD_INSERT: 'insert',
        METHOD_UPDATE: 'update',
        METHOD_DELETE: 'delete'

    },

	/**
	 * @type {Jii.sql.BaseConnection} the DB connection that this command is associated with
	 */
	db: null,

	/**
	 * @returns {Promise}
	 */
	queryAll: function () {
		return this._queryInternal('all');
	},

	/**
	 * @returns {Promise}
	 */
	queryOne: function () {
		return this._queryInternal('one');
	},

	/**
	 * @returns {Promise}
	 */
	queryScalar: function () {
		return this._queryInternal('scalar');
	},

	/**
	 * @returns {Promise}
	 */
	queryColumn: function () {
		return this._queryInternal('column');
	},

	/**
	 * Performs the actual DB query of a SQL statement.
	 * @param {string} method
	 * @returns {Promise} the method execution result
	 * @throws Exception if the query causes any problem
	 */
	_queryInternal: function (method) {
	},

    /**
     *
     * @param {Jii.sql.ActiveRecord} model
     * @param {object} values
     * @returns {Promise}
     */
    insertModel: function(model, values) {
        return this.db.exec(this.__static.METHOD_INSERT, model.className(), {
            values: values
        }).then(function(result) {
            if (!result) {
                return null;
            }

            if (!Jii._.isEmpty(result.errors)) {
                model.setErrors(result.errors);
                return null;
            }
            if (result.attributes) {
                model.setAttributes(result.attributes);
            }

            return {
                insertId: model.getPrimaryKey()
            };
        });
    },

    /**
     *
     * @param {Jii.base.ActiveRecord} model
     * @param {object} values
     * @returns {Promise}
     */
    updateModel: function(model, values) {
        return this.db.exec(this.__static.METHOD_UPDATE, model.className(), {
            primaryKey: model.getOldPrimaryKey(true),
            values: values
        }).then(function(result) {
            if (!result) {
                return 0;
            }

            if (!Jii._.isEmpty(result.errors)) {
                model.setErrors(result.errors);
                return 0;
            }

            return result.success ? 1 : 0;
        });
    },


    /**
     *
     * @param {Jii.base.ActiveRecord} model
     * @returns {Promise}
     */
    deleteModel: function(model) {
        return this.db.exec(this.__static.METHOD_DELETE, model.className(), {
            primaryKey: model.getOldPrimaryKey(true)
        }).then(function(result) {
            return result && result.success ? 1 : 0;
        });
    }

});
},{"jii":124}],14:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 *
 * @class Jii.sql.remote.Connection
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.Connection', /** @lends Jii.sql.remote.Connection.prototype */{

	__extends: Jii.base.Component,

    /**
     * @type {Jii.sql.remote.Schema} the database schema
     */
    schema: {
        className: 'Jii.sql.remote.Schema'
    },

    /**
     * @type {Jii.sql.remote.TransportInterface}
     */
    transport: null,

    /**
     * @type {string}
     */
    route: 'api/ar',

    init: function() {
        this.schema = Jii.createObject(this.schema);
    },

    getTransport: function() {
        if (this.transport === null) {
            this.transport = Jii.app.get('comet');
        } else if (!(this.transport instanceof Jii.base.Component)) {
            this.transport = Jii.createObject(this.transport);
        }
        return this.transport;
    },

    /**
     * Creates a command for execution.
     * @returns {Jii.sql.remote.Command} the DB command
     */
    createCommand: function () {
        return new Jii.sql.remote.Command({
            db: this
        });
    },

    /**
     *
     * @param {string} method
     * @param {string} modelClassName
     * @param {object} [params]
     * @returns {Promise}
     */
    exec: function(method, modelClassName, params) {
        params = params || {};
        params.method = method;
        params.modelClassName = modelClassName;

        return this.getTransport().request(this.route, params);
    },

    /**
     * Returns the schema information for the database opened by this connection.
     * @returns {Jii.sql.remote.Schema} the schema information for the database opened by this connection.
     */
    getSchema: function () {
        return this.schema;
    },

    /**
     * Obtains the schema information for the named table.
     * @param {string} name table name.
     * @returns {*} table schema information. Null if the named table does not exist.
     */
    getTableSchema: function (name) {
        return this.getSchema().getTableSchema(name);
    }

});
},{"jii":124}],15:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.Schema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.sql.remote.Schema', /** @lends Jii.sql.remote.Schema.prototype */{

	__extends: Jii.base.Object,


    tables: {},

    /**
     *
     * @param name
     * @returns {Jii.base.ModelSchema}
     */
    getTableSchema: function (name) {
        if (Jii._.isObject(this.tables[name]) && !(this.tables[name] instanceof Jii.base.ModelSchema)) {
            this.tables[name] = Jii.base.ModelSchema.createFromObject(this.tables[name]);
        }

        return this.tables[name] || null;
    },

    getTableNames: function () {
        return Jii._.keys(this.tables);
    }

});

},{"jii":124}],16:[function(require,module,exports){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.sql.remote.TransportInterface
 * @interface Jii.sql.remote.TransportInterface
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.sql.remote.TransportInterface', /** @lends Jii.sql.remote.TransportInterface.prototype */{

	__extends: Jii.base.Component,

    /**
     * Send request to backend
     * @param {string} route
     * @param {object} [params]
     * @returns {Promise}
     */
	request: function(route, params) {
	}

});
},{"jii":124}],17:[function(require,module,exports){
'use strict';

require('jii');

// Load framework files
require('./lib/client/plugin/AutoReconnect');
require('./lib/client/plugin/PluginInterface');
require('./lib/client/transport/TransportInterface');
require('./lib/client/Client');
require('./lib/client/LogMessageEvent');
require('./lib/client/MessageEvent');
require('./lib/client/RequestEvent');
require('./lib/ChannelEvent');
require('./lib/LogEvent');

},{"./lib/ChannelEvent":18,"./lib/LogEvent":19,"./lib/client/Client":20,"./lib/client/LogMessageEvent":21,"./lib/client/MessageEvent":22,"./lib/client/RequestEvent":24,"./lib/client/plugin/AutoReconnect":25,"./lib/client/plugin/PluginInterface":26,"./lib/client/transport/TransportInterface":28,"jii":124}],18:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.ChannelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.ChannelEvent', /** @lends Jii.comet.ChannelEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
	channel: null,

	/**
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],19:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.LogEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.LogEvent', /** @lends Jii.comet.LogEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * Level: debug/info/warning/error
	 * @type {string}
	 */
	level: null,

	/**
	 * Log message
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],20:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * Read-only from api stationUid
 * @type {null}
 */
var stationUid = null;

/**
 * @class Jii.comet.client.Client
 * @extends Jii.base.Component
 * @implements Jii.sql.remote.TransportInterface
 */
Jii.defineClass('Jii.comet.client.Client', /** @lends Jii.comet.client.Client.prototype */{

	__extends: Jii.base.Component,

	__static: /** @lends Jii.comet.client.Client */{

		/**
		 * @event Jii.comet.client.Client#open
		 * @property {Jii.base.Event} event
		 */
		EVENT_OPEN: 'open',

		/**
		 * @event Jii.comet.client.Client#close
		 * @property {Jii.base.Event} event
		 */
		EVENT_CLOSE: 'close',

		/**
		 * @event Jii.comet.client.Client#beforeSend
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_BEFORE_SEND: 'beforeSend',

		/**
		 * @event Jii.comet.client.Client#channel
		 * @property {Jii.comet.ChannelEvent} event
		 */
		EVENT_CHANNEL: 'channel',

		/**
		 * @event Jii.comet.client.Client#channel:
		 * @property {Jii.comet.ChannelEvent} event
		 */
		EVENT_CHANNEL_NAME: 'channel:',

		/**
		 * @event Jii.comet.client.Client#message
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_MESSAGE: 'message',

        /**
         * @event Jii.comet.client.Client#beforeRequest
         * @property {Jii.comet.client.RequestEvent} event
         */
        EVENT_BEFORE_REQUEST: 'beforeRequest',

        /**
         * @event Jii.comet.client.Client#request
         * @property {Jii.comet.client.RequestEvent} event
         */
        EVENT_REQUEST: 'request'

	},

	/**
	 * @type {Jii.comet.client.transport.TransportInterface}
	 */
	transport: {
		className: 'Jii.comet.client.transport.Sockjs'
	},

	plugins: {

		/**
		 * @type {Jii.comet.client.plugin.AutoReconnect}
		 */
		autoReconnect: {
			className: 'Jii.comet.client.plugin.AutoReconnect'
		}

	},

	/**
	 * Max comet workers number. Used for auto generate different server urls (balancer).
	 */
	workersCount: null,

	/**
	 * @type {boolean}
	 */
	autoOpen: true,

	/**
	 * Url to comet server
	 * @type {string}
	 */
	_serverUrl: '',

	/**
	 * @type {boolean}
	 */
	_isOpened: false,

	/**
	 * @type {boolean}
	 */
	_forceClosed: false,

    /**
     * @type {object}
     */
    _requestsInProcess: {},

	init: function () {
		stationUid = Jii.helpers.String.generateUid();

		// Init transport
		this.transport = Jii.createObject(this.transport);
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_OPEN, this._onOpen.bind(this));
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_CLOSE, this._onClose.bind(this));
		this.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_MESSAGE, this._onMessage.bind(this));

		// Init plugins
		Jii._.each(this.plugins, function(config, name) {
			config.comet = this;
			this.plugins[name] = Jii.createObject(config);
		}.bind(this));

		// Auto open
		if (this.autoOpen) {
			this.open();
		}
	},

	/**
	 * Set url to comet server
	 * Detect server url by pattern, if set. Used for balancer server by clients random().
	 * @param {string} value
	 */
	setServerUrl: function(value) {
		// Normalize
		if (value.indexOf('//') === 0) {
			var sslSuffix = location.protocol === 'https' ? 's' : ''
			value = 'http' + sslSuffix + ':' + value;
		}

		// Balancer
		if (value.indexOf('{workerIndex}') !== -1) {
			var min = 0;
			var max = Math.max(this.workersCount || 0, 1) - 1;
			var workerIndex = min + Math.floor(Math.random() * (max - min + 1));
			value = value.replace('{workerIndex}', String(workerIndex));
		}

		// Switch server URL protocol to HTTP instead of HTTPS if browser is IE9 or lesser
		var isIE = window.navigator && (/MSIE/.test(navigator.userAgent) && !/opera/i.test(navigator.userAgent));
		if (isIE && window.document && window.document.all && !window.atob) {
			var isSsl = /^(http|ws)s/.test(value);
			if (isSsl === location.protocol === 'https') {
				value = value.replace(/^(http|ws)s/, '$1');
			}
		}

		this._serverUrl = value;
	},

	/**
	 * Return comet server url
	 * @returns {string}
	 */
	getServerUrl: function() {
		return this._serverUrl;
	},

	/**
	 * Return station UID - unique id of current javascript environment (browser tab)
	 * @returns {null}
	 */
	getStationUid: function() {
		return stationUid;
	},

	/**
	 * Return true, if connection is opened
	 * @returns {boolean}
	 */
	isOpened: function() {
		return this._isOpened;
	},

	/**
	 * Return true, if connection closed by client (manually)
	 * @returns {boolean}
	 */
	isForceClosed: function() {
		return this._forceClosed;
	},

	/**
	 * Open connection
	 */
	open: function() {
		this._forceClosed = false;
		if (!this._isOpened) {
			this.transport.open(this._serverUrl);
		}
	},

	/**
	 * Close connection
	 */
	close: function() {
		this._forceClosed = true;
		if (this._isOpened) {
			this.transport.close();
		}
	},

	/**
	 *
	 * @param {string} channel
	 * @param {object} data
	 */
	send: function(channel, data) {
		this._sendInternal('channel ' + channel + ' ' + JSON.stringify(data));
	},

    /**
     *
     * @param {string} route
     * @param {object} [data]
     */
    request: function (route, data) {
        data = data || {};
        data.requestUid = Jii.helpers.String.generateUid();

        // Trigger event for append data
        var event = new Jii.comet.client.RequestEvent({
            route: route,
            params: data
        });
        this.trigger(this.__static.EVENT_BEFORE_REQUEST, event);
        data = event.params;

        // Generate promise for wait response
        var promise = new Promise(function(resolve) {
            this._requestsInProcess[data.requestUid] = {
                route: route,
                resolve: resolve
            };
        }.bind(this));

        // Send request
        this._sendInternal('action ' + route + ' ' + JSON.stringify(data));

        return promise;
    },

	/**
	 *
	 * @param {string} message
	 * @private
	 */
	_sendInternal: function(message) {
		// Trigger event before send message
        var event = new Jii.comet.client.MessageEvent({
            message: message
        });
		this.trigger(this.__static.EVENT_BEFORE_SEND, event);
        message = event.message;

		if (this._isOpened) {
			this.transport.send(message);
		}
	},

	_onOpen: function (event) {
		if (!this._isOpened) {
			this._isOpened = true;
			this.trigger(this.__static.EVENT_OPEN, event);
		}
	},

	_onClose: function (event) {
		if (this._isOpened) {
			this._isOpened = false;
			this.trigger(this.__static.EVENT_CLOSE, event);
		}
	},

    _onMessage: function (event) {
        if (event.message.indexOf('action ') === 0) {
            var response = JSON.parse(event.message.substr(7));
            if (response.requestUid && this._requestsInProcess[response.requestUid]) {
                this._requestsInProcess[response.requestUid].resolve(response);

                // Trigger request event
                this.trigger(this.__static.EVENT_REQUEST, new Jii.comet.client.RequestEvent({
                    route: this._requestsInProcess[response.requestUid].route,
                    params: response
                }));

                delete this._requestsInProcess[response.requestUid];
            }
        }

		if (event.message.indexOf('channel ') === 0) {
			var message = event.message.substr(8);
			var i = message.indexOf(' ');
			var channelEvent = new Jii.comet.ChannelEvent({
				channel: message.substr(0, i),
				params: JSON.parse(message.substr(i + 1))
			});

			// Trigger channel and channel:* events
			this.trigger(this.__static.EVENT_CHANNEL_NAME + channelEvent.channel, channelEvent);
			this.trigger(this.__static.EVENT_CHANNEL, channelEvent);
		}

		// Trigger message event
		this.trigger(this.__static.EVENT_MESSAGE, new Jii.comet.client.MessageEvent({
			message: event.message
		}));
	}

});

},{"jii":124}],21:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.LogMessageEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.LogMessageEvent', /** @lends Jii.comet.client.LogMessageEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 *  Level: debug/info/warning/error
	 * @type {string}
	 */
	level: null,

	/**
	 * Log message
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],22:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.MessageEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.MessageEvent', /** @lends Jii.comet.client.MessageEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
	message: null

});

},{"jii":124}],23:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

var NeatComet = require('neatcomet');


/**
 * @class Jii.comet.client.NeatClient
 * @extends Jii.base.Component
 * @implements NeatComet.api.ICometClient
 */
Jii.defineClass('Jii.comet.client.NeatClient', /** @lends Jii.comet.client.NeatClient.prototype */{

    __extends: Jii.base.Component,

    __static: /** @lends Jii.comet.client.NeatClient */{

        ROUTE_PREFIX: 'profiles:'

    },

    /**
     * @type {Jii.comet.client.Client}
     */
    comet: null,

    /**
     * @type {object}
     */
    bindings: null,

    /**
     * @type {NeatComet.NeatCometClient}
     */
    engine: {
        className: 'NeatComet.NeatCometClient'
    },

    init: function () {
        this.__super();

        this.comet = this.comet === null ?
            Jii.app.get('comet') :
            (
                this.comet instanceof Jii.base.Component ?
                    this.comet :
                    Jii.createObject(this.comet)
            );

        // Move NeatComet to Jii namespace
        Jii._.extend(Jii.namespace('NeatComet'), NeatComet);

        this.engine.comet = this;
        this.engine.profilesDefinition = this.bindings;
        this.engine.createCollection = this.engine.createCollection || this._createCollection.bind(this);
        this.engine.callCollection = this.engine.callCollection || this._callCollection.bind(this);
        this.engine = Jii.createObject(this.engine);
    },

    /**
     *
     * @param profileId
     * @param params
     * @returns {NeatComet.router.OpenedProfileClient}
     */
    openProfile: function(profileId, params) {
        return this.engine.openProfile(profileId, params);
    },

    /**
     * Allowed to expect that it will be called only once per ICometServer instance
     * @param {NeatComet.api.ICometClientEvents} eventsHandler
     */
    bindEvents: function(eventsHandler) {
        this.comet.on(Jii.comet.client.Client.EVENT_CHANNEL, function(event) {
            if (event.channel.indexOf(this.__static.ROUTE_PREFIX) === 0) {
                eventsHandler.onMessage(event.channel.substr(this.__static.ROUTE_PREFIX.length), event.params);
            }
        }.bind(this));

        this.comet.on('open', function() {
            eventsHandler.onConnectionRestore();
        });
    },

    /**
     * @param {object} params
     * @param {NeatComet.api.ICometClient~openSuccess} successCallback
     */
    sendOpen: function(params, successCallback) {
        this.comet.request('neat/open', { neat: params }).then(function(data) {

            // Chain with NeatComet handler
            successCallback(data.neat);
        });
    },

    /**
     * @param {string[]} ids
     */
    sendClose: function(ids) {
        this.comet.request('neat/close', { neat: ids });
    },

    _createCollection: function(profileId, bindingId, definition, openedProfile) {
        var modelClassName = definition.clientModel || definition.serverModel || Jii.base.ActiveRecord;
        return new Jii.base.Collection([], {
            modelClass: Jii.namespace(modelClassName)
        });
    },

    /**
     *
     * @param {Jii.base.Collection} collection
     * @param {string} method
     * @param {*} param1
     * @param {...*} param2
     * @protected
     */
    _callCollection: function(collection, method, param1, param2) {
        var model;

        if (collection instanceof Jii.base.Collection) {
            switch (method) {
                case 'add':
                    model = collection.createModel(param1);

                    // Mark as exists record (not isNew)
                    model.setOldAttributes(Jii._.clone(model.getAttributes()));

                    collection.add(model);
                    return;

                case 'reset':
                    Jii._.each(param1, function(data) {
                        this._callCollection(collection, 'add', data);
                    }.bind(this));
                    return;

                case 'update':
                    model = collection.getById(param2);
                    if (model) {
                        model.set(param1);
                    } else {
                        collection.add(param1);
                    }
                    return;
            }
        }

        collection[method].apply(collection, Jii._.toArray(arguments).slice(2));
    }

});

},{"jii":124,"neatcomet":2}],24:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.RequestEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.comet.client.RequestEvent', /** @lends Jii.comet.client.RequestEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {string}
	 */
    route: null

});

},{"jii":124}],25:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./PluginInterface');

/**
 * @class Jii.comet.client.plugin.AutoReconnect
 * @extends Jii.comet.client.plugin.PluginInterface
 */
Jii.defineClass('Jii.comet.client.plugin.AutoReconnect', /** @lends Jii.comet.client.plugin.AutoReconnect.prototype */{

	__extends: Jii.comet.client.plugin.PluginInterface,

	/**
	 * @type {boolean}
	 */
	enable: true,

	/**
	 * Minimal retry interval in milliseconds
	 * @type {number}
	 */
	minRetryInterval: 2000,

	/**
	 * Maximal retry interval in milliseconds
	 * @type {number}
	 */
	maxRetryInterval: 20000,

	/**
	 * @type {number}
	 */
	_tryReconnectNumber: 0,

	init: function() {
		this.comet.on(Jii.comet.client.Client.EVENT_OPEN, this._onOpen.bind(this));
		this.comet.transport.on(Jii.comet.client.transport.TransportInterface.EVENT_CLOSE, this._onClose.bind(this));
	},

	_onOpen: function() {
		this._tryReconnectNumber = 0;
	},

	_onClose: function() {
		if (this.enable && !this.comet.isForceClosed()) {
			setTimeout(function() {
				this._tryReconnectNumber++;
				this.comet.open();
			}.bind(this), this._tryReconnectNumber > 10 ? this.maxRetryInterval : this.minRetryInterval);
		}
	}

});
},{"./PluginInterface":26,"jii":124}],26:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.plugin.PluginInterface
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.comet.client.plugin.PluginInterface', /** @lends Jii.comet.client.plugin.PluginInterface.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {Jii.comet.client.Client}
	 */
	comet: null

});
},{"jii":124}],27:[function(require,module,exports){
(function (global){
'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

// sockjs global fix: sockjs expect that global object is equal window, but it is not always, for example in node-webkit
if (typeof global !== 'undefined' && typeof window !== 'undefined' && global !== window) {
    var usedWindowKeys = ['document', 'location', 'XMLHttpRequest', 'EventSource', 'WebSocket', 'MozWebSocket',
        'XDomainRequest', 'crypto', 'navigator', 'chrome', 'addEventListener', 'attachEvent',
        'removeEventListener', 'detachEvent', 'parent', 'postMessage', 'console'];
    Jii._.each(usedWindowKeys, function(key) {
        global[key] = window[key];
    });
}
// @todo jsonp callbacks

var SockJS = require('sockjs-client');

/**
 * @class Jii.comet.client.transport.Sockjs
 * @extends Jii.comet.client.transport.TransportInterface
 */
Jii.defineClass('Jii.comet.client.transport.Sockjs', /** @lends Jii.comet.client.transport.Sockjs.prototype */{

	__extends: Jii.comet.client.transport.TransportInterface,

    /**
     * Available:
     * - websocket
     * - xdr-polling
     * - xdr-streaming
     * - xhr-polling
     * - xhr-streaming
     * - eventsource
     * - htmlfile
     * - iframe
     * - jsonp-polling
     */
    transports: null,

	/**
	 * @type {SockJS}
	 */
	_websocket: null,

	/**
	 * Open connection
	 * @param {string} url
	 */
	open: function(url) {
		this._websocket = new SockJS(url, null, {
			//debug: HelpOnClick.debug,
            transports: this.transports
		});

		this._websocket.onopen = this._onOpen.bind(this);
		this._websocket.onmessage = this._onMessage.bind(this);
		this._websocket.onclose = this._onClose.bind(this);
	},

	/**
	 * Close connection
	 */
	close: function() {
		if (this._websocket) {
			this._websocket.close();
			this._websocket = null;
		}
	},

	/**
	 * Send message to server
	 * @param {string} message
	 */
	send: function(message) {
		if (this._websocket) {
			this._websocket.send(message);
		}
	},

	_onOpen: function() {
		this.trigger(this.__static.EVENT_OPEN, new Jii.base.Event());
	},

	_onClose: function(errorEvent) {
		this.trigger(this.__static.EVENT_CLOSE, new Jii.base.Event());
	},

	_onMessage: function (event) {
		if (event.type === 'message') {
			this.trigger(this.__static.EVENT_MESSAGE, new Jii.comet.client.MessageEvent({
				message: event.data
			}));
		}
	}

});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"jii":124,"sockjs-client":31}],28:[function(require,module,exports){

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.comet.client.transport.TransportInterface
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.comet.client.transport.TransportInterface', /** @lends Jii.comet.client.transport.TransportInterface.prototype */{

	__extends: Jii.base.Component,

	__static: /** @lends Jii.comet.client.transport.TransportInterface */{

		/**
		 * @event Jii.comet.client.transport.TransportInterface#open
		 * @property {Jii.base.Event} event
		 */
		EVENT_OPEN: 'open',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#close
		 * @property {Jii.base.Event} event
		 */
		EVENT_CLOSE: 'close',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#message
		 * @property {Jii.comet.client.MessageEvent} event
		 */
		EVENT_MESSAGE: 'message',

		/**
		 * @event Jii.comet.client.transport.TransportInterface#log
		 * @property {Jii.comet.client.LogMessageEvent} event
		 */
		EVENT_LOG: 'log'

	},

	/**
	 * Open connection
	 * @param {string} url
	 */
	open: function(url) {
	},

	/**
	 * Close connection
	 */
	close: function() {
	},

	/**
	 * Send message to server
	 * @param {string} message
	 */
	send: function(message) {
	}

});
},{"jii":124}],29:[function(require,module,exports){
require('./index-client');
require('./lib/client/NeatClient');
},{"./index-client":17,"./lib/client/NeatClient":23}],30:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],31:[function(require,module,exports){
(function (global){
'use strict';

var transportList = require('./transport-list');

module.exports = require('./main')(transportList);

// TODO can't get rid of this until all servers do
if ('_sockjs_onload' in global) {
  setTimeout(global._sockjs_onload, 1);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./main":44,"./transport-list":46}],32:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function CloseEvent() {
  Event.call(this);
  this.initEvent('close', false, false);
  this.wasClean = false;
  this.code = 0;
  this.reason = '';
}

inherits(CloseEvent, Event);

module.exports = CloseEvent;

},{"./event":34,"inherits":87}],33:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventTarget = require('./eventtarget')
  ;

function EventEmitter() {
  EventTarget.call(this);
}

inherits(EventEmitter, EventTarget);

EventEmitter.prototype.removeAllListeners = function(type) {
  if (type) {
    delete this._listeners[type];
  } else {
    this._listeners = {};
  }
};

EventEmitter.prototype.once = function(type, listener) {
  var self = this
    , fired = false;

  function g() {
    self.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  this.on(type, g);
};

EventEmitter.prototype.emit = function(type) {
  var listeners = this._listeners[type];
  if (!listeners) {
    return;
  }
  var args = Array.prototype.slice.call(arguments, 1);
  for (var i = 0; i < listeners.length; i++) {
    listeners[i].apply(this, args);
  }
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener = EventTarget.prototype.addEventListener;
EventEmitter.prototype.removeListener = EventTarget.prototype.removeEventListener;

module.exports.EventEmitter = EventEmitter;

},{"./eventtarget":35,"inherits":87}],34:[function(require,module,exports){
'use strict';

function Event(eventType) {
  this.type = eventType;
}

Event.prototype.initEvent = function(eventType, canBubble, cancelable) {
  this.type = eventType;
  this.bubbles = canBubble;
  this.cancelable = cancelable;
  this.timeStamp = +new Date();
  return this;
};

Event.prototype.stopPropagation = function() {};
Event.prototype.preventDefault  = function() {};

Event.CAPTURING_PHASE = 1;
Event.AT_TARGET       = 2;
Event.BUBBLING_PHASE  = 3;

module.exports = Event;

},{}],35:[function(require,module,exports){
'use strict';

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */

function EventTarget() {
  this._listeners = {};
}

EventTarget.prototype.addEventListener = function(eventType, listener) {
  if (!(eventType in this._listeners)) {
    this._listeners[eventType] = [];
  }
  var arr = this._listeners[eventType];
  // #4
  if (arr.indexOf(listener) === -1) {
    // Make a copy so as not to interfere with a current dispatchEvent.
    arr = arr.concat([listener]);
  }
  this._listeners[eventType] = arr;
};

EventTarget.prototype.removeEventListener = function(eventType, listener) {
  var arr = this._listeners[eventType];
  if (!arr) {
    return;
  }
  var idx = arr.indexOf(listener);
  if (idx !== -1) {
    if (arr.length > 1) {
      // Make a copy so as not to interfere with a current dispatchEvent.
      this._listeners[eventType] = arr.slice(0, idx).concat(arr.slice(idx + 1));
    } else {
      delete this._listeners[eventType];
    }
    return;
  }
};

EventTarget.prototype.dispatchEvent = function(event) {
  var t = event.type;
  var args = Array.prototype.slice.call(arguments, 0);
  // TODO: This doesn't match the real behavior; per spec, onfoo get
  // their place in line from the /first/ time they're set from
  // non-null. Although WebKit bumps it to the end every time it's
  // set.
  if (this['on' + t]) {
    this['on' + t].apply(this, args);
  }
  if (t in this._listeners) {
    // Grab a reference to the listeners list. removeEventListener may alter the list.
    var listeners = this._listeners[t];
    for (var i = 0; i < listeners.length; i++) {
      listeners[i].apply(this, args);
    }
  }
};

module.exports = EventTarget;

},{}],36:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , Event = require('./event')
  ;

function TransportMessageEvent(data) {
  Event.call(this);
  this.initEvent('message', false, false);
  this.data = data;
}

inherits(TransportMessageEvent, Event);

module.exports = TransportMessageEvent;

},{"./event":34,"inherits":87}],37:[function(require,module,exports){
'use strict';

var JSON3 = require('json3')
  , iframeUtils = require('./utils/iframe')
  ;

function FacadeJS(transport) {
  this._transport = transport;
  transport.on('message', this._transportMessage.bind(this));
  transport.on('close', this._transportClose.bind(this));
}

FacadeJS.prototype._transportClose = function(code, reason) {
  iframeUtils.postMessage('c', JSON3.stringify([code, reason]));
};
FacadeJS.prototype._transportMessage = function(frame) {
  iframeUtils.postMessage('t', frame);
};
FacadeJS.prototype._send = function(data) {
  this._transport.send(data);
};
FacadeJS.prototype._close = function() {
  this._transport.close();
  this._transport.removeAllListeners();
};

module.exports = FacadeJS;

},{"./utils/iframe":77,"json3":88}],38:[function(require,module,exports){
(function (process){
'use strict';

var urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , JSON3 = require('json3')
  , FacadeJS = require('./facade')
  , InfoIframeReceiver = require('./info-iframe-receiver')
  , iframeUtils = require('./utils/iframe')
  , loc = require('./location')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:iframe-bootstrap');
}

module.exports = function(SockJS, availableTransports) {
  var transportMap = {};
  availableTransports.forEach(function(at) {
    if (at.facadeTransport) {
      transportMap[at.facadeTransport.transportName] = at.facadeTransport;
    }
  });

  // hard-coded for the info iframe
  // TODO see if we can make this more dynamic
  transportMap[InfoIframeReceiver.transportName] = InfoIframeReceiver;
  var parentOrigin;

  /* eslint-disable camelcase */
  SockJS.bootstrap_iframe = function() {
    /* eslint-enable camelcase */
    var facade;
    iframeUtils.currentWindowId = loc.hash.slice(1);
    var onMessage = function(e) {
      if (e.source !== parent) {
        return;
      }
      if (typeof parentOrigin === 'undefined') {
        parentOrigin = e.origin;
      }
      if (e.origin !== parentOrigin) {
        return;
      }

      var iframeMessage;
      try {
        iframeMessage = JSON3.parse(e.data);
      } catch (ignored) {
        debug('bad json', e.data);
        return;
      }

      if (iframeMessage.windowId !== iframeUtils.currentWindowId) {
        return;
      }
      switch (iframeMessage.type) {
      case 's':
        var p;
        try {
          p = JSON3.parse(iframeMessage.data);
        } catch (ignored) {
          debug('bad json', iframeMessage.data);
          break;
        }
        var version = p[0];
        var transport = p[1];
        var transUrl = p[2];
        var baseUrl = p[3];
        debug(version, transport, transUrl, baseUrl);
        // change this to semver logic
        if (version !== SockJS.version) {
          throw new Error('Incompatibile SockJS! Main site uses:' +
                    ' "' + version + '", the iframe:' +
                    ' "' + SockJS.version + '".');
        }

        if (!urlUtils.isOriginEqual(transUrl, loc.href) ||
            !urlUtils.isOriginEqual(baseUrl, loc.href)) {
          throw new Error('Can\'t connect to different domain from within an ' +
                    'iframe. (' + loc.href + ', ' + transUrl + ', ' + baseUrl + ')');
        }
        facade = new FacadeJS(new transportMap[transport](transUrl, baseUrl));
        break;
      case 'm':
        facade._send(iframeMessage.data);
        break;
      case 'c':
        if (facade) {
          facade._close();
        }
        facade = null;
        break;
      }
    };

    eventUtils.attachEvent('message', onMessage);

    // Start
    iframeUtils.postMessage('s');
  };
};

}).call(this,require('_process'))
},{"./facade":37,"./info-iframe-receiver":40,"./location":43,"./utils/event":76,"./utils/iframe":77,"./utils/url":82,"_process":30,"debug":84,"json3":88}],39:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , objectUtils = require('./utils/object')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-ajax');
}

function InfoAjax(url, AjaxObject) {
  EventEmitter.call(this);

  var self = this;
  var t0 = +new Date();
  this.xo = new AjaxObject('GET', url);

  this.xo.once('finish', function(status, text) {
    var info, rtt;
    if (status === 200) {
      rtt = (+new Date()) - t0;
      if (text) {
        try {
          info = JSON3.parse(text);
        } catch (e) {
          debug('bad json', text);
        }
      }

      if (!objectUtils.isObject(info)) {
        info = {};
      }
    }
    self.emit('finish', info, rtt);
    self.removeAllListeners();
  });
}

inherits(InfoAjax, EventEmitter);

InfoAjax.prototype.close = function() {
  this.removeAllListeners();
  this.xo.close();
};

module.exports = InfoAjax;

}).call(this,require('_process'))
},{"./utils/object":79,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],40:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , JSON3 = require('json3')
  , XHRLocalObject = require('./transport/sender/xhr-local')
  , InfoAjax = require('./info-ajax')
  ;

function InfoReceiverIframe(transUrl) {
  var self = this;
  EventEmitter.call(this);

  this.ir = new InfoAjax(transUrl, XHRLocalObject);
  this.ir.once('finish', function(info, rtt) {
    self.ir = null;
    self.emit('message', JSON3.stringify([info, rtt]));
  });
}

inherits(InfoReceiverIframe, EventEmitter);

InfoReceiverIframe.transportName = 'iframe-info-receiver';

InfoReceiverIframe.prototype.close = function() {
  if (this.ir) {
    this.ir.close();
    this.ir = null;
  }
  this.removeAllListeners();
};

module.exports = InfoReceiverIframe;

},{"./info-ajax":39,"./transport/sender/xhr-local":67,"events":33,"inherits":87,"json3":88}],41:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , utils = require('./utils/event')
  , IframeTransport = require('./transport/iframe')
  , InfoReceiverIframe = require('./info-iframe-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-iframe');
}

function InfoIframe(baseUrl, url) {
  var self = this;
  EventEmitter.call(this);

  var go = function() {
    var ifr = self.ifr = new IframeTransport(InfoReceiverIframe.transportName, url, baseUrl);

    ifr.once('message', function(msg) {
      if (msg) {
        var d;
        try {
          d = JSON3.parse(msg);
        } catch (e) {
          debug('bad json', msg);
          self.emit('finish');
          self.close();
          return;
        }

        var info = d[0], rtt = d[1];
        self.emit('finish', info, rtt);
      }
      self.close();
    });

    ifr.once('close', function() {
      self.emit('finish');
      self.close();
    });
  };

  // TODO this seems the same as the 'needBody' from transports
  if (!global.document.body) {
    utils.attachEvent('load', go);
  } else {
    go();
  }
}

inherits(InfoIframe, EventEmitter);

InfoIframe.enabled = function() {
  return IframeTransport.enabled();
};

InfoIframe.prototype.close = function() {
  if (this.ifr) {
    this.ifr.close();
  }
  this.removeAllListeners();
  this.ifr = null;
};

module.exports = InfoIframe;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./info-iframe-receiver":40,"./transport/iframe":52,"./utils/event":76,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],42:[function(require,module,exports){
(function (process){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , urlUtils = require('./utils/url')
  , XDR = require('./transport/sender/xdr')
  , XHRCors = require('./transport/sender/xhr-cors')
  , XHRLocal = require('./transport/sender/xhr-local')
  , XHRFake = require('./transport/sender/xhr-fake')
  , InfoIframe = require('./info-iframe')
  , InfoAjax = require('./info-ajax')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:info-receiver');
}

function InfoReceiver(baseUrl, urlInfo) {
  debug(baseUrl);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self.doXhr(baseUrl, urlInfo);
  }, 0);
}

inherits(InfoReceiver, EventEmitter);

// TODO this is currently ignoring the list of available transports and the whitelist

InfoReceiver._getReceiver = function(baseUrl, url, urlInfo) {
  // determine method of CORS support (if needed)
  if (urlInfo.sameOrigin) {
    return new InfoAjax(url, XHRLocal);
  }
  if (XHRCors.enabled) {
    return new InfoAjax(url, XHRCors);
  }
  if (XDR.enabled && urlInfo.sameScheme) {
    return new InfoAjax(url, XDR);
  }
  if (InfoIframe.enabled()) {
    return new InfoIframe(baseUrl, url);
  }
  return new InfoAjax(url, XHRFake);
};

InfoReceiver.prototype.doXhr = function(baseUrl, urlInfo) {
  var self = this
    , url = urlUtils.addPath(baseUrl, '/info')
    ;
  debug('doXhr', url);

  this.xo = InfoReceiver._getReceiver(baseUrl, url, urlInfo);

  this.timeoutRef = setTimeout(function() {
    debug('timeout');
    self._cleanup(false);
    self.emit('finish');
  }, InfoReceiver.timeout);

  this.xo.once('finish', function(info, rtt) {
    debug('finish', info, rtt);
    self._cleanup(true);
    self.emit('finish', info, rtt);
  });
};

InfoReceiver.prototype._cleanup = function(wasClean) {
  debug('_cleanup');
  clearTimeout(this.timeoutRef);
  this.timeoutRef = null;
  if (!wasClean && this.xo) {
    this.xo.close();
  }
  this.xo = null;
};

InfoReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  this._cleanup(false);
};

InfoReceiver.timeout = 8000;

module.exports = InfoReceiver;

}).call(this,require('_process'))
},{"./info-ajax":39,"./info-iframe":41,"./transport/sender/xdr":64,"./transport/sender/xhr-cors":65,"./transport/sender/xhr-fake":66,"./transport/sender/xhr-local":67,"./utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],43:[function(require,module,exports){
(function (global){
'use strict';

module.exports = global.location || {
  origin: 'http://localhost:80'
, protocol: 'http'
, host: 'localhost'
, port: 80
, href: 'http://localhost/'
, hash: ''
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],44:[function(require,module,exports){
(function (process,global){
'use strict';

require('./shims');

var URL = require('url-parse')
  , inherits = require('inherits')
  , JSON3 = require('json3')
  , random = require('./utils/random')
  , escape = require('./utils/escape')
  , urlUtils = require('./utils/url')
  , eventUtils = require('./utils/event')
  , transport = require('./utils/transport')
  , objectUtils = require('./utils/object')
  , browser = require('./utils/browser')
  , log = require('./utils/log')
  , Event = require('./event/event')
  , EventTarget = require('./event/eventtarget')
  , loc = require('./location')
  , CloseEvent = require('./event/close')
  , TransportMessageEvent = require('./event/trans-message')
  , InfoReceiver = require('./info-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  // Make debug module available globally so you can enable via the console easily
  global.dbg = require('debug');
  debug = global.dbg('sockjs-client:main');
}

var transports;

// follow constructor steps defined at http://dev.w3.org/html5/websockets/#the-websocket-interface
function SockJS(url, protocols, options) {
  if (!(this instanceof SockJS)) {
    return new SockJS(url, protocols, options);
  }
  if (arguments.length < 1) {
    throw new TypeError("Failed to construct 'SockJS: 1 argument required, but only 0 present");
  }
  EventTarget.call(this);

  this.readyState = SockJS.CONNECTING;
  this.extensions = '';
  this.protocol = '';

  // non-standard extension
  options = options || {};
  if (options.protocols_whitelist) {
    log.warn("'protocols_whitelist' is DEPRECATED. Use 'transports' instead.");
  }
  this._transportsWhitelist = options.transports;

  var sessionId = options.sessionId || 8;
  if (typeof sessionId === 'function') {
    this._generateSessionId = sessionId;
  } else if (typeof sessionId === 'number') {
    this._generateSessionId = function() {
      return random.string(sessionId);
    };
  } else {
    throw new TypeError("If sessionId is used in the options, it needs to be a number or a function.");
  }

  this._server = options.server || random.numberString(1000);

  // Step 1 of WS spec - parse and validate the url. Issue #8
  var parsedUrl = new URL(url);
  if (!parsedUrl.host || !parsedUrl.protocol) {
    throw new SyntaxError("The URL '" + url + "' is invalid");
  } else if (parsedUrl.hash) {
    throw new SyntaxError('The URL must not contain a fragment');
  } else if (parsedUrl.protocol !== 'http:' && parsedUrl.protocol !== 'https:') {
    throw new SyntaxError("The URL's scheme must be either 'http:' or 'https:'. '" + parsedUrl.protocol + "' is not allowed.");
  }

  var secure = parsedUrl.protocol === 'https:';
  // Step 2 - don't allow secure origin with an insecure protocol
  if (loc.protocol === 'https' && !secure) {
    throw new Error('SecurityError: An insecure SockJS connection may not be initiated from a page loaded over HTTPS');
  }

  // Step 3 - check port access - no need here
  // Step 4 - parse protocols argument
  if (!protocols) {
    protocols = [];
  } else if (!Array.isArray(protocols)) {
    protocols = [protocols];
  }

  // Step 5 - check protocols argument
  var sortedProtocols = protocols.sort();
  sortedProtocols.forEach(function(proto, i) {
    if (!proto) {
      throw new SyntaxError("The protocols entry '" + proto + "' is invalid.");
    }
    if (i < (sortedProtocols.length - 1) && proto === sortedProtocols[i + 1]) {
      throw new SyntaxError("The protocols entry '" + proto + "' is duplicated.");
    }
  });

  // Step 6 - convert origin
  var o = urlUtils.getOrigin(loc.href);
  this._origin = o ? o.toLowerCase() : null;

  // remove the trailing slash
  parsedUrl.set('pathname', parsedUrl.pathname.replace(/\/+$/, ''));

  // store the sanitized url
  this.url = parsedUrl.href;
  debug('using url', this.url);

  // Step 7 - start connection in background
  // obtain server info
  // http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html#section-26
  this._urlInfo = {
    nullOrigin: !browser.hasDomain()
  , sameOrigin: urlUtils.isOriginEqual(this.url, loc.href)
  , sameScheme: urlUtils.isSchemeEqual(this.url, loc.href)
  };

  this._ir = new InfoReceiver(this.url, this._urlInfo);
  this._ir.once('finish', this._receiveInfo.bind(this));
}

inherits(SockJS, EventTarget);

function userSetCode(code) {
  return code === 1000 || (code >= 3000 && code <= 4999);
}

SockJS.prototype.close = function(code, reason) {
  // Step 1
  if (code && !userSetCode(code)) {
    throw new Error('InvalidAccessError: Invalid code');
  }
  // Step 2.4 states the max is 123 bytes, but we are just checking length
  if (reason && reason.length > 123) {
    throw new SyntaxError('reason argument has an invalid length');
  }

  // Step 3.1
  if (this.readyState === SockJS.CLOSING || this.readyState === SockJS.CLOSED) {
    return;
  }

  // TODO look at docs to determine how to set this
  var wasClean = true;
  this._close(code || 1000, reason || 'Normal closure', wasClean);
};

SockJS.prototype.send = function(data) {
  // #13 - convert anything non-string to string
  // TODO this currently turns objects into [object Object]
  if (typeof data !== 'string') {
    data = '' + data;
  }
  if (this.readyState === SockJS.CONNECTING) {
    throw new Error('InvalidStateError: The connection has not been established yet');
  }
  if (this.readyState !== SockJS.OPEN) {
    return;
  }
  this._transport.send(escape.quote(data));
};

SockJS.version = require('./version');

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._receiveInfo = function(info, rtt) {
  debug('_receiveInfo', rtt);
  this._ir = null;
  if (!info) {
    this._close(1002, 'Cannot connect to server');
    return;
  }

  // establish a round-trip timeout (RTO) based on the
  // round-trip time (RTT)
  this._rto = this.countRTO(rtt);
  // allow server to override url used for the actual transport
  this._transUrl = info.base_url ? info.base_url : this.url;
  info = objectUtils.extend(info, this._urlInfo);
  debug('info', info);
  // determine list of desired and supported transports
  var enabledTransports = transports.filterToEnabled(this._transportsWhitelist, info);
  this._transports = enabledTransports.main;
  debug(this._transports.length + ' enabled transports');

  this._connect();
};

SockJS.prototype._connect = function() {
  for (var Transport = this._transports.shift(); Transport; Transport = this._transports.shift()) {
    debug('attempt', Transport.transportName);
    if (Transport.needBody) {
      if (!global.document.body ||
          (typeof global.document.readyState !== 'undefined' &&
            global.document.readyState !== 'complete' &&
            global.document.readyState !== 'interactive')) {
        debug('waiting for body');
        this._transports.unshift(Transport);
        eventUtils.attachEvent('load', this._connect.bind(this));
        return;
      }
    }

    // calculate timeout based on RTO and round trips. Default to 5s
    var timeoutMs = (this._rto * Transport.roundTrips) || 5000;
    this._transportTimeoutId = setTimeout(this._transportTimeout.bind(this), timeoutMs);
    debug('using timeout', timeoutMs);

    var transportUrl = urlUtils.addPath(this._transUrl, '/' + this._server + '/' + this._generateSessionId());
    debug('transport url', transportUrl);
    var transportObj = new Transport(transportUrl, this._transUrl);
    transportObj.on('message', this._transportMessage.bind(this));
    transportObj.once('close', this._transportClose.bind(this));
    transportObj.transportName = Transport.transportName;
    this._transport = transportObj;

    return;
  }
  this._close(2000, 'All transports failed', false);
};

SockJS.prototype._transportTimeout = function() {
  debug('_transportTimeout');
  if (this.readyState === SockJS.CONNECTING) {
    this._transportClose(2007, 'Transport timed out');
  }
};

SockJS.prototype._transportMessage = function(msg) {
  debug('_transportMessage', msg);
  var self = this
    , type = msg.slice(0, 1)
    , content = msg.slice(1)
    , payload
    ;

  // first check for messages that don't need a payload
  switch (type) {
    case 'o':
      this._open();
      return;
    case 'h':
      this.dispatchEvent(new Event('heartbeat'));
      debug('heartbeat', this.transport);
      return;
  }

  if (content) {
    try {
      payload = JSON3.parse(content);
    } catch (e) {
      debug('bad json', content);
    }
  }

  if (typeof payload === 'undefined') {
    debug('empty payload', content);
    return;
  }

  switch (type) {
    case 'a':
      if (Array.isArray(payload)) {
        payload.forEach(function(p) {
          debug('message', self.transport, p);
          self.dispatchEvent(new TransportMessageEvent(p));
        });
      }
      break;
    case 'm':
      debug('message', this.transport, payload);
      this.dispatchEvent(new TransportMessageEvent(payload));
      break;
    case 'c':
      if (Array.isArray(payload) && payload.length === 2) {
        this._close(payload[0], payload[1], true);
      }
      break;
  }
};

SockJS.prototype._transportClose = function(code, reason) {
  debug('_transportClose', this.transport, code, reason);
  if (this._transport) {
    this._transport.removeAllListeners();
    this._transport = null;
    this.transport = null;
  }

  if (!userSetCode(code) && code !== 2000 && this.readyState === SockJS.CONNECTING) {
    this._connect();
    return;
  }

  this._close(code, reason);
};

SockJS.prototype._open = function() {
  debug('_open', this._transport.transportName, this.readyState);
  if (this.readyState === SockJS.CONNECTING) {
    if (this._transportTimeoutId) {
      clearTimeout(this._transportTimeoutId);
      this._transportTimeoutId = null;
    }
    this.readyState = SockJS.OPEN;
    this.transport = this._transport.transportName;
    this.dispatchEvent(new Event('open'));
    debug('connected', this.transport);
  } else {
    // The server might have been restarted, and lost track of our
    // connection.
    this._close(1006, 'Server lost session');
  }
};

SockJS.prototype._close = function(code, reason, wasClean) {
  debug('_close', this.transport, code, reason, wasClean, this.readyState);
  var forceFail = false;

  if (this._ir) {
    forceFail = true;
    this._ir.close();
    this._ir = null;
  }
  if (this._transport) {
    this._transport.close();
    this._transport = null;
    this.transport = null;
  }

  if (this.readyState === SockJS.CLOSED) {
    throw new Error('InvalidStateError: SockJS has already been closed');
  }

  this.readyState = SockJS.CLOSING;
  setTimeout(function() {
    this.readyState = SockJS.CLOSED;

    if (forceFail) {
      this.dispatchEvent(new Event('error'));
    }

    var e = new CloseEvent('close');
    e.wasClean = wasClean || false;
    e.code = code || 1000;
    e.reason = reason;

    this.dispatchEvent(e);
    this.onmessage = this.onclose = this.onerror = null;
    debug('disconnected');
  }.bind(this), 0);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
SockJS.prototype.countRTO = function(rtt) {
  // In a local environment, when using IE8/9 and the `jsonp-polling`
  // transport the time needed to establish a connection (the time that pass
  // from the opening of the transport to the call of `_dispatchOpen`) is
  // around 200msec (the lower bound used in the article above) and this
  // causes spurious timeouts. For this reason we calculate a value slightly
  // larger than that used in the article.
  if (rtt > 100) {
    return 4 * rtt; // rto > 400msec
  }
  return 300 + rtt; // 300msec < rto <= 400msec
};

module.exports = function(availableTransports) {
  transports = transport(availableTransports);
  require('./iframe-bootstrap')(SockJS, availableTransports);
  return SockJS;
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./event/close":32,"./event/event":34,"./event/eventtarget":35,"./event/trans-message":36,"./iframe-bootstrap":38,"./info-receiver":42,"./location":43,"./shims":45,"./utils/browser":74,"./utils/escape":75,"./utils/event":76,"./utils/log":78,"./utils/object":79,"./utils/random":80,"./utils/transport":81,"./utils/url":82,"./version":83,"_process":30,"debug":84,"inherits":87,"json3":88,"url-parse":89}],45:[function(require,module,exports){
/* eslint-disable */
/* jscs: disable */
'use strict';

// pulled specific shims from https://github.com/es-shims/es5-shim

var ArrayPrototype = Array.prototype;
var ObjectPrototype = Object.prototype;
var FunctionPrototype = Function.prototype;
var StringPrototype = String.prototype;
var array_slice = ArrayPrototype.slice;

var _toString = ObjectPrototype.toString;
var isFunction = function (val) {
    return ObjectPrototype.toString.call(val) === '[object Function]';
};
var isArray = function isArray(obj) {
    return _toString.call(obj) === '[object Array]';
};
var isString = function isString(obj) {
    return _toString.call(obj) === '[object String]';
};

var supportsDescriptors = Object.defineProperty && (function () {
    try {
        Object.defineProperty({}, 'x', {});
        return true;
    } catch (e) { /* this is ES3 */
        return false;
    }
}());

// Define configurable, writable and non-enumerable props
// if they don't exist.
var defineProperty;
if (supportsDescriptors) {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        Object.defineProperty(object, name, {
            configurable: true,
            enumerable: false,
            writable: true,
            value: method
        });
    };
} else {
    defineProperty = function (object, name, method, forceAssign) {
        if (!forceAssign && (name in object)) { return; }
        object[name] = method;
    };
}
var defineProperties = function (object, map, forceAssign) {
    for (var name in map) {
        if (ObjectPrototype.hasOwnProperty.call(map, name)) {
          defineProperty(object, name, map[name], forceAssign);
        }
    }
};

var toObject = function (o) {
    if (o == null) { // this matches both null and undefined
        throw new TypeError("can't convert " + o + ' to object');
    }
    return Object(o);
};

//
// Util
// ======
//

// ES5 9.4
// http://es5.github.com/#x9.4
// http://jsperf.com/to-integer

function toInteger(num) {
    var n = +num;
    if (n !== n) { // isNaN
        n = 0;
    } else if (n !== 0 && n !== (1 / 0) && n !== -(1 / 0)) {
        n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
}

function ToUint32(x) {
    return x >>> 0;
}

//
// Function
// ========
//

// ES-5 15.3.4.5
// http://es5.github.com/#x15.3.4.5

function Empty() {}

defineProperties(FunctionPrototype, {
    bind: function bind(that) { // .length is 1
        // 1. Let Target be the this value.
        var target = this;
        // 2. If IsCallable(Target) is false, throw a TypeError exception.
        if (!isFunction(target)) {
            throw new TypeError('Function.prototype.bind called on incompatible ' + target);
        }
        // 3. Let A be a new (possibly empty) internal list of all of the
        //   argument values provided after thisArg (arg1, arg2 etc), in order.
        // XXX slicedArgs will stand in for "A" if used
        var args = array_slice.call(arguments, 1); // for normal call
        // 4. Let F be a new native ECMAScript object.
        // 11. Set the [[Prototype]] internal property of F to the standard
        //   built-in Function prototype object as specified in 15.3.3.1.
        // 12. Set the [[Call]] internal property of F as described in
        //   15.3.4.5.1.
        // 13. Set the [[Construct]] internal property of F as described in
        //   15.3.4.5.2.
        // 14. Set the [[HasInstance]] internal property of F as described in
        //   15.3.4.5.3.
        var binder = function () {

            if (this instanceof bound) {
                // 15.3.4.5.2 [[Construct]]
                // When the [[Construct]] internal method of a function object,
                // F that was created using the bind function is called with a
                // list of arguments ExtraArgs, the following steps are taken:
                // 1. Let target be the value of F's [[TargetFunction]]
                //   internal property.
                // 2. If target has no [[Construct]] internal method, a
                //   TypeError exception is thrown.
                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Construct]] internal
                //   method of target providing args as the arguments.

                var result = target.apply(
                    this,
                    args.concat(array_slice.call(arguments))
                );
                if (Object(result) === result) {
                    return result;
                }
                return this;

            } else {
                // 15.3.4.5.1 [[Call]]
                // When the [[Call]] internal method of a function object, F,
                // which was created using the bind function is called with a
                // this value and a list of arguments ExtraArgs, the following
                // steps are taken:
                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
                //   property.
                // 2. Let boundThis be the value of F's [[BoundThis]] internal
                //   property.
                // 3. Let target be the value of F's [[TargetFunction]] internal
                //   property.
                // 4. Let args be a new list containing the same values as the
                //   list boundArgs in the same order followed by the same
                //   values as the list ExtraArgs in the same order.
                // 5. Return the result of calling the [[Call]] internal method
                //   of target providing boundThis as the this value and
                //   providing args as the arguments.

                // equiv: target.call(this, ...boundArgs, ...args)
                return target.apply(
                    that,
                    args.concat(array_slice.call(arguments))
                );

            }

        };

        // 15. If the [[Class]] internal property of Target is "Function", then
        //     a. Let L be the length property of Target minus the length of A.
        //     b. Set the length own property of F to either 0 or L, whichever is
        //       larger.
        // 16. Else set the length own property of F to 0.

        var boundLength = Math.max(0, target.length - args.length);

        // 17. Set the attributes of the length own property of F to the values
        //   specified in 15.3.5.1.
        var boundArgs = [];
        for (var i = 0; i < boundLength; i++) {
            boundArgs.push('$' + i);
        }

        // XXX Build a dynamic function with desired amount of arguments is the only
        // way to set the length property of a function.
        // In environments where Content Security Policies enabled (Chrome extensions,
        // for ex.) all use of eval or Function costructor throws an exception.
        // However in all of these environments Function.prototype.bind exists
        // and so this code will never be executed.
        var bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);

        if (target.prototype) {
            Empty.prototype = target.prototype;
            bound.prototype = new Empty();
            // Clean up dangling references.
            Empty.prototype = null;
        }

        // TODO
        // 18. Set the [[Extensible]] internal property of F to true.

        // TODO
        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
        // 20. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
        //   false.
        // 21. Call the [[DefineOwnProperty]] internal method of F with
        //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
        //   and false.

        // TODO
        // NOTE Function objects created using Function.prototype.bind do not
        // have a prototype property or the [[Code]], [[FormalParameters]], and
        // [[Scope]] internal properties.
        // XXX can't delete prototype in pure-js.

        // 22. Return F.
        return bound;
    }
});

//
// Array
// =====
//

// ES5 15.4.3.2
// http://es5.github.com/#x15.4.3.2
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
defineProperties(Array, { isArray: isArray });


var boxedString = Object('a');
var splitString = boxedString[0] !== 'a' || !(0 in boxedString);

var properlyBoxesContext = function properlyBoxed(method) {
    // Check node 0.6.21 bug where third parameter is not boxed
    var properlyBoxesNonStrict = true;
    var properlyBoxesStrict = true;
    if (method) {
        method.call('foo', function (_, __, context) {
            if (typeof context !== 'object') { properlyBoxesNonStrict = false; }
        });

        method.call([1], function () {
            'use strict';
            properlyBoxesStrict = typeof this === 'string';
        }, 'x');
    }
    return !!method && properlyBoxesNonStrict && properlyBoxesStrict;
};

defineProperties(ArrayPrototype, {
    forEach: function forEach(fun /*, thisp*/) {
        var object = toObject(this),
            self = splitString && isString(this) ? this.split('') : object,
            thisp = arguments[1],
            i = -1,
            length = self.length >>> 0;

        // If no callback function or if callback is not a callable function
        if (!isFunction(fun)) {
            throw new TypeError(); // TODO message
        }

        while (++i < length) {
            if (i in self) {
                // Invoke the callback function with call, passing arguments:
                // context, property value, property key, thisArg object
                // context
                fun.call(thisp, self[i], i, object);
            }
        }
    }
}, !properlyBoxesContext(ArrayPrototype.forEach));

// ES5 15.4.4.14
// http://es5.github.com/#x15.4.4.14
// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
var hasFirefox2IndexOfBug = Array.prototype.indexOf && [0, 1].indexOf(1, 2) !== -1;
defineProperties(ArrayPrototype, {
    indexOf: function indexOf(sought /*, fromIndex */ ) {
        var self = splitString && isString(this) ? this.split('') : toObject(this),
            length = self.length >>> 0;

        if (!length) {
            return -1;
        }

        var i = 0;
        if (arguments.length > 1) {
            i = toInteger(arguments[1]);
        }

        // handle negative indices
        i = i >= 0 ? i : Math.max(0, length + i);
        for (; i < length; i++) {
            if (i in self && self[i] === sought) {
                return i;
            }
        }
        return -1;
    }
}, hasFirefox2IndexOfBug);

//
// String
// ======
//

// ES5 15.5.4.14
// http://es5.github.com/#x15.5.4.14

// [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
// Many browsers do not split properly with regular expressions or they
// do not perform the split correctly under obscure conditions.
// See http://blog.stevenlevithan.com/archives/cross-browser-split
// I've tested in many browsers and this seems to cover the deviant ones:
//    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
//    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
//    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
//       [undefined, "t", undefined, "e", ...]
//    ''.split(/.?/) should be [], not [""]
//    '.'.split(/()()/) should be ["."], not ["", "", "."]

var string_split = StringPrototype.split;
if (
    'ab'.split(/(?:ab)*/).length !== 2 ||
    '.'.split(/(.?)(.?)/).length !== 4 ||
    'tesst'.split(/(s)*/)[1] === 't' ||
    'test'.split(/(?:)/, -1).length !== 4 ||
    ''.split(/.?/).length ||
    '.'.split(/()()/).length > 1
) {
    (function () {
        var compliantExecNpcg = /()??/.exec('')[1] === void 0; // NPCG: nonparticipating capturing group

        StringPrototype.split = function (separator, limit) {
            var string = this;
            if (separator === void 0 && limit === 0) {
                return [];
            }

            // If `separator` is not a regex, use native split
            if (_toString.call(separator) !== '[object RegExp]') {
                return string_split.call(this, separator, limit);
            }

            var output = [],
                flags = (separator.ignoreCase ? 'i' : '') +
                        (separator.multiline  ? 'm' : '') +
                        (separator.extended   ? 'x' : '') + // Proposed for ES6
                        (separator.sticky     ? 'y' : ''), // Firefox 3+
                lastLastIndex = 0,
                // Make `global` and avoid `lastIndex` issues by working with a copy
                separator2, match, lastIndex, lastLength;
            separator = new RegExp(separator.source, flags + 'g');
            string += ''; // Type-convert
            if (!compliantExecNpcg) {
                // Doesn't need flags gy, but they don't hurt
                separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
            }
            /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
            limit = limit === void 0 ?
                -1 >>> 0 : // Math.pow(2, 32) - 1
                ToUint32(limit);
            while (match = separator.exec(string)) {
                // `separator.lastIndex` is not reliable cross-browser
                lastIndex = match.index + match[0].length;
                if (lastIndex > lastLastIndex) {
                    output.push(string.slice(lastLastIndex, match.index));
                    // Fix browsers whose `exec` methods don't consistently return `undefined` for
                    // nonparticipating capturing groups
                    if (!compliantExecNpcg && match.length > 1) {
                        match[0].replace(separator2, function () {
                            for (var i = 1; i < arguments.length - 2; i++) {
                                if (arguments[i] === void 0) {
                                    match[i] = void 0;
                                }
                            }
                        });
                    }
                    if (match.length > 1 && match.index < string.length) {
                        ArrayPrototype.push.apply(output, match.slice(1));
                    }
                    lastLength = match[0].length;
                    lastLastIndex = lastIndex;
                    if (output.length >= limit) {
                        break;
                    }
                }
                if (separator.lastIndex === match.index) {
                    separator.lastIndex++; // Avoid an infinite loop
                }
            }
            if (lastLastIndex === string.length) {
                if (lastLength || !separator.test('')) {
                    output.push('');
                }
            } else {
                output.push(string.slice(lastLastIndex));
            }
            return output.length > limit ? output.slice(0, limit) : output;
        };
    }());

// [bugfix, chrome]
// If separator is undefined, then the result array contains just one String,
// which is the this value (converted to a String). If limit is not undefined,
// then the output array is truncated so that it contains no more than limit
// elements.
// "0".split(undefined, 0) -> []
} else if ('0'.split(void 0, 0).length) {
    StringPrototype.split = function split(separator, limit) {
        if (separator === void 0 && limit === 0) { return []; }
        return string_split.call(this, separator, limit);
    };
}

// ES5 15.5.4.20
// whitespace from: http://es5.github.io/#x15.5.4.20
var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003' +
    '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' +
    '\u2029\uFEFF';
var zeroWidth = '\u200b';
var wsRegexChars = '[' + ws + ']';
var trimBeginRegexp = new RegExp('^' + wsRegexChars + wsRegexChars + '*');
var trimEndRegexp = new RegExp(wsRegexChars + wsRegexChars + '*$');
var hasTrimWhitespaceBug = StringPrototype.trim && (ws.trim() || !zeroWidth.trim());
defineProperties(StringPrototype, {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    trim: function trim() {
        if (this === void 0 || this === null) {
            throw new TypeError("can't convert " + this + ' to object');
        }
        return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
    }
}, hasTrimWhitespaceBug);

// ECMA-262, 3rd B.2.3
// Not an ECMAScript standard, although ECMAScript 3rd Edition has a
// non-normative section suggesting uniform semantics and it should be
// normalized across all browsers
// [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
var string_substr = StringPrototype.substr;
var hasNegativeSubstrBug = ''.substr && '0b'.substr(-1) !== 'b';
defineProperties(StringPrototype, {
    substr: function substr(start, length) {
        return string_substr.call(
            this,
            start < 0 ? ((start = this.length + start) < 0 ? 0 : start) : start,
            length
        );
    }
}, hasNegativeSubstrBug);

},{}],46:[function(require,module,exports){
'use strict';

module.exports = [
  // streaming transports
  require('./transport/websocket')
, require('./transport/xhr-streaming')
, require('./transport/xdr-streaming')
, require('./transport/eventsource')
, require('./transport/lib/iframe-wrap')(require('./transport/eventsource'))

  // polling transports
, require('./transport/htmlfile')
, require('./transport/lib/iframe-wrap')(require('./transport/htmlfile'))
, require('./transport/xhr-polling')
, require('./transport/xdr-polling')
, require('./transport/lib/iframe-wrap')(require('./transport/xhr-polling'))
, require('./transport/jsonp-polling')
];

},{"./transport/eventsource":50,"./transport/htmlfile":51,"./transport/jsonp-polling":53,"./transport/lib/iframe-wrap":56,"./transport/websocket":68,"./transport/xdr-polling":69,"./transport/xdr-streaming":70,"./transport/xhr-polling":71,"./transport/xhr-streaming":72}],47:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , utils = require('../../utils/event')
  , urlUtils = require('../../utils/url')
  , XHR = global.XMLHttpRequest
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:browser:xhr');
}

function AbstractXHRObject(method, url, payload, opts) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function () {
    self._start(method, url, payload, opts);
  }, 0);
}

inherits(AbstractXHRObject, EventEmitter);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
  var self = this;

  try {
    this.xhr = new XHR();
  } catch (x) {}

  if (!this.xhr) {
    debug('no xhr');
    this.emit('finish', 0, 'no xhr support');
    this._cleanup();
    return;
  }

  // several browsers cache POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  // Explorer tends to keep connection open, even after the
  // tab gets closed: http://bugs.jquery.com/ticket/5280
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload cleanup');
    self._cleanup(true);
  });
  try {
    this.xhr.open(method, url, true);
    if (this.timeout && 'timeout' in this.xhr) {
      this.xhr.timeout = this.timeout;
      this.xhr.ontimeout = function() {
        debug('xhr timeout');
        self.emit('finish', 0, '');
        self._cleanup(false);
      };
    }
  } catch (e) {
    debug('exception', e);
    // IE raises an exception on wrong port.
    this.emit('finish', 0, '');
    this._cleanup(false);
    return;
  }

  if ((!opts || !opts.noCredentials) && AbstractXHRObject.supportsCORS) {
    debug('withCredentials');
    // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
    // "This never affects same-site requests."

    this.xhr.withCredentials = 'true';
  }
  if (opts && opts.headers) {
    for (var key in opts.headers) {
      this.xhr.setRequestHeader(key, opts.headers[key]);
    }
  }

  this.xhr.onreadystatechange = function() {
    if (self.xhr) {
      var x = self.xhr;
      var text, status;
      debug('readyState', x.readyState);
      switch (x.readyState) {
      case 3:
        // IE doesn't like peeking into responseText or status
        // on Microsoft.XMLHTTP and readystate=3
        try {
          status = x.status;
          text = x.responseText;
        } catch (e) {}
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }

        // IE does return readystate == 3 for 404 answers.
        if (status === 200 && text && text.length > 0) {
          debug('chunk');
          self.emit('chunk', status, text);
        }
        break;
      case 4:
        status = x.status;
        debug('status', status);
        // IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450
        if (status === 1223) {
          status = 204;
        }
        // IE returns this for a bad port
        // http://msdn.microsoft.com/en-us/library/windows/desktop/aa383770(v=vs.85).aspx
        if (status === 12005 || status === 12029) {
          status = 0;
        }

        debug('finish', status, x.responseText);
        self.emit('finish', status, x.responseText);
        self._cleanup(false);
        break;
      }
    }
  };

  try {
    self.xhr.send(payload);
  } catch (e) {
    self.emit('finish', 0, '');
    self._cleanup(false);
  }
};

AbstractXHRObject.prototype._cleanup = function(abort) {
  debug('cleanup');
  if (!this.xhr) {
    return;
  }
  this.removeAllListeners();
  utils.unloadDel(this.unloadRef);

  // IE needs this field to be a function
  this.xhr.onreadystatechange = function() {};
  if (this.xhr.ontimeout) {
    this.xhr.ontimeout = null;
  }

  if (abort) {
    try {
      this.xhr.abort();
    } catch (x) {}
  }
  this.unloadRef = this.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

AbstractXHRObject.enabled = !!XHR;
// override XMLHttpRequest for IE6/7
// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (!AbstractXHRObject.enabled && (axo in global)) {
  debug('overriding xmlhttprequest');
  XHR = function() {
    try {
      return new global[axo]('Microsoft.XMLHTTP');
    } catch (e) {
      return null;
    }
  };
  AbstractXHRObject.enabled = !!new XHR();
}

var cors = false;
try {
  cors = 'withCredentials' in new XHR();
} catch (ignored) {}

AbstractXHRObject.supportsCORS = cors;

module.exports = AbstractXHRObject;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/event":76,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],48:[function(require,module,exports){
(function (global){
module.exports = global.EventSource;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],49:[function(require,module,exports){
(function (global){
module.exports = global.WebSocket || global.MozWebSocket;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],50:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , EventSourceReceiver = require('./receiver/eventsource')
  , XHRCorsObject = require('./sender/xhr-cors')
  , EventSourceDriver = require('eventsource')
  ;

function EventSourceTransport(transUrl) {
  if (!EventSourceTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  AjaxBasedTransport.call(this, transUrl, '/eventsource', EventSourceReceiver, XHRCorsObject);
}

inherits(EventSourceTransport, AjaxBasedTransport);

EventSourceTransport.enabled = function() {
  return !!EventSourceDriver;
};

EventSourceTransport.transportName = 'eventsource';
EventSourceTransport.roundTrips = 2;

module.exports = EventSourceTransport;

},{"./lib/ajax-based":54,"./receiver/eventsource":59,"./sender/xhr-cors":65,"eventsource":48,"inherits":87}],51:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , HtmlfileReceiver = require('./receiver/htmlfile')
  , XHRLocalObject = require('./sender/xhr-local')
  , AjaxBasedTransport = require('./lib/ajax-based')
  ;

function HtmlFileTransport(transUrl) {
  if (!HtmlfileReceiver.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/htmlfile', HtmlfileReceiver, XHRLocalObject);
}

inherits(HtmlFileTransport, AjaxBasedTransport);

HtmlFileTransport.enabled = function(info) {
  return HtmlfileReceiver.enabled && info.sameOrigin;
};

HtmlFileTransport.transportName = 'htmlfile';
HtmlFileTransport.roundTrips = 2;

module.exports = HtmlFileTransport;

},{"./lib/ajax-based":54,"./receiver/htmlfile":60,"./sender/xhr-local":67,"inherits":87}],52:[function(require,module,exports){
(function (process){
'use strict';

// Few cool transports do work only for same-origin. In order to make
// them work cross-domain we shall use iframe, served from the
// remote domain. New browsers have capabilities to communicate with
// cross domain iframe using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var inherits = require('inherits')
  , JSON3 = require('json3')
  , EventEmitter = require('events').EventEmitter
  , version = require('../version')
  , urlUtils = require('../utils/url')
  , iframeUtils = require('../utils/iframe')
  , eventUtils = require('../utils/event')
  , random = require('../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:transport:iframe');
}

function IframeTransport(transport, transUrl, baseUrl) {
  if (!IframeTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  EventEmitter.call(this);

  var self = this;
  this.origin = urlUtils.getOrigin(baseUrl);
  this.baseUrl = baseUrl;
  this.transUrl = transUrl;
  this.transport = transport;
  this.windowId = random.string(8);

  var iframeUrl = urlUtils.addPath(baseUrl, '/iframe.html') + '#' + this.windowId;
  debug(transport, transUrl, iframeUrl);

  this.iframeObj = iframeUtils.createIframe(iframeUrl, function(r) {
    debug('err callback');
    self.emit('close', 1006, 'Unable to load an iframe (' + r + ')');
    self.close();
  });

  this.onmessageCallback = this._message.bind(this);
  eventUtils.attachEvent('message', this.onmessageCallback);
}

inherits(IframeTransport, EventEmitter);

IframeTransport.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.iframeObj) {
    eventUtils.detachEvent('message', this.onmessageCallback);
    try {
      // When the iframe is not loaded, IE raises an exception
      // on 'contentWindow'.
      this.postMessage('c');
    } catch (x) {}
    this.iframeObj.cleanup();
    this.iframeObj = null;
    this.onmessageCallback = this.iframeObj = null;
  }
};

IframeTransport.prototype._message = function(e) {
  debug('message', e.data);
  if (!urlUtils.isOriginEqual(e.origin, this.origin)) {
    debug('not same origin', e.origin, this.origin);
    return;
  }

  var iframeMessage;
  try {
    iframeMessage = JSON3.parse(e.data);
  } catch (ignored) {
    debug('bad json', e.data);
    return;
  }

  if (iframeMessage.windowId !== this.windowId) {
    debug('mismatched window id', iframeMessage.windowId, this.windowId);
    return;
  }

  switch (iframeMessage.type) {
  case 's':
    this.iframeObj.loaded();
    // window global dependency
    this.postMessage('s', JSON3.stringify([
      version
    , this.transport
    , this.transUrl
    , this.baseUrl
    ]));
    break;
  case 't':
    this.emit('message', iframeMessage.data);
    break;
  case 'c':
    var cdata;
    try {
      cdata = JSON3.parse(iframeMessage.data);
    } catch (ignored) {
      debug('bad json', iframeMessage.data);
      return;
    }
    this.emit('close', cdata[0], cdata[1]);
    this.close();
    break;
  }
};

IframeTransport.prototype.postMessage = function(type, data) {
  debug('postMessage', type, data);
  this.iframeObj.post(JSON3.stringify({
    windowId: this.windowId
  , type: type
  , data: data || ''
  }), this.origin);
};

IframeTransport.prototype.send = function(message) {
  debug('send', message);
  this.postMessage('m', message);
};

IframeTransport.enabled = function() {
  return iframeUtils.iframeEnabled;
};

IframeTransport.transportName = 'iframe';
IframeTransport.roundTrips = 2;

module.exports = IframeTransport;

}).call(this,require('_process'))
},{"../utils/event":76,"../utils/iframe":77,"../utils/random":80,"../utils/url":82,"../version":83,"_process":30,"debug":84,"events":33,"inherits":87,"json3":88}],53:[function(require,module,exports){
(function (global){
'use strict';

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// message could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors

var inherits = require('inherits')
  , SenderReceiver = require('./lib/sender-receiver')
  , JsonpReceiver = require('./receiver/jsonp')
  , jsonpSender = require('./sender/jsonp')
  ;

function JsonPTransport(transUrl) {
  if (!JsonPTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }
  SenderReceiver.call(this, transUrl, '/jsonp', jsonpSender, JsonpReceiver);
}

inherits(JsonPTransport, SenderReceiver);

JsonPTransport.enabled = function() {
  return !!global.document;
};

JsonPTransport.transportName = 'jsonp-polling';
JsonPTransport.roundTrips = 1;
JsonPTransport.needBody = true;

module.exports = JsonPTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./lib/sender-receiver":58,"./receiver/jsonp":61,"./sender/jsonp":63,"inherits":87}],54:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , SenderReceiver = require('./sender-receiver')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:ajax-based');
}

function createAjaxSender(AjaxObject) {
  return function(url, payload, callback) {
    debug('create ajax sender', url, payload);
    var opt = {};
    if (typeof payload === 'string') {
      opt.headers = {'Content-type':'text/plain'};
    }
    var ajaxUrl = urlUtils.addPath(url, '/xhr_send');
    var xo = new AjaxObject('POST', ajaxUrl, payload, opt);
    xo.once('finish', function(status) {
      debug('finish', status);
      xo = null;

      if (status !== 200 && status !== 204) {
        return callback(new Error('http status ' + status));
      }
      callback();
    });
    return function() {
      debug('abort');
      xo.close();
      xo = null;

      var err = new Error('Aborted');
      err.code = 1000;
      callback(err);
    };
  };
}

function AjaxBasedTransport(transUrl, urlSuffix, Receiver, AjaxObject) {
  SenderReceiver.call(this, transUrl, urlSuffix, createAjaxSender(AjaxObject), Receiver, AjaxObject);
}

inherits(AjaxBasedTransport, SenderReceiver);

module.exports = AjaxBasedTransport;

}).call(this,require('_process'))
},{"../../utils/url":82,"./sender-receiver":58,"_process":30,"debug":84,"inherits":87}],55:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:buffered-sender');
}

function BufferedSender(url, sender) {
  debug(url);
  EventEmitter.call(this);
  this.sendBuffer = [];
  this.sender = sender;
  this.url = url;
}

inherits(BufferedSender, EventEmitter);

BufferedSender.prototype.send = function(message) {
  debug('send', message);
  this.sendBuffer.push(message);
  if (!this.sendStop) {
    this.sendSchedule();
  }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.sendScheduleWait = function() {
  debug('sendScheduleWait');
  var self = this;
  var tref;
  this.sendStop = function() {
    debug('sendStop');
    self.sendStop = null;
    clearTimeout(tref);
  };
  tref = setTimeout(function() {
    debug('timeout');
    self.sendStop = null;
    self.sendSchedule();
  }, 25);
};

BufferedSender.prototype.sendSchedule = function() {
  debug('sendSchedule', this.sendBuffer.length);
  var self = this;
  if (this.sendBuffer.length > 0) {
    var payload = '[' + this.sendBuffer.join(',') + ']';
    this.sendStop = this.sender(this.url, payload, function(err) {
      self.sendStop = null;
      if (err) {
        debug('error', err);
        self.emit('close', err.code || 1006, 'Sending error: ' + err);
        self._cleanup();
      } else {
        self.sendScheduleWait();
      }
    });
    this.sendBuffer = [];
  }
};

BufferedSender.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

BufferedSender.prototype.stop = function() {
  debug('stop');
  this._cleanup();
  if (this.sendStop) {
    this.sendStop();
    this.sendStop = null;
  }
};

module.exports = BufferedSender;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],56:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , IframeTransport = require('../iframe')
  , objectUtils = require('../../utils/object')
  ;

module.exports = function(transport) {

  function IframeWrapTransport(transUrl, baseUrl) {
    IframeTransport.call(this, transport.transportName, transUrl, baseUrl);
  }

  inherits(IframeWrapTransport, IframeTransport);

  IframeWrapTransport.enabled = function(url, info) {
    if (!global.document) {
      return false;
    }

    var iframeInfo = objectUtils.extend({}, info);
    iframeInfo.sameOrigin = true;
    return transport.enabled(iframeInfo) && IframeTransport.enabled();
  };

  IframeWrapTransport.transportName = 'iframe-' + transport.transportName;
  IframeWrapTransport.needBody = true;
  IframeWrapTransport.roundTrips = IframeTransport.roundTrips + transport.roundTrips - 1; // html, javascript (2) + transport - no CORS (1)

  IframeWrapTransport.facadeTransport = transport;

  return IframeWrapTransport;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/object":79,"../iframe":52,"inherits":87}],57:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:polling');
}

function Polling(Receiver, receiveUrl, AjaxObject) {
  debug(receiveUrl);
  EventEmitter.call(this);
  this.Receiver = Receiver;
  this.receiveUrl = receiveUrl;
  this.AjaxObject = AjaxObject;
  this._scheduleReceiver();
}

inherits(Polling, EventEmitter);

Polling.prototype._scheduleReceiver = function() {
  debug('_scheduleReceiver');
  var self = this;
  var poll = this.poll = new this.Receiver(this.receiveUrl, this.AjaxObject);

  poll.on('message', function(msg) {
    debug('message', msg);
    self.emit('message', msg);
  });

  poll.once('close', function(code, reason) {
    debug('close', code, reason, self.pollIsClosing);
    self.poll = poll = null;

    if (!self.pollIsClosing) {
      if (reason === 'network') {
        self._scheduleReceiver();
      } else {
        self.emit('close', code || 1006, reason);
        self.removeAllListeners();
      }
    }
  });
};

Polling.prototype.abort = function() {
  debug('abort');
  this.removeAllListeners();
  this.pollIsClosing = true;
  if (this.poll) {
    this.poll.abort();
  }
};

module.exports = Polling;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],58:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , urlUtils = require('../../utils/url')
  , BufferedSender = require('./buffered-sender')
  , Polling = require('./polling')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender-receiver');
}

function SenderReceiver(transUrl, urlSuffix, senderFunc, Receiver, AjaxObject) {
  var pollUrl = urlUtils.addPath(transUrl, urlSuffix);
  debug(pollUrl);
  var self = this;
  BufferedSender.call(this, transUrl, senderFunc);

  this.poll = new Polling(Receiver, pollUrl, AjaxObject);
  this.poll.on('message', function(msg) {
    debug('poll message', msg);
    self.emit('message', msg);
  });
  this.poll.once('close', function(code, reason) {
    debug('poll close', code, reason);
    self.poll = null;
    self.emit('close', code, reason);
    self.close();
  });
}

inherits(SenderReceiver, BufferedSender);

SenderReceiver.prototype.close = function() {
  debug('close');
  this.removeAllListeners();
  if (this.poll) {
    this.poll.abort();
    this.poll = null;
  }
  this.stop();
};

module.exports = SenderReceiver;

}).call(this,require('_process'))
},{"../../utils/url":82,"./buffered-sender":55,"./polling":57,"_process":30,"debug":84,"inherits":87}],59:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , EventSourceDriver = require('eventsource')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:eventsource');
}

function EventSourceReceiver(url) {
  debug(url);
  EventEmitter.call(this);

  var self = this;
  var es = this.es = new EventSourceDriver(url);
  es.onmessage = function(e) {
    debug('message', e.data);
    self.emit('message', decodeURI(e.data));
  };
  es.onerror = function(e) {
    debug('error', es.readyState, e);
    // ES on reconnection has readyState = 0 or 1.
    // on network error it's CLOSED = 2
    var reason = (es.readyState !== 2 ? 'network' : 'permanent');
    self._cleanup();
    self._close(reason);
  };
}

inherits(EventSourceReceiver, EventEmitter);

EventSourceReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

EventSourceReceiver.prototype._cleanup = function() {
  debug('cleanup');
  var es = this.es;
  if (es) {
    es.onmessage = es.onerror = null;
    es.close();
    this.es = null;
  }
};

EventSourceReceiver.prototype._close = function(reason) {
  debug('close', reason);
  var self = this;
  // Safari and chrome < 15 crash if we close window before
  // waiting for ES cleanup. See:
  // https://code.google.com/p/chromium/issues/detail?id=89155
  setTimeout(function() {
    self.emit('close', null, reason);
    self.removeAllListeners();
  }, 200);
};

module.exports = EventSourceReceiver;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"eventsource":48,"inherits":87}],60:[function(require,module,exports){
(function (process,global){
'use strict';

var inherits = require('inherits')
  , iframeUtils = require('../../utils/iframe')
  , urlUtils = require('../../utils/url')
  , EventEmitter = require('events').EventEmitter
  , random = require('../../utils/random')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:htmlfile');
}

function HtmlfileReceiver(url) {
  debug(url);
  EventEmitter.call(this);
  var self = this;
  iframeUtils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  url = urlUtils.addQuery(url, 'c=' + decodeURIComponent(iframeUtils.WPrefix + '.' + this.id));

  debug('using htmlfile', HtmlfileReceiver.htmlfileEnabled);
  var constructFunc = HtmlfileReceiver.htmlfileEnabled ?
      iframeUtils.createHtmlfile : iframeUtils.createIframe;

  global[iframeUtils.WPrefix][this.id] = {
    start: function() {
      debug('start');
      self.iframeObj.loaded();
    }
  , message: function(data) {
      debug('message', data);
      self.emit('message', data);
    }
  , stop: function() {
      debug('stop');
      self._cleanup();
      self._close('network');
    }
  };
  this.iframeObj = constructFunc(url, function() {
    debug('callback');
    self._cleanup();
    self._close('permanent');
  });
}

inherits(HtmlfileReceiver, EventEmitter);

HtmlfileReceiver.prototype.abort = function() {
  debug('abort');
  this._cleanup();
  this._close('user');
};

HtmlfileReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  if (this.iframeObj) {
    this.iframeObj.cleanup();
    this.iframeObj = null;
  }
  delete global[iframeUtils.WPrefix][this.id];
};

HtmlfileReceiver.prototype._close = function(reason) {
  debug('_close', reason);
  this.emit('close', null, reason);
  this.removeAllListeners();
};

HtmlfileReceiver.htmlfileEnabled = false;

// obfuscate to avoid firewalls
var axo = ['Active'].concat('Object').join('X');
if (axo in global) {
  try {
    HtmlfileReceiver.htmlfileEnabled = !!new global[axo]('htmlfile');
  } catch (x) {}
}

HtmlfileReceiver.enabled = HtmlfileReceiver.htmlfileEnabled || iframeUtils.iframeEnabled;

module.exports = HtmlfileReceiver;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/iframe":77,"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],61:[function(require,module,exports){
(function (process,global){
'use strict';

var utils = require('../../utils/iframe')
  , random = require('../../utils/random')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:jsonp');
}

function JsonpReceiver(url) {
  debug(url);
  var self = this;
  EventEmitter.call(this);

  utils.polluteGlobalNamespace();

  this.id = 'a' + random.string(6);
  var urlWithId = urlUtils.addQuery(url, 'c=' + encodeURIComponent(utils.WPrefix + '.' + this.id));

  global[utils.WPrefix][this.id] = this._callback.bind(this);
  this._createScript(urlWithId);

  // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
  this.timeoutId = setTimeout(function() {
    debug('timeout');
    self._abort(new Error('JSONP script loaded abnormally (timeout)'));
  }, JsonpReceiver.timeout);
}

inherits(JsonpReceiver, EventEmitter);

JsonpReceiver.prototype.abort = function() {
  debug('abort');
  if (global[utils.WPrefix][this.id]) {
    var err = new Error('JSONP user aborted read');
    err.code = 1000;
    this._abort(err);
  }
};

JsonpReceiver.timeout = 35000;
JsonpReceiver.scriptErrorTimeout = 1000;

JsonpReceiver.prototype._callback = function(data) {
  debug('_callback', data);
  this._cleanup();

  if (this.aborting) {
    return;
  }

  if (data) {
    debug('message', data);
    this.emit('message', data);
  }
  this.emit('close', null, 'network');
  this.removeAllListeners();
};

JsonpReceiver.prototype._abort = function(err) {
  debug('_abort', err);
  this._cleanup();
  this.aborting = true;
  this.emit('close', err.code, err.message);
  this.removeAllListeners();
};

JsonpReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  clearTimeout(this.timeoutId);
  if (this.script2) {
    this.script2.parentNode.removeChild(this.script2);
    this.script2 = null;
  }
  if (this.script) {
    var script = this.script;
    // Unfortunately, you can't really abort script loading of
    // the script.
    script.parentNode.removeChild(script);
    script.onreadystatechange = script.onerror =
        script.onload = script.onclick = null;
    this.script = null;
  }
  delete global[utils.WPrefix][this.id];
};

JsonpReceiver.prototype._scriptError = function() {
  debug('_scriptError');
  var self = this;
  if (this.errorTimer) {
    return;
  }

  this.errorTimer = setTimeout(function() {
    if (!self.loadedOkay) {
      self._abort(new Error('JSONP script loaded abnormally (onerror)'));
    }
  }, JsonpReceiver.scriptErrorTimeout);
};

JsonpReceiver.prototype._createScript = function(url) {
  debug('_createScript', url);
  var self = this;
  var script = this.script = global.document.createElement('script');
  var script2;  // Opera synchronous load trick.

  script.id = 'a' + random.string(8);
  script.src = url;
  script.type = 'text/javascript';
  script.charset = 'UTF-8';
  script.onerror = this._scriptError.bind(this);
  script.onload = function() {
    debug('onload');
    self._abort(new Error('JSONP script loaded abnormally (onload)'));
  };

  // IE9 fires 'error' event after onreadystatechange or before, in random order.
  // Use loadedOkay to determine if actually errored
  script.onreadystatechange = function() {
    debug('onreadystatechange', script.readyState);
    if (/loaded|closed/.test(script.readyState)) {
      if (script && script.htmlFor && script.onclick) {
        self.loadedOkay = true;
        try {
          // In IE, actually execute the script.
          script.onclick();
        } catch (x) {}
      }
      if (script) {
        self._abort(new Error('JSONP script loaded abnormally (onreadystatechange)'));
      }
    }
  };
  // IE: event/htmlFor/onclick trick.
  // One can't rely on proper order for onreadystatechange. In order to
  // make sure, set a 'htmlFor' and 'event' properties, so that
  // script code will be installed as 'onclick' handler for the
  // script object. Later, onreadystatechange, manually execute this
  // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
  // set. For reference see:
  //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
  // Also, read on that about script ordering:
  //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
  if (typeof script.async === 'undefined' && global.document.attachEvent) {
    // According to mozilla docs, in recent browsers script.async defaults
    // to 'true', so we may use it to detect a good browser:
    // https://developer.mozilla.org/en/HTML/Element/script
    if (!browser.isOpera()) {
      // Naively assume we're in IE
      try {
        script.htmlFor = script.id;
        script.event = 'onclick';
      } catch (x) {}
      script.async = true;
    } else {
      // Opera, second sync script hack
      script2 = this.script2 = global.document.createElement('script');
      script2.text = "try{var a = document.getElementById('" + script.id + "'); if(a)a.onerror();}catch(x){};";
      script.async = script2.async = false;
    }
  }
  if (typeof script.async !== 'undefined') {
    script.async = true;
  }

  var head = global.document.getElementsByTagName('head')[0];
  head.insertBefore(script, head.firstChild);
  if (script2) {
    head.insertBefore(script2, head.firstChild);
  }
};

module.exports = JsonpReceiver;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/browser":74,"../../utils/iframe":77,"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],62:[function(require,module,exports){
(function (process){
'use strict';

var inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:receiver:xhr');
}

function XhrReceiver(url, AjaxObject) {
  debug(url);
  EventEmitter.call(this);
  var self = this;

  this.bufferPosition = 0;

  this.xo = new AjaxObject('POST', url, null);
  this.xo.on('chunk', this._chunkHandler.bind(this));
  this.xo.once('finish', function(status, text) {
    debug('finish', status, text);
    self._chunkHandler(status, text);
    self.xo = null;
    var reason = status === 200 ? 'network' : 'permanent';
    debug('close', reason);
    self.emit('close', null, reason);
    self._cleanup();
  });
}

inherits(XhrReceiver, EventEmitter);

XhrReceiver.prototype._chunkHandler = function(status, text) {
  debug('_chunkHandler', status);
  if (status !== 200 || !text) {
    return;
  }

  for (var idx = -1; ; this.bufferPosition += idx + 1) {
    var buf = text.slice(this.bufferPosition);
    idx = buf.indexOf('\n');
    if (idx === -1) {
      break;
    }
    var msg = buf.slice(0, idx);
    if (msg) {
      debug('message', msg);
      this.emit('message', msg);
    }
  }
};

XhrReceiver.prototype._cleanup = function() {
  debug('_cleanup');
  this.removeAllListeners();
};

XhrReceiver.prototype.abort = function() {
  debug('abort');
  if (this.xo) {
    this.xo.close();
    debug('close');
    this.emit('close', null, 'user');
    this.xo = null;
  }
  this._cleanup();
};

module.exports = XhrReceiver;

}).call(this,require('_process'))
},{"_process":30,"debug":84,"events":33,"inherits":87}],63:[function(require,module,exports){
(function (process,global){
'use strict';

var random = require('../../utils/random')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:jsonp');
}

var form, area;

function createIframe(id) {
  debug('createIframe', id);
  try {
    // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
    return global.document.createElement('<iframe name="' + id + '">');
  } catch (x) {
    var iframe = global.document.createElement('iframe');
    iframe.name = id;
    return iframe;
  }
}

function createForm() {
  debug('createForm');
  form = global.document.createElement('form');
  form.style.display = 'none';
  form.style.position = 'absolute';
  form.method = 'POST';
  form.enctype = 'application/x-www-form-urlencoded';
  form.acceptCharset = 'UTF-8';

  area = global.document.createElement('textarea');
  area.name = 'd';
  form.appendChild(area);

  global.document.body.appendChild(form);
}

module.exports = function(url, payload, callback) {
  debug(url, payload);
  if (!form) {
    createForm();
  }
  var id = 'a' + random.string(8);
  form.target = id;
  form.action = urlUtils.addQuery(urlUtils.addPath(url, '/jsonp_send'), 'i=' + id);

  var iframe = createIframe(id);
  iframe.id = id;
  iframe.style.display = 'none';
  form.appendChild(iframe);

  try {
    area.value = payload;
  } catch (e) {
    // seriously broken browsers get here
  }
  form.submit();

  var completed = function(err) {
    debug('completed', id, err);
    if (!iframe.onerror) {
      return;
    }
    iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
    // Opera mini doesn't like if we GC iframe
    // immediately, thus this timeout.
    setTimeout(function() {
      debug('cleaning up', id);
      iframe.parentNode.removeChild(iframe);
      iframe = null;
    }, 500);
    area.value = '';
    // It is not possible to detect if the iframe succeeded or
    // failed to submit our form.
    callback(err);
  };
  iframe.onerror = function() {
    debug('onerror', id);
    completed();
  };
  iframe.onload = function() {
    debug('onload', id);
    completed();
  };
  iframe.onreadystatechange = function(e) {
    debug('onreadystatechange', id, iframe.readyState, e);
    if (iframe.readyState === 'complete') {
      completed();
    }
  };
  return function() {
    debug('aborted', id);
    completed(new Error('Aborted'));
  };
};

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/random":80,"../../utils/url":82,"_process":30,"debug":84}],64:[function(require,module,exports){
(function (process,global){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  , eventUtils = require('../../utils/event')
  , browser = require('../../utils/browser')
  , urlUtils = require('../../utils/url')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:sender:xdr');
}

// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx

function XDRObject(method, url, payload) {
  debug(method, url);
  var self = this;
  EventEmitter.call(this);

  setTimeout(function() {
    self._start(method, url, payload);
  }, 0);
}

inherits(XDRObject, EventEmitter);

XDRObject.prototype._start = function(method, url, payload) {
  debug('_start');
  var self = this;
  var xdr = new global.XDomainRequest();
  // IE caches even POSTs
  url = urlUtils.addQuery(url, 't=' + (+new Date()));

  xdr.onerror = function() {
    debug('onerror');
    self._error();
  };
  xdr.ontimeout = function() {
    debug('ontimeout');
    self._error();
  };
  xdr.onprogress = function() {
    debug('progress', xdr.responseText);
    self.emit('chunk', 200, xdr.responseText);
  };
  xdr.onload = function() {
    debug('load');
    self.emit('finish', 200, xdr.responseText);
    self._cleanup(false);
  };
  this.xdr = xdr;
  this.unloadRef = eventUtils.unloadAdd(function() {
    self._cleanup(true);
  });
  try {
    // Fails with AccessDenied if port number is bogus
    this.xdr.open(method, url);
    if (this.timeout) {
      this.xdr.timeout = this.timeout;
    }
    this.xdr.send(payload);
  } catch (x) {
    this._error();
  }
};

XDRObject.prototype._error = function() {
  this.emit('finish', 0, '');
  this._cleanup(false);
};

XDRObject.prototype._cleanup = function(abort) {
  debug('cleanup', abort);
  if (!this.xdr) {
    return;
  }
  this.removeAllListeners();
  eventUtils.unloadDel(this.unloadRef);

  this.xdr.ontimeout = this.xdr.onerror = this.xdr.onprogress = this.xdr.onload = null;
  if (abort) {
    try {
      this.xdr.abort();
    } catch (x) {}
  }
  this.unloadRef = this.xdr = null;
};

XDRObject.prototype.close = function() {
  debug('close');
  this._cleanup(true);
};

// IE 8/9 if the request target uses the same scheme - #79
XDRObject.enabled = !!(global.XDomainRequest && browser.hasDomain());

module.exports = XDRObject;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/browser":74,"../../utils/event":76,"../../utils/url":82,"_process":30,"debug":84,"events":33,"inherits":87}],65:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRCorsObject(method, url, payload, opts) {
  XhrDriver.call(this, method, url, payload, opts);
}

inherits(XHRCorsObject, XhrDriver);

XHRCorsObject.enabled = XhrDriver.enabled && XhrDriver.supportsCORS;

module.exports = XHRCorsObject;

},{"../driver/xhr":47,"inherits":87}],66:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter
  , inherits = require('inherits')
  ;

function XHRFake(/* method, url, payload, opts */) {
  var self = this;
  EventEmitter.call(this);

  this.to = setTimeout(function() {
    self.emit('finish', 200, '{}');
  }, XHRFake.timeout);
}

inherits(XHRFake, EventEmitter);

XHRFake.prototype.close = function() {
  clearTimeout(this.to);
};

XHRFake.timeout = 2000;

module.exports = XHRFake;

},{"events":33,"inherits":87}],67:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , XhrDriver = require('../driver/xhr')
  ;

function XHRLocalObject(method, url, payload /*, opts */) {
  XhrDriver.call(this, method, url, payload, {
    noCredentials: true
  });
}

inherits(XHRLocalObject, XhrDriver);

XHRLocalObject.enabled = XhrDriver.enabled;

module.exports = XHRLocalObject;

},{"../driver/xhr":47,"inherits":87}],68:[function(require,module,exports){
(function (process){
'use strict';

var utils = require('../utils/event')
  , urlUtils = require('../utils/url')
  , inherits = require('inherits')
  , EventEmitter = require('events').EventEmitter
  , WebsocketDriver = require('./driver/websocket')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:websocket');
}

function WebSocketTransport(transUrl) {
  if (!WebSocketTransport.enabled()) {
    throw new Error('Transport created when disabled');
  }

  EventEmitter.call(this);
  debug('constructor', transUrl);

  var self = this;
  var url = urlUtils.addPath(transUrl, '/websocket');
  if (url.slice(0, 5) === 'https') {
    url = 'wss' + url.slice(5);
  } else {
    url = 'ws' + url.slice(4);
  }
  this.url = url;

  this.ws = new WebsocketDriver(this.url);
  this.ws.onmessage = function(e) {
    debug('message event', e.data);
    self.emit('message', e.data);
  };
  // Firefox has an interesting bug. If a websocket connection is
  // created after onunload, it stays alive even when user
  // navigates away from the page. In such situation let's lie -
  // let's not open the ws connection at all. See:
  // https://github.com/sockjs/sockjs-client/issues/28
  // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
  this.unloadRef = utils.unloadAdd(function() {
    debug('unload');
    self.ws.close();
  });
  this.ws.onclose = function(e) {
    debug('close event', e.code, e.reason);
    self.emit('close', e.code, e.reason);
    self._cleanup();
  };
  this.ws.onerror = function(e) {
    debug('error event', e);
    self.emit('close', 1006, 'WebSocket connection broken');
    self._cleanup();
  };
}

inherits(WebSocketTransport, EventEmitter);

WebSocketTransport.prototype.send = function(data) {
  var msg = '[' + data + ']';
  debug('send', msg);
  this.ws.send(msg);
};

WebSocketTransport.prototype.close = function() {
  debug('close');
  if (this.ws) {
    this.ws.close();
  }
  this._cleanup();
};

WebSocketTransport.prototype._cleanup = function() {
  debug('_cleanup');
  var ws = this.ws;
  if (ws) {
    ws.onmessage = ws.onclose = ws.onerror = null;
  }
  utils.unloadDel(this.unloadRef);
  this.unloadRef = this.ws = null;
  this.removeAllListeners();
};

WebSocketTransport.enabled = function() {
  debug('enabled');
  return !!WebsocketDriver;
};
WebSocketTransport.transportName = 'websocket';

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;

module.exports = WebSocketTransport;

}).call(this,require('_process'))
},{"../utils/event":76,"../utils/url":82,"./driver/websocket":49,"_process":30,"debug":84,"events":33,"inherits":87}],69:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XdrStreamingTransport = require('./xdr-streaming')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

function XdrPollingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XDRObject);
}

inherits(XdrPollingTransport, AjaxBasedTransport);

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.transportName = 'xdr-polling';
XdrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrPollingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xdr":64,"./xdr-streaming":70,"inherits":87}],70:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XDRObject = require('./sender/xdr')
  ;

// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/

function XdrStreamingTransport(transUrl) {
  if (!XDRObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XDRObject);
}

inherits(XdrStreamingTransport, AjaxBasedTransport);

XdrStreamingTransport.enabled = function(info) {
  if (info.cookie_needed || info.nullOrigin) {
    return false;
  }
  return XDRObject.enabled && info.sameScheme;
};

XdrStreamingTransport.transportName = 'xdr-streaming';
XdrStreamingTransport.roundTrips = 2; // preflight, ajax

module.exports = XdrStreamingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xdr":64,"inherits":87}],71:[function(require,module,exports){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  ;

function XhrPollingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr', XhrReceiver, XHRCorsObject);
}

inherits(XhrPollingTransport, AjaxBasedTransport);

XhrPollingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }

  if (XHRLocalObject.enabled && info.sameOrigin) {
    return true;
  }
  return XHRCorsObject.enabled;
};

XhrPollingTransport.transportName = 'xhr-polling';
XhrPollingTransport.roundTrips = 2; // preflight, ajax

module.exports = XhrPollingTransport;

},{"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xhr-cors":65,"./sender/xhr-local":67,"inherits":87}],72:[function(require,module,exports){
(function (global){
'use strict';

var inherits = require('inherits')
  , AjaxBasedTransport = require('./lib/ajax-based')
  , XhrReceiver = require('./receiver/xhr')
  , XHRCorsObject = require('./sender/xhr-cors')
  , XHRLocalObject = require('./sender/xhr-local')
  , browser = require('../utils/browser')
  ;

function XhrStreamingTransport(transUrl) {
  if (!XHRLocalObject.enabled && !XHRCorsObject.enabled) {
    throw new Error('Transport created when disabled');
  }
  AjaxBasedTransport.call(this, transUrl, '/xhr_streaming', XhrReceiver, XHRCorsObject);
}

inherits(XhrStreamingTransport, AjaxBasedTransport);

XhrStreamingTransport.enabled = function(info) {
  if (info.nullOrigin) {
    return false;
  }
  // Opera doesn't support xhr-streaming #60
  // But it might be able to #92
  if (browser.isOpera()) {
    return false;
  }

  return XHRCorsObject.enabled;
};

XhrStreamingTransport.transportName = 'xhr-streaming';
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
// Only require body when used in a browser
XhrStreamingTransport.needBody = !!global.document;

module.exports = XhrStreamingTransport;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../utils/browser":74,"./lib/ajax-based":54,"./receiver/xhr":62,"./sender/xhr-cors":65,"./sender/xhr-local":67,"inherits":87}],73:[function(require,module,exports){
(function (global){
'use strict';

if (global.crypto && global.crypto.getRandomValues) {
  module.exports.randomBytes = function(length) {
    var bytes = new Uint8Array(length);
    global.crypto.getRandomValues(bytes);
    return bytes;
  };
} else {
  module.exports.randomBytes = function(length) {
    var bytes = new Array(length);
    for (var i = 0; i < length; i++) {
      bytes[i] = Math.floor(Math.random() * 256);
    }
    return bytes;
  };
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],74:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  isOpera: function() {
    return global.navigator &&
      /opera/i.test(global.navigator.userAgent);
  }

, isKonqueror: function() {
    return global.navigator &&
      /konqueror/i.test(global.navigator.userAgent);
  }

  // #187 wrap document.domain in try/catch because of WP8 from file:///
, hasDomain: function () {
    // non-browser client always has a domain
    if (!global.document) {
      return true;
    }

    try {
      return !!global.document.domain;
    } catch (e) {
      return false;
    }
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],75:[function(require,module,exports){
'use strict';

var JSON3 = require('json3');

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extraEscapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g
  , extraLookup;

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unrollLookup = function(escapable) {
  var i;
  var unrolled = {};
  var c = [];
  for (i = 0; i < 65536; i++) {
    c.push( String.fromCharCode(i) );
  }
  escapable.lastIndex = 0;
  c.join('').replace(escapable, function(a) {
    unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    return '';
  });
  escapable.lastIndex = 0;
  return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
// http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
module.exports = {
  quote: function(string) {
    var quoted = JSON3.stringify(string);

    // In most cases this should be very fast and good enough.
    extraEscapable.lastIndex = 0;
    if (!extraEscapable.test(quoted)) {
      return quoted;
    }

    if (!extraLookup) {
      extraLookup = unrollLookup(extraEscapable);
    }

    return quoted.replace(extraEscapable, function(a) {
      return extraLookup[a];
    });
  }
};

},{"json3":88}],76:[function(require,module,exports){
(function (global){
'use strict';

var random = require('./random');

var onUnload = {}
  , afterUnload = false
    // detect google chrome packaged apps because they don't allow the 'unload' event
  , isChromePackagedApp = global.chrome && global.chrome.app && global.chrome.app.runtime
  ;

module.exports = {
  attachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.addEventListener(event, listener, false);
    } else if (global.document && global.attachEvent) {
      // IE quirks.
      // According to: http://stevesouders.com/misc/test-postmessage.php
      // the message gets delivered only to 'document', not 'window'.
      global.document.attachEvent('on' + event, listener);
      // I get 'window' for ie8.
      global.attachEvent('on' + event, listener);
    }
  }

, detachEvent: function(event, listener) {
    if (typeof global.addEventListener !== 'undefined') {
      global.removeEventListener(event, listener, false);
    } else if (global.document && global.detachEvent) {
      global.document.detachEvent('on' + event, listener);
      global.detachEvent('on' + event, listener);
    }
  }

, unloadAdd: function(listener) {
    if (isChromePackagedApp) {
      return null;
    }

    var ref = random.string(8);
    onUnload[ref] = listener;
    if (afterUnload) {
      setTimeout(this.triggerUnloadCallbacks, 0);
    }
    return ref;
  }

, unloadDel: function(ref) {
    if (ref in onUnload) {
      delete onUnload[ref];
    }
  }

, triggerUnloadCallbacks: function() {
    for (var ref in onUnload) {
      onUnload[ref]();
      delete onUnload[ref];
    }
  }
};

var unloadTriggered = function() {
  if (afterUnload) {
    return;
  }
  afterUnload = true;
  module.exports.triggerUnloadCallbacks();
};

// 'unload' alone is not reliable in opera within an iframe, but we
// can't use `beforeunload` as IE fires it on javascript: links.
if (!isChromePackagedApp) {
  module.exports.attachEvent('unload', unloadTriggered);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./random":80}],77:[function(require,module,exports){
(function (process,global){
'use strict';

var eventUtils = require('./event')
  , JSON3 = require('json3')
  , browser = require('./browser')
  ;

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:iframe');
}

module.exports = {
  WPrefix: '_jp'
, currentWindowId: null

, polluteGlobalNamespace: function() {
    if (!(module.exports.WPrefix in global)) {
      global[module.exports.WPrefix] = {};
    }
  }

, postMessage: function(type, data) {
    if (global.parent !== global) {
      global.parent.postMessage(JSON3.stringify({
        windowId: module.exports.currentWindowId
      , type: type
      , data: data || ''
      }), '*');
    } else {
      debug('Cannot postMessage, no parent window.', type, data);
    }
  }

, createIframe: function(iframeUrl, errorCallback) {
    var iframe = global.document.createElement('iframe');
    var tref, unloadRef;
    var unattach = function() {
      debug('unattach');
      clearTimeout(tref);
      // Explorer had problems with that.
      try {
        iframe.onload = null;
      } catch (x) {}
      iframe.onerror = null;
    };
    var cleanup = function() {
      debug('cleanup');
      if (iframe) {
        unattach();
        // This timeout makes chrome fire onbeforeunload event
        // within iframe. Without the timeout it goes straight to
        // onunload.
        setTimeout(function() {
          if (iframe) {
            iframe.parentNode.removeChild(iframe);
          }
          iframe = null;
        }, 0);
        eventUtils.unloadDel(unloadRef);
      }
    };
    var onerror = function(err) {
      debug('onerror', err);
      if (iframe) {
        cleanup();
        errorCallback(err);
      }
    };
    var post = function(msg, origin) {
      debug('post', msg, origin);
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {}
    };

    iframe.src = iframeUrl;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function() {
      onerror('onerror');
    };
    iframe.onload = function() {
      debug('onload');
      // `onload` is triggered before scripts on the iframe are
      // executed. Give it few seconds to actually load stuff.
      clearTimeout(tref);
      tref = setTimeout(function() {
        onerror('onload timeout');
      }, 2000);
    };
    global.document.body.appendChild(iframe);
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }

/* jshint undef: false, newcap: false */
/* eslint no-undef: 0, new-cap: 0 */
, createHtmlfile: function(iframeUrl, errorCallback) {
    var axo = ['Active'].concat('Object').join('X');
    var doc = new global[axo]('htmlfile');
    var tref, unloadRef;
    var iframe;
    var unattach = function() {
      clearTimeout(tref);
      iframe.onerror = null;
    };
    var cleanup = function() {
      if (doc) {
        unattach();
        eventUtils.unloadDel(unloadRef);
        iframe.parentNode.removeChild(iframe);
        iframe = doc = null;
        CollectGarbage();
      }
    };
    var onerror = function(r)  {
      debug('onerror', r);
      if (doc) {
        cleanup();
        errorCallback(r);
      }
    };
    var post = function(msg, origin) {
      try {
        // When the iframe is not loaded, IE raises an exception
        // on 'contentWindow'.
        setTimeout(function() {
          if (iframe && iframe.contentWindow) {
              iframe.contentWindow.postMessage(msg, origin);
          }
        }, 0);
      } catch (x) {}
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + global.document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[module.exports.WPrefix] = global[module.exports.WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframeUrl;
    iframe.onerror = function() {
      onerror('onerror');
    };
    tref = setTimeout(function() {
      onerror('timeout');
    }, 15000);
    unloadRef = eventUtils.unloadAdd(cleanup);
    return {
      post: post
    , cleanup: cleanup
    , loaded: unattach
    };
  }
};

module.exports.iframeEnabled = false;
if (global.document) {
  // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
  // huge delay, or not at all.
  module.exports.iframeEnabled = (typeof global.postMessage === 'function' ||
    typeof global.postMessage === 'object') && (!browser.isKonqueror());
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./browser":74,"./event":76,"_process":30,"debug":84,"json3":88}],78:[function(require,module,exports){
(function (global){
'use strict';

var logObject = {};
['log', 'debug', 'warn'].forEach(function (level) {
  var levelExists = global.console && global.console[level] && global.console[level].apply;
  logObject[level] = levelExists ? function () {
    return global.console[level].apply(global.console, arguments);
  } : (level === 'log' ? function () {} : logObject.log);
});

module.exports = logObject;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],79:[function(require,module,exports){
'use strict';

module.exports = {
  isObject: function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  }

, extend: function(obj) {
    if (!this.isObject(obj)) {
      return obj;
    }
    var source, prop;
    for (var i = 1, length = arguments.length; i < length; i++) {
      source = arguments[i];
      for (prop in source) {
        if (Object.prototype.hasOwnProperty.call(source, prop)) {
          obj[prop] = source[prop];
        }
      }
    }
    return obj;
  }
};

},{}],80:[function(require,module,exports){
'use strict';

/* global crypto:true */
var crypto = require('crypto');

// This string has length 32, a power of 2, so the modulus doesn't introduce a
// bias.
var _randomStringChars = 'abcdefghijklmnopqrstuvwxyz012345';
module.exports = {
  string: function(length) {
    var max = _randomStringChars.length;
    var bytes = crypto.randomBytes(length);
    var ret = [];
    for (var i = 0; i < length; i++) {
      ret.push(_randomStringChars.substr(bytes[i] % max, 1));
    }
    return ret.join('');
  }

, number: function(max) {
    return Math.floor(Math.random() * max);
  }

, numberString: function(max) {
    var t = ('' + (max - 1)).length;
    var p = new Array(t + 1).join('0');
    return (p + this.number(max)).slice(-t);
  }
};

},{"crypto":73}],81:[function(require,module,exports){
(function (process){
'use strict';

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:transport');
}

module.exports = function(availableTransports) {
  return {
    filterToEnabled: function(transportsWhitelist, info) {
      var transports = {
        main: []
      , facade: []
      };
      if (!transportsWhitelist) {
        transportsWhitelist = [];
      } else if (typeof transportsWhitelist === 'string') {
        transportsWhitelist = [transportsWhitelist];
      }

      availableTransports.forEach(function(trans) {
        if (!trans) {
          return;
        }

        if (trans.transportName === 'websocket' && info.websocket === false) {
          debug('disabled from server', 'websocket');
          return;
        }

        if (transportsWhitelist.length &&
            transportsWhitelist.indexOf(trans.transportName) === -1) {
          debug('not in whitelist', trans.transportName);
          return;
        }

        if (trans.enabled(info)) {
          debug('enabled', trans.transportName);
          transports.main.push(trans);
          if (trans.facadeTransport) {
            transports.facade.push(trans.facadeTransport);
          }
        } else {
          debug('disabled', trans.transportName);
        }
      });
      return transports;
    }
  };
};

}).call(this,require('_process'))
},{"_process":30,"debug":84}],82:[function(require,module,exports){
(function (process){
'use strict';

var URL = require('url-parse');

var debug = function() {};
if (process.env.NODE_ENV !== 'production') {
  debug = require('debug')('sockjs-client:utils:url');
}

module.exports = {
  getOrigin: function(url) {
    if (!url) {
      return null;
    }

    var p = new URL(url);
    if (p.protocol === 'file:') {
      return null;
    }

    var port = p.port;
    if (!port) {
      port = (p.protocol === 'https:') ? '443' : '80';
    }

    return p.protocol + '//' + p.hostname + ':' + port;
  }

, isOriginEqual: function(a, b) {
    var res = this.getOrigin(a) === this.getOrigin(b);
    debug('same', a, b, res);
    return res;
  }

, isSchemeEqual: function(a, b) {
    return (a.split(':')[0] === b.split(':')[0]);
  }

, addPath: function (url, path) {
    var qs = url.split('?');
    return qs[0] + path + (qs[1] ? '?' + qs[1] : '');
  }

, addQuery: function (url, q) {
    return url + (url.indexOf('?') === -1 ? ('?' + q) : ('&' + q));
  }
};

}).call(this,require('_process'))
},{"_process":30,"debug":84,"url-parse":89}],83:[function(require,module,exports){
module.exports = '1.0.3';
},{}],84:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":85}],85:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":86}],86:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],87:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],88:[function(require,module,exports){
(function (global){
/*! JSON v3.3.2 | http://bestiejs.github.io/json3 | Copyright 2012-2014, Kit Cambridge | http://kit.mit-license.org */
;(function () {
  // Detect the `define` function exposed by asynchronous module loaders. The
  // strict `define` check is necessary for compatibility with `r.js`.
  var isLoader = typeof define === "function" && define.amd;

  // A set of types used to distinguish objects from primitives.
  var objectTypes = {
    "function": true,
    "object": true
  };

  // Detect the `exports` object exposed by CommonJS implementations.
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  // Use the `global` object exposed by Node (including Browserify via
  // `insert-module-globals`), Narwhal, and Ringo as the default context,
  // and the `window` object in browsers. Rhino exports a `global` function
  // instead.
  var root = objectTypes[typeof window] && window || this,
      freeGlobal = freeExports && objectTypes[typeof module] && module && !module.nodeType && typeof global == "object" && global;

  if (freeGlobal && (freeGlobal["global"] === freeGlobal || freeGlobal["window"] === freeGlobal || freeGlobal["self"] === freeGlobal)) {
    root = freeGlobal;
  }

  // Public: Initializes JSON 3 using the given `context` object, attaching the
  // `stringify` and `parse` functions to the specified `exports` object.
  function runInContext(context, exports) {
    context || (context = root["Object"]());
    exports || (exports = root["Object"]());

    // Native constructor aliases.
    var Number = context["Number"] || root["Number"],
        String = context["String"] || root["String"],
        Object = context["Object"] || root["Object"],
        Date = context["Date"] || root["Date"],
        SyntaxError = context["SyntaxError"] || root["SyntaxError"],
        TypeError = context["TypeError"] || root["TypeError"],
        Math = context["Math"] || root["Math"],
        nativeJSON = context["JSON"] || root["JSON"];

    // Delegate to the native `stringify` and `parse` implementations.
    if (typeof nativeJSON == "object" && nativeJSON) {
      exports.stringify = nativeJSON.stringify;
      exports.parse = nativeJSON.parse;
    }

    // Convenience aliases.
    var objectProto = Object.prototype,
        getClass = objectProto.toString,
        isProperty, forEach, undef;

    // Test the `Date#getUTC*` methods. Based on work by @Yaffle.
    var isExtended = new Date(-3509827334573292);
    try {
      // The `getUTCFullYear`, `Month`, and `Date` methods return nonsensical
      // results for certain dates in Opera >= 10.53.
      isExtended = isExtended.getUTCFullYear() == -109252 && isExtended.getUTCMonth() === 0 && isExtended.getUTCDate() === 1 &&
        // Safari < 2.0.2 stores the internal millisecond time value correctly,
        // but clips the values returned by the date methods to the range of
        // signed 32-bit integers ([-2 ** 31, 2 ** 31 - 1]).
        isExtended.getUTCHours() == 10 && isExtended.getUTCMinutes() == 37 && isExtended.getUTCSeconds() == 6 && isExtended.getUTCMilliseconds() == 708;
    } catch (exception) {}

    // Internal: Determines whether the native `JSON.stringify` and `parse`
    // implementations are spec-compliant. Based on work by Ken Snyder.
    function has(name) {
      if (has[name] !== undef) {
        // Return cached feature test result.
        return has[name];
      }
      var isSupported;
      if (name == "bug-string-char-index") {
        // IE <= 7 doesn't support accessing string characters using square
        // bracket notation. IE 8 only supports this for primitives.
        isSupported = "a"[0] != "a";
      } else if (name == "json") {
        // Indicates whether both `JSON.stringify` and `JSON.parse` are
        // supported.
        isSupported = has("json-stringify") && has("json-parse");
      } else {
        var value, serialized = '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}';
        // Test `JSON.stringify`.
        if (name == "json-stringify") {
          var stringify = exports.stringify, stringifySupported = typeof stringify == "function" && isExtended;
          if (stringifySupported) {
            // A test function object with a custom `toJSON` method.
            (value = function () {
              return 1;
            }).toJSON = value;
            try {
              stringifySupported =
                // Firefox 3.1b1 and b2 serialize string, number, and boolean
                // primitives as object literals.
                stringify(0) === "0" &&
                // FF 3.1b1, b2, and JSON 2 serialize wrapped primitives as object
                // literals.
                stringify(new Number()) === "0" &&
                stringify(new String()) == '""' &&
                // FF 3.1b1, 2 throw an error if the value is `null`, `undefined`, or
                // does not define a canonical JSON representation (this applies to
                // objects with `toJSON` properties as well, *unless* they are nested
                // within an object or array).
                stringify(getClass) === undef &&
                // IE 8 serializes `undefined` as `"undefined"`. Safari <= 5.1.7 and
                // FF 3.1b3 pass this test.
                stringify(undef) === undef &&
                // Safari <= 5.1.7 and FF 3.1b3 throw `Error`s and `TypeError`s,
                // respectively, if the value is omitted entirely.
                stringify() === undef &&
                // FF 3.1b1, 2 throw an error if the given value is not a number,
                // string, array, object, Boolean, or `null` literal. This applies to
                // objects with custom `toJSON` methods as well, unless they are nested
                // inside object or array literals. YUI 3.0.0b1 ignores custom `toJSON`
                // methods entirely.
                stringify(value) === "1" &&
                stringify([value]) == "[1]" &&
                // Prototype <= 1.6.1 serializes `[undefined]` as `"[]"` instead of
                // `"[null]"`.
                stringify([undef]) == "[null]" &&
                // YUI 3.0.0b1 fails to serialize `null` literals.
                stringify(null) == "null" &&
                // FF 3.1b1, 2 halts serialization if an array contains a function:
                // `[1, true, getClass, 1]` serializes as "[1,true,],". FF 3.1b3
                // elides non-JSON values from objects and arrays, unless they
                // define custom `toJSON` methods.
                stringify([undef, getClass, null]) == "[null,null,null]" &&
                // Simple serialization test. FF 3.1b1 uses Unicode escape sequences
                // where character escape codes are expected (e.g., `\b` => `\u0008`).
                stringify({ "a": [value, true, false, null, "\x00\b\n\f\r\t"] }) == serialized &&
                // FF 3.1b1 and b2 ignore the `filter` and `width` arguments.
                stringify(null, value) === "1" &&
                stringify([1, 2], null, 1) == "[\n 1,\n 2\n]" &&
                // JSON 2, Prototype <= 1.7, and older WebKit builds incorrectly
                // serialize extended years.
                stringify(new Date(-8.64e15)) == '"-271821-04-20T00:00:00.000Z"' &&
                // The milliseconds are optional in ES 5, but required in 5.1.
                stringify(new Date(8.64e15)) == '"+275760-09-13T00:00:00.000Z"' &&
                // Firefox <= 11.0 incorrectly serializes years prior to 0 as negative
                // four-digit years instead of six-digit years. Credits: @Yaffle.
                stringify(new Date(-621987552e5)) == '"-000001-01-01T00:00:00.000Z"' &&
                // Safari <= 5.1.5 and Opera >= 10.53 incorrectly serialize millisecond
                // values less than 1000. Credits: @Yaffle.
                stringify(new Date(-1)) == '"1969-12-31T23:59:59.999Z"';
            } catch (exception) {
              stringifySupported = false;
            }
          }
          isSupported = stringifySupported;
        }
        // Test `JSON.parse`.
        if (name == "json-parse") {
          var parse = exports.parse;
          if (typeof parse == "function") {
            try {
              // FF 3.1b1, b2 will throw an exception if a bare literal is provided.
              // Conforming implementations should also coerce the initial argument to
              // a string prior to parsing.
              if (parse("0") === 0 && !parse(false)) {
                // Simple parsing test.
                value = parse(serialized);
                var parseSupported = value["a"].length == 5 && value["a"][0] === 1;
                if (parseSupported) {
                  try {
                    // Safari <= 5.1.2 and FF 3.1b1 allow unescaped tabs in strings.
                    parseSupported = !parse('"\t"');
                  } catch (exception) {}
                  if (parseSupported) {
                    try {
                      // FF 4.0 and 4.0.1 allow leading `+` signs and leading
                      // decimal points. FF 4.0, 4.0.1, and IE 9-10 also allow
                      // certain octal literals.
                      parseSupported = parse("01") !== 1;
                    } catch (exception) {}
                  }
                  if (parseSupported) {
                    try {
                      // FF 4.0, 4.0.1, and Rhino 1.7R3-R4 allow trailing decimal
                      // points. These environments, along with FF 3.1b1 and 2,
                      // also allow trailing commas in JSON objects and arrays.
                      parseSupported = parse("1.") !== 1;
                    } catch (exception) {}
                  }
                }
              }
            } catch (exception) {
              parseSupported = false;
            }
          }
          isSupported = parseSupported;
        }
      }
      return has[name] = !!isSupported;
    }

    if (!has("json")) {
      // Common `[[Class]]` name aliases.
      var functionClass = "[object Function]",
          dateClass = "[object Date]",
          numberClass = "[object Number]",
          stringClass = "[object String]",
          arrayClass = "[object Array]",
          booleanClass = "[object Boolean]";

      // Detect incomplete support for accessing string characters by index.
      var charIndexBuggy = has("bug-string-char-index");

      // Define additional utility methods if the `Date` methods are buggy.
      if (!isExtended) {
        var floor = Math.floor;
        // A mapping between the months of the year and the number of days between
        // January 1st and the first of the respective month.
        var Months = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        // Internal: Calculates the number of days between the Unix epoch and the
        // first day of the given month.
        var getDay = function (year, month) {
          return Months[month] + 365 * (year - 1970) + floor((year - 1969 + (month = +(month > 1))) / 4) - floor((year - 1901 + month) / 100) + floor((year - 1601 + month) / 400);
        };
      }

      // Internal: Determines if a property is a direct property of the given
      // object. Delegates to the native `Object#hasOwnProperty` method.
      if (!(isProperty = objectProto.hasOwnProperty)) {
        isProperty = function (property) {
          var members = {}, constructor;
          if ((members.__proto__ = null, members.__proto__ = {
            // The *proto* property cannot be set multiple times in recent
            // versions of Firefox and SeaMonkey.
            "toString": 1
          }, members).toString != getClass) {
            // Safari <= 2.0.3 doesn't implement `Object#hasOwnProperty`, but
            // supports the mutable *proto* property.
            isProperty = function (property) {
              // Capture and break the object's prototype chain (see section 8.6.2
              // of the ES 5.1 spec). The parenthesized expression prevents an
              // unsafe transformation by the Closure Compiler.
              var original = this.__proto__, result = property in (this.__proto__ = null, this);
              // Restore the original prototype chain.
              this.__proto__ = original;
              return result;
            };
          } else {
            // Capture a reference to the top-level `Object` constructor.
            constructor = members.constructor;
            // Use the `constructor` property to simulate `Object#hasOwnProperty` in
            // other environments.
            isProperty = function (property) {
              var parent = (this.constructor || constructor).prototype;
              return property in this && !(property in parent && this[property] === parent[property]);
            };
          }
          members = null;
          return isProperty.call(this, property);
        };
      }

      // Internal: Normalizes the `for...in` iteration algorithm across
      // environments. Each enumerated key is yielded to a `callback` function.
      forEach = function (object, callback) {
        var size = 0, Properties, members, property;

        // Tests for bugs in the current environment's `for...in` algorithm. The
        // `valueOf` property inherits the non-enumerable flag from
        // `Object.prototype` in older versions of IE, Netscape, and Mozilla.
        (Properties = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;

        // Iterate over a new instance of the `Properties` class.
        members = new Properties();
        for (property in members) {
          // Ignore all properties inherited from `Object.prototype`.
          if (isProperty.call(members, property)) {
            size++;
          }
        }
        Properties = members = null;

        // Normalize the iteration algorithm.
        if (!size) {
          // A list of non-enumerable properties inherited from `Object.prototype`.
          members = ["valueOf", "toString", "toLocaleString", "propertyIsEnumerable", "isPrototypeOf", "hasOwnProperty", "constructor"];
          // IE <= 8, Mozilla 1.0, and Netscape 6.2 ignore shadowed non-enumerable
          // properties.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, length;
            var hasProperty = !isFunction && typeof object.constructor != "function" && objectTypes[typeof object.hasOwnProperty] && object.hasOwnProperty || isProperty;
            for (property in object) {
              // Gecko <= 1.0 enumerates the `prototype` property of functions under
              // certain conditions; IE does not.
              if (!(isFunction && property == "prototype") && hasProperty.call(object, property)) {
                callback(property);
              }
            }
            // Manually invoke the callback for each non-enumerable property.
            for (length = members.length; property = members[--length]; hasProperty.call(object, property) && callback(property));
          };
        } else if (size == 2) {
          // Safari <= 2.0.4 enumerates shadowed properties twice.
          forEach = function (object, callback) {
            // Create a set of iterated properties.
            var members = {}, isFunction = getClass.call(object) == functionClass, property;
            for (property in object) {
              // Store each property name to prevent double enumeration. The
              // `prototype` property of functions is not enumerated due to cross-
              // environment inconsistencies.
              if (!(isFunction && property == "prototype") && !isProperty.call(members, property) && (members[property] = 1) && isProperty.call(object, property)) {
                callback(property);
              }
            }
          };
        } else {
          // No bugs detected; use the standard `for...in` algorithm.
          forEach = function (object, callback) {
            var isFunction = getClass.call(object) == functionClass, property, isConstructor;
            for (property in object) {
              if (!(isFunction && property == "prototype") && isProperty.call(object, property) && !(isConstructor = property === "constructor")) {
                callback(property);
              }
            }
            // Manually invoke the callback for the `constructor` property due to
            // cross-environment inconsistencies.
            if (isConstructor || isProperty.call(object, (property = "constructor"))) {
              callback(property);
            }
          };
        }
        return forEach(object, callback);
      };

      // Public: Serializes a JavaScript `value` as a JSON string. The optional
      // `filter` argument may specify either a function that alters how object and
      // array members are serialized, or an array of strings and numbers that
      // indicates which properties should be serialized. The optional `width`
      // argument may be either a string or number that specifies the indentation
      // level of the output.
      if (!has("json-stringify")) {
        // Internal: A map of control characters and their escaped equivalents.
        var Escapes = {
          92: "\\\\",
          34: '\\"',
          8: "\\b",
          12: "\\f",
          10: "\\n",
          13: "\\r",
          9: "\\t"
        };

        // Internal: Converts `value` into a zero-padded string such that its
        // length is at least equal to `width`. The `width` must be <= 6.
        var leadingZeroes = "000000";
        var toPaddedString = function (width, value) {
          // The `|| 0` expression is necessary to work around a bug in
          // Opera <= 7.54u2 where `0 == -0`, but `String(-0) !== "0"`.
          return (leadingZeroes + (value || 0)).slice(-width);
        };

        // Internal: Double-quotes a string `value`, replacing all ASCII control
        // characters (characters with code unit values between 0 and 31) with
        // their escaped equivalents. This is an implementation of the
        // `Quote(value)` operation defined in ES 5.1 section 15.12.3.
        var unicodePrefix = "\\u00";
        var quote = function (value) {
          var result = '"', index = 0, length = value.length, useCharIndex = !charIndexBuggy || length > 10;
          var symbols = useCharIndex && (charIndexBuggy ? value.split("") : value);
          for (; index < length; index++) {
            var charCode = value.charCodeAt(index);
            // If the character is a control character, append its Unicode or
            // shorthand escape sequence; otherwise, append the character as-is.
            switch (charCode) {
              case 8: case 9: case 10: case 12: case 13: case 34: case 92:
                result += Escapes[charCode];
                break;
              default:
                if (charCode < 32) {
                  result += unicodePrefix + toPaddedString(2, charCode.toString(16));
                  break;
                }
                result += useCharIndex ? symbols[index] : value.charAt(index);
            }
          }
          return result + '"';
        };

        // Internal: Recursively serializes an object. Implements the
        // `Str(key, holder)`, `JO(value)`, and `JA(value)` operations.
        var serialize = function (property, object, callback, properties, whitespace, indentation, stack) {
          var value, className, year, month, date, time, hours, minutes, seconds, milliseconds, results, element, index, length, prefix, result;
          try {
            // Necessary for host object support.
            value = object[property];
          } catch (exception) {}
          if (typeof value == "object" && value) {
            className = getClass.call(value);
            if (className == dateClass && !isProperty.call(value, "toJSON")) {
              if (value > -1 / 0 && value < 1 / 0) {
                // Dates are serialized according to the `Date#toJSON` method
                // specified in ES 5.1 section 15.9.5.44. See section 15.9.1.15
                // for the ISO 8601 date time string format.
                if (getDay) {
                  // Manually compute the year, month, date, hours, minutes,
                  // seconds, and milliseconds if the `getUTC*` methods are
                  // buggy. Adapted from @Yaffle's `date-shim` project.
                  date = floor(value / 864e5);
                  for (year = floor(date / 365.2425) + 1970 - 1; getDay(year + 1, 0) <= date; year++);
                  for (month = floor((date - getDay(year, 0)) / 30.42); getDay(year, month + 1) <= date; month++);
                  date = 1 + date - getDay(year, month);
                  // The `time` value specifies the time within the day (see ES
                  // 5.1 section 15.9.1.2). The formula `(A % B + B) % B` is used
                  // to compute `A modulo B`, as the `%` operator does not
                  // correspond to the `modulo` operation for negative numbers.
                  time = (value % 864e5 + 864e5) % 864e5;
                  // The hours, minutes, seconds, and milliseconds are obtained by
                  // decomposing the time within the day. See section 15.9.1.10.
                  hours = floor(time / 36e5) % 24;
                  minutes = floor(time / 6e4) % 60;
                  seconds = floor(time / 1e3) % 60;
                  milliseconds = time % 1e3;
                } else {
                  year = value.getUTCFullYear();
                  month = value.getUTCMonth();
                  date = value.getUTCDate();
                  hours = value.getUTCHours();
                  minutes = value.getUTCMinutes();
                  seconds = value.getUTCSeconds();
                  milliseconds = value.getUTCMilliseconds();
                }
                // Serialize extended years correctly.
                value = (year <= 0 || year >= 1e4 ? (year < 0 ? "-" : "+") + toPaddedString(6, year < 0 ? -year : year) : toPaddedString(4, year)) +
                  "-" + toPaddedString(2, month + 1) + "-" + toPaddedString(2, date) +
                  // Months, dates, hours, minutes, and seconds should have two
                  // digits; milliseconds should have three.
                  "T" + toPaddedString(2, hours) + ":" + toPaddedString(2, minutes) + ":" + toPaddedString(2, seconds) +
                  // Milliseconds are optional in ES 5.0, but required in 5.1.
                  "." + toPaddedString(3, milliseconds) + "Z";
              } else {
                value = null;
              }
            } else if (typeof value.toJSON == "function" && ((className != numberClass && className != stringClass && className != arrayClass) || isProperty.call(value, "toJSON"))) {
              // Prototype <= 1.6.1 adds non-standard `toJSON` methods to the
              // `Number`, `String`, `Date`, and `Array` prototypes. JSON 3
              // ignores all `toJSON` methods on these objects unless they are
              // defined directly on an instance.
              value = value.toJSON(property);
            }
          }
          if (callback) {
            // If a replacement function was provided, call it to obtain the value
            // for serialization.
            value = callback.call(object, property, value);
          }
          if (value === null) {
            return "null";
          }
          className = getClass.call(value);
          if (className == booleanClass) {
            // Booleans are represented literally.
            return "" + value;
          } else if (className == numberClass) {
            // JSON numbers must be finite. `Infinity` and `NaN` are serialized as
            // `"null"`.
            return value > -1 / 0 && value < 1 / 0 ? "" + value : "null";
          } else if (className == stringClass) {
            // Strings are double-quoted and escaped.
            return quote("" + value);
          }
          // Recursively serialize objects and arrays.
          if (typeof value == "object") {
            // Check for cyclic structures. This is a linear search; performance
            // is inversely proportional to the number of unique nested objects.
            for (length = stack.length; length--;) {
              if (stack[length] === value) {
                // Cyclic structures cannot be serialized by `JSON.stringify`.
                throw TypeError();
              }
            }
            // Add the object to the stack of traversed objects.
            stack.push(value);
            results = [];
            // Save the current indentation level and indent one additional level.
            prefix = indentation;
            indentation += whitespace;
            if (className == arrayClass) {
              // Recursively serialize array elements.
              for (index = 0, length = value.length; index < length; index++) {
                element = serialize(index, value, callback, properties, whitespace, indentation, stack);
                results.push(element === undef ? "null" : element);
              }
              result = results.length ? (whitespace ? "[\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "]" : ("[" + results.join(",") + "]")) : "[]";
            } else {
              // Recursively serialize object members. Members are selected from
              // either a user-specified list of property names, or the object
              // itself.
              forEach(properties || value, function (property) {
                var element = serialize(property, value, callback, properties, whitespace, indentation, stack);
                if (element !== undef) {
                  // According to ES 5.1 section 15.12.3: "If `gap` {whitespace}
                  // is not the empty string, let `member` {quote(property) + ":"}
                  // be the concatenation of `member` and the `space` character."
                  // The "`space` character" refers to the literal space
                  // character, not the `space` {width} argument provided to
                  // `JSON.stringify`.
                  results.push(quote(property) + ":" + (whitespace ? " " : "") + element);
                }
              });
              result = results.length ? (whitespace ? "{\n" + indentation + results.join(",\n" + indentation) + "\n" + prefix + "}" : ("{" + results.join(",") + "}")) : "{}";
            }
            // Remove the object from the traversed object stack.
            stack.pop();
            return result;
          }
        };

        // Public: `JSON.stringify`. See ES 5.1 section 15.12.3.
        exports.stringify = function (source, filter, width) {
          var whitespace, callback, properties, className;
          if (objectTypes[typeof filter] && filter) {
            if ((className = getClass.call(filter)) == functionClass) {
              callback = filter;
            } else if (className == arrayClass) {
              // Convert the property names array into a makeshift set.
              properties = {};
              for (var index = 0, length = filter.length, value; index < length; value = filter[index++], ((className = getClass.call(value)), className == stringClass || className == numberClass) && (properties[value] = 1));
            }
          }
          if (width) {
            if ((className = getClass.call(width)) == numberClass) {
              // Convert the `width` to an integer and create a string containing
              // `width` number of space characters.
              if ((width -= width % 1) > 0) {
                for (whitespace = "", width > 10 && (width = 10); whitespace.length < width; whitespace += " ");
              }
            } else if (className == stringClass) {
              whitespace = width.length <= 10 ? width : width.slice(0, 10);
            }
          }
          // Opera <= 7.54u2 discards the values associated with empty string keys
          // (`""`) only if they are used directly within an object member list
          // (e.g., `!("" in { "": 1})`).
          return serialize("", (value = {}, value[""] = source, value), callback, properties, whitespace, "", []);
        };
      }

      // Public: Parses a JSON source string.
      if (!has("json-parse")) {
        var fromCharCode = String.fromCharCode;

        // Internal: A map of escaped control characters and their unescaped
        // equivalents.
        var Unescapes = {
          92: "\\",
          34: '"',
          47: "/",
          98: "\b",
          116: "\t",
          110: "\n",
          102: "\f",
          114: "\r"
        };

        // Internal: Stores the parser state.
        var Index, Source;

        // Internal: Resets the parser state and throws a `SyntaxError`.
        var abort = function () {
          Index = Source = null;
          throw SyntaxError();
        };

        // Internal: Returns the next token, or `"$"` if the parser has reached
        // the end of the source string. A token may be a string, number, `null`
        // literal, or Boolean literal.
        var lex = function () {
          var source = Source, length = source.length, value, begin, position, isSigned, charCode;
          while (Index < length) {
            charCode = source.charCodeAt(Index);
            switch (charCode) {
              case 9: case 10: case 13: case 32:
                // Skip whitespace tokens, including tabs, carriage returns, line
                // feeds, and space characters.
                Index++;
                break;
              case 123: case 125: case 91: case 93: case 58: case 44:
                // Parse a punctuator token (`{`, `}`, `[`, `]`, `:`, or `,`) at
                // the current position.
                value = charIndexBuggy ? source.charAt(Index) : source[Index];
                Index++;
                return value;
              case 34:
                // `"` delimits a JSON string; advance to the next character and
                // begin parsing the string. String tokens are prefixed with the
                // sentinel `@` character to distinguish them from punctuators and
                // end-of-string tokens.
                for (value = "@", Index++; Index < length;) {
                  charCode = source.charCodeAt(Index);
                  if (charCode < 32) {
                    // Unescaped ASCII control characters (those with a code unit
                    // less than the space character) are not permitted.
                    abort();
                  } else if (charCode == 92) {
                    // A reverse solidus (`\`) marks the beginning of an escaped
                    // control character (including `"`, `\`, and `/`) or Unicode
                    // escape sequence.
                    charCode = source.charCodeAt(++Index);
                    switch (charCode) {
                      case 92: case 34: case 47: case 98: case 116: case 110: case 102: case 114:
                        // Revive escaped control characters.
                        value += Unescapes[charCode];
                        Index++;
                        break;
                      case 117:
                        // `\u` marks the beginning of a Unicode escape sequence.
                        // Advance to the first character and validate the
                        // four-digit code point.
                        begin = ++Index;
                        for (position = Index + 4; Index < position; Index++) {
                          charCode = source.charCodeAt(Index);
                          // A valid sequence comprises four hexdigits (case-
                          // insensitive) that form a single hexadecimal value.
                          if (!(charCode >= 48 && charCode <= 57 || charCode >= 97 && charCode <= 102 || charCode >= 65 && charCode <= 70)) {
                            // Invalid Unicode escape sequence.
                            abort();
                          }
                        }
                        // Revive the escaped character.
                        value += fromCharCode("0x" + source.slice(begin, Index));
                        break;
                      default:
                        // Invalid escape sequence.
                        abort();
                    }
                  } else {
                    if (charCode == 34) {
                      // An unescaped double-quote character marks the end of the
                      // string.
                      break;
                    }
                    charCode = source.charCodeAt(Index);
                    begin = Index;
                    // Optimize for the common case where a string is valid.
                    while (charCode >= 32 && charCode != 92 && charCode != 34) {
                      charCode = source.charCodeAt(++Index);
                    }
                    // Append the string as-is.
                    value += source.slice(begin, Index);
                  }
                }
                if (source.charCodeAt(Index) == 34) {
                  // Advance to the next character and return the revived string.
                  Index++;
                  return value;
                }
                // Unterminated string.
                abort();
              default:
                // Parse numbers and literals.
                begin = Index;
                // Advance past the negative sign, if one is specified.
                if (charCode == 45) {
                  isSigned = true;
                  charCode = source.charCodeAt(++Index);
                }
                // Parse an integer or floating-point value.
                if (charCode >= 48 && charCode <= 57) {
                  // Leading zeroes are interpreted as octal literals.
                  if (charCode == 48 && ((charCode = source.charCodeAt(Index + 1)), charCode >= 48 && charCode <= 57)) {
                    // Illegal octal literal.
                    abort();
                  }
                  isSigned = false;
                  // Parse the integer component.
                  for (; Index < length && ((charCode = source.charCodeAt(Index)), charCode >= 48 && charCode <= 57); Index++);
                  // Floats cannot contain a leading decimal point; however, this
                  // case is already accounted for by the parser.
                  if (source.charCodeAt(Index) == 46) {
                    position = ++Index;
                    // Parse the decimal component.
                    for (; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal trailing decimal.
                      abort();
                    }
                    Index = position;
                  }
                  // Parse exponents. The `e` denoting the exponent is
                  // case-insensitive.
                  charCode = source.charCodeAt(Index);
                  if (charCode == 101 || charCode == 69) {
                    charCode = source.charCodeAt(++Index);
                    // Skip past the sign following the exponent, if one is
                    // specified.
                    if (charCode == 43 || charCode == 45) {
                      Index++;
                    }
                    // Parse the exponential component.
                    for (position = Index; position < length && ((charCode = source.charCodeAt(position)), charCode >= 48 && charCode <= 57); position++);
                    if (position == Index) {
                      // Illegal empty exponent.
                      abort();
                    }
                    Index = position;
                  }
                  // Coerce the parsed value to a JavaScript number.
                  return +source.slice(begin, Index);
                }
                // A negative sign may only precede numbers.
                if (isSigned) {
                  abort();
                }
                // `true`, `false`, and `null` literals.
                if (source.slice(Index, Index + 4) == "true") {
                  Index += 4;
                  return true;
                } else if (source.slice(Index, Index + 5) == "false") {
                  Index += 5;
                  return false;
                } else if (source.slice(Index, Index + 4) == "null") {
                  Index += 4;
                  return null;
                }
                // Unrecognized token.
                abort();
            }
          }
          // Return the sentinel `$` character if the parser has reached the end
          // of the source string.
          return "$";
        };

        // Internal: Parses a JSON `value` token.
        var get = function (value) {
          var results, hasMembers;
          if (value == "$") {
            // Unexpected end of input.
            abort();
          }
          if (typeof value == "string") {
            if ((charIndexBuggy ? value.charAt(0) : value[0]) == "@") {
              // Remove the sentinel `@` character.
              return value.slice(1);
            }
            // Parse object and array literals.
            if (value == "[") {
              // Parses a JSON array, returning a new JavaScript array.
              results = [];
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing square bracket marks the end of the array literal.
                if (value == "]") {
                  break;
                }
                // If the array literal contains elements, the current token
                // should be a comma separating the previous element from the
                // next.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "]") {
                      // Unexpected trailing `,` in array literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each array element.
                    abort();
                  }
                }
                // Elisions and leading commas are not permitted.
                if (value == ",") {
                  abort();
                }
                results.push(get(value));
              }
              return results;
            } else if (value == "{") {
              // Parses a JSON object, returning a new JavaScript object.
              results = {};
              for (;; hasMembers || (hasMembers = true)) {
                value = lex();
                // A closing curly brace marks the end of the object literal.
                if (value == "}") {
                  break;
                }
                // If the object literal contains members, the current token
                // should be a comma separator.
                if (hasMembers) {
                  if (value == ",") {
                    value = lex();
                    if (value == "}") {
                      // Unexpected trailing `,` in object literal.
                      abort();
                    }
                  } else {
                    // A `,` must separate each object member.
                    abort();
                  }
                }
                // Leading commas are not permitted, object property names must be
                // double-quoted strings, and a `:` must separate each property
                // name and value.
                if (value == "," || typeof value != "string" || (charIndexBuggy ? value.charAt(0) : value[0]) != "@" || lex() != ":") {
                  abort();
                }
                results[value.slice(1)] = get(lex());
              }
              return results;
            }
            // Unexpected token encountered.
            abort();
          }
          return value;
        };

        // Internal: Updates a traversed object member.
        var update = function (source, property, callback) {
          var element = walk(source, property, callback);
          if (element === undef) {
            delete source[property];
          } else {
            source[property] = element;
          }
        };

        // Internal: Recursively traverses a parsed JSON object, invoking the
        // `callback` function for each value. This is an implementation of the
        // `Walk(holder, name)` operation defined in ES 5.1 section 15.12.2.
        var walk = function (source, property, callback) {
          var value = source[property], length;
          if (typeof value == "object" && value) {
            // `forEach` can't be used to traverse an array in Opera <= 8.54
            // because its `Object#hasOwnProperty` implementation returns `false`
            // for array indices (e.g., `![1, 2, 3].hasOwnProperty("0")`).
            if (getClass.call(value) == arrayClass) {
              for (length = value.length; length--;) {
                update(value, length, callback);
              }
            } else {
              forEach(value, function (property) {
                update(value, property, callback);
              });
            }
          }
          return callback.call(source, property, value);
        };

        // Public: `JSON.parse`. See ES 5.1 section 15.12.2.
        exports.parse = function (source, callback) {
          var result, value;
          Index = 0;
          Source = "" + source;
          result = get(lex());
          // If a JSON string contains multiple tokens, it is invalid.
          if (lex() != "$") {
            abort();
          }
          // Reset the parser state.
          Index = Source = null;
          return callback && getClass.call(callback) == functionClass ? walk((value = {}, value[""] = result, value), "", callback) : result;
        };
      }
    }

    exports["runInContext"] = runInContext;
    return exports;
  }

  if (freeExports && !isLoader) {
    // Export for CommonJS environments.
    runInContext(root, freeExports);
  } else {
    // Export for web browsers and JavaScript engines.
    var nativeJSON = root.JSON,
        previousJSON = root["JSON3"],
        isRestored = false;

    var JSON3 = runInContext(root, (root["JSON3"] = {
      // Public: Restores the original value of the global `JSON` object and
      // returns a reference to the `JSON3` object.
      "noConflict": function () {
        if (!isRestored) {
          isRestored = true;
          root.JSON = nativeJSON;
          root["JSON3"] = previousJSON;
          nativeJSON = previousJSON = null;
        }
        return JSON3;
      }
    }));

    root.JSON = {
      "parse": JSON3.parse,
      "stringify": JSON3.stringify
    };
  }

  // Export for asynchronous module loaders.
  if (isLoader) {
    define(function () {
      return JSON3;
    });
  }
}).call(this);

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],89:[function(require,module,exports){
'use strict';

var required = require('requires-port')
  , lolcation = require('./lolcation')
  , qs = require('querystringify')
  , relativere = /^\/(?!\/)/;

/**
 * These are the parse instructions for the URL parsers, it informs the parser
 * about:
 *
 * 0. The char it Needs to parse, if it's a string it should be done using
 *    indexOf, RegExp using exec and NaN means set as current value.
 * 1. The property we should set when parsing this value.
 * 2. Indication if it's backwards or forward parsing, when set as number it's
 *    the value of extra chars that should be split off.
 * 3. Inherit from location if non existing in the parser.
 * 4. `toLowerCase` the resulting value.
 */
var instructions = [
  ['#', 'hash'],                        // Extract from the back.
  ['?', 'query'],                       // Extract from the back.
  ['//', 'protocol', 2, 1, 1],          // Extract from the front.
  ['/', 'pathname'],                    // Extract from the back.
  ['@', 'auth', 1],                     // Extract from the front.
  [NaN, 'host', undefined, 1, 1],       // Set left over value.
  [/\:(\d+)$/, 'port'],                 // RegExp the back.
  [NaN, 'hostname', undefined, 1, 1]    // Set left over.
];

/**
 * The actual URL instance. Instead of returning an object we've opted-in to
 * create an actual constructor as it's much more memory efficient and
 * faster and it pleases my CDO.
 *
 * @constructor
 * @param {String} address URL we want to parse.
 * @param {Boolean|function} parser Parser for the query string.
 * @param {Object} location Location defaults for relative paths.
 * @api public
 */
function URL(address, location, parser) {
  if (!(this instanceof URL)) {
    return new URL(address, location, parser);
  }

  var relative = relativere.test(address)
    , parse, instruction, index, key
    , type = typeof location
    , url = this
    , i = 0;

  //
  // The following if statements allows this module two have compatibility with
  // 2 different API:
  //
  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
  //    where the boolean indicates that the query string should also be parsed.
  //
  // 2. The `URL` interface of the browser which accepts a URL, object as
  //    arguments. The supplied object will be used as default values / fall-back
  //    for relative paths.
  //
  if ('object' !== type && 'string' !== type) {
    parser = location;
    location = null;
  }

  if (parser && 'function' !== typeof parser) {
    parser = qs.parse;
  }

  location = lolcation(location);

  for (; i < instructions.length; i++) {
    instruction = instructions[i];
    parse = instruction[0];
    key = instruction[1];

    if (parse !== parse) {
      url[key] = address;
    } else if ('string' === typeof parse) {
      if (~(index = address.indexOf(parse))) {
        if ('number' === typeof instruction[2]) {
          url[key] = address.slice(0, index);
          address = address.slice(index + instruction[2]);
        } else {
          url[key] = address.slice(index);
          address = address.slice(0, index);
        }
      }
    } else if (index = parse.exec(address)) {
      url[key] = index[1];
      address = address.slice(0, address.length - index[0].length);
    }

    url[key] = url[key] || (instruction[3] || ('port' === key && relative) ? location[key] || '' : '');

    //
    // Hostname, host and protocol should be lowercased so they can be used to
    // create a proper `origin`.
    //
    if (instruction[4]) {
      url[key] = url[key].toLowerCase();
    }
  }

  //
  // Also parse the supplied query string in to an object. If we're supplied
  // with a custom parser as function use that instead of the default build-in
  // parser.
  //
  if (parser) url.query = parser(url.query);

  //
  // We should not add port numbers if they are already the default port number
  // for a given protocol. As the host also contains the port number we're going
  // override it with the hostname which contains no port number.
  //
  if (!required(url.port, url.protocol)) {
    url.host = url.hostname;
    url.port = '';
  }

  //
  // Parse down the `auth` for the username and password.
  //
  url.username = url.password = '';
  if (url.auth) {
    instruction = url.auth.split(':');
    url.username = instruction[0] || '';
    url.password = instruction[1] || '';
  }

  //
  // The href is just the compiled result.
  //
  url.href = url.toString();
}

/**
 * This is convenience method for changing properties in the URL instance to
 * insure that they all propagate correctly.
 *
 * @param {String} prop Property we need to adjust.
 * @param {Mixed} value The newly assigned value.
 * @returns {URL}
 * @api public
 */
URL.prototype.set = function set(part, value, fn) {
  var url = this;

  if ('query' === part) {
    if ('string' === typeof value && value.length) {
      value = (fn || qs.parse)(value);
    }

    url[part] = value;
  } else if ('port' === part) {
    url[part] = value;

    if (!required(value, url.protocol)) {
      url.host = url.hostname;
      url[part] = '';
    } else if (value) {
      url.host = url.hostname +':'+ value;
    }
  } else if ('hostname' === part) {
    url[part] = value;

    if (url.port) value += ':'+ url.port;
    url.host = value;
  } else if ('host' === part) {
    url[part] = value;

    if (/\:\d+/.test(value)) {
      value = value.split(':');
      url.hostname = value[0];
      url.port = value[1];
    }
  } else {
    url[part] = value;
  }

  url.href = url.toString();
  return url;
};

/**
 * Transform the properties back in to a valid and full URL string.
 *
 * @param {Function} stringify Optional query stringify function.
 * @returns {String}
 * @api public
 */
URL.prototype.toString = function toString(stringify) {
  if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;

  var query
    , url = this
    , result = url.protocol +'//';

  if (url.username) {
    result += url.username;
    if (url.password) result += ':'+ url.password;
    result += '@';
  }

  result += url.hostname;
  if (url.port) result += ':'+ url.port;

  result += url.pathname;

  query = 'object' === typeof url.query ? stringify(url.query) : url.query;
  if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;

  if (url.hash) result += url.hash;

  return result;
};

//
// Expose the URL parser and some additional properties that might be useful for
// others.
//
URL.qs = qs;
URL.location = lolcation;
module.exports = URL;

},{"./lolcation":90,"querystringify":91,"requires-port":92}],90:[function(require,module,exports){
(function (global){
'use strict';

/**
 * These properties should not be copied or inherited from. This is only needed
 * for all non blob URL's as the a blob URL does not include a hash, only the
 * origin.
 *
 * @type {Object}
 * @private
 */
var ignore = { hash: 1, query: 1 }
  , URL;

/**
 * The location object differs when your code is loaded through a normal page,
 * Worker or through a worker using a blob. And with the blobble begins the
 * trouble as the location object will contain the URL of the blob, not the
 * location of the page where our code is loaded in. The actual origin is
 * encoded in the `pathname` so we can thankfully generate a good "default"
 * location from it so we can generate proper relative URL's again.
 *
 * @param {Object} loc Optional default location object.
 * @returns {Object} lolcation object.
 * @api public
 */
module.exports = function lolcation(loc) {
  loc = loc || global.location || {};
  URL = URL || require('./');

  var finaldestination = {}
    , type = typeof loc
    , key;

  if ('blob:' === loc.protocol) {
    finaldestination = new URL(unescape(loc.pathname), {});
  } else if ('string' === type) {
    finaldestination = new URL(loc, {});
    for (key in ignore) delete finaldestination[key];
  } else if ('object' === type) for (key in loc) {
    if (key in ignore) continue;
    finaldestination[key] = loc[key];
  }

  return finaldestination;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./":89}],91:[function(require,module,exports){
'use strict';

var has = Object.prototype.hasOwnProperty;

/**
 * Simple query string parser.
 *
 * @param {String} query The query string that needs to be parsed.
 * @returns {Object}
 * @api public
 */
function querystring(query) {
  var parser = /([^=?&]+)=([^&]*)/g
    , result = {}
    , part;

  //
  // Little nifty parsing hack, leverage the fact that RegExp.exec increments
  // the lastIndex property so we can continue executing this loop until we've
  // parsed all results.
  //
  for (;
    part = parser.exec(query);
    result[decodeURIComponent(part[1])] = decodeURIComponent(part[2])
  );

  return result;
}

/**
 * Transform a query string to an object.
 *
 * @param {Object} obj Object that should be transformed.
 * @param {String} prefix Optional prefix.
 * @returns {String}
 * @api public
 */
function querystringify(obj, prefix) {
  prefix = prefix || '';

  var pairs = [];

  //
  // Optionally prefix with a '?' if needed
  //
  if ('string' !== typeof prefix) prefix = '?';

  for (var key in obj) {
    if (has.call(obj, key)) {
      pairs.push(encodeURIComponent(key) +'='+ encodeURIComponent(obj[key]));
    }
  }

  return pairs.length ? prefix + pairs.join('&') : '';
}

//
// Expose the module.
//
exports.stringify = querystringify;
exports.parse = querystring;

},{}],92:[function(require,module,exports){
'use strict';

/**
 * Check if we're required to add a port number.
 *
 * @see https://url.spec.whatwg.org/#default-port
 * @param {Number|String} port Port number we need to check
 * @param {String} protocol Protocol we need to check against.
 * @returns {Boolean} Is it a default port for the given protocol
 * @api private
 */
module.exports = function required(port, protocol) {
  protocol = protocol.split(':')[0];
  port = +port;

  if (!port) return false;

  switch (protocol) {
    case 'http':
    case 'ws':
    return port !== 80;

    case 'https':
    case 'wss':
    return port !== 443;

    case 'ftp':
    return port !== 22;

    case 'gopher':
    return port !== 70;

    case 'file':
    return false;
  }

  return port !== 0;
};

},{}],93:[function(require,module,exports){
require('./index-client');
require('./lib/client/transport/Sockjs');
},{"./index-client":17,"./lib/client/transport/Sockjs":27}],94:[function(require,module,exports){
require('jii/deps');
require('jii-comet/sockjs');
require('jii-comet/neat');
require('jii-ar-sql');

var app = Jii.namespace('app');

require('../models/DemoRow');

$(function () {

    Jii.createWebApplication(Jii.mergeConfigs({
        application: {
            basePath: '/',
            components: {
                /**
                 * @name Jii.app.comet
                 * @type {Jii.comet.client.Client}
                 */
                comet: {
                    className: 'Jii.comet.client.Client',
                    serverUrl: 'http://127.0.0.1:3100/stat/node-comet/0/'
                },

                /**
                 * @name Jii.app.neat
                 * @type {Jii.comet.client.NeatClient}
                 */
                neat: {
                    className: 'Jii.comet.client.NeatClient',
                    engine: {
                        className: 'NeatComet.NeatCometClient'
                    }
                },

                /**
                 * @name Jii.app.db
                 * @type {Jii.sql.remote.Connection}
                 */
                db: {
                    className: 'Jii.sql.remote.Connection',
                    schema: {
                        className: 'Jii.sql.remote.Schema'
                    }
                }
            }
        }
    }, window.JII_CONFIG)).start();

    var profile = Jii.app.neat.openProfile('test', {
        category: 'n',
        filter: 'nn'
    });

    profile.getCollection('all').on(Jii.base.Collection.EVENT_CHANGE, function (event) {
        Jii._.each(event.added, function (model) {
            $('' +
                '<tr data-id="' + model.get('id') + '">' +
                '<td>' + model.get('id') + '</td>' +
                '<td><input class="form-control" value="' + model.get('subject') + '" /></td>' +
                '<td>' + model.get('kind') + '</td>' +
                '<td>' + model.get('category') + '</td>' +
                '<td><a href="#" class="btn-remove">x</a></td>' +
                '</tr>'
            )
                .appendTo($('#demo-rows tbody'))
                .on('change', 'input', function (e) {
                    e.preventDefault();
                    model.set('subject', $(this).val());
                    model.save();
                })
                .on('click', 'a.btn-remove', function (e) {
                    e.preventDefault();
                    model.delete();
                });
        });
        Jii._.each(event.removed, function (model) {
            $('#demo-rows tbody').find('[data-id=' + model.get('id') + ']').remove();
        });
    });

    var form = $('#demo-form');

    var randValues = function () {
        form.find('[name=subject]').val(Jii._.random(1, 100));
        form.find('[name=category]').val(Jii._.random(1, 9));
        form.find('[name=kind]').val(Jii._.random(1, 9));
    }
    randValues();

    form.on('submit', function (e) {
        e.preventDefault();

        new app.models.DemoRow({
            subject: form.find('[name=subject]').val(),
            category: form.find('[name=category]').val(),
            kind: form.find('[name=kind]').val()
        }).save();

        randValues();
    });

});
},{"../models/DemoRow":95,"jii-ar-sql":9,"jii-comet/neat":29,"jii-comet/sockjs":93,"jii/deps":123}],95:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class app.models.DemoRow
 * @extends Jii.sql.ActiveRecord
 */
Jii.defineClass('app.models.DemoRow', /** @lends app.models.DemoRow.prototype */{

	__extends: Jii.sql.ActiveRecord,

	__static: /** @lends Jii.comet.server.HubServer */{

        tableName: function () {
            return 'ep_comet_sample_demo_rows';
        }

	},

    rules: function() {
        return [
            [['subject'], 'string', {max: 255}],
            [['category', 'kind'], 'string', {max: 1}]
        ];
    }

});

},{"jii":124}],96:[function(require,module,exports){

'use strict';

require('jii');

// Load framework files
require('./lib/base/ActiveRecord');
require('./lib/base/Collection');
require('./lib/base/DataProvider');
require('./lib/base/Model');
require('./lib/base/ModelAttributeSchema');
require('./lib/base/ModelSchema');
require('./lib/model/ArrayDataProvider');
require('./lib/model/ChangeAttributeEvent');
require('./lib/model/ChangeEvent');
require('./lib/model/CollectionEvent');
require('./lib/model/LinkModelEvent');
require('./lib/validators/BooleanValidator');
require('./lib/validators/CompareValidator');
require('./lib/validators/DateValidator');
require('./lib/validators/DefaultValueValidator');
require('./lib/validators/EmailValidator');
require('./lib/validators/FilterValidator');
require('./lib/validators/InlineValidator');
require('./lib/validators/NumberValidator');
require('./lib/validators/RangeValidator');
require('./lib/validators/RegularExpressionValidator');
require('./lib/validators/RequiredValidator');
require('./lib/validators/SafeValidator');
require('./lib/validators/StringValidator');
require('./lib/validators/UrlValidator');
require('./lib/validators/Validator');
},{"./lib/base/ActiveRecord":97,"./lib/base/Collection":98,"./lib/base/DataProvider":99,"./lib/base/Model":100,"./lib/base/ModelAttributeSchema":101,"./lib/base/ModelSchema":102,"./lib/model/ArrayDataProvider":103,"./lib/model/ChangeAttributeEvent":104,"./lib/model/ChangeEvent":105,"./lib/model/CollectionEvent":106,"./lib/model/LinkModelEvent":107,"./lib/validators/BooleanValidator":108,"./lib/validators/CompareValidator":109,"./lib/validators/DateValidator":110,"./lib/validators/DefaultValueValidator":111,"./lib/validators/EmailValidator":112,"./lib/validators/FilterValidator":113,"./lib/validators/InlineValidator":114,"./lib/validators/NumberValidator":115,"./lib/validators/RangeValidator":116,"./lib/validators/RegularExpressionValidator":117,"./lib/validators/RequiredValidator":118,"./lib/validators/SafeValidator":119,"./lib/validators/StringValidator":120,"./lib/validators/UrlValidator":121,"./lib/validators/Validator":122,"jii":124}],97:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Model');

/**
 * @abstract
 * @class Jii.base.ActiveRecord
 * @extends Jii.base.Model
 */
Jii.defineClass('Jii.base.ActiveRecord', /** @lends Jii.base.ActiveRecord.prototype */{

	__extends: Jii.base.Model,
	
	__static: /** @lends Jii.base.ActiveRecord */{

        /**
         * @event Jii.base.ActiveRecord#init
         * @property {Jii.base.Event} event an event that is triggered when the record is initialized via [[init()]].
         */
		EVENT_INIT: 'init',

        /**
         * @event Jii.base.ActiveRecord#afterFind
         * @property {Jii.base.Event} event an event that is triggered after the record is created and populated with query result.
         */
		EVENT_AFTER_FIND: 'afterFind',

        /**
         * You may set [[Jii.base.ModelEvent.isValid]] to be false to stop the insertion.
         * @event Jii.base.ActiveRecord#beforeInsert
         * @property {Jii.base.ModelEvent} event an event that is triggered before inserting a record.
         */
		EVENT_BEFORE_INSERT: 'beforeInsert',

        /**
         * Event an event that is triggered after a record is inserted.
         * @event Jii.base.ActiveRecord#afterInsert
         * @property {Jii.sql.AfterSaveEvent} event
         */
		EVENT_AFTER_INSERT: 'afterInsert',

        /**
         * You may set [[ModelEvent.isValid]] to be false to stop the update.
         * @event Jii.base.ActiveRecord#beforeUpdate
         * @property {Jii.base.ModelEvent} event an event that is triggered before updating a record.
         */
		EVENT_BEFORE_UPDATE: 'beforeUpdate',

        /**
         * @event Jii.base.ActiveRecord#afterUpdate
         * @property {Jii.sql.AfterSaveEvent} event an event that is triggered after a record is updated.
         */
		EVENT_AFTER_UPDATE: 'afterUpdate',

		/**
         * You may set [[ModelEvent.isValid]] to be false to stop the deletion.
         * @event Jii.base.ActiveRecord#beforeDelete
		 * @property {Jii.base.ModelEvent} event an event that is triggered before deleting a record.
		 */
		EVENT_BEFORE_DELETE: 'beforeDelete',

		/**
         * @event Jii.base.ActiveRecord#afterDelete
		 * @property {Jii.base.Event} event an event that is triggered after a record is deleted.
		 */
		EVENT_AFTER_DELETE: 'afterDelete',

        /**
         * @event Jii.base.ActiveRecord#link
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_LINK: 'link',

        /**
         * @event Jii.base.ActiveRecord#link:
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_LINK_NAME: 'link:',

        /**
         * @event Jii.base.ActiveRecord#unlink
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_UNLINK: 'unlink',

        /**
         * @event Jii.base.ActiveRecord#unlink:
         * @property {Jii.model.LinkModelEvent} event
         */
		EVENT_UNLINK_NAME: 'unlink:',

        _modelSchema: null,

        /**
         * @returns {{}}
         */
        modelSchema: function() {
            return {};
        },

        /**
         * @returns {Jii.sql.TableSchema}
         */
        getTableSchema: function() {
            if (this._modelSchema === null) {
                this._modelSchema = this.modelSchema();

                if (!(this._modelSchema instanceof Jii.base.ModelSchema)) {
                    this._modelSchema = Jii.base.ModelSchema.createFromObject(this._modelSchema);
                }
            }
            return this._modelSchema;
        },

        tableName: function() {
            return null;
        },

		/**
		 * @inheritdoc
		 * @returns {Jii.base.ActiveRecord} ActiveRecord instance matching the condition, or `null` if nothing matches.
		 */
		findOne: function (condition) {
			return this._findByCondition(condition, true);
		},

		/**
		 * @inheritdoc
		 * @returns {Jii.base.ActiveRecord[]} an array of ActiveRecord instances, or an empty array if nothing matches.
		 */
		findAll: function (condition) {
			return this._findByCondition(condition, false);
		},

        /**
         * @inheritdoc
         */
        find: function () {
            // @todo
            return new Jii.sql.ActiveQuery(this);
        },

        /**
         * Returns the primary key name(s) for this AR class.
         * The default implementation will return the primary key(s) as declared
         * in the DB table that is associated with this AR class.
         *
         * If the DB table does not declare any primary key, you should override
         * this method to return the attributes that you want to use as primary keys
         * for this AR class.
         *
         * Note that an array should be returned even for a table with single primary key.
         *
         * @returns {string[]} the primary keys of the associated database table.
         */
        primaryKey: function () {
            return this.getTableSchema().primaryKey;
        },

		/**
		 * Finds ActiveRecord instance(s) by the given condition.
		 * This method is internally called by [[findOne()]] and [[findAll()]].
		 * @param {*} condition please refer to [[findOne()]] for the explanation of this parameter
		 * @param {boolean} one whether this method is called by [[findOne()]] or [[findAll()]]
		 * @returns {Jii.base.ActiveRecord|Jii.base.ActiveRecord[]}
		 * @throws {Jii.exceptions.InvalidConfigException} if there is no primary key defined
		 * @internal
		 */
		_findByCondition: function (condition, one) {
			var query = this.find();

			return Promise.resolve().then(function() {
				if (Jii._.isArray(condition) || Jii._.isObject(condition)) {
					return Promise.resolve(condition);
				}

				var primaryKey = this.primaryKey();

				// query by primary key
				if (primaryKey.length > 0) {
					var pk = primaryKey[0];
					if (!Jii._.isEmpty(query.getJoin()) || !Jii._.isEmpty(query.getJoinWith())) {
						pk = this.tableName() + '.' + pk;
					}

					var conditionObject = {};
					conditionObject[pk] = condition;
					return conditionObject;
				}

				throw new Jii.exceptions.InvalidConfigException(this.className() + ' must have a primary key.');
			}.bind(this)).then(function(condition) {
				query.andWhere(condition);

				return one ? query.one() : query.all();
			}.bind(this));
		},

		/**
		 * Updates the whole table using the provided attribute values and conditions.
		 * For example, to change the status to be 1 for all customers whose status is 2:
		 *
		 * ~~~
		 * Customer.updateAll({status: 1}, 'status = 2');
		 * ~~~
		 *
		 * @param {object} attributes attribute values (name-value pairs) to be saved into the table
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @returns {Promise.<number>} the number of rows updated
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		updateAll: function (attributes, condition) {
			condition = condition || '';

			throw new Jii.exceptions.NotSupportedException('updateAll() is not supported.');
		},

		/**
		 * Updates the whole table using the provided counter changes and conditions.
		 * For example, to increment all customers' age by 1,
		 *
		 * ~~~
		 * Customer.updateAllCounters({age: 1});
		 * ~~~
		 *
		 * @param {[]} counters the counters to be updated (attribute name => increment value).
		 * Use negative values if you want to decrement the counters.
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the UPDATE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @returns {number} the number of rows updated
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		updateAllCounters: function (counters, condition) {
			condition = condition || '';

			throw new Jii.exceptions.NotSupportedException('updateAllCounters() is not supported.');
		},

		/**
		 * Deletes rows in the table using the provided conditions.
		 * WARNING: If you do not specify any condition, this method will delete ALL rows in the table.
		 *
		 * For example, to delete all customers whose status is 3:
		 *
		 * ~~~
		 * Customer.deleteAll('status = 3');
		 * ~~~
		 *
		 * @param {string|[]} [condition] the conditions that will be put in the WHERE part of the DELETE SQL.
		 * Please refer to [[Query.where()]] on how to specify this parameter.
		 * @param {[]} [params] the parameters (name => value) to be bound to the query.
		 * @returns {number} the number of rows deleted
		 * @throws {Jii.exceptions.NotSupportedException} if not overrided
		 */
		deleteAll: function (condition, params) {
			condition = condition || '';
			params = params || [];

			throw new Jii.exceptions.NotSupportedException('deleteAll() is not supported.');
		},

		/**
		 * Populates an active record object using a row of data from the database/storage.
		 *
		 * This is an internal method meant to be called to create active record objects after
		 * fetching data from the database. It is mainly used by [[ActiveQuery]] to populate
		 * the query results into active records.
		 *
		 * When calling this method manually you should call [[afterFind()]] on the created
		 * record to trigger the [[EVENT_AFTER_FIND|afterFind Event]].
		 *
		 * @param {Jii.base.ActiveRecord} record the record to be populated. In most cases this will be an instance
		 * created by [[instantiate()]] beforehand.
		 * @param {object} row attribute values (name => value)
		 */
		populateRecord: function (record, row) {
			var columns = record.attributes();

			Jii._.each(row, Jii._.bind(function(value, name) {
				if (Jii._.indexOf(columns, name) !== -1) {
					record._attributes[name] = value;
				} else if (record.canSetProperty(name)) {
					record.set(name, value);
				}
			}, this));
			record.setOldAttributes(Jii._.clone(record._attributes));
		},

		/**
		 * Creates an active record instance.
		 *
		 * This method is called together with [[populateRecord()]] by [[ActiveQuery]].
		 * It is not meant to be used for creating new records() directly.
		 *
		 * You may override this method if the instance being created
		 * depends on the row data to be populated into the record.
		 * For example, by creating a record based on the value of a column,
		 * you may implement the so-called single-table inheritance mapping.
		 * @param {object} row row data to be populated into the record.
		 * @returns {Jii.base.ActiveRecord} the newly created active record
		 */
		instantiate: function (row) {
			return new this();
		},

		/**
		 * Returns a value indicating whether the given set of attributes represents the primary key for this model
		 * @param {[]} keys the set of attributes to check
		 * @returns {boolean} whether the given set of attributes represents the primary key for this model
		 */
		isPrimaryKey: function (keys) {
			var pks = this.primaryKey();

			if (keys.length !== Jii._.size(pks)) {
				return false;
			}
            return (!Jii._.isArray(pks) ? Jii._.keys(pks) : pks).sort().toString() === keys.sort().toString();
		}

	},

	/**
	 * @type {object} related models indexed by the relation names
	 */
	_related: {},

	/**
	 * @type {object}
	 */
	_relatedLazyEvents: {},

	/**
	 * @type {object|null} old attribute values indexed by attribute names.
	 * This is `null` if the record [[isNewRecord|is new]].
	 */
	_oldAttributes: null,

	/**
	 * Initializes the object.
	 * This method is called at the end of the constructor.
	 * The default implementation will trigger an [[EVENT_INIT]] event.
	 * If you override this method, make sure you call the parent implementation at the end
	 * to ensure triggering of the event.
	 */
	init: function () {
		this.trigger(this.__static.EVENT_INIT);

		this.__super();
	},

	/**
	 * Declares a `has-one` relation.
	 * The declaration is returned in terms of a relational [[ActiveQuery]] instance
	 * through which the related record can be queried and retrieved back.
	 *
	 * A `has-one` relation means that there is at most one related record matching
	 * the criteria set by this relation, e.g., a customer has one country.
	 *
	 * For example, to declare the `country` relation for `Customer` class, we can write
	 * the following code in the `Customer` class:
	 *
	 * ~~~
	 * public function getCountry()
	 * {
     *     return this.hasOne(Country.className(), {id: 'country_id'});
     * }
	 * ~~~
	 *
	 * Note that in the above, the 'id' key in the `link` parameter refers to an attribute name
	 * in the related class `Country`, while the 'country_id' value refers to an attribute name
	 * in the current AR class.
	 *
	 * Call methods declared in [[ActiveQuery]] to further customize the relation.
	 *
	 * @param {string} className the class name of the related record
	 * @param {object} link the primary-foreign key constraint. The keys of the array refer to
	 * the attributes of the record associated with the `class` model, while the values of the
	 * array refer to the corresponding attributes in **this** AR class.
	 * @returns {Jii.sql.ActiveQuery} the relational query object.
	 */
	hasOne: function (className, link) {
		/** @typedef {Jii.sql.ActiveRecord} classObject */
		var classObject = Jii.namespace(className);

		/** @typedef {Jii.data.ActiveQuery} query */
		var query = classObject.find();
		query.primaryModel = this;
		query.link = link;
		query.multiple = false;
		return query;
	},

	/**
	 * Declares a `has-many` relation.
	 * The declaration is returned in terms of a relational [[ActiveQuery]] instance
	 * through which the related record can be queried and retrieved back.
	 *
	 * A `has-many` relation means that there are multiple related records matching
	 * the criteria set by this relation, e.g., a customer has many orders.
	 *
	 * For example, to declare the `orders` relation for `Customer` class, we can write
	 * the following code in the `Customer` class:
	 *
	 * ~~~
	 * public function getOrders()
	 * {
		 *     return this.hasMany(Order.className(), {customer_id: 'id'});
		 * }
	 * ~~~
	 *
	 * Note that in the above, the 'customer_id' key in the `link` parameter refers to
	 * an attribute name in the related class `Order`, while the 'id' value refers to
	 * an attribute name in the current AR class.
	 *
	 * Call methods declared in [[ActiveQuery]] to further customize the relation.
	 *
	 * @param {string} className the class name of the related record
	 * @param {object} link the primary-foreign key constraint. The keys of the array refer to
	 * the attributes of the record associated with the `class` model, while the values of the
	 * array refer to the corresponding attributes in **this** AR class.
	 * @returns {Jii.sql.ActiveQuery} the relational query object.
	 */
	hasMany: function (className, link) {
		/** @type {class} ActiveRecordInterface */
		var classObject = Jii.namespace(className);

		/** @type {Jii.sql.ActiveQuery} */
		var query = classObject.find();
		query.primaryModel = this;
		query.link = link;
		query.multiple = true;
		return query;
	},

	load: function(name) {
		if (this._related[name]) {
			return Promise.resolve(this._related[name]);
		}

		var relation = this.getRelation(name);
		if (relation instanceof Jii.sql.ActiveQuery) {
			return relation.findFor(name, this).then(function(models) {
                this._setRelated(name, relation.multiple ? new Jii.base.Collection(models, {modelClass: relation.modelClass}) : models);
				return this._related[name];
			}.bind(this));
		}

		return relation;
	},

	/**
	 * Populates the named relation with the related records.
	 * Note that this method does not check if the relation exists or not.
	 * @param {string} name the relation name (case-sensitive)
	 * @param {Jii.base.ActiveRecord|Jii.base.ActiveRecord[]|null} records the related records to be populated into the relation.
	 */
	populateRelation: function (name, records) {
        this._setRelated(name, Jii._.isArray(records) ? new Jii.base.Collection(records) : records);
	},

	/**
	 * Check whether the named relation has been populated with records.
	 * @param {string} name the relation name (case-sensitive)
	 * @returns {boolean} whether relation has been populated with records.
	 */
	isRelationPopulated: function (name) {
		return Jii._.has(this._related, name);
	},

	/**
	 * Returns all populated related records.
	 * @returns {object} an array of related records indexed by relation names.
	 */
	getRelatedRecords: function () {
		return this._related;
	},

    /**
     * Get attribute value
     * @param {String} name
     * @returns {*}
     */
    get: function (name) {
        if (this.hasRelation(name)) {
            var relation = this.getRelation(name);
            if (!this._related[name] && relation.multiple) {
                this._setRelated(name, new Jii.base.Collection([], {modelClass: relation.modelClass}));
            }
            return this._related[name] || null;
        }

        return this.__super(name);
    },

    /**
     * Set attribute value
     * @param {object|string} name
     * @param {*} [value]
     */
    set: function (name, value) {
        if (this.hasRelation(name)) {
            if (this._related[name]) {
                this._related[name].set(value);
            } else {
                var relation = this.getRelation(name);
                if (relation.multiple) {
                    var models = !Jii._.isArray(value) ? [value] : value;
                    this._setRelated(name, new Jii.base.Collection(models, {
                        modelClass: relation.modelClass
                    }));
                } else {
                    var _class = relation.modelClass;

                    /** @typedef {Jii.sql.ActiveRecord} model */
                    var model = _class.instantiate(value);
                    _class.populateRecord(model, value);
                    this._setRelated(name, model);
                }
            }
            return;
        }

        this.__super(name, value);
    },

    /**
     * @param {string|string[]} name
     * @param {function} handler
     * @param {*} [data]
     * @param {boolean} [isAppend]
     */
    on: function(name, handler, data, isAppend) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, this.__static.EVENT_CHANGE_NAME);
        if (collectionFormat) {
            var collEventName = collectionFormat.subName || this.__static.EVENT_CHANGE;
            collectionFormat.model.on(collEventName, handler, data, isAppend);
            return;
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name, this.__static.EVENT_CHANGE_NAME);
        if (modelFormat) {
            if (modelFormat.model) {
                modelFormat.model.on(modelFormat.subName, handler, data, isAppend);
            } else {
                // Lazy subscribe
                this._relatedLazyEvents[modelFormat.name] = this._relatedLazyEvents[modelFormat.name] || [];
                this._relatedLazyEvents[modelFormat.name].push([modelFormat.subName, handler, data, isAppend]);
            }
            return;
        }

        // Relation support
        var relationFormat = this._detectKeyFormatRelation(name, this.__static.EVENT_CHANGE_NAME);
        if (relationFormat) {
            var relationEvent = relationFormat.multiple ? Jii.base.Collection.EVENT_CHANGE : this.__static.EVENT_CHANGE;
            if (relationFormat.model) {
                relationFormat.model.on(relationEvent, handler, data, isAppend);
            } else {
                // Lazy subscribe
                this._relatedLazyEvents[relationFormat.name] = this._relatedLazyEvents[relationFormat.name] || [];
                this._relatedLazyEvents[relationFormat.name].push([relationEvent, handler, data, isAppend]);
            }
        }

        this.__super(name, handler, data, isAppend);
    },

    /**
     * @param {string|string[]} name
     * @param {function} [handler]
     * @return boolean
     */
    off: function(name, handler) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, this.__static.EVENT_CHANGE_NAME);
        if (collectionFormat) {
            var collEventName = collectionFormat.subName || this.__static.EVENT_CHANGE;
            return collectionFormat.model.off(collEventName, handler);
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name, this.__static.EVENT_CHANGE_NAME);
        if (modelFormat) {
            if (modelFormat.model) {
                return modelFormat.model.off(modelFormat.subName, handler);
            } else {
                // Lazy unsubscribe
                if (this._relatedLazyEvents[modelFormat.name]) {
                    this._relatedLazyEvents[modelFormat.name] = Jii._.filter(this._relatedLazyEvents[modelFormat.name], function(arr) {
                        return arr[0] !== modelFormat.subName || arr[1] !== handler;
                    });
                }
            }
        }

        // Relation support
        var relationFormat = this._detectKeyFormatRelation(name, this.__static.EVENT_CHANGE_NAME);
        if (relationFormat) {
            var relationEvent = relationFormat.multiple ? Jii.base.Collection.EVENT_CHANGE : this.__static.EVENT_CHANGE;
            if (relationFormat.model) {
                return relationFormat.model.off(relationEvent, handler);
            } else {
                // Lazy unsubscribe
                if (this._relatedLazyEvents[relationFormat.name]) {
                    this._relatedLazyEvents[relationFormat.name] = Jii._.filter(this._relatedLazyEvents[relationFormat.name], function(arr) {
                        return arr[0] !== relationEvent || arr[1] !== handler;
                    });
                }
            }
        }

        return this.__super(name, handler);
    },

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @returns {{model: Jii.base.ActiveRecord|null, name: string}|null}
     * @protected
     */
    _detectKeyFormatRelation: function(name, prefix) {
        prefix = prefix || '';

        if (prefix && name.indexOf(prefix) !== 0) {
            return null;
        }
        name = name.substr(prefix.length);

        if (!this.hasRelation(name)) {
            return null;
        }

        var multiple = null;
        if (this._related[name]) {
            multiple = this._related[name] instanceof Jii.base.Collection;
        }
        if (multiple === null) {
            multiple = this.getRelation(name).multiple;
        }

        return {
            model: this.get(name),
            name: name,
            multiple: multiple
        };
    },

    /**
     *
     * @param {string} name
     * @param value
     * @protected
     */
    _setRelated: function(name, value) {
        this._related[name] = value;

        // Attach lazy events
        Jii._.each(this._relatedLazyEvents[name] || {}, function(args) {
            this._related[name].on.apply(this._related[name], args);
        }.bind(this));
        this.trigger(this.__static.EVENT_LINK, new Jii.model.LinkModelEvent({
            relationName: name
        }));
        this.trigger(this.__static.EVENT_LINK_NAME + name, new Jii.model.LinkModelEvent({
            relationName: name
        }));
    },

    /**
     *
     * @param {string} name
     * @protected
     */
    _removeRelated: function(name) {
        delete this._related[name];

        this.trigger(this.__static.EVENT_UNLINK, new Jii.model.LinkModelEvent({
            relationName: name
        }));
        this.trigger(this.__static.EVENT_UNLINK_NAME + name, new Jii.model.LinkModelEvent({
            relationName: name
        }));
    },

	/**
	 *
	 * @param {string} name
	 * @returns {boolean}
	 */
	hasAttribute: function (name) {
		return Jii._.has(this._attributes, name) || Jii._.indexOf(this.attributes(), name) !== -1;
	},

	/**
	 * Returns the old attribute values.
	 * @returns {object} the old attribute values (name-value pairs)
	 */
	getOldAttributes: function () {
		return this._oldAttributes || {};
	},

	/**
	 * Sets the old attribute values.
	 * All existing old attribute values will be discarded.
	 * @param {{}|null} values old attribute values to be set.
	 * If set to `null` this record is considered to be [[isNewRecord|new]].
	 */
	setOldAttributes: function (values) {
		this._oldAttributes = values;
	},

	/**
	 * Returns the old value of the named attribute.
	 * If this record is the result of a query and the attribute is not loaded,
	 * null will be returned.
	 * @param {string} name the attribute name
	 * @returns {*} the old attribute value. Null if the attribute is not loaded before
	 * or does not exist.
	 * @see hasAttribute()
	 */
	getOldAttribute: function (name) {
		return Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
	},

	/**
	 * Sets the old value of the named attribute.
	 * @param {string} name the attribute name
	 * @param {*} value the old attribute value.
	 * @throws {Jii.exceptions.InvalidParamException} if the named attribute does not exist.
	 * @see hasAttribute()
	 */
	setOldAttribute: function (name, value) {
		if (Jii._.has(this._oldAttributes, name) || this.hasAttribute(name)) {
			if (this._oldAttributes === null) {
				this._oldAttributes = {};
			}
			this._oldAttributes[name] = value;
		}

		throw new Jii.exceptions.InvalidParamException(this.className() + ' has no attribute named "' + name + '".');
	},

	/**
	 * Marks an attribute dirty.
	 * This method may be called to force updating a record when calling [[update()]],
	 * even if there is no change being made to the record.
	 * @param {string} name the attribute name
	 */
	markAttributeDirty: function (name) {
		delete this._oldAttributes[name];
	},

	/**
	 * Returns a value indicating whether the named attribute has been changed.
	 * @param {string} name the name of the attribute
	 * @returns {boolean} whether the attribute has been changed
	 */
	isAttributeChanged: function (name) {
		if (Jii._.has(this._attributes, name) && this._oldAttributes && Jii._.has(this._oldAttributes, name)) {
			return !Jii._.isEqual(this._attributes[name], this._oldAttributes[name]);
		}

		return Jii._.has(this._attributes, name) || (this._oldAttributes && Jii._.has(this._oldAttributes, name));
	},

	/**
	 * Returns the attribute values that have been modified since they are loaded or saved most recently.
	 * @param {string[]|null} names the names of the attributes whose values may be returned if they are
	 * changed recently. If null, [[attributes()]] will be used.
	 * @returns {object} the changed attribute values (name-value pairs)
	 */
	getDirtyAttributes: function (names) {
		names = names || null;

		if (names === null) {
			names = this.attributes();
		}

		var attributes = {};
		Jii._.each(this._attributes, Jii._.bind(function(value, name) {
			if (Jii._.indexOf(names, name) === -1) {
				return;
			}

			if (this._oldAttributes === null || !Jii._.has(this._oldAttributes, name) || !Jii._.isEqual(this._oldAttributes[name], value)) {
				attributes[name] = value;
			}
		}, this));

		return attributes;
	},


	/**
	 * Returns the list of all attribute names of the model.
	 * The default implementation will return all column names of the table associated with this AR class.
	 * @return {string[]} list of attribute names.
	 */
	attributes: function() {
		return Jii._.keys(this.__static.getTableSchema().columns);
	},

	/**
	 * Saves the current record.
	 *
	 * This method will call [[insert()]] when [[isNewRecord]] is true, or [[update()]]
	 * when [[isNewRecord]] is false.
	 *
	 * For example, to save a customer record:
	 *
	 * ~~~
	 * customer = new Customer();  // or customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.save();
	 * ~~~
	 *
	 *
	 * @param {boolean} [runValidation] whether to perform validation before saving the record.
	 * If the validation fails, the record will not be saved to database.
	 * @param {string[]} [attributeNames] list of attribute names that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {boolean} whether the saving succeeds
	 */
	save: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		if (this.isNewRecord()) {
			return this.insert(runValidation, attributeNames);
		} else {
			return this.update(runValidation, attributeNames).then(function(result) {
				return result !== false;
			});
		}
	},

	/**
	 * Inserts the record into the database using the attribute values of this record.
	 *
	 * Usage example:
	 *
	 * ```php
	 * $customer = new Customer;
	 * $customer->name = $name;
	 * $customer->email = $email;
	 * $customer->insert();
	 * ```
	 *
	 * @param {boolean} runValidation whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {object} attributeNames list of attributes that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @return boolean whether the attributes are valid and the record is inserted successfully.
	 */
	insert: function (runValidation, attributeNames) {

	},

	/**
	 * Saves the changes to this active record into the associated database table.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeValidate()]] when `runValidation` is true. If validation
	 *    fails, it will skip the rest of the steps;
	 * 2. call [[afterValidate()]] when `runValidation` is true.
	 * 3. call [[beforeSave()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 4. save the record into database. If this fails, it will skip the rest of the steps;
	 * 5. call [[afterSave()]];
	 *
	 * In the above step 1, 2, 3 and 5, events [[EVENT_BEFORE_VALIDATE]],
	 * [[EVENT_BEFORE_UPDATE]], [[EVENT_AFTER_UPDATE]] and [[EVENT_AFTER_VALIDATE]]
	 * will be raised by the corresponding methods.
	 *
	 * Only the [[dirtyAttributes|changed attribute values]] will be saved into database.
	 *
	 * For example, to update a customer record:
	 *
	 * ~~~
	 * customer = Customer.findOne(id);
	 * customer.name = name;
	 * customer.email = email;
	 * customer.update();
	 * ~~~
	 *
	 * Note that it is possible the update does not affect any row in the table.
	 * In this case, this method will return 0. For this reason, you should use the following
	 * code to check if update() is successful or not:
	 *
	 * ~~~
	 * if (this.update() !== false) {
     *     // update successful
     * } else {
     *     // update failed
     * }
	 * ~~~
	 *
	 * @param {boolean} [runValidation] whether to perform validation before saving the record.
	 * If the validation fails, the record will not be inserted into the database.
	 * @param {string[]} [attributeNames] list of attribute names that need to be saved. Defaults to null,
	 * meaning all attributes that are loaded from DB will be saved.
	 * @returns {Promise.<number|boolean>} the number of rows affected, or false if validation fails
	 * or [[beforeSave()]] stops the updating process.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being updated is outdated.
	 * @throws \Exception in case update failed.
	 */
	update: function (runValidation, attributeNames) {
		runValidation = runValidation !== false;
		attributeNames = attributeNames || null;

		var validatePromise = runValidation ? this.validate(attributeNames) : Promise.resolve(true);
		return validatePromise.then(Jii._.bind(function(isValid) {
			if (!isValid) {
				return false;
			}

			return this._updateInternal(attributeNames);
		}, this));
	},

	/**
	 * Updates the specified attributes.
	 *
	 * This method is a shortcut to [[update()]] when data validation is not needed
	 * and only a small set attributes need to be updated.
	 *
	 * You may specify the attributes to be updated as name list or name-value pairs.
	 * If the latter, the corresponding attribute values will be modified accordingly.
	 * The method will then save the specified attributes into database.
	 *
	 * Note that this method will **not** perform data validation and will **not** trigger events.
	 *
	 * @param {[]} attributes the attributes (names or name-value pairs) to be updated
	 * @returns {Promise.<number>} the number of rows affected.
	 */
	updateAttributes: function (attributes) {
		var attrs = [];
		Jii._.each(attributes, Jii._.bind(function(value, name) {
			if (Jii._.isNumber(name)) {
				attrs.push(value);
			} else {
				this.set(name, value);
				attrs.push(name);
			}
		}, this));

		var values = this.getDirtyAttributes(attrs);
		if (Jii._.isEmpty(values)) {
			return Promise.resolve(0);
		}

		var oldPrimaryKey = this.getOldPrimaryKey(true);

		return this.__static.updateAll(values, oldPrimaryKey)
			.then(Jii._.bind(function(rows) {
				Jii._.each(values, Jii._.bind(function(value, name) {
					this._oldAttributes[name] = this._attributes[name];
				}, this));

				return rows;
			}, this));
	},

	/**
	 * @see update()
	 * @param {[]} [attributes] attributes to update
	 * @returns {Promise.<number>} number of rows updated
	 * @throws StaleObjectException
	 */
	_updateInternal: function (attributes) {
        attributes = attributes || null;

		var values = null;

		return this.beforeSave(false).then(function(bool) {
            if (!bool) {
                return Promise.resolve(false);
            }

            values = this.getDirtyAttributes(attributes);
            if (Jii._.isEmpty(values)) {
                return this.afterSave(false, values).then(function() {
                    return 0;
                });
            }

            return this.__static.getDb().createCommand().updateModel(this, values);
        }.bind(this)).then(Jii._.bind(function(rows) {

			var changedAttributes = {};
			Jii._.each(values, Jii._.bind(function(value, name) {
				changedAttributes[name] = Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
				this._oldAttributes[name] = value;
			}, this));

			return this.afterSave(false, changedAttributes).then(function() {
				return rows;
			});
		}, this));
	},

	/**
	 * Updates one or several counter columns for the current AR object.
	 * Note that this method differs from [[updateAllCounters()]] in that it only
	 * saves counters for the current AR object.
	 *
	 * An example usage is as follows:
	 *
	 * ~~~
	 * post = Post.findOne(id);
	 * post.updateCounters({view_count: 1});
	 * ~~~
	 *
	 * @param {[]} counters the counters to be updated (attribute name => increment value)
	 * Use negative values if you want to decrement the counters.
	 * @returns {boolean} whether the saving is successful
	 * @see updateAllCounters()
	 */
	updateCounters: function (counters) {
		var oldPrimaryKey = this.getOldPrimaryKey(true);
		return this.__static.updateAllCounters(Jii._.clone(counters), oldPrimaryKey)
			.then(Jii._.bind(function(affectedRows) {
				if (affectedRows === 0) {
					return Promise.resolve(false);
				}

				Jii._.each(counters, function(value, name) {
					this._attributes[name] += value;
					this._oldAttributes[name] = this._attributes[name];
				}.bind(this));
				return Promise.resolve(true);
			}, this));
	},

	/**
	 * Deletes the table row corresponding to this active record.
	 *
	 * This method performs the following steps in order:
	 *
	 * 1. call [[beforeDelete()]]. If the method returns false, it will skip the
	 *    rest of the steps;
	 * 2. delete the record from the database;
	 * 3. call [[afterDelete()]].
	 *
	 * In the above step 1 and 3, events named [[EVENT_BEFORE_DELETE]] and [[EVENT_AFTER_DELETE]]
	 * will be raised by the corresponding methods.
	 *
	 * @returns {number|boolean} the number of rows deleted, or false if the deletion is unsuccessful for some reason.
	 * Note that it is possible the number of rows deleted is 0, even though the deletion execution is successful.
	 * @throws StaleObjectException if [[optimisticLock|optimistic locking]] is enabled and the data
	 * being deleted is outdated.
	 * @throws \Exception in case delete failed.
	 */
	delete: function () {
		return this.beforeDelete().then(Jii._.bind(function(bool) {
			if (!bool) {
				return Promise.resolve(false);
			}

			var condition = this.getOldPrimaryKey(true);

			// we do not check the return value of deleteAll() because it's possible
			// the record is already deleted in the database and thus the method will return 0
			return this.__static.deleteAll(condition);
		}, this)).then(Jii._.bind(function(result) {

			this._oldAttributes = null;

			return this.afterDelete().then(function() {
				return result;
			});
		}, this));
	},

	/**
	 * Returns a value indicating whether the current record is new.
	 * @returns {boolean} whether the record is new and() should be inserted when calling [[save()]].
	 */
	isNewRecord: function () {
		return this._oldAttributes === null;
	},

	/**
	 * Sets the value indicating whether the record is new.
	 * @param {boolean} value whether the record is new and() should be inserted when calling [[save()]].
	 * @see isNewRecord()
	 */
	setIsNewRecord: function (value) {
		this._oldAttributes = value ? null : this._attributes;
	},

	/**
	 * This method is called when the AR object is created and populated with the query result.
	 * The default implementation will trigger an [[EVENT_AFTER_FIND]] event.
	 * When overriding this method, make sure you call the parent implementation to ensure the
	 * event is triggered.
	 */
	afterFind: function () {
		this.trigger(this.__static.EVENT_AFTER_FIND);

		return Promise.resolve();
	},

	/**
	 * This method is called at the beginning of inserting or updating a record.
	 * The default implementation will trigger an [[EVENT_BEFORE_INSERT]] event when `insert` is true,
	 * or an [[EVENT_BEFORE_UPDATE]] event if `insert` is false.
	 * When overriding this method, make sure you call the parent implementation like the following:
	 *
	 * ~~~
	 * public function beforeSave(insert)
	 * {
     *     if (parent.beforeSave(insert)) {
     *         // ...custom code here...
     *         return true;
     *     } else {
     *         return false;
     *     }
     * }
	 * ~~~
	 *
	 * @param {boolean} insert whether this method called while inserting a record.
	 * If false, it means the method is called while updating a record.
	 * @returns {Promise.<boolean>} whether the insertion or updating should continue.
	 * If false, the insertion or updating will be cancelled.
	 */
	beforeSave: function (insert) {
		var event = new Jii.base.ModelEvent();
		this.trigger(insert ? this.__static.EVENT_BEFORE_INSERT : this.__static.EVENT_BEFORE_UPDATE, event);

		return Promise.resolve(event.isValid);
	},

	/**
	 * This method is called at the end of inserting or updating a record.
	 * The default implementation will trigger an [[EVENT_AFTER_INSERT]] event when `insert` is true,
	 * or an [[EVENT_AFTER_UPDATE]] event if `insert` is false. The event class used is [[AfterSaveEvent]].
	 * When overriding this method, make sure you call the parent implementation so that
	 * the event is triggered.
	 * @param {boolean} insert whether this method called while inserting a record.
	 * If false, it means the method is called while updating a record.
	 * @param {object} changedAttributes The old values of attributes that had changed and were saved.
	 * You can use this parameter to take action based on the changes made for example send an email
	 * when the password had changed or implement audit trail that tracks all the changes.
	 * `changedAttributes` gives you the old attribute values while the active record (`this`) has
	 * already the new, updated values.
	 */
	afterSave: function (insert, changedAttributes) {
		var eventName = insert ? this.__static.EVENT_AFTER_INSERT : this.__static.EVENT_AFTER_UPDATE;

		this.trigger(eventName, new Jii.sql.AfterSaveEvent({
			changedAttributes: changedAttributes
		}));

		return Promise.resolve();
	},

	/**
	 * This method is invoked before deleting a record.
	 * The default implementation raises the [[EVENT_BEFORE_DELETE]] event.
	 * When overriding this method, make sure you call the parent implementation like the following:
	 *
	 * ~~~
	 * public function beforeDelete()
	 * {
     *     if (parent.beforeDelete()) {
     *         // ...custom code here...
     *         return true;
     *     } else {
     *         return false;
     *     }
     * }
	 * ~~~
	 *
	 * @returns {boolean} whether the record should be deleted. Defaults to true.
	 */
	beforeDelete: function () {
		var event = new Jii.base.ModelEvent();
		this.trigger(this.__static.EVENT_BEFORE_DELETE, event);

		return Promise.resolve(event.isValid);
	},

	/**
	 * This method is invoked after deleting a record.
	 * The default implementation raises the [[EVENT_AFTER_DELETE]] event.
	 * You may override this method to do postprocessing after the record is deleted.
	 * Make sure you call the parent implementation so that the event is raised properly.
	 */
	afterDelete: function () {
		this.trigger(this.__static.EVENT_AFTER_DELETE);
		return Promise.resolve();
	},

	/**
	 * Repopulates this active record with the latest data.
	 * @returns {boolean} whether the row still exists in the database. If true, the latest data
	 * will be populated to this active record. Otherwise, this record will remain unchanged.
	 */
	refresh: function () {
		var primaryKey = this.getPrimaryKey(true);

		return this.__static.findOne(primaryKey).then(Jii._.bind(function(record) {
			if (record === null) {
				return Promise.resolve(false);
			}

			Jii._.each(this.attributes(), Jii._.bind(function(name) {
				this._attributes[name] = Jii._.has(record._attributes, name) ? record._attributes[name] : null;
			}, this));
			this._oldAttributes = Jii._.clone(this._attributes);

            Jii._.each(this._related, function(relation, name) {
                this._removeRelated(name);
            }.bind(this))

			return Promise.resolve(true);
		}, this));
	},

	/**
	 * Returns a value indicating whether the given active record is the same as the current one.
	 * The comparison is made by comparing the table names and the primary key values of the two active records.
	 * If one of the records [[isNewRecord|is new]] they are also considered not equal.
	 * @param {Jii.base.ActiveRecord} record record to compare to
	 * @returns {boolean} whether the two active records refer to the same row in the same database table.
	 */
	equals: function (record) {
		if (this.isNewRecord() || record.isNewRecord()) {
			return false;
		}

		if (this.className() !== record.className()) {
			return false;
		}

		return this.getPrimaryKey().toString() === record.getPrimaryKey().toString();
	},

	/**
	 * Returns the primary key value(s).
	 * @param {boolean} [asArray] whether to return the primary key value as an array. If true,
	 * the return value will be an array with column names as keys and column values as values.
	 * Note that for composite primary keys, an array will always be returned regardless of this parameter value.
	 * @property mixed The primary key value. An array (column name => column value) is returned if
	 * the primary key is composite. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 * @returns {*} the primary key value. An array (column name => column value) is returned if the primary key
	 * is composite or `asArray` is true. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 */
	getPrimaryKey: function (asArray) {
		asArray = asArray || false;

		var keys = this.__static.primaryKey();
		if (keys.length === 1 && !asArray) {
			return Jii._.has(this._attributes, keys[0]) ? this._attributes[keys[0]] : null;
		}

		var values = {};
		Jii._.each(keys, Jii._.bind(function(name) {
			values[name] = Jii._.has(this._attributes, name) ? this._attributes[name] : null;
		}, this));

		return values;
	},

	/**
	 * Returns the old primary key value(s).
	 * This refers to the primary key value that is populated into the record
	 * after executing a find method (e.g. find(), findOne()).
	 * The value remains unchanged even if the primary key attribute is manually assigned with a different value.
	 * @param {boolean} [asArray] whether to return the primary key value as an array. If true,
	 * the return value will be an array with column name as key and column value as value.
	 * If this is false (default), a scalar value will be returned for non-composite primary key.
	 * @property mixed The old primary key value. An array (column name => column value) is
	 * returned if the primary key is composite. A string is returned otherwise (null will be
	 * returned if the key value is null).
	 * @returns {*} the old primary key value. An array (column name => column value) is returned if the primary key
	 * is composite or `asArray` is true. A string is returned otherwise (null will be returned if
	 * the key value is null).
	 */
	getOldPrimaryKey: function (asArray) {
		asArray = asArray || false;

		var keys = this.__static.primaryKey();

		if (keys.length === 1 && !asArray) {
			return Jii._.has(this._oldAttributes, keys[0]) ? this._oldAttributes[keys[0]] : null;
		}

		var values = {};
		Jii._.each(keys, Jii._.bind(function(name) {
			values[name] = Jii._.has(this._oldAttributes, name) ? this._oldAttributes[name] : null;
		}, this));

		return values;
	},

	/**
	 * Returns the relation object with the specified name.
	 * A relation is defined by a getter method which returns an [[ActiveQueryInterface]] object.
	 * It can be declared in either the Active Record class itself or one of its behaviors.
	 * @param {string} name the relation name
	 * @param {boolean} [throwException] whether to throw exception if the relation does not exist.
	 * @returns {Promise.<Jii.sql.ActiveQuery>} the relational query object. If the relation does not exist
	 * and `throwException` is false, null will be returned.
	 * @throws {Jii.exceptions.InvalidParamException} if the named relation does not exist.
	 */
	getRelation: function (name, throwException) {
		throwException = !Jii._.isUndefined(throwException) ? throwException : true;

		var getter = 'get' + Jii._s.capitalize(name);
		if (Jii._.isFunction(this[getter])) {
			return this[getter]();
		} else if (throwException) {
			throw new Jii.exceptions.InvalidParamException(this.className() + ' has no relation named `' + name + '`.');
		}

		return null;
	},

    /**
     *
     * @param {string} name
     * @returns {boolean}
     */
    hasRelation: function(name) {
        var getter = 'get' + Jii._s.capitalize(name);
        return Jii._.isFunction(this[getter]);
    },

	/**
	 * Establishes the relationship between two models.
	 *
	 * The relationship is established by setting the foreign key value(s) in one model
	 * to be the corresponding primary key value(s) in the other model.
	 * The model with the foreign key will be saved into database without performing validation.
	 *
	 * If the relationship involves a pivot table, a new row() will be inserted into the
	 * pivot table which contains the primary key values from both models.
	 *
	 * Note that this method requires that the primary key value is not null.
	 *
	 * @param {string} name the case sensitive name of the relationship
	 * @param {Jii.base.ActiveRecord} model the model to be linked with the current one.
	 * @param {object} [extraColumns] additional column values to be saved into the pivot table.
	 * This parameter is only meaningful for a relationship involving a pivot table
	 * (i.e., a relation set with [[ActiveRelationTrait.via()]] or `[[ActiveQuery.viaTable()]]`.)
	 * @returns {Promise}
	 * @throws {Jii.exceptions.InvalidCallException} if the method is unable to link two models.
	 */
	link: function (name, model, extraColumns) {
		extraColumns = extraColumns || {};

		var relation = this.getRelation(name);

		return Promise.resolve().then(function() {
			if (relation.getVia() !== null) {
				if (this.isNewRecord() || model.isNewRecord()) {
					throw new Jii.exceptions.InvalidCallException('Unable to link models: both models must NOT be newly created.');
				}

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

					// unset viaName so that it can be reloaded to reflect the change
                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var columns = {};
				Jii._.each(viaRelation.link, function(b, a) {
					columns[a] = this.get(b);
				}.bind(this));
				Jii._.each(relation.link, function(b, a) {
					columns[b] = model.get(a);
				}.bind(this));
				Jii._.each(extraColumns, function(v, k) {
					columns[k] = v;
				}.bind(this));

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					var record = new viaClass();
					Jii._.each(columns, Jii._.bind(function(value, column) {
						record.set(column, value);
					}, this));
					return record.insert(false);
				}

				/* @type {viaTable} string */
				return this.__static.getDb().createCommand().insert(viaTable, columns);
			}

			var p1 = model.__static.isPrimaryKey(Jii._.keys(relation.link));
			var p2 = this.__static.isPrimaryKey(Jii._.values(relation.link));
			if (p1 && p2) {
				if (this.isNewRecord() && model.isNewRecord()) {
					throw new Jii.exceptions.InvalidCallException('Unable to link models: both models are newly created.');
				} else if (this.isNewRecord()) {
					var link = {};
					for (var fk in relation.link) {
						if (relation.link.hasOwnProperty(fk)) {
							link[relation.link[fk]] = fk;
						}
					}
					return this._bindModels(link, this, model);
				} else {
					return this._bindModels(relation.link, model, this);
				}
			} else if (p1) {
				var link2 = {};
				for (var fk2 in relation.link) {
					if (relation.link.hasOwnProperty(fk2)) {
						link2[relation.link[fk2]] = fk2;
					}
				}
				return this._bindModels(link2, this, model);
			} else if (p2) {
				return this._bindModels(relation.link, model, this);
			} else {
				throw new Jii.exceptions.InvalidCallException('Unable to link models: the link does not involve any primary key.');
			}
		}.bind(this)).then(Jii._.bind(function() {
			// update lazily loaded related objects
			if (!relation.multiple) {
                this._setRelated(name, model);
			} else if (Jii._.has(this._related, name)) {
                this._related[name].add(model);
			}

			return Promise.resolve();
		}, this));
	},

	/**
	 * Destroys the relationship between two models.
	 *
	 * The model with the foreign key of the relationship will be deleted if `delete` is true.
	 * Otherwise, the foreign key will be set null and the model will be saved without validation.
	 *
	 * @param {string} name the case sensitive name of the relationship.
	 * @param {Jii.base.ActiveRecord} model the model to be unlinked from the current one.
	 * @param {boolean} [isDelete] whether to delete the model that contains the foreign key.
	 * If false, the model's foreign key will be set null and saved.
	 * If true, the model containing the foreign key will be deleted.
	 * @returns {Promise}
	 * @throws InvalidCallException if the models cannot be unlinked
	 */
	unlink: function (name, model, isDelete) {
		isDelete = isDelete || false;

		var relation = this.getRelation(name);

		return Promise.resolve().then(function() {

			if (relation.getVia() !== null) {

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var columns = {};
				var nulls = {};
				Jii._.each(viaRelation.link, Jii._.bind(function(b, a) {
					columns[a] = this.get(b);
				}, this));
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					columns[b] = model.get(a);
				}, this));
				Jii._.each(Jii._.keys(columns), Jii._.bind(function(k) {
					nulls[k] = null;
				}, this));

				if (Jii._.isArray(relation.getVia())) {
					if (isDelete) {
						return viaClass.deleteAll(columns);
					}

					return viaClass.updateAll(nulls, columns);
				}

				/* @type Jii.sql.Command */
				var command = this.__static.getDb().createCommand();
				if (isDelete) {
					return command.delete(viaTable, columns);
				}

				return command.update(viaTable, nulls, columns);
			}

			var p1 = model.__static.isPrimaryKey(Jii._.keys(relation.link));
			var p2 = this.__static.isPrimaryKey(Jii._.values(relation.link));

			if (p1 && p2 || p2) {
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					model.set(a, null);
				}, this));

				return isDelete ? model.delete() : model.save(false);
			}

			if (p1) {
				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					var values = this.get(b);

					if (Jii._.isArray(values)) { // relation via array valued attribute
						var index = Jii._.indexOf(values, model.get(a));
						if (index !== -1) {
							values.splice(index, 1);
						}
					} else {
						this.set(b, null);
					}
				}, this));

				return isDelete ? this.delete() : this.save(false);
			}

			throw new Jii.exceptions.InvalidCallException('Unable to unlink models: the link does not involve any primary key.');
		}.bind(this)).then(function() {
				if (!relation.multiple) {
                    this._removeRelated(name);
					return;
				}

				if (Jii._.has(this._related, name)) {
					this._related[name].remove(model);
				}
		}.bind(this));
	},

	/**
	 * Destroys the relationship in current model.
	 *
	 * The model with the foreign key of the relationship will be deleted if `delete` is true.
	 * Otherwise, the foreign key will be set null and the model will be saved without validation.
	 *
	 * Note that to destroy the relationship without removing records make sure your keys can be set to null
	 *
	 * @param {string} name the case sensitive name of the relationship.
	 * @param {boolean} [isDelete] whether to delete the model that contains the foreign key.
	 * @returns {Promise}
	 */
	unlinkAll: function (name, isDelete) {
		isDelete = isDelete || false;

		var relation = this.getRelation(name);

		return Promise.resolve().then(Jii._.bind(function() {

			if (relation.getVia() !== null) {

				var viaName = null;
				var viaRelation = null;
				var viaClass = null;
				var viaTable = null;

				if (Jii._.isArray(relation.getVia())) {
					/** @type {Jii.base.ActiveRecord} */
					viaName = relation.getVia()[0];
					viaRelation = relation.getVia()[1];

					/** @type {Jii.base.ActiveRecord} */
					viaClass = viaRelation.modelClass;

                    this._removeRelated(viaName);
				} else {
					viaRelation = relation.getVia();
					viaTable = Jii._.first(relation.getVia().getFrom());
				}

				var condition = {};
				var nulls = {};
				Jii._.each(viaRelation.link, Jii._.bind(function(b, a) {
					nulls[a] = null;
					condition[a] = this.get(b);
				}, this));

				if (Jii._.isArray(relation.getVia())) {
					if (isDelete) {
						return viaClass.deleteAll(condition);
					}
					return viaClass.updateAll(nulls, condition);
				}

				/** @type {Jii.sql.Command} */
				var command = this.__static.getDb().createCommand();
				if (isDelete) {
					return command.delete(viaTable, condition);
				}

				return command.update(viaTable, nulls, condition);
			}

			/** @typedef {Jii.base.ActiveRecord} relatedModel */
			var relatedModel = relation.modelClass;
			var key = relation.link[0];
			if (!isDelete && relation.link.length == 1 && Jii._.isArray(this.get(key))) {
				// relation via array valued attribute
				this.set(key, []);
				return this.save(false);
			} else {
				var nulls2 = {};
				var condition2 = {};

				Jii._.each(relation.link, Jii._.bind(function(b, a) {
					nulls2[a] = null;
					condition2[a] = this.get(b);
				}, this));
				if (relation.getWhere()) {
					condition2 = ['and', condition2, relation.getWhere()];
				}

				if (isDelete) {
					return relatedModel.deleteAll(condition2);
				}
				return relatedModel.updateAll(nulls2, condition2);
			}
		}, this)).then(Jii._.bind(function() {
            this._removeRelated(name);
		}, this));
	},

	/**
	 * @param {object} link
	 * @param {Jii.base.ActiveRecord} foreignModel
	 * @param {Jii.base.ActiveRecord} primaryModel
	 * @throws {Jii.exceptions.InvalidCallException}
	 * @returns {Promise}
	 */
	_bindModels: function (link, foreignModel, primaryModel) {
		Jii._.each(link, Jii._.bind(function(pk, fk) {
			var value = primaryModel.get(pk);
			if (value === null) {
				throw new Jii.exceptions.InvalidCallException('Unable to link models: the primary key of `' + primaryModel.className() + '` is null.');
			}

			if (Jii._.isArray(foreignModel.get(fk))) { // relation via array valued attribute
				foreignModel.get(fk).concat(value);
			} else {
				foreignModel.set(fk, value);
			}
		}, this));

		return foreignModel.save(false);
	},




	/**
	 * Returns the text label for the specified attribute.
	 * If the attribute looks like `relatedModel.attribute`, then the attribute will be received from the related model.
	 * @param {string} attribute the attribute name
	 * @returns {string} the attribute label
	 * @see generateAttributeLabel()
	 * @see attributeLabels()
	 */
	getAttributeLabel: function (attribute) {
		var labels = this.attributeLabels();

		if (Jii._.has(labels[attribute])) {
			return labels[attribute];
		}

		if (attribute.indexOf('.') !== -1) {
			var attributeParts = attribute.split('.');
			var neededAttribute = attributeParts.pop();

			var relatedModel = this;
			Jii._.each(attributeParts, Jii._.bind(function(relationName) {
				if (Jii._.has(this._related, relationName) && this._related[relationName] instanceof Jii.base.ActiveRecord) {
					relatedModel = this._related[relationName];
				} else {
					// @todo
					/*try {
						relation = relatedModel.getRelation(relationName);
					} catch (InvalidParamException e) {
						return this.generateAttributeLabel(attribute);
					}
					relatedModel = new relation.modelClass();*/
				}
			}, this));

			labels = relatedModel.attributeLabels();

			if (Jii._.has(labels[attribute])) {
				return labels[attribute];
			}
		}

		return this.generateAttributeLabel(attribute);
	}

});

},{"./Model":100,"jii":124}],98:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * BaseCollection provides a base class that implements the [[CollectionInterface]].
 *
 * @class Jii.base.Collection
 * @extends Jii.base.Component
 * @extends Array
 */
Jii.defineClass('Jii.base.Collection', /** @lends Jii.base.Collection.prototype */{

    __extends: Jii.base.Component,

    __static: /** @lends Jii.base.Collection */{

        /**
         * @event Jii.base.Collection#add
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_ADD: 'add',

        /**
         * @event Jii.base.Collection#change
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_CHANGE: 'change',

        /**
         * @event Jii.base.Collection#change:
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_CHANGE_NAME: 'change:',

        /**
         * @event Jii.base.Collection#remove
         * @property {Jii.model.CollectionEvent} event
         */
        EVENT_REMOVE: 'remove'

    },

    /**
     * @type {number}
     */
    length: 0,

    /**
     * @type {string|Jii.base.Model}
     */
    modelClass: null,

    _byId: {},

    _eventsChangeName: [],

    /**
     * @param {[]|object} [models]
     * @param {object} [config]
     * @constructor
     */
    constructor: function (models, config) {
        this.__super(config);

        if (Jii._.isArray(models)) {
            this.add(models);
        }
    },

    /**
     * @returns {[]|object}
     */
    getModels: function () {
        return this.map(function(model) {
            return model;
        });
    },

    /**
     *
     * @param {object|object[]|Jii.base.Model|Jii.base.Model[]} models
     */
    setModels: function(models) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        this._change(this.length, models, [], true);
    },

    /**
     *
     * @param {object|object[]|Jii.base.Model|Jii.base.Model[]} models
     * @param {number} [index]
     * @returns {Jii.base.Model[]}
     */
    add: function(models, index) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        if (!index && index !== 0) {
            index = this.length;
        }
        return this._change(index, models, []).added;
    },

    /**
     *
     * @param {*|*[]} models
     * @returns {Jii.base.Model[]}
     */
    remove: function(models) {
        if (!Jii._.isArray(models)) {
            models = [models];
        }
        return this._change(0, [], models).removed;
    },

    /**
     *
     * @param {string|object|object[]} name
     * @param {*} [value]
     * @returns {*}
     */
    set: function(name, value) {
        // Format [0].name
        var indexFormat = this._detectKeyFormatIndex(name);
        if (indexFormat) {
            var model = this.at(indexFormat.index);
            if (model) {
                return model.set(indexFormat.subName, value);
            }

            throw new Jii.exceptions.InvalidParamException('Not found model with index `' + indexFormat.index + '` for set attribute `' + indexFormat.subName + '`.');
        }

        // Object format
        if (Jii._.isObject(name) && !Jii._.has(name, 'modelClass')) {
            return this.setModels(name);
        }

        // Array format
        if (Jii._.isArray(name)) {
            return this.setModels(name);
        }

        return this.__super(name, value);
    },

    /**
     *
     * @param {string} name
     * @returns {*}
     */
    get: function(name) {
        // Format [0].name
        var indexFormat = this._detectKeyFormatIndex(name);
        if (indexFormat) {
            var model = this.at(indexFormat.index);
            if (model) {
                return indexFormat.subName ? model.get(indexFormat.subName) : model;
            }
            return null;
        }

        // Get by pk
        var primaryKey = this._getPrimaryKey(name);
        if (Jii._.has(this._byId, primaryKey)) {
            return this._byId[primaryKey];
        }

        return this.__super(name);
    },

    /**
     *
     * @param name
     * @returns {{index: number, subName: string|null}}
     * @private
     */
    _detectKeyFormatIndex: function(name) {
        var matches = /^\[([0-9]+)\]\.?(.*)/.exec(name);
        if (matches === null) {
            return null;
        }

        return {
            index: parseInt(matches[1]),
            subName: matches[2] || null
        };
    },

    /**
     *
     *
     * @param {number|string|object} primaryKey
     * @returns {*|null}
     */
    getById: function(primaryKey) {
        return this._byId[this._getPrimaryKey(primaryKey)] || null;
    },

    /**
     *
     * @returns {number}
     */
    getCount: function () {
        return this.length;
    },

    /**
     * @param options
     * @returns {*}
     */
    toJSON: function(options) {
        return this.map(function(model) {
            return model.toJSON(options);
        });
    },

    /**
     *
     * @param {number} index
     * @returns {*}
     */
    at: function(index) {
        if (index < 0) {
            index = Math.max(0, this.length + index);
        }
        return this[index] || null;
    },

    /**
     *
     * @param {*} [models]
     */
    reset: function(models) {
        models = models || [];
        if (!Jii._.isArray(models)) {
            models = [models];
        }

        var toAdd = [];
        Jii._.each(models, function(data) {
            var finedModels = this._findModels(data);
            if (finedModels.length) {
                // Convert data to model
                Jii._.each(this._findModels(data), function(model) {
                    if (Jii._.indexOf(toAdd, model) === -1) {
                        toAdd.push(model);
                    }
                });
            } else {
                toAdd.push(data);
            }
        }.bind(this));

        var toRemove = [];
        Jii._.each(this.getModels(), function(model) {
            if (Jii._.indexOf(toAdd, model) === -1) {
                toRemove.push(model);
            }
        });

        this._change(0, toAdd, toRemove, true);
    },

    /**
     *
     * @returns {Jii.base.Object.__super}
     */
    clone: function() {
        return new this.__super(this.getModels(), {
            modelClass: this.modelClass
        });
    },

    _reset: function() {
        this._byId  = {};
        Array.prototype.splice.call(this, 0, this.length);
    },

    _change: function(startIndex, toAdd, toRemove, unique) {
        unique = unique || false;

        var added = [];
        var removed = [];
        var isSorted = false;

        // Remove
        Jii._.each(toRemove, function(data) {
            Jii._.each(this._findModels(data), function(model) {
                var index = this.indexOf(model);
                if (index < startIndex) {
                    startIndex--;
                }

                removed.push(model);

                // Array access
                Array.prototype.splice.call(this, index, 1);

                // By id
                if (model instanceof Jii.base.ActiveRecord) {
                    delete this._byId[this._getPrimaryKey(model)];
                }
            }.bind(this));
        }.bind(this));

        // Add
        Jii._.each(toAdd, function(data) {
            var existsModels = unique ? this._findModels(data) : [];
            var models = existsModels.length > 0 ? existsModels : [this.createModel(data)];

            Jii._.each(models, function(model) {
                // Check moving
                if (existsModels.length > 0) {
                    isSorted = true;

                    // Update model attributes
                    if (model instanceof Jii.base.Model && Jii._.isObject(data) && !(data instanceof Jii.base.Model)) {
                        model.set(data);
                    }
                } else {
                    added.push(model);

                    // Array access
                    Array.prototype.splice.call(this, startIndex++, 0, model);

                    // By id
                    if (model instanceof Jii.base.ActiveRecord) {
                        this._byId[this._getPrimaryKey(model)] = model;
                    }
                }
            }.bind(this));
        }.bind(this));

        // Lazy subscribe on added
        Jii._.each(added, function(model) {
            Jii._.each(this._eventsChangeName, function(arr) {
                model.on.apply(model, arr);
            });
        }.bind(this));

        // Unsubscribe on removed
        Jii._.each(removed, function(model) {
            Jii._.each(this._eventsChangeName, function(arr) {
                model.off.apply(model, arr.slice(0, 2));
            });
        }.bind(this));

        // Trigger events
        var event = new Jii.model.CollectionEvent({
            added: added,
            removed: removed
        })
        if (added.length > 0) {
            this.trigger(this.__static.EVENT_ADD, event);
        }
        if (removed.length > 0) {
            this.trigger(this.__static.EVENT_REMOVE, event);
        }
        if (added.length > 0 || removed.length > 0) {
            this.trigger(this.__static.EVENT_CHANGE, event);
        }

        if (isSorted) {
            this._onSort();
        }

        return {
            added: added,
            removed: removed
        }
    },

    /**
     *
     * @param {number|string|object} data
     * @returns {*|*[]}
     * @private
     */
    _findModels: function(data) {
        var primaryKey = this._getPrimaryKey(data);
        return this.filter(function(model) {
            return primaryKey == this._getPrimaryKey(model);
        }.bind(this));
    },

    /**
     *
     * @param {number|string|object} data
     * @returns {string}
     */
    _getPrimaryKey: function(data) {
        if (Jii._.isObject(data) && this.modelClass && !(data instanceof Jii.base.ActiveRecord)) {
            data = this.createModel(data);
        }

        if (data instanceof Jii.base.ActiveRecord) {
            data = data.getPrimaryKey();
        }

        if (Jii._.isObject(data)) {
            return JSON.stringify(data);
        }
        return data;
    },

    /**
     * Convert any data to model
     * @param {object|*} data
     * @returns {Jii.base.Model}
     */
    createModel: function(data) {
        // Already model
        if (data instanceof Jii.base.Model) {
            return data;
        }

        // Disabled model auto create
        if (this.modelClass === false) {
            return data;
        }

        // Required
        if (this.modelClass === null) {
            Jii.exceptions.InvalidConfigException('Property `modelClass` in collection is required (or set false to force disable).');
        }

        if (Jii._.isObject(data)) {
            var modelClass = this.modelClass;
            if (Jii._.isString(modelClass)) {
                modelClass = Jii.namespace(modelClass);
            }
            if (!Jii._.isFunction(modelClass)) {
                Jii.exceptions.InvalidConfigException('Not found model class for create instance in collection, modelClass: ' + this.modelClass);
            }

            return new modelClass(data);
        }

        throw new Jii.exceptions.InvalidParamException('Cannot create model instance from data: ' + JSON.stringify(data));
    },

    _onSort: function() {
        // @todo Trigger sort event
    },

    /**
     * @param {string|string[]} name
     * @param {function} handler
     * @param {*} [data]
     * @param {boolean} [isAppend]
     */
    on: function(name, handler, data, isAppend) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        // Attributes in models
        var changeNameFormat = this._detectKeyFormatChangeName(name);
        if (changeNameFormat) {
            var changeNameEvent = Jii.base.Model.EVENT_CHANGE_NAME + changeNameFormat.subName;
            this._eventsChangeName.push([changeNameEvent, handler, data, isAppend]);
            this.each(function(model) {
                model.on(changeNameEvent, handler, data, isAppend);
            })
            return;
        }

        this.__super(name, handler, data, isAppend);
    },

    /**
     * @param {string|string[]} name
     * @param {function} [handler]
     * @return boolean
     */
    off: function(name, handler) {
        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

        // Attributes in models
        var changeNameFormat = this._detectKeyFormatChangeName(name);
        if (changeNameFormat) {
            var changeNameEvent = Jii.base.Model.EVENT_CHANGE_NAME + changeNameFormat.subName;
            this._eventsChangeName = Jii._.filter(this._eventsChangeName, function(arr) {
                return arr[0] !== changeNameEvent || arr[1] !== handler;
            });

            var bool = false;
            this.each(function(model) {
                if (model.off(changeNameEvent, handler)) {
                    bool = true;
                }
            })
            return bool;
        }

        return this.__super(name, handler);
    },

    _detectKeyFormatChangeName: function(name) {
        if (name.indexOf(this.__static.EVENT_CHANGE_NAME) !== 0) {
            return null;
        }

        return {
            subName: name.substr(this.__static.EVENT_CHANGE_NAME.length)
        };
    },

    // Array prototype
    /////////////////////

    /**
     *
     * @param {...*} value1
     * @returns {self}
     */
    concat: function(value1) {
        this.add(Jii._.toArray(arguments));
        return this;
    },

    /**
     *
     */
    reverse: function() {
        Array.prototype.reverse.call(this);
    },

    /**
     *
     */
    sort: function() {
        Array.prototype.sort.call(this);
        this._onSort();
    },

    /**
     *
     */
    join: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     */
    toString: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     */
    toLocaleString: function() {
        // @todo
        throw new Jii.exceptions.NotSupportedException();
    },

    /**
     *
     *
     * @param {number} start
     * @param {number} deleteCount
     * @param {...object} [model1]
     * @returns {[]}
     */
    splice: function(start, deleteCount, model1) {
        var toRemove = Array.prototype.slice.call(this, start, start + deleteCount);
        this.remove(toRemove);
        this.add(Jii._.toArray(arguments).slice(2), start);
        return toRemove;
    },

    /**
     *
     * @param begin
     * @param end
     * @returns {*}
     */
    slice: function(begin, end) {
        return new this.__static(Array.prototype.slice.call(this, begin, end), {
            modelClass: this.modelClass
        });
    },

    /**
     *
     * @param {...object} model1
     */
    push: function(model1) {
        this.add(Jii._.toArray(arguments));
    },

    /**
     *
     * @returns {object}
     */
    pop: function() {
        if (this.length === 0) {
            return null;
        }

        var model = this[this.length - 1];
        this.remove(model);
        return model;
    },

    /**
     *
     * @param {...object} model1
     * @returns {number}
     */
    unshift: function(model1) {
        this.add(Jii._.toArray(arguments), 0);
        return this.length;
    },

    /**
     *
     * @returns {object}
     */
    shift: function() {
        if (this.length === 0) {
            return null;
        }

        var model = this[0];
        this.remove(model);
        return model;
    },

    // @todo ES6 methods
    //es6 copyWithin: function() {},
    //es6 entries: function() {},
    //es6 fill: function() {},
    //es6 keys: function() {},
    //es6 values: function() {},

    // Underscore methods
    /////////////////////

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     */
    each: function(iteratee, context) {
        return Jii._.each(this, iteratee, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     */
    forEach: function(iteratee, context) {
        return this.each.apply(this, arguments);
    },

    /**
     *
     * @param {function} iteratee
     * @param {object} [context]
     * @returns {[]}
     */
    map: function(iteratee, context) {
        return Jii._.map(this, iteratee, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {*} [memo]
     * @param {object} [context]
     * @returns {[]}
     */
    reduce: function(iteratee, memo, context) {
        return Jii._.reduce(this, iteratee, memo, context);
    },

    /**
     *
     * @param {function} iteratee
     * @param {*} [memo]
     * @param {object} [context]
     * @returns {[]}
     */
    reduceRight: function(iteratee, memo, context) {
        return Jii._.reduceRight(this, iteratee, memo, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {object}
     */
    find: function(predicate, context) {
        return Jii._.find(this, predicate, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {[]}
     */
    filter: function(predicate, context) {
        return Jii._.filter(this, predicate, context);
    },

    /**
     *
     * @param {object} properties
     * @returns {object}
     */
    where: function(properties) {
        return Jii._.where(this, properties);
    },

    /**
     *
     * @param {object} properties
     * @returns {object}
     */
    findWhere: function(properties) {
        return Jii._.findWhere(this, properties);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {[]}
     */
    reject: function(predicate, context) {
        return Jii._.reject(this, predicate, context);
    },

    /**
     *
     * @param {function} [predicate]
     * @param {object} [context]
     */
    every: function(predicate, context) {
        return Jii._.every(this, predicate, context);
    },

    /**
     *
     * @param {function} [predicate]
     * @param {object} [context]
     */
    some: function(predicate, context) {
        return Jii._.some(this, predicate, context);
    },

    /**
     *
     * @param {object} value
     * @param {number} [fromIndex]
     */
    contains: function(value, fromIndex) {
        return Jii._.contains(this, value, fromIndex);
    },

    /**
     *
     * @param {object} value
     * @param {number} [fromIndex]
     */
    includes: function(value, fromIndex) {
        return this.contains.apply(this, arguments);
    },

    /**
     *
     * @param {string} [methodName]
     * @param {...*} [methodParam]
     * @returns {Array}
     */
    invoke: function(methodName, methodParam) {
        var args = Jii._.toArray(arguments);
        args.unshift(this);
        return Jii._.invoke.apply(Jii._, args);
    },

    /**
     *
     * @param {string} propertyName
     * @returns {Array}
     */
    pluck: function(propertyName) {
        return Jii._.map(this, function(model) {
            return Jii._.isFunction(model.get) ? model.get(propertyName) : model[propertyName];
        });
    },

    /**
     *
     * @param {function} [iteratee]
     * @param {object} [context]
     * @returns {object}
     */
    max: function(iteratee, context) {
        return Jii._.max(this, iteratee, context);
    },

    /**
     *
     * @param {function} [iteratee]
     * @param {object} [context]
     * @returns {object}
     */
    min: function(iteratee, context) {
        return Jii._.min(this, iteratee, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    sortBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        Jii._.each(Jii._.sortBy(this, iterator, context), function(model, i) {
            this[i] = model;
        }.bind(this));
        this._onSort();
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    groupBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.groupBy(this, iterator, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    indexBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.indexBy(this, iterator, context);
    },

    /**
     *
     * @param {string|function} value
     * @param [context]
     * @returns {[]}
     */
    countBy: function(value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.countBy(this, iterator, context);
    },

    /**
     *
     * @returns {number}
     */
    size: function() {
        return this.length;
    },

    /**
     *
     * @param [num]
     * @returns {number}
     */
    first: function(num) {
        return Jii._.first(this, num);
    },

    /**
     *
     * @param [num]
     * @returns {[]}
     */
    initial: function(num) {
        return Jii._.initial(this, num);
    },

    /**
     *
     * @param [num]
     * @returns {number}
     */
    last: function(num) {
        return Jii._.last(this, num);
    },

    /**
     *
     * @param [index]
     * @returns {number}
     */
    rest: function(index) {
        return Jii._.rest(this, index);
    },

    /**
     *
     * @param {...*} [value]
     * @returns {[]}
     */
    without: function(value) {
        var args = Jii._.toArray(arguments);
        args.unshift(this);
        return Jii._.without.apply(Jii._, args);
    },

    /**
     *
     * @param {*} [value]
     * @param {boolean} [isSorted]
     * @returns {number}
     */
    indexOf: function(value, isSorted) {
        return Jii._.indexOf(this, value, isSorted);
    },

    /**
     *
     * @param {*} value
     * @param {number} [fromIndex]
     * @returns {object}
     */
    lastIndexOf: function(value, fromIndex) {
        return Jii._.lastIndexOf(this, value, fromIndex);
    },

    /**
     *
     * @param {object} model
     * @param {*} value
     * @param {object} [context]
     * @returns {number}
     */
    sortedIndex: function(model, value, context) {
        var iterator = Jii._.isFunction(value) ? value : function(model) {
            return Jii._.isFunction(model.get) ? model.get(value) : model[value];
        };
        return Jii._.sortedIndex(this, model, iterator, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {number}
     */
    findIndex: function(predicate, context) {
        return Jii._.findIndex(this, predicate, context);
    },

    /**
     *
     * @param {function} predicate
     * @param {object} [context]
     * @returns {number}
     */
    findLastIndex: function(predicate, context) {
        return Jii._.findLastIndex(this, predicate, context);
    },

    /**
     *
     */
    shuffle: function() {
        Jii._.shuffle(this);
    },

    /**
     *
     * @returns {boolean}
     */
    isEmpty: function() {
        return this.length === 0;
    }

});

},{"jii":124}],99:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Collection');

/**
 * BaseDataProvider provides a base class that implements the [[DataProviderInterface]].
 *
 * @class Jii.base.DataProvider
 * @extends Jii.base.Collection
 */
Jii.defineClass('Jii.base.DataProvider', /** @lends Jii.base.DataProvider.prototype */{

    __extends: Jii.base.Collection,

    /**
     * @type {string} an ID that uniquely identifies the data provider among all data providers.
     * You should set this property if the same page contains two or more different data providers.
     * Otherwise, the [[pagination]] and [[sort]] may not work properly.
     */
    id: null,

    _sort: null,
    _pagination: null,
    _keys: null,
    _isModelsPrepare: false,
    _totalCount: null,

    /**
     * Prepares the data models that will be made available in the current page.
     * @returns {[]} the available data models
     */
    prepareModels: function () {

    },

    /**
     * Prepares the keys associated with the currently available data models.
     * @param {[]} models the available data models
     * @returns {[]} the keys
     */
    prepareKeys: function (models) {

    },

    /**
     * Returns a value indicating the total number of data models in this data provider.
     * @returns {number} total number of data models in this data provider.
     */
    prepareTotalCount: function () {

    },

    /**
     * Prepares the data models and keys.
     *
     * This method will prepare the data models and keys that can be retrieved via
     * [[getModels()]] and [[getKeys()]].
     *
     * This method will be implicitly called by [[getModels()]] and [[getKeys()]] if it has not been called before.
     *
     * @param {boolean} [forcePrepare] whether to force data preparation even if it has been done before.
     */
    prepare: function (forcePrepare) {
        forcePrepare = forcePrepare || false;

        if (forcePrepare || !this._isModelsPrepare) {
            this.splice(0, this.length);
            Jii._.each(this.prepareModels(), function (model) {
                this.push(model);
            }.bind(this));
        }
        if (forcePrepare || this._keys === null) {
            this._keys = this.prepareKeys(this._models);
        }
    },

    /**
     * Returns the data models in the current page.
     * @returns {[]} the list of data models in the current page.
     */
    getModels: function () {
        this.prepare();
        return this._super();
    },

    /**
     * Returns the key values associated with the data models.
     * @returns {[]} the list of key values corresponding to [[models]]. Each data model in [[models]]
     * is uniquely identified by the corresponding key value in this array.
     */
    getKeys: function () {
        this.prepare();

        return this._keys;
    },

    /**
     * Sets the key values associated with the data models.
     * @param {[]} keys the list of key values corresponding to [[models]].
     */
    setKeys: function (keys) {
        this._keys = keys;
    },

    /**
     * Returns the total number of data models.
     * When [[pagination]] is false, this returns the same value as [[count]].
     * Otherwise, it will call [[prepareTotalCount()]] to get the count.
     * @returns {number} total number of possible data models.
     */
    getTotalCount: function () {
        if (this.getPagination() === false) {
            return this.getCount();
        } else if (this._totalCount === null) {
            this._totalCount = this.prepareTotalCount();
        }

        return this._totalCount;
    },

    /**
     * Sets the total number of data models.
     * @param {number} value the total number of data models.
     */
    setTotalCount: function (value) {
        this._totalCount = value;
    },

    /**
     * Returns the pagination object used by this data provider.
     * Note that you should call [[prepare()]] or [[getModels()]] first to get correct values
     * of [[Pagination.totalCount]] and [[Pagination.pageCount]].
     * @returns {jii.data.Pagination|boolean} the pagination object. If this is false, it means the pagination is disabled.
     */
    getPagination: function () {
        // @todo Pagination & Sort
        /*if (this._pagination === null) {
         this.setPagination({});
         }

         return this._pagination;*/
    },

    /**
     * Sets the pagination for this data provider.
     * @param {[]|jii.data.Pagination|boolean} value the pagination to be used by this data provider.
     * This can be one of the following:
     *
     * - a configuration array for creating the pagination object. The "class" element defaults
     *   to 'jii\data\Pagination'
     * - an instance of [[Pagination]] or its subclass
     * - false, if pagination needs to be disabled.
     *
     * @throws InvalidParamException
     */
    setPagination: function (value) {
        // @todo Pagination & Sort
        /*if (Jii._.isObject(value)) {
         config = {class: Pagination.className()};
         if (this.id !== null) {
         config['pageParam'] = this.id . '-page';
         config['pageSizeParam'] = this.id . '-per-page';
         }
         this._pagination = Jii.createObject(array_merge(config, value));
         } else if (value instanceof Pagination || value === false) {
         this._pagination = value;
         } else {
         throw new InvalidParamException('Only Pagination instance, configuration array or false is allowed.');
         }*/
    },

    /**
     * @returns {jii.data.Sort|boolean} the sorting object. If this is false, it means the sorting is disabled.
     */
    getSort: function () {
        // @todo Pagination & Sort
        /*if (this._sort === null) {
         this.setSort({});
         }

         return this._sort;*/
    },

    /**
     * Sets the sort definition for this data provider.
     * @param {[]|jii.data.Sort|boolean} value the sort definition to be used by this data provider.
     * This can be one of the following:
     *
     * - a configuration array for creating the sort definition object. The "class" element defaults
     *   to 'jii\data\Sort'
     * - an instance of [[Sort]] or its subclass
     * - false, if sorting needs to be disabled.
     *
     * @throws InvalidParamException
     */
    setSort: function (value) {
        // @todo Pagination & Sort
        /*if (Jii._.isObject(value)) {
         config = {class: Sort.className()};
         if (this.id !== null) {
         config['sortParam'] = this.id . '-sort';
         }
         this._sort = Jii.createObject(array_merge(config, value));
         } else if (value instanceof Sort || value === false) {
         this._sort = value;
         } else {
         throw new InvalidParamException('Only Sort instance, configuration array or false is allowed.');
         }*/
    },

    /**
     * Refreshes the data provider.
     * After calling this method, if [[getModels()]], [[getKeys()]] or [[getTotalCount()]] is called again,
     * they will re-execute the query and return the latest data available.
     */
    refresh: function () {
        this.splice(0, this.length);
        this._totalCount = null;
        this._keys = null;
    }


});

},{"./Collection":98,"jii":124}],100:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.Model
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Model', /** @lends Jii.base.Model.prototype */{

	__extends: Jii.base.Component,

	_attributes: {},
	_errors: {},
	_validators: null,
	_scenario: 'default',

    _editedLevel: 0,
    _editedSubModels: [],
    _editedChanges: {},

    __static: /** @lends Jii.base.Model */{

        /**
         * @event Jii.base.Model#change
         * @property {Jii.model.ChangeEvent} event
         */
        EVENT_CHANGE: 'change',

        /**
         * @event Jii.base.Model#change:
         * @property {Jii.model.ChangeAttributeEvent} event
         */
        EVENT_CHANGE_NAME: 'change:'

    },

    /**
     * @constructor
     */
    constructor: function (attributes, config) {
        if (Jii._.isObject(attributes)) {
            this.set(attributes);
        }

        this.__super(config);
    },

    /**
     * Validation rules
     * @returns {Array}
     */
    rules: function () {
        return [];
    },

    /**
     * Begin change operation
     */
    beginEdit: function() {
        this._editedLevel++;
    },

    /**
     * Cancel all changes after beginEdit() call
     */
    cancelEdit: function() {
        if (this._editedLevel > 0) {
            this._editedLevel--;
        }

        // Cancel in sub-models
        if (this._editedLevel === 0) {
            Jii._.each(this._editedSubModels, function (subModel) {
                subModel.cancelEdit();
            });

            // Revert attribute changes
            Jii._.each(this._editedChanges, function (values, name) {
                this._attributes[name] = values[0];
            }.bind(this));
        }
    },

    /**
     * End change operation - trigger change events
     */
    endEdit: function() {
        if (this._editedLevel > 0) {
            this._editedLevel--;
        }

        if (this._editedLevel === 0) {
            // End in sub-models
            Jii._.each(this._editedSubModels, function(subModel) {
                subModel.endEdit();
            });

            // Trigger change attribute events
            if (!Jii._.isEmpty(this._editedChanges)) {
                Jii._.each(this._editedChanges, function(values, name) {
                    this.trigger(this.__static.EVENT_CHANGE_NAME + name, new Jii.model.ChangeAttributeEvent({
                        sender: this,
                        attribute: name,
                        oldValue: values[0],
                        newValue: values[1],
                        changedAttributes: this._editedChanges
                    }));
                }.bind(this));

                // Trigger change event
                this.trigger(this.__static.EVENT_CHANGE, new Jii.model.ChangeEvent({
                    sender: this,
                    changedAttributes: this._editedChanges
                }));
            }

            // Reset state
            this._editedSubModels = [];
            this._editedChanges = {};
        }
    },

	/**
	 * Get attribute value
	 * @param {String} name
	 * @returns {*}
	 */
	get: function (name) {
        if (this.hasAttribute(name)) {
            return this.getAttribute(name);
        }

        // Sub models support: foo[0]
        var collectionFormat = this._detectKeyFormatCollection(name, '', true);
        if (collectionFormat) {
            return collectionFormat.subName ?
                collectionFormat.model.get(collectionFormat.subName) :
                collectionFormat.model;
        }

        // Sub models support: foo.bar
        var modelFormat = this._detectKeyFormatModel(name);
        if (modelFormat) {
            return modelFormat.model ?
                modelFormat.model.get(modelFormat.subName) :
                null;
        }

        try {
            return this.__super(name);
        } catch (e) {
            if (!(e instanceof Jii.exceptions.UnknownPropertyException)) {
                throw e;
            }
            return null;
        }
	},

	/**
	 * Set attribute value
	 * @param {object|string} name
	 * @param {*} [value]
	 */
	set: function (name, value) {
        // Object format support
        if (Jii._.isObject(name)) {
            this.beginEdit();

            var isChanged = false;
            Jii._.each(name, function(value, name) {
                if (this.set(name, value)) {
                    isChanged = true;
                }
            }.bind(this));

            this.endEdit();
            return isChanged;
        }

        // Sub models support: foo[0].bar.zen
        var subMatches = /^(.+)\.([^\[\].]+)$/.exec(name);
        if (subMatches !== null) {
            var subModel = this.get(subMatches[1]);

            // Check sub-model is Jii.base.Model
            if (subModel instanceof Jii.base.Collection) {
                throw new Jii.exceptions.InvalidParamException('Try set property of array models: `' + name + '`');
            } else if (!(subModel instanceof Jii.base.Model)) {
                throw new Jii.exceptions.UnknownPropertyException('Setting property of null sub-model `' + name + '`');
            }

            subModel.beginEdit();
            this._editedSubModels.push(subModel);

            var isSubChanged = subModel.set(subMatches[2], value);

            this.endEdit();
            return isSubChanged;
        }

        if (this.hasAttribute(name)) {
            this.beginEdit();

            var oldValue = this._attributes[name];
            var isAttributeChanged = !Jii._.isEqual(oldValue, value);
            this._attributes[name] = value;

            if (isAttributeChanged) {
                this._editedChanges[name] = [oldValue, value];
            }

            this.endEdit();
            return isAttributeChanged;
        }

        this.__super(name, value);
	},

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @param {boolean} [skipThrow]
     * @returns {{model: Jii.base.ActiveRecord, name: string, subName: string}|null}
     * @protected
     */
    _detectKeyFormatCollection: function(name, prefix, skipThrow) {
        prefix = prefix || '';
        skipThrow = skipThrow || false;

        // Sub models support: change:foo[0]
        var arrRegExp = new RegExp('^' + prefix + '([^\\[\\].]+)\\[([-0-9]+)\\](\\.(.+))?$');
        var arrMatches = arrRegExp.exec(name);
        if (arrMatches === null) {
            return null;
        }

        var collection = this.get(arrMatches[1]);
        if (collection instanceof Jii.base.Collection) {
            var index = parseInt(arrMatches[2]);
            var arrSubModel = collection.at(index);
            if (arrSubModel) {
                return {
                    model: arrSubModel,
                    subName: arrMatches[4] ? prefix + arrMatches[4] : null,
                    index: index
                };
            } else if (!skipThrow) {
                throw new Jii.exceptions.InvalidParamException('Model with index `' + index + '` in collection `' + arrMatches[1] + '` is not found.');
            }
        } else if (!skipThrow) {
            throw new Jii.exceptions.InvalidParamException('Relation `' + arrMatches[1] + '` is not collection.');
        }

        return null;
    },

    /**
     *
     * @param {string} name
     * @param {string} [prefix]
     * @returns {{model: Jii.base.ActiveRecord|null, name: string, subName: string}|null}
     * @protected
     */
    _detectKeyFormatModel: function(name, prefix) {
        prefix = prefix || '';

        if (prefix && name.indexOf(prefix) !== 0) {
            return null;
        }
        name = name.substr(prefix.length);

        var dotIndex = name.indexOf('.');
        if (dotIndex === -1) {
            return null;
        }

        var relationName = name.substr(0, dotIndex);

        return {
            model: this.get(relationName),
            name: relationName,
            subName: prefix + name.substr(dotIndex + 1)
        };
    },

    /**
     * Returns the named attribute value.
     * If this record is the result of a query and the attribute is not loaded,
     * null will be returned.
     * @param {string} name the attribute name
     * @returns {*} the attribute value. Null if the attribute is not set or does not exist.
     * @see hasAttribute()
     */
    getAttribute: function (name) {
        return Jii._.has(this._attributes, name) ? this._attributes[name] : null;
    },

    /**
     * Sets the named attribute value.
     * @param {string} name the attribute name
     * @param {*} value the attribute value.
     * @throws {Jii.exceptions.InvalidParamException} if the named attribute does not exist.
     * @see hasAttribute()
     */
    setAttribute: function (name, value) {
        if (this.hasAttribute(name)) {
            this.set(name, value);
        } else {
            throw new Jii.exceptions.InvalidParamException(this.className() + ' has no attribute named "' + name + '".');
        }
    },

	/**
	 * Update model attributes. This method run change
	 * and change:* events, if attributes will be changes
	 * @param attributes
	 * @param {Boolean} [safeOnly]
	 * @returns {boolean}
	 */
	setAttributes: function (attributes, safeOnly) {
		if (Jii._.isUndefined(safeOnly)) {
			safeOnly = true;
		}

        var filteredAttributes = {};
		var attributeNames = safeOnly ? this.safeAttributes() : this.attributes();

		Jii._.each(attributes, Jii._.bind(function (value, key) {
			if (Jii._.indexOf(attributeNames, key) !== -1) {
                filteredAttributes[key] = value;
			} else if (safeOnly) {
				this.onUnsafeAttribute(key, value);
			}
		}, this));

		return this.set(filteredAttributes);
	},

	/**
	 * This method is invoked when an unsafe attribute is being massively assigned.
	 * The default implementation will log a warning message if YII_DEBUG is on.
	 * It does nothing otherwise.
	 * @param {string} name the unsafe attribute name
	 * @param {*} value the attribute value
	 */
	onUnsafeAttribute: function (name, value) {
		if (Jii.debug) {
			Jii.trace('Failed to set unsafe attribute `' + name + '` in ' + this.className() + '`');
		}
	},

	/**
	 * Returns attribute values.
	 * @param {Array} [names]
	 * @param {Array} [except]
	 * @returns {{}} Attribute values (name => value).
	 */
	getAttributes: function (names, except) {
		var values = {};

		if (!Jii._.isArray(names)) {
			names = this.attributes();
		}

		Jii._.each(names, Jii._.bind(function (name) {
			if (!Jii._.isArray(except) || Jii._.indexOf(name, except) === -1) {
				values[name] = this.get(name);
			}
		}, this));

		return values;
	},

	/**
	 * Get attributes list for this model
	 * @return {Array}
	 */
	attributes: function () {
		return Jii._.keys(this._attributes);
	},

	/**
	 * Check attribute exists in this model
	 * @param {String} name
	 * @returns {boolean}
	 */
	hasAttribute: function (name) {
		//return true;
		return Jii._.indexOf(this.attributes(), name) !== -1;
	},

	/**
	 * Format: attribute => label
	 * @return {object}
	 */
	attributeLabels: function () {
		return {};
	},

	/**
	 * Get label by attribute name
	 * @param {string} name
	 * @returns {string}
	 */
	getAttributeLabel: function (name) {
		var attributes = this.attributeLabels();
		return Jii._.has(attributes, name) ? attributes[name] : name;
	},

	/**
	 *
	 * @param scenario
	 */
	setScenario: function (scenario) {
		this._scenario = scenario;
	},

	/**
	 *
	 * @returns {string}
	 */
	getScenario: function () {
		return this._scenario;
	},

	safeAttributes: function () {
		var scenario = this.getScenario();
		var scenarios = this.scenarios();

		if (!Jii._.has(scenarios, scenario)) {
			return [];
		}

		var attributes = [];
		Jii._.each(scenarios[scenario], function (attribute, i) {
			if (attribute.substr(0, 1) !== '!') {
				attributes.push(attribute);
			}
		});
		return attributes;
	},

	/**
	 *
	 * @returns {*}
	 */
	activeAttributes: function () {
		var scenario = this.getScenario();
		var scenarios = this.scenarios();

		if (!Jii._.has(scenarios, scenario)) {
			return [];
		}

		var attributes = scenarios[scenario];
		Jii._.each(attributes, function (attribute, i) {
			if (attribute.substr(0, 1) === '!') {
				attributes[i] = attribute.substr(1);
			}
		});

		return attributes;
	},

	/**
	 *
	 * @returns {Object}
	 */
	scenarios: function () {
		var scenarios = {};
		scenarios['default'] = [];

		Jii._.each(this.getValidators(), function (validator) {
			Jii._.each(validator.on, function(scenario) {
				scenarios[scenario] = [];
			});
			Jii._.each(validator.except, function(scenario) {
				scenarios[scenario] = [];
			});
		});
		var names = Jii._.keys(scenarios);

		Jii._.each(this.getValidators(), function (validator) {
			var validatorScenarios = validator.on && validator.on.length > 0 ? validator.on : names;
			Jii._.each(validatorScenarios, function (name) {
				if (!scenarios[name]) {
					scenarios[name] = [];
				}

				if (Jii._.indexOf(validator.except, name) !== -1) {
					return;
				}

				Jii._.each(validator.attributes, function (attribute) {

					if (Jii._.indexOf(scenarios[name], attribute) !== -1) {
						return;
					}

					scenarios[name].push(attribute);
				});
			});
		});

		return scenarios;
	},

	/**
	 *
	 * @returns {Array}
	 */
	createValidators: function () {
		var validators = [];
		Jii._.each(this.rules(), Jii._.bind(function (rule) {
			if (rule instanceof Jii.validators.Validator) {
				validators.push(rule);
			} else if (Jii._.isArray(rule) && rule.length >= 2) {
				var attributes = Jii._.isString(rule[0]) ? [rule[0]] : rule[0];
				var params = rule[2] || {};
				params.on = Jii._.isString(params.on) ? [params.on] : params.on;

				var validator = Jii.validators.Validator.create(rule[1], this, attributes, params);
				validators.push(validator);
			} else {
				throw new Jii.exceptions.ApplicationException('Invalid validation rule: a rule must specify both attribute names and validator type.');
			}
		}, this));
		return validators;
	},

	/**
	 *
	 * @returns {*}
	 */
	getValidators: function () {
		if (this._validators === null) {
			this._validators = this.createValidators();
		}
		return this._validators;
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {Array}
	 */
	getActiveValidators: function (attribute) {
		var validators = [];
		var scenario = this.getScenario();

		Jii._.each(this.getValidators(), function (validator) {
			if (!validator.isActive(scenario)) {
				return;
			}

			if (attribute && Jii._.indexOf(validator.attributes, attribute) === -1) {
				return;
			}

			validators.push(validator);
		});

		return validators;
	},

	/**
	 * Validate model by rules, see rules() method.
	 * @param {Array} [attributes]
	 * @param {Boolean} [isClearErrors]
	 */
	validate: function (attributes, isClearErrors) {
		if (Jii._.isUndefined(isClearErrors)) {
			isClearErrors = true;
		}
		if (!attributes) {
			attributes = this.activeAttributes();
		}

		var scenarios = this.scenarios();
		var scenario = this.getScenario();
		if (!Jii._.has(scenarios, scenario)) {
			throw new Jii.exceptions.ApplicationException('Unknown scenario `' + scenario + '`.');
		}

		if (isClearErrors) {
			this.clearErrors();
		}

		return Promise.resolve(this.beforeValidate())
			.then(Jii._.bind(function (bool) {
				if (!bool) {
					return Promise.resolve(false);
				}

				var promises = Jii._.map(this.getActiveValidators(), Jii._.bind(function (validator) {
					return validator.validate(this, attributes);
				}, this));
				return Promise.all(promises);
			}, this))
			.then(this.afterValidate)
			.then(Jii._.bind(function () {
				if (this.hasErrors()) {
					return Promise.resolve(false);
				}

				// Return result
				return Promise.resolve(true);
			}, this));
	},

	addError: function (attribute, error) {
		if (!this._errors[attribute]) {
			this._errors[attribute] = [];
		}

		this._errors[attribute].push(error);
	},

	setErrors: function (errors) {
		this._errors = errors;
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	getErrors: function (attribute) {
		return !attribute ? this._errors : this._errors[attribute] || {};
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	hasErrors: function (attribute) {
		return attribute ? Jii._.has(this._errors, attribute) : !Jii._.isEmpty(this._errors);
	},

	/**
	 *
	 * @param [attribute]
	 * @returns {*}
	 */
	clearErrors: function (attribute) {
		if (!attribute) {
			this._errors = {};
		} else if (this._errors) {
			delete this._errors[attribute];
		}
	},

	beforeValidate: function () {
		return true;
	},

	afterValidate: function () {
	},

	/**
	 * Returns a value indicating whether the attribute is required.
	 * This is determined by checking if the attribute is associated with a
	 * [[\jii\validators\RequiredValidator|required]] validation rule in the
	 * current [[scenario]].
	 *
	 * Note that when the validator has a conditional validation applied using
	 * [[\jii\validators\RequiredValidator.when|when]] this method will return
	 * `false` regardless of the `when` condition because it may be called be
	 * before the model is loaded with data.
	 *
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is required
	 */
	isAttributeRequired: function (attribute) {
		var bool = false;
		Jii._.each(this.getActiveValidators(attribute), Jii._.bind(function(validator) {
			if (validator instanceof Jii.validators.RequiredValidator && validator.when === null) {
				bool = true;
			}
		}, this));
		return bool;
	},

	/**
	 * Returns a value indicating whether the attribute is safe for massive assignments.
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is safe for massive assignments
	 * @see safeAttributes()
	 */
	isAttributeSafe: function (attribute) {
		return Jii._.indexOf(this.safeAttributes(), attribute) !== -1;
	},

	/**
	 * Returns a value indicating whether the attribute is active in the current scenario.
	 * @param {string} attribute attribute name
	 * @returns {boolean} whether the attribute is active in the current scenario
	 * @see activeAttributes()
	 */
	isAttributeActive: function (attribute) {
		return Jii._.indexOf(this.activeAttributes(), attribute) !== -1;
	},

	/**
	 * Returns the first error of every attribute in the model.
	 * @returns {object} the first errors. The array keys are the attribute names, and the array
	 * values are the corresponding error messages. An empty array will be returned if there is no error.
	 * @see getErrors()
	 * @see getFirstError()
	 */
	getFirstErrors: function () {
		if (Jii._.isEmpty(this._errors)) {
			return {};
		}

		var errors = {};
		Jii._.each(this._errors, Jii._.bind(function(es, name) {
			if (es.length > 0) {
				errors[name] = es[0];
			}
		}, this));

		return errors;
	},

	/**
	 * Returns the first error of the specified attribute.
	 * @param {string} attribute attribute name.
	 * @returns {string} the error message. Null is returned if no error.
	 * @see getErrors()
	 * @see getFirstErrors()
	 */
	getFirstError: function (attribute) {
		return Jii._.has(this._errors, attribute) ? this._errors[attribute][0] : null;
	},

	/**
	 * Generates a user friendly attribute label based on the give attribute name.
	 * This is done by replacing underscores, dashes and dots with blanks and
	 * changing the first letter of each word to upper case.
	 * For example, 'department_name' or 'DepartmentName' will generate 'Department Name'.
	 * @param {string} name the column name
	 * @returns {string} the attribute label
	 */
	generateAttributeLabel: function (name) {
		return Jii._s.humanize(name);
	}

});

},{"jii":124}],101:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.ModelAttributeSchema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.ModelAttributeSchema', /** @lends Jii.base.ModelAttributeSchema.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {string} name of this column (without quotes).
	 */
	name: null,

	/**
	 * @var {string} abstract type of this column. Possible abstract types include:
	 * string, text, boolean, smallint, integer, bigint, float, decimal, datetime,
	 * timestamp, time, date, binary, and money.
	 */
	type: null,

	/**
	 * @var {string} the JS type of this column. Possible JS types include:
	 * string, boolean, number, double.
	 */
	jsType: null,

	/**
	 * @var {*} default value of this column
	 */
	defaultValue: null,

	/**
	 * @var {boolean} whether this column is a primary key
	 */
	isPrimaryKey: false,

	/**
	 * Converts the input value according to [[jsType]].
	 * If the value is null or an [[Expression]], it will not be converted.
	 * @param {*} value input value
	 * @return {*} converted value
	 */
	typecast: function(value) {
		if (value === '' && this.type !== Jii.sql.BaseSchema.TYPE_TEXT &&
			this.type !== Jii.sql.BaseSchema.TYPE_STRING &&
			this.type !== Jii.sql.BaseSchema.TYPE_BINARY) {
			return null;
		}

		// @todo php->js types
		if (value === null || typeof(value) === this.jsType || value instanceof Jii.sql.Expression) {
			return value;
		}

		switch (this.jsType) {
			case 'string':
				return String(value);

			case 'number':
				return Jii._.isBoolean(value) ?
					(value ? 1 : 0) :
					parseFloat(value);

			case 'boolean':
				return !!value;
		}

		return value;
	},

    toJSON: function() {
        var obj = {};

        if (this.defaultValue !== null) {
            obj.defaultValue = this.defaultValue;
        }
        if (this.isPrimaryKey) {
            obj.isPrimaryKey = this.isPrimaryKey;
        }
        if (this.jsType !== null) {
            obj.jsType = this.jsType;
        }
        if (this.name !== null) {
            obj.name = this.name;
        }

        if (Jii._.isEmpty(obj)) {
            return this.type;
        }

        if (this.type !== null) {
            obj.type = this.type;
        }
        return obj;
    }

});

},{"jii":124}],102:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.base.ModelSchema
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.ModelSchema', /** @lends Jii.base.ModelSchema.prototype */{

	__extends: Jii.base.Object,

    __static: /** @lends Jii.base.ModelSchema */{

        /**
         *
         * @param {object} obj
         * @returns {Jii.base.ModelSchema}
         */
        createFromObject: function(obj) {
            Jii._.each(obj.columns, function(column, name) {
                if (!(column instanceof Jii.base.ModelAttributeSchema)) {
                    if (Jii._.isString(column)) {
                        if (Jii._.isNumber(name)) {
                            var parts = column.split(':');
                            column = {
                                name: parts[0],
                                type: 'string'
                            };
                        } else {
                            column = {
                                name: name,
                                type: column
                            }
                        }
                    }

                    if (!Jii._.isObject(column)) {
                        throw new Jii.exceptions.InvalidConfigException('Invalid column format: ' + column);
                    }
                    if (!Jii._.isString(name)) {
                        column.name = name;
                    }
                    obj.columns[name] = new Jii.base.ModelAttributeSchema(column);
                }
            }.bind(this));

            return new Jii.base.ModelSchema(obj);
        }

    },

	/**
	 * @var {string} the name of the schema that this table belongs to.
	 */
	schemaName: '',

	/**
	 * @var {string[]} primary keys of this table.
	 */
	primaryKey: [],

	/**
	 * @var {{string: Jii.base.ModelAttributeSchema}} column metadata of this table. Each array element is a [[Jii.base.ModelAttributeSchema]] object, indexed by column names.
	 */
	columns: {},

	/**
	 * Gets the named column metadata.
	 * This is a convenient method for retrieving a named column even if it does not exist.
	 * @param {string} name column name
	 * @return {Jii.base.ModelAttributeSchema} metadata of the named column. Null if the named column does not exist.
	 */
	getColumn: function (name) {
		return Jii._.has(this.columns, name) ? this.columns[name] : null;
	},

	/**
	 * Returns the names of all columns in this table.
	 * @return {[]} list of column names
	 */
	getColumnNames: function () {
		return Jii._.keys(this.columns);
	},

    toJSON: function() {
        var obj = {};

        if (!Jii._.isEmpty(this.primaryKey)) {
            obj.primaryKey = this.primaryKey;
        }
        if (!Jii._.isEmpty(this.schemaName)) {
            obj.schemaName = this.schemaName;
        }
        if (!Jii._.isEmpty(this.columns)) {
            obj.columns = {};
            Jii._.each(this.columns, function(column, name) {
                obj.columns[name] = column.toJSON();
            });
        }

        return obj;
    }

});

},{"jii":124}],103:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * ArrayDataProvider implements a data provider based on a data array.
 *
 * The [[allModels]] property contains all data models that may be sorted and/or paginated.
 * ArrayDataProvider will provide the data after sorting and/or pagination.
 * You may configure the [[sort]] and [[pagination]] properties to
 * customize the sorting and pagination behaviors.
 *
 * Elements in the [[allModels]] array may be either objects (e.g. model objects)
 * or associative arrays (e.g. query results of DAO).
 * Make sure to set the [[key]] property to the name of the field that uniquely
 * identifies a data record or false if you do not have such a field.
 *
 * Compared to [[ActiveDataProvider]], ArrayDataProvider could be less efficient
 * because it needs to have [[allModels]] ready.
 *
 * @class Jii.base.ArrayDataProvider
 * @extends Jii.base.DataProvider
 */
Jii.defineClass('Jii.base.ArrayDataProvider', /** @lends Jii.base.ArrayDataProvider.prototype */{

    __extends: Jii.base.DataProvider,

    /**
     * @type {string|function} the column that is used as the key of the data models.
     * This can be either a column name, or a callable that returns the key value of a given data model.
     * If this is not set, the index of the [[models]] array will be used.
     * @see getKeys()
     */
    key: null,

    /**
     * @type {[]} the data that is not paginated or sorted. When pagination is enabled,
     * this property usually contains more elements than [[models]].
     * The array elements must use zero-based integer keys.
     */
    allModels: null,

    /**
     * @inheritdoc
     */
    _prepareModels: function () {
        var models = this.allModels;
        if (models === null) {
            return [];
        }

        // @todo Pagination & Sort
        /*var sort = this.getSort();
        if (sort !== false) {
            models = this._sortModels(Jii._.clone(models), sort);
        }

        var pagination = this.getPagination();
        if (pagination !== false) {
            pagination.totalCount = this.getTotalCount();

            if (pagination.getPageSize() > 0) {
                models = array_slice(models, pagination.getOffset(), pagination.getLimit(), true);
            }
        }*/

        return models;
    },

    /**
     * @inheritdoc
     */
    _prepareKeys: function (models) {
        if (this.key !== null) {
            return Jii._.map(models, function(model) {
                if (Jii._.isString(this.key)) {
                    return model[this.key];
                }
                return this.key.call(null, model);
            }.bind(this));
        }

        return Jii._.keys(models);
    },

    /**
     * @inheritdoc
     */
    _prepareTotalCount: function () {
        return this.allModels.length;
    },

    /**
     * Sorts the data models according to the given sort definition
     * @param {[]} models the models to be sorted
     * @param {jii.data.Sort} sort the sort definition
     * @returns {[]} the sorted data models
     */
    _sortModels: function (models, sort) {
        // @todo Pagination & Sort
        /*var orders = sort.getOrders();
        if (!Jii._.isEmpty(orders)) {
            ArrayHelper.multisort(models, array_keys(orders), array_values(orders));
        }

        return models;*/
    }

});

},{"jii":124}],104:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./ChangeEvent');

/**
 * @class Jii.model.ChangeAttributeEvent
 * @extends Jii.model.ChangeEvent
 */
Jii.defineClass('Jii.model.ChangeAttributeEvent', /** @lends Jii.model.ChangeAttributeEvent.prototype */{

	__extends: Jii.model.ChangeEvent,

    /**
     * @type {string}
     */
    attribute: '',

    /**
     * @type {*}
     */
    oldValue: null,

    /**
     * @type {*}
     */
    newValue: null

});

},{"./ChangeEvent":105,"jii":124}],105:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.ChangeEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.ChangeEvent', /** @lends Jii.model.ChangeEvent.prototype */{

	__extends: Jii.base.Event,

    changedAttributes: {}

});

},{"jii":124}],106:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.CollectionEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.CollectionEvent', /** @lends Jii.model.CollectionEvent.prototype */{

	__extends: Jii.base.Event,

    /**
     *
     * @type {Jii.base.Model[]}
     */
    added: [],

    /**
     *
     * @type {Jii.base.Model[]}
     */
    removed: []

});

},{"jii":124}],107:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.model.LinkModelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.model.LinkModelEvent', /** @lends Jii.model.LinkModelEvent.prototype */{

	__extends: Jii.base.Event,

    /**
     * Relation name
     * @type {string}
     */
    relationName: null

});

},{"jii":124}],108:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.BooleanValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.BooleanValidator', /** @lends Jii.validators.BooleanValidator.prototype */{

	__extends: Jii.validators.Validator,

    trueValue: '1',

    falseValue: '0',

    strict: false,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message, {
                trueValue: this.trueValue,
                falseValue: this.falseValue
            });
        }
    },

    validateValue: function(value) {
        if (this.strict) {
            return value === this.trueValue || value === this.falseValue;
        } else {
            return value == this.trueValue || value == this.falseValue;
        }
    }

});

},{"./Validator":122,"jii":124}],109:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.CompareValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.CompareValidator', /** @lends Jii.validators.CompareValidator.prototype */{

	__extends: Jii.validators.Validator,

    compareAttribute: null,

    compareValue: null,

    operator: '==',

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var compareLabel = null;
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, Jii.t('{attribute} is invalid.'));
            return;
        }

        if (this.compareValue === null) {
            if (this.compareAttribute === null) {
                this.compareAttribute = attribute + '_repeat';
            }
            compareLabel = object.getAttributeLabel(this.compareAttribute);
            this.compareValue = object.get(this.compareAttribute);
        } else {
            compareLabel = this.compareValue;
        }

        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message, {
                compareAttribute: compareLabel,
                compareValue: this.compareValue
            });
        }
    },

    validateValue: function(value) {
        if (!this.compareValue) {
            throw new Jii.exceptions.ApplicationException('CompareValidator::compareValue must be set.');
        }

        switch (this.operator) {
            case '==': return this.compareValue == value;
            case '===': return this.compareValue === value;
            case '!=': return this.compareValue != value;
            case '!==': return this.compareValue !== value;
            case '>': return this.compareValue > value;
            case '>=': return this.compareValue >= value;
            case '<': return this.compareValue < value;
            case '<=': return this.compareValue <= value;
        }
        return false;
    }

});

},{"./Validator":122,"jii":124}],110:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.DateValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.DateValidator', /** @lends Jii.validators.DateValidator.prototype */{

	__extends: Jii.validators.Validator,

	format: 'Y-m-d',

    timestampAttribute: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', 'The format of {attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, this.message);
            return;
        }

        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        } else if (this.timestampAttribute !== null) {
            // @todo Parse by format
            var timestamp = Date.parse(value);
            object.set(this.timestampAttribute, Math.round(timestamp / 1000));
        }
    },

    validateValue: function(value) {
        // @todo Validate by format
        var timestamp = Date.parse(value);
        return !Jii._.isNaN(timestamp);
    }

});

},{"./Validator":122,"jii":124}],111:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.DefaultValueValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.DefaultValueValidator', /** @lends Jii.validators.DefaultValueValidator.prototype */{

	__extends: Jii.validators.Validator,

	value: null,

    skipOnEmpty: false,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        if (this.isEmpty(object.get(attribute))) {
            object.set(attribute, this.value);
        }

    }

});

},{"./Validator":122,"jii":124}],112:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.EmailValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.EmailValidator', /** @lends Jii.validators.EmailValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: /^[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?$/,

    fullPattern: /^[^@]*<[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&\'*+\\/=?^_`{|}~-]+)*@(?:[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9-]*[a-zA-Z0-9])?>$/,

    allowName: false,

    init: function () {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is not a valid email address.');
        }
    },

    validateAttribute: function (object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function (value) {
        if (!Jii._.isString(value) || value.length > 320) {
            return false;
        }

        return this.pattern.test(value) || (this.allowName && this.fullPattern.test(value));
    }

});

},{"./Validator":122,"jii":124}],113:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.FilterValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.FilterValidator', /** @lends Jii.validators.FilterValidator.prototype */{

	__extends: Jii.validators.Validator,

	filter: null,

    skipOnEmpty: false,

    init: function() {
        this.__super();
        if (this.filter === null) {
            throw new Jii.exceptions.ApplicationException('The `filter` property must be set.');
        }
    },

    validateAttribute: function(object, attribute) {
        object.set(attribute, this.filter.call(object, object.get(attribute)));
    }

});

},{"./Validator":122,"jii":124}],114:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.InlineValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.InlineValidator', /** @lends Jii.validators.InlineValidator.prototype */{

	__extends: Jii.validators.Validator,

	method: null,

    params: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = ''; // @todo
        }
    },

    validateAttribute: function(object, attribute) {
        var method = object[this.method];

        if (!Jii._.isFunction(method)) {
            throw new Jii.exceptions.ApplicationException('Not find method `' + this.method + '` in model `' + object.debugClassName + '`.');
        }

        return method.call(object, attribute, this.params || {});
    }

});

},{"./Validator":122,"jii":124}],115:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.NumberValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.NumberValidator', /** @lends Jii.validators.NumberValidator.prototype */{

	__extends: Jii.validators.Validator,

	integerOnly: false,

    max: null,

    min: null,

    tooBig: null,

    tooSmall: null,

    integerPattern: /^\s*[+-]?\d+\s*$/,

    numberPattern: /^\s*[-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?\s*$/,

    init: function() {
        this.__super();

        if (this.message === null) {
            this.message = this.integerOnly ?
                Jii.t('jii', '{attribute} must be an integer.') :
                Jii.t('jii', '{attribute} must be an number.');
        }
        if (this.min !== null && this.tooSmall === null) {
            this.tooSmall = Jii.t('jii', '{attribute} must be no less than {min}.');
        }
        if (this.max !== null && this.tooBig === null) {
            this.tooBig = Jii.t('jii', '{attribute} must be no greater than {max}.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (Jii._.isArray(value)) {
            this.addError(object, attribute, Jii.t('{attribute} is invalid.'));
            return;
        }

        var pattern = this.integerOnly ? this.integerPattern : this.numberPattern;
        if (!pattern.test(value)) {
            this.addError(object, attribute, this.message);
        }

        if (this.min !== null && value < this.min) {
            this.addError(object, attribute, this.tooSmall, {
                min: this.min
            });
        }
        if (this.max !== null && value > this.max) {
            this.addError(object, attribute, this.tooBig, {
                max: this.max
            });
        }
    },

    validateValue: function(value) {
        var pattern = this.integerOnly ? this.integerPattern : this.numberPattern;
        return pattern.test(value) &&
            (this.min === null || value >= this.min) &&
            (this.max === null || value <= this.max);
    }

});

},{"./Validator":122,"jii":124}],116:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RangeValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RangeValidator', /** @lends Jii.validators.RangeValidator.prototype */{

	__extends: Jii.validators.Validator,

	range: null,

    strict: false,

    not: false,

    init: function() {
        this.__super();

        if (!Jii._.isArray(this.range)) {
            throw new Jii.exceptions.ApplicationException('The `range` property must be set.');
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function(value) {
        var isFined = false;

        Jii._.each(this.range, Jii._.bind(function(item) {
            if (this.strict && value === item) {
                isFined = true;
                return false;
            }

            if (!this.strict && value == item) {
                isFined = true;
                return false;
            }
        }, this));

        return !this.not ? isFined : !isFined;
    }

});

},{"./Validator":122,"jii":124}],117:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RegularExpressionValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RegularExpressionValidator', /** @lends Jii.validators.RegularExpressionValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: null,

    not: false,

    init: function() {
        this.__super();

        if (!Jii._.isRegExp(this.pattern)) {
            throw new Jii.exceptions.ApplicationException('The `pattern` property must be set.');
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is invalid.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        }
    },

    validateValue: function(value) {
        var isMatch = this.pattern.test(value);
        return !this.not ? isMatch : !isMatch;
    }

});

},{"./Validator":122,"jii":124}],118:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.RequiredValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.RequiredValidator', /** @lends Jii.validators.RequiredValidator.prototype */{

	__extends: Jii.validators.Validator,

	skipOnEmpty: false,

    requiredValue: null,

    strict: false,

    init: function () {
        this.__super();
        if (this.message === null) {
            this.message = this.requiredValue === null ?
                Jii.t('jii', '{attribute} cannot be blank.') :
                Jii.t('jii', '{attribute} must be `{requiredValue}`.');
        }
    },

    validateAttribute: function (object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            var params = this.requiredValue !== null ? {requiredValue: this.requiredValue} : {};
            this.addError(object, attribute, this.message, params);
        }
    },

    validateValue: function (value) {
        if (this.requiredValue === null) {
            return this.strict ? value !== null : !this.isEmpty(value, true);
        }
        return this.strict ? value !== this.requiredValue : value != this.requiredValue;
    }

});

},{"./Validator":122,"jii":124}],119:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.SafeValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.SafeValidator', /** @lends Jii.validators.SafeValidator.prototype */{

	__extends: Jii.validators.Validator,

	validateAttribute: function(object, attribute) {
    }

});

},{"./Validator":122,"jii":124}],120:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.StringValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.StringValidator', /** @lends Jii.validators.StringValidator.prototype */{

	__extends: Jii.validators.Validator,

	length: null,

    max: null,

    min: null,

    tooLong: null,

    tooShort: null,

    notEqual: null,

    init: function() {
        this.__super();

        if (Jii._.isArray(this.length)) {
            if (this.length[0]) {
                this.min = this.length[0];
            }
            if (this.length[1]) {
                this.max = this.length[1];
            }
            this.length = null;
        }

        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} must be a string.');
        }
        if (this.min !== null && this.tooShort === null) {
            this.tooShort = Jii.t('jii', '{attribute} should contain at least {min} characters.');
        }
        if (this.max !== null && this.tooLong === null) {
            this.tooLong = Jii.t('jii', '{attribute} should contain at most {max} characters.');
        }
        if (this.length !== null && this.notEqual === null) {
            this.notEqual = Jii.t('jii', '{attribute} should contain {length} characters.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);

        if (!Jii._.isString(value)) {
            this.addError(object, attribute, this.message);
            return;
        }

        var length = value.length;

        if (this.min !== null && length < this.min) {
            this.addError(object, attribute, this.tooShort, {
                min: this.min
            });
        }
        if (this.max !== null && length > this.max) {
            this.addError(object, attribute, this.tooLong, {
                max: this.max
            });
        }
        if (this.length !== null && length !== this.length) {
            this.addError(object, attribute, this.notEqual, {
                length: this.length
            });
        }
    },

    validateValue: function(value) {
        if (!Jii._.isString(value)) {
            return false;
        }

        var length = value.length;
        return (this.min === null || length >= this.min) &&
            (this.max === null || length <= this.max) &&
            (this.length === null || length === this.length);
    }

});

},{"./Validator":122,"jii":124}],121:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

require('./Validator');

/**
 * @class Jii.validators.UrlValidator
 * @extends Jii.validators.Validator
 */
Jii.defineClass('Jii.validators.UrlValidator', /** @lends Jii.validators.UrlValidator.prototype */{

	__extends: Jii.validators.Validator,

	pattern: /^{schemes}:\/\/(([A-Z0-9][A-Z0-9_-]*)(\.[A-Z0-9][A-Z0-9_-]*)+)/i,

    validSchemes: [
        'http',
        'https'
    ],

    defaultScheme: null,

    init: function() {
        this.__super();
        if (this.message === null) {
            this.message = Jii.t('jii', '{attribute} is not a valid URL.');
        }
    },

    validateAttribute: function(object, attribute) {
        var value = object.get(attribute);
        if (!this.validateValue(value)) {
            this.addError(object, attribute, this.message);
        } else if (this.defaultScheme !== null && value.indexOf('://') === -1) {
            object.set(attribute, this.defaultScheme + '://' + value);
        }
    },

    validateValue: function(value) {
        if (!Jii._.isString(value) || value.length > 2000) {
            return false;
        }

        if (this.defaultScheme !== null && value.indexOf('://') === -1) {
            value = this.defaultScheme + '://' + value;
        }

        var pattern = this.pattern.source;
        pattern = pattern.replace('{schemes}', '(' + this.validSchemes.join('|') + ')');

        var flags = '';
        Jii._.each({global: 'g', ignoreCase: 'i', multiline: 'm'}, Jii._.bind(function(flag, key) {
            if (this.pattern[key]) {
                flags += flag;
            }
        }, this));

        return (new RegExp(pattern, flags)).test(value);
    }

});

},{"./Validator":122,"jii":124}],122:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('jii');

/**
 * @class Jii.validators.Validator
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.validators.Validator', /** @lends Jii.validators.Validator.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.validators.Validator */{

		defaultValidators: {

			'boolean': 'Jii.validators.BooleanValidator',
			'compare': 'Jii.validators.CompareValidator',
			'date': 'Jii.validators.DateValidator',
			'default': 'Jii.validators.DefaultValueValidator',
			'double': 'Jii.validators.NumberValidator',
			'email': 'Jii.validators.EmailValidator',
			//'exist': 'Jii.validators.ExistValidator',
			//'file': 'Jii.validators.FileValidator',
			'filter': 'Jii.validators.FilterValidator',
			//'image': 'Jii.validators.ImageValidator',
			'in': 'Jii.validators.RangeValidator',
			'integer': {
				'className': 'Jii.validators.NumberValidator',
				'integerOnly': true
			},
			'match': 'Jii.validators.RegularExpressionValidator',
			'number': 'Jii.validators.NumberValidator',
			'required': 'Jii.validators.RequiredValidator',
			'safe': 'Jii.validators.SafeValidator',
			'string': 'Jii.validators.StringValidator',
			//'unique': 'Jii.validators.UniqueValidator',
			'url': 'Jii.validators.UrlValidator'
		},

		create: function (type, object, attributes, params) {
			params = params || {};
			params.attributes = attributes;

			if (Jii._.isFunction(object[type])) {
				params.className = 'Jii.validators.InlineValidator';
				params.method = type;
			} else {
				if (Jii._.has(this.defaultValidators, type)) {
					type = this.defaultValidators[type];
				}

				if (Jii._.isArray(type)) {
					Jii._.extend(params, type);
				} else {
					params.className = type;
				}
			}

			return Jii.createObject(params);
		}

	},

    attributes: [],
    message: null,
    on: [],
    except: [],
    skipOnError: true,
    skipOnEmpty: true,
    deferred: null,

    /**
     * @abstract
     * @param object
     * @param attribute
	 * @returns {Promise|null}
     */
    validateAttribute: function (object, attribute) {
    },

    validateValue: function() {
        throw new Jii.exceptions.ApplicationException('Not found implementation for method `validateValue()`.');
    },

    validate: function(object, attributes) {
        attributes = Jii._.isArray(attributes) ?
            Jii._.intersection(this.attributes, attributes) :
            this.attributes;

        var promises = Jii._.map(attributes, Jii._.bind(function(attribute) {
            if (this.skipOnError && object.hasErrors(attribute)) {
                return;
            }

            if (this.skipOnEmpty && this.isEmpty(object.get(attribute))) {
                return;
            }

            return this.validateAttribute(object, attribute);
        }, this));

        return Promise.all(promises);
    },

    isActive: function(scenario) {
        return Jii._.indexOf(this.except, scenario) === -1 &&
            (!this.on || this.on.length === 0 || Jii._.indexOf(this.on, scenario) !== -1);
    },

    addError: function(object, attribute, message, params) {
        params = params || {};
        params.attribute = object.getAttributeLabel(attribute);
        params.value = object.get(attribute);

        // @todo
        //message = Jii.t('jii', message);
        Jii._.each(params, function(value, key) {
            message = message.replace('{' + key + '}', value);
        });

        object.addError(attribute, message);
        Jii.warning('Validation error in model `' + object.className() + '`: ' + message);
    },

    isEmpty: function(value, isTrim) {
        return value === null ||
            value === '' ||
            (isTrim && Jii._.isString(value) && value.replace(/^\s+|\s+$/g, '') === '') ||
            (Jii._.isArray(value) && value.length === 0);
    }


});

},{"jii":124}],123:[function(require,module,exports){
var Jii = require('jii');
Jii._ = require('underscore');
Jii._s = require('underscore.string');

module.exports = Jii;
},{"jii":124,"underscore":155,"underscore.string":154}],124:[function(require,module,exports){
/**
 * Require relations libs and jii files
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = module.exports = window.Jii = require('./lib/Jii');

// Global libraries
Jii._ = window._ || null;
Jii._s = window._s || window.s || (window._ ? window._.string : null) || null;
Jii.isNode = false;

// Load framework files
require('./lib/application/WebApplication');
require('./lib/base/Action');
require('./lib/base/ActionEvent');
require('./lib/base/Application');
require('./lib/base/Behavior');
require('./lib/base/Component');
require('./lib/base/Context');
require('./lib/base/Controller');
require('./lib/base/Event');
require('./lib/base/HttpRequest');
require('./lib/base/ModelEvent');
require('./lib/base/Module');
require('./lib/base/Object');
require('./lib/base/Request');
require('./lib/base/Response');
require('./lib/exceptions/ApplicationException');
require('./lib/exceptions/InvalidCallException');
require('./lib/exceptions/InvalidConfigException');
require('./lib/exceptions/InvalidParamException');
require('./lib/exceptions/InvalidRouteException');
require('./lib/exceptions/NotSupportedException');
require('./lib/exceptions/UnknownPropertyException');
require('./lib/helpers/File');
require('./lib/helpers/String');
require('./lib/helpers/Url');
require('./lib/request/AnonymousAction');
require('./lib/request/HeaderCollection');
require('./lib/request/InlineAction');

},{"./lib/Jii":125,"./lib/application/WebApplication":126,"./lib/base/Action":127,"./lib/base/ActionEvent":128,"./lib/base/Application":129,"./lib/base/Behavior":130,"./lib/base/Component":131,"./lib/base/Context":132,"./lib/base/Controller":133,"./lib/base/Event":134,"./lib/base/HttpRequest":135,"./lib/base/ModelEvent":136,"./lib/base/Module":137,"./lib/base/Object":138,"./lib/base/Request":139,"./lib/base/Response":140,"./lib/exceptions/ApplicationException":141,"./lib/exceptions/InvalidCallException":142,"./lib/exceptions/InvalidConfigException":143,"./lib/exceptions/InvalidParamException":144,"./lib/exceptions/InvalidRouteException":145,"./lib/exceptions/NotSupportedException":146,"./lib/exceptions/UnknownPropertyException":147,"./lib/helpers/File":148,"./lib/helpers/String":149,"./lib/helpers/Url":150,"./lib/request/AnonymousAction":151,"./lib/request/HeaderCollection":152,"./lib/request/InlineAction":153}],125:[function(require,module,exports){
(function (process,__dirname){
/**
 * Jii — Full-Stack JavaScript Framework based on PHP Yii 2 Framework architecture.
 *
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

var Neatness = require('neatness').newContext();

/**
 * @namespace
 * @alias module:jii
 */
var Jii = Neatness.namespace('Jii');

/**
 * @class Jii
 */
Jii = Neatness.defineClass('Jii', {

	__static: /** @lends Jii */{

		/**
		 * @alias lodash
		 */
		_: null,

		/**
		 * @alias _s
		 */
		_s: null,

		/**
		 * @type module:when
		 */
		when: null,

		/**
		 * @type {Jii.base.Application}
		 */
		app: null,

		/**
		 * @type {object}
		 */
		aliases: null,

		/**
		 * True, if running in node js
		 * @type {boolean}
		 */
		isNode: false,

		_contextConfig: null,

		/**
		 * Returns framework version
		 * @returns {string}
		 */
		getVersion: function () {
			return require('../package.json').version;
		},

		/**
		 * Get class by full namespace.
		 * @param {string} name
		 * @returns {function|object}
		 */
		namespace: function (name) {
			return Jii._.isString(name) ? Neatness.namespace.apply(Neatness, arguments) : name;
		},

		/**
		 * Move namespace to other object
		 * @param {object} newContext
		 * @param {boolean} [removeFromOld]
		 * @returns {*|Function|Object}
		 */
		namespaceMoveContext: function (newContext, removeFromOld) {
			return Neatness.moveContext.apply(Neatness, arguments);
		},

		/**
		 * Method for define class. Options object will be converter to class prototype.
		 * For set static properties and methods, set param `__static` as object with properties and methods.
		 * For extends from class, set `__extends` property as extended class (function). Example format:
		 *    {
		 *      __extends: Jii.base.Object,
		 *      __static: {
		 *          staticParam: 10,
		 *          MY_CONSTANT: 'constant',
		 *          normalizeName: function() {},
		 *      },
		 *      prototypeParam: 20,
		 *      getName: function() {}
		 * }
		 * @param {string} globalName
		 * @param {object} options
		 * @return {object}
		 */
		defineClass: function (globalName, options) {
			return Neatness.defineClass.apply(Neatness, arguments);
		},

		/**
		 * Create web application, which available by Jii.app
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createWebApplication: function (config) {
			return this.createApplication('Jii.application.WebApplication', config);
		},

		/**
		 * Create console application, which available by Jii.app
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createConsoleApplication: function (config) {
			return this.createApplication('Jii.application.ConsoleApplication', config);
		},

		/**
		 * Main method which create application by class name and config.
		 * @param {string} className
		 * @param {object} config
		 * @returns {Jii.app.Application}
		 */
		createApplication: function(className, config) {
			config = config || {};
			config.application = config.application || {};

			// Save context config
			this._contextConfig = config.context || {};

			var ApplicationClass = this.namespace(className);
			if (!Jii._.isFunction(ApplicationClass)) {
				throw new Jii.exceptions.InvalidParamException('Not found application class: ' + className);
			}

			// Init aliases
			this.aliases = {};
			if (this.isNode) {
				this.aliases['@jii'] = __dirname;
			}

			// Create application instance
			return new ApplicationClass(config.application);
		},

		/**
		 * Main method which create application by class name and config.
		 * @param {object} config
		 * @returns {Jii.base.Context}
		 */
		createContext: function(config) {
			config = config || {};

			// Merge with default context config
            config = this.mergeConfigs(this._contextConfig || {}, config);

			if (config.className) {
				var ContextClass = this.namespace(config.className);
				if (!Jii._.isFunction(ContextClass)) {
					throw new Jii.exceptions.InvalidParamException('Not found context class: ' + className);
				}

				return new ContextClass(config);
			}

			return new Jii.base.Context(config);
		},

		/**
		 * Translates a path alias into an actual path.
		 *
		 * The translation is done according to the following procedure:
		 *
		 * 1. If the given alias does not start with '@', it is returned back without change;
		 * 2. Otherwise, look for the longest registered alias that matches the beginning part
		 *    of the given alias. If it exists, replace the matching part of the given alias with
		 *    the corresponding registered path.
		 * 3. Throw an exception or return false, depending on the `$throwException` parameter.
		 *
		 * For example, by default '@jii' is registered as the alias to the Jii framework directory,
		 * say '/path/to/jii'. The alias '@jii/web' would then be translated into '/path/to/jii/web'.
		 *
		 * If you have registered two aliases '@foo' and '@foo/bar'. Then translating '@foo/bar/config'
		 * would replace the part '@foo/bar' (instead of '@foo') with the corresponding registered path.
		 * This is because the longest alias takes precedence.
		 *
		 * However, if the alias to be translated is '@foo/barbar/config', then '@foo' will be replaced
		 * instead of '@foo/bar', because '/' serves as the boundary character.
		 *
		 * Note, this method does not check if the returned path exists or not.
		 *
		 * @param {string} alias the alias to be translated.
		 * @param {boolean} [throwException] whether to throw an exception if the given alias is invalid.
		 * If this is false and an invalid alias is given, false will be returned by this method.
		 * @return {string|boolean} the path corresponding to the alias, false if the root alias is not previously registered.
		 * @throws {Jii.exceptions.InvalidParamException} if the alias is invalid while throwException is true.
		 * @see setAlias()
		 */
		getAlias: function (alias, throwException) {
			if (Jii._.isUndefined(throwException)) {
				throwException = true;
			}

			if (alias.indexOf('@') !== 0) {
				return alias;
			}

			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (Jii._.has(this.aliases, root)) {
				if (Jii._.isString(this.aliases[root])) {
					return this.aliases[root] + (index !== -1 ? alias.substr(index) : '');
				}

				var finedPath = null;
				Jii._.each(this.aliases[root], function (path, name) {
					var testAlias = alias + '/';
					if (testAlias.indexOf(name + '/') === 0) {
						finedPath = path + alias.substr(name.length);
						return false;
					}
				});
				if (finedPath !== null) {
					return finedPath;
				}
			}

			if (throwException) {
				throw new Jii.exceptions.InvalidParamException('Invalid path alias: ' + alias);
			}
			return false;
		},

		/**
		 * Returns the root alias part of a given alias.
		 * A root alias is an alias that has been registered via [[setAlias()]] previously.
		 * If a given alias matches multiple root aliases, the longest one will be returned.
		 * @param {string} alias the alias
		 * @return {string|boolean} the root alias, or false if no root alias is found
		 */
		getRootAlias: function (alias) {
			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (Jii._.has(this.aliases, root)) {
				if (Jii._.isString(this.aliases[root])) {
					return root;
				}

				var finedPath = null;
				Jii._.each(this.aliases[root], function (path, name) {
					if (Jii._.indexOf(alias + '/', name + '/') === 0) {
						finedPath = name;
						return false;
					}
				});
				if (finedPath !== null) {
					return finedPath;
				}
			}

			return false;
		},

		/**
		 * Registers a path alias.
		 *
		 * A path alias is a short name representing a long path (a file path, a URL, etc.)
		 * For example, we use '@jii' as the alias of the path to the Jii framework directory.
		 *
		 * A path alias must start with the character '@' so that it can be easily differentiated
		 * from non-alias paths.
		 *
		 * Note that this method does not check if the given path exists or not. All it does is
		 * to associate the alias with the path.
		 *
		 * Any trailing '/' and '\' characters in the given path will be trimmed.
		 *
		 * @param {string} alias the alias name (e.g. "@jii"). It must start with a '@' character.
		 * It may contain the forward slash '/' which serves as boundary character when performing
		 * alias translation by [[getAlias()]].
		 * @param {string} path the path corresponding to the alias. Trailing '/' and '\' characters
		 * will be trimmed. This can be
		 *
		 * - a directory or a file path (e.g. `/tmp`, `/tmp/main.txt`)
		 * - a URL (e.g. `http://example.com`)
		 * - a path alias (e.g. `@jii/base`). In this case, the path alias will be converted into the
		 *   actual path first by calling [[getAlias()]].
		 *
		 * @throws {Jii.exceptions.InvalidParamException} if $path is an invalid alias.
		 * @see getAlias()
		 */
		setAlias: function (alias, path) {
			if (alias.indexOf('@') !== 0) {
				alias = '@' + alias;
			}

			var index = alias.indexOf('/');
			var root = index === -1 ? alias : alias.substr(0, index);

			if (path !== null) {
				path = alias.indexOf('@') !== 0 ? Jii._s.rtrim(path, '/') : this.getAlias(path);

				if (!Jii._.has(this.aliases, root)) {
					if (index === -1) {
						this.aliases[root] = path;
					} else {
						this.aliases[root] = {};
						this.aliases[root][alias] = path;
					}
				} else if (Jii._.isString(this.aliases[root])) {
					if (index === -1) {
						this.aliases[root] = path;
					} else {
						var oldPath = this.aliases[root];
						this.aliases[root] = {};
						this.aliases[root][alias] = path;
						this.aliases[root][root] = oldPath;
					}
				} else {
					this.aliases[root][alias] = path;
					//krsort(static::$aliases[$root]);
				}
			} else if (Jii._.has(this.aliases, root)) {
				if (Jii._.isObject(this.aliases[root])) {
					delete this.aliases[root][alias];
				} else if (index === -1) {
					delete this.aliases[root];
				}
			}
		},

		/**
		 * Creates a new instance using the given configuration.
		 * @param {string|object} config Class name or object with param `className`
		 * @returns {object}
		 */
		createObject: function (config) {
			var className = null;

			// Normalize config
			if (Jii._.isString(config)) {
				className = config;
				config = {};
			} else if (Jii._.has(config, 'className')) {
				config = Jii._.clone(config);
				className = config.className;
				delete config.className;
			} else {
				throw new Jii.exceptions.ApplicationException('Wrong configuration for create object.');
			}

			// Get class
			var objectClass = Jii.namespace(className);
			if (!Jii._.isFunction(objectClass)) {
				throw new Jii.exceptions.ApplicationException('Not found class `' + className + '` for create instance.');
			}

			// Arguments for constructor of class
			var args = [objectClass];
			args = args.concat(Jii._.rest(arguments));
			if (!Jii._.isEmpty(config)) {
				args.push(config);
			}

			// @todo Support old browsers (bind function)
			return new (objectClass.bind.apply(objectClass, args))();
		},

		/**
		 * Set configuration to object. This method find public param in object or setter method.
		 * You can not use setter and public param at the same time for safety reason
		 * @param {Jii.base.Object} object Class instance
		 * @param {object} config Configuration object {key: value, ..}
		 */
		configure: function (object, config) {
			for (var key in config) {
				if (!config.hasOwnProperty(key)) {
					continue;
				}

                if (object instanceof Jii.base.Component) {
                    object.set(key, config[key]);
                    continue;
                }

				// Generate setter name
				var setter = 'set' + Jii._s.capitalize(key);

				if (!Jii._.isFunction(object[setter])) {
					if (Jii._.isFunction(object[key])) {
						throw new Jii.exceptions.InvalidConfigException('You can not replace from config function `' + key + '` in object `' + object.className() + '`.');
					}

					if (Jii._.isUndefined(object[key])) {
						throw new Jii.exceptions.InvalidConfigException('Config param `' + key + '` is undefined in object `' + object.className() + '`.');
					}
				}

				if (!Jii._.isUndefined(object[key]) && !Jii._.isFunction(object[key]) && Jii._.isFunction(object[setter])) {
					throw new Jii.exceptions.InvalidConfigException('You have two setters (function and public param) for config param `' + key + '` in object `' + object.className() + '`.  Please change param access (to `_' + key + '`) or remove setter method.');
				}

				if (!Jii._.isUndefined(object[key]) && !Jii._.isFunction(object[key])) {
					if (Jii._.isObject(object[key]) && Jii._.isObject(config[key]) && !Jii._.isArray(object[key]) && !Jii._.isArray(config[key])) {
						object[key] = Jii.mergeConfigs(object[key], config[key]);
					} else {
						object[key] = config[key];
					}
				} else if (Jii._.isFunction(object[setter])) {
					object[setter].call(object, config[key]);
				}
			}
		},

		/**
		 * Logs a trace message.
		 * Trace messages are logged mainly for development purpose to see
		 * the execution work flow of some code.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		trace: function (message, category) {
			category = category || '';

			console.log(message);
			//if (YII_DEBUG) {
				// @todo static.getLogger().log(message, Logger.LEVEL_TRACE, category);
			//}
		},

		/**
		 * Logs an error message.
		 * An error message is typically logged when an unrecoverable error occurs
		 * during the execution of an application.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		error: function (message, category) {
			category = category || '';

			console.error(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_ERROR, category);
		},

		/**
		 * Logs a warning message.
		 * A warning message is typically logged when an error occurs while the execution
		 * can still continue.
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		warning: function (message, category) {
			category = category || '';

			console.warn(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_WARNING, category);
		},

		/**
		 * Logs an informative message.
		 * An informative message is typically logged by an application to keep record of
		 * something important (e.g. an administrator logs in).
		 * @param {string} message the message to be logged.
		 * @param {string} [category] the category of the message.
		 */
		info: function (message, category) {
			category = category || '';

			console.info(message);
			// @todo static.getLogger().log(message, Logger.LEVEL_INFO, category);
		},

		/**
		 * Short alias for translate texts
		 * @param group
		 * @param [message]
		 * @returns {*}
		 */
		t: function (group, message) {
			// @todo
			return message;
		},

        /**
         * @param {object} [obj]
         * @param {object} [obj]
         * @param {object} [obj]
         * @param {object} [obj]
         * @returns {object}
         */
        mergeConfigs: function(obj) {
            var dst = {};

            for (var i = 0, ii = arguments.length; i < ii; ++i) {
                var obj = arguments[i];
                if (!Jii._.isObject(obj)) {
                    continue;
                }

                for (var key in obj) {
                    if (obj.hasOwnProperty(key)) {
                        if (Jii._.isObject(obj[key]) && !Jii._.isArray(obj[key]) && !Jii._.isFunction(obj[key])) {
                            dst[key] = this.mergeConfigs(dst[key], obj[key]);
                        } else {
                            dst[key] = obj[key];
                        }
                    }
                }
            }

            return dst;
        },

        catchHandler: function(e) {
            console.error(e.stack || e)
        }
	}

});

// @todo Move to Errors module
process.on('unhandledRejection', function(reason, promise) {
    console.warn("Possibly Unhandled Rejection at: Promise ", promise, " reason: ", reason);
});

/**
 * @module Jii
 */
module.exports = Jii;
}).call(this,require('_process'),"/../../../jii/lib")
},{"../package.json":156,"_process":30,"neatness":157}],126:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Application');

/**
 * @class Jii.application.WebApplication
 * @extends Jii.base.Application
 */
Jii.defineClass('Jii.application.WebApplication', /** @lends Jii.application.WebApplication.prototype */{

	__extends: Jii.base.Application,

	/**
	 * @var {string|boolean} the layout that should be applied for views in this application. Defaults to 'main'.
	 * If this is false, layout will be disabled.
	 */
	layout: 'main',

    defaultRoute: 'site',

	_preInit: function(config) {
		this.__super(config);

		// Set default webroot
		this.setWebPath(config.webPath || this.getBasePath() + '/web');
		this.setWebUrl(config.webUrl || '/');
	},

	/**
	 * @return {String}
	 */
	getWebPath: function () {
		return Jii.getAlias('@webroot');
	},

	/**
	 * @param  {String} path
	 */
	setWebPath: function (path) {
		Jii.setAlias('@webroot', path);
	},

	/**
	 * @return {String}
	 */
	getWebUrl: function () {
		return Jii.getAlias('@web');
	},

	/**
	 * @param  {String} path
	 */
	setWebUrl: function (path) {
		Jii.setAlias('@web', path);
	}

});
},{"../Jii":125,"../base/Application":129}],127:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Action
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Action', /** @lends Jii.base.Action.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @type {string} ID of the action
	 */
	id: null,

	/**
	 * @type {Jii.base.Controller} the controller that owns this action
	 */
	controller: null,

	constructor: function (id, controller, config) {
		this.id = id;
		this.controller = controller;
		this.__super(config);
	},

	/**
	 * Returns the unique ID of this action among the whole application.
	 * @returns {string} the unique ID of this action among the whole application.
	 */
	getUniqueId: function () {
		return this.controller.getUniqueId() + '/' + this.id;
	},

	/**
	 * @param {Jii.base.Context} context
	 */
	run: function (context) {
	},

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {Promise} the result of the action
	 * @throws {Jii.exceptions.InvalidConfigException} if the action class does not have a run() method
	 */
	runWithParams: function (context) {
		if (!Jii._.isFunction(this.run)) {
			throw new Jii.exceptions.InvalidConfigException(this.debugClassName + ' must define a `run()` method.');
		}

		//Yii::trace('Running action: ' . get_class($this) . '::run()', __METHOD__);

		return Promise.resolve(this.beforeRun(context))
			.then(Jii._.bind(function (bool) {
				if (!bool) {
					return Promise.reject();
				}

				return this.run(context);
			}, this))
			.then(Jii._.bind(function (result) {
				return Promise.resolve(this.afterRun()).then(function () {
					return result;
				});
			}, this));
	},

	/**
	 * This method is called right before `run()` is executed.
	 * You may override this method to do preparation work for the action run.
	 * If the method returns false, it will cancel the action.
	 * @param {Jii.base.Context} context
	 * @return {Promise|boolean} whether to run the action.
	 */
	beforeRun: function (context) {
		return true;
	},

	/**
	 * This method is called right after `run()` is executed.
	 * You may override this method to do post-processing work for the action run.
	 */
	afterRun: function () {
	}

});

},{"../Jii":125,"./Object":138}],128:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Event');

/**
 * @class Jii.base.ActionEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.base.ActionEvent', /** @lends Jii.base.ActionEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * @type {Jii.base.Action}
	 */
	action: null,

	/**
	 * @type {Jii.base.Context}
	 */
	context: null

});

},{"../Jii":125,"./Event":134}],129:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Module');

/**
 * @class Jii.base.Application
 * @extends Jii.base.Module
 */
Jii.defineClass('Jii.base.Application', /** @lends Jii.base.Application.prototype */{

	__extends: Jii.base.Module,

	__static: /** @lends Jii.base.Application */{

		ENVIRONMENT_PRODUCTION: 'production',
		ENVIRONMENT_DEVELOPMENT: 'development',
		ENVIRONMENT_TEST: 'test'

	},

	/**
	 * @type {string} the namespace that controller classes are in. If not set,
	 * it will use the "app\controllers" namespace.
	 */
	controllerNamespace: 'app.controllers',

	/**
	 * @type {string} the application name.
	 */
	name: 'My Application',

	/**
	 * @type {string} the version of this application.
	 */
	version: '1.0',

	/**
	 * @type {string} the charset currently used for the application.
	 */
	charset: 'UTF-8',

	/**
	 * @type {string} the language that is meant to be used for end users.
	 * @see sourceLanguage
	 */
	language: 'en',

	/**
	 * @type {string} the language that the application is written in. This mainly refers to
	 * the language that the messages and view files are written in.
	 * @see language
	 */
	sourceLanguage: 'en',

	/**
	 * The IDs of the components or modules that should be preloaded right after initialization.
	 * @type {string[]}
	 */
	bootstrap: null,

	/**
	 * @type {string}
	 */
	environment: 'development',

	/**
	 * @constructs
	 */
	constructor: function (config) {
		Jii.app = this;

		this.bootstrap = [];

		// Merge with default config
		config = Jii.mergeConfigs(this._getBaseConfig(), config);

		this._preInit(config);
		this._loadBootstrapComponents();

		this.__super(null, null, config);
	},

	/**
	 *
	 * @returns {string}
	 */
	getUniqueId: function () {
		return '';
	},

	/**
	 * Sets the root directory of the application and the @app alias.
	 * This method can only be invoked at the beginning of the constructor.
	 * @param {string} path the root directory of the application.
	 */
	setBasePath: function (path) {
		this.__super(path);
		Jii.setAlias('@app', this.getBasePath());
	},

	/**
	 * Overwrite this method for return default configuration specified for application
	 * @type {object} base application's config.
	 */
	_getBaseConfig: function() {
		return {};
	},

	/**
	 *
	 * @param config
	 * @private
	 */
	_preInit: function (config) {
		if (Jii._.has(config, 'basePath')) {
			this.setBasePath(config.basePath);
			delete config.basePath;
		} else {
			throw new Jii.exceptions.InvalidConfigException('The `basePath` configuration is required.');
		}
	},

	/**
	 * Loads components that are declared in [[bootstrap]].
	 * @throws {Jii.exceptions.InvalidConfigException} if a component or module to be preloaded is unknown
	 */
	_loadBootstrapComponents: function () {
		Jii._.each(this.bootstrap, Jii._.bind(function (id) {
			if (this.hasComponent(id)) {
				this.getComponent(id);
			} else if (this.hasModule(id)) {
				this.getModule(id);
			} else {
				throw new Jii.exceptions.InvalidConfigException("Unknown component or module: " + id);
			}
		}, this));
	}
});

},{"../Jii":125,"./Module":137}],130:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Behavior
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Behavior', /** @lends Jii.base.Behavior.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {Jii.base.Component} the owner of this behavior
	 */
	owner: null,

	/**
	 * Declares event handlers for the [[owner]]'s events.
	 *
	 * Child classes may override this method to declare what callbacks should
	 * be attached to the events of the [[owner]] component.
	 *
	 * The callbacks will be attached to the [[owner]]'s events when the behavior is
	 * attached to the owner; and they will be detached from the events when
	 * the behavior is detached from the component.
	 *
	 * The callbacks can be any of the followings:
	 *
	 * - method in this behavior: `'handleClick'`
	 * - anonymous function: `function (event) { ... }`
	 * - method with context: `{callback: function (event) { ... }, context: this}`
	 *
	 * The following is an example:
	 *
	 * ~~~
	 * {
	 *     beforeValidate: 'myBeforeValidate',
	 *     afterValidate: {
	 *         callback: function() {},
	 *         context: this
	 *     }
	 * }
	 * ~~~
	 *
	 * @return {object} events (array keys) and the corresponding event handler methods (array values).
	 */
	events: function () {
		return {};
	},

	/**
	 * Attaches the behavior object to the component.
	 * The default implementation will set the [[owner]] property
	 * and attach event handlers as declared in [[events]].
	 * Make sure you call the parent implementation if you override this method.
	 * @param {Jii.base.Component} owner the component that this behavior is to be attached to.
	 */
	attach: function (owner) {
		this.owner = owner;

		Jii._.each(this.events(), Jii._.bind(function(handler, event) {
			handler = Jii.base.Event.normalizeHandler(handler, this);
			this.owner.on(event, handler);
		}, this));
	},

	/**
	 * Detaches the behavior object from the component.
	 * The default implementation will unset the [[owner]] property
	 * and detach event handlers declared in [[events]].
	 * Make sure you call the parent implementation if you override this method.
	 */
	detach: function () {
		if (!this.owner) {
			return;
		}

		Jii._.each(this.events(), Jii._.bind(function(handler, event) {
			handler = Jii.base.Event.normalizeHandler(handler, this);
			this.owner.off(event, handler);
		}, this));
		this.owner = null;
	}

});

},{"../Jii":125,"./Object":138}],131:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Component
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Component', /** @lends Jii.base.Component.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {object} the attached event handlers (event name: handlers)
	 */
	_events: null,

	/**
	 * @var {object} the attached behaviors (behavior name: behavior)
	 */
	_behaviors: null,

	/**
	 * @constructor
	 */
	constructor: function () {
		// Proxy behaviour methods
		this.proxyBehaviors();

		this.__super.apply(this, arguments);
	},

	/**
	 * Returns a list of behaviors that this component should behave as.
	 *
	 * Child classes may override this method to specify the behaviors they want to behave as.
	 *
	 * The return value of this method should be an array of behavior objects or configurations
	 * indexed by behavior names. A behavior configuration can be either a string specifying
	 * the behavior class or an array of the following structure:
	 *
	 * ~~~
	 * behaviorName: {
	 *     class: 'BehaviorClass',
	 *     property1: 'value1',
	 *     property2: 'value2'
	 * }
	 * ~~~
	 *
	 * Note that a behavior class must extend from [[Jii.base.Behavior]]. Behavior names can be strings
	 * or integers. If the former, they uniquely identify the behaviors. If the latter, the corresponding
	 * behaviors are anonymous and their properties and methods will NOT be made available via the component
	 * (however, the behaviors can still respond to the component's events).
	 *
	 * Behaviors declared in this method will be attached to the component automatically (on demand).
	 *
	 * @return {object} the behavior configurations.
	 */
	behaviors: function () {
		return {};
	},

	/**
	 * Returns a value indicating whether there is any handler attached to the named event.
	 * @param {string} name the event name
	 * @return {boolean} whether there is any handler attached to the event.
	 */
	hasEventHandlers: function (name) {
		this.ensureBehaviors();

		return this._events && this._events[name] && this._events[name].length > 0 ? true : false;// @todo || Event::hasHandlers(this, name);
	},

	/**
	 * Attaches an event handler to an event.
	 *
	 * The event handler must be a valid PHP callback. The followings are
	 * some examples:
	 *
	 * ~~~
	 * function (event) { ... }         // anonymous function
	 * ~~~
	 *
	 * The event handler must be defined with the following signature,
	 *
	 * ~~~
	 * function (event)
	 * ~~~
	 *
	 * where `event` is an [[Jii.base.Event]] object which includes parameters associated with the event.
	 *
	 * @param {string|string[]} name the event name
	 * @param {function} handler the event handler
	 * @param {*} [data] the data to be passed to the event handler when the event is triggered.
	 * When the event handler is invoked, this data can be accessed via data.
	 * @param {boolean} [isAppend] whether to append new event handler to the end of the existing
	 * handler list. If false, the new handler will be inserted at the beginning of the existing
	 * handler list.
	 * @see off()
	 */
	on: function (name, handler, data, isAppend) {
		data = data || null;
		isAppend = Jii._.isUndefined(isAppend) ? true : isAppend;

        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            Jii._.each(name, function(n) {
                this.on(n, handler, data, isAppend)
            }.bind(this));
            return;
        } else {
            name = name[0];
        }

        this.ensureBehaviors();
		if (isAppend || !this._events || !this._events[name]) {
			this._events = this._events || {};
			this._events[name] = this._events[name] || [];
			this._events[name].push([handler, data]);
		} else {
			this._events[name].unshift([handler, data]);
		}
	},

	/**
	 * Detaches an existing event handler from this component.
	 * This method is the opposite of [[on()]].
	 * @param {string|string[]} name event name
	 * @param {function} [handler] the event handler to be removed.
	 * If it is null, all handlers attached to the named event will be removed.
	 * @return boolean if a handler is found and detached
	 * @see on()
	 */
	off: function (name, handler) {
		handler = handler || null;

        // Multiple names support
        name = this._normalizeEventNames(name);
        if (name.length > 1) {
            var bool = false;
            Jii._.each(name, function(n) {
                if (this.on(n, handler)) {
                    bool = true;
                }
            }.bind(this));
            return bool;
        } else {
            name = name[0];
        }

		this.ensureBehaviors();
		if (!this._events || !this._events[name]) {
			return false;
		}

		if (handler === null) {
			delete this._events[name];
			return true;
		}

		var newEvents = [];
		var isRemoved = false;
		Jii._.each(this._events[name], function(event, i) {
            if (Jii._.isObject(handler) && Jii._.has(handler, 'context') && Jii._.isFunction(handler.callback)) {
                if (event.callback !== handler.callback || event.context !== handler.context) {
                    newEvents.push(event);
                } else {
                    isRemoved = true;
                }
            } else {
                if (event.callback !== handler.callback) {
                    newEvents.push(event);
                } else {
                    isRemoved = true;
                }
            }
        }.bind(this));
		this._events[name] = newEvents;

		return isRemoved;
	},

    _normalizeEventNames: function(names) {
        return Jii._.isString(names) ?
            names.split(/[ ,]+/) :
            names;
    },

	/**
	 * Triggers an event.
	 * This method represents the happening of an event. It invokes
	 * all attached handlers for the event including class-level handlers.
	 * @param {string} name the event name
	 * @param {Jii.base.Event} [event] the event parameter. If not set, a default [[Jii.base.Event]] object will be created.
	 */
	trigger: function (name, event) {
		this.ensureBehaviors();
		if (this._events && this._events[name]) {
			if (event === null) {
				event = new Jii.base.Event();
			}
			if (!(event instanceof Jii.base.Event)) {
				event = new Jii.base.Event({
					params: event
				});
			}

			if (event.sender === null) {
				event.sender = this;
			}

			event.handled = false;
			event.name = name;

			var isStopped = false;
			Jii._.each(this._events[name], function(handler) {
				if (isStopped) {
					return;
				}

				event.data = handler[1];
				handler[0] = Jii.base.Event.normalizeHandler(handler[0]);
				handler[0].callback.call(handler[0].context, event);

				// stop further handling if the event is handled
				if (event.handled) {
					isStopped = true;
				}
			});
		}

		// invoke class-level attached handlers
		Jii.base.Event.trigger(this, name, event);
	},

	/**
	 * Returns the named behavior object.
	 * @param {string} name the behavior name
	 * @return {Jii.base.Behavior} the behavior object, or null if the behavior does not exist
	 */
	getBehavior: function (name) {
		this.ensureBehaviors();

		return this._behaviors && this._behaviors[name] ? this._behaviors[name] : null;
	},

	/**
	 * Returns all behaviors attached to this component.
	 * @return {object} list of behaviors attached to this component
	 */
	getBehaviors: function () {
		this.ensureBehaviors();

		return this._behaviors;
	},

	/**
	 * Attaches a behavior to this component.
	 * This method will create the behavior object based on the given
	 * configuration. After that, the behavior object will be attached to
	 * this component by calling the attach method.
	 * @param {string} name the name of the behavior.
	 * @param {string|Jii.base.Behavior[]|Jii.base.Behavior} behavior the behavior configuration. This can be one of the following:
	 *
	 *  - a [[Jii.base.Behavior]] object
	 *  - a string specifying the behavior class
	 *  - an object configuration array that will be passed to [[Jii.createObject()]] to create the behavior object.
	 *
	 * @return {Jii.base.Behavior} the behavior object
	 * @see detachBehavior()
	 */
	attachBehavior: function (name, behavior) {
		this.ensureBehaviors();

		return this._attachBehaviorInternal(name, behavior);
	},

	/**
	 * Attaches a list of behaviors to the component.
	 * Each behavior is indexed by its name and should be a [[Jii.base.Behavior]] object,
	 * a string specifying the behavior class, or an configuration array for creating the behavior.
	 * @param {[]} behaviors list of behaviors to be attached to the component
	 * @see attachBehavior()
	 */
	attachBehaviors: function (behaviors) {
		this.ensureBehaviors();

		Jii._.each(behaviors, Jii._.bind(function(behavior, name) {
			this._attachBehaviorInternal(name, behavior);
		}, this));
	},

	/**
	 * Detaches a behavior from the component.
	 * The behavior's detach method will be invoked.
	 * @param {string} name the behavior's name.
	 * @return {Jii.base.Behavior} the detached behavior. Null if the behavior does not exist.
	 */
	detachBehavior: function (name) {
		this.ensureBehaviors();
		if (this._behaviors && this._behaviors[name]) {
			var behavior = this._behaviors[name];
			delete this._behaviors[name];
			behavior.detach();

			return behavior;
		}

		return null;
	},

	/**
	 * Detaches all behaviors from the component.
	 */
	detachBehaviors: function () {
		this.ensureBehaviors();

		Jii._.each(Jii._.keys(this._behaviors), Jii._.bind(this.detachBehavior, this));
	},

	/**
	 * Makes sure that the behaviors declared in [[behaviors()]] are attached to this component.
	 */
	ensureBehaviors: function () {
		if (this._behaviors !== null) {
			return;
		}

		this._behaviors = [];
		Jii._.each(this.behaviors(), Jii._.bind(function(behavior, name) {
			this._attachBehaviorInternal(name, behavior);
		}, this));
	},

	/**
	 *
	 */
	proxyBehaviors: function () {
		Jii._.each(this.behaviors(), Jii._.bind(function(behavior, name) {
			var className = Jii._.isString(behavior) ? behavior : behavior.className;
			this._proxyBehaviorInternal(name, className);
		}, this));
	},

	/**
	 * Attaches a behavior to this component.
	 * @param {string} name the name of the behavior.
	 * @param {string|Jii.base.Behavior[]|Jii.base.Behavior} behavior the behavior to be attached
	 * @return {Jii.base.Behavior} the attached behavior.
	 * @private
	 */
	_attachBehaviorInternal: function (name, behavior) {
		if (!(behavior instanceof Jii.base.Behavior)) {
			behavior = Jii.createObject(behavior);
		}

		if (this._behaviors[name]) {
			this._behaviors[name].detach();
		}
		behavior.attach(this);

		this._proxyBehaviorInternal(name, behavior.className());

		this._behaviors[name] = behavior;
		return behavior;
	},

	/**
	 *
	 */
	_proxyBehaviorInternal: function (behaviorName, className) {
		var behaviorClass = Jii.namespace(className);

		while (true) {
			if (!behaviorClass || !behaviorClass.prototype || className === 'Jii.base.Behavior') {
				break;
			}

			for (var name in behaviorClass.prototype) {
				if (!behaviorClass.prototype.hasOwnProperty(name)) {
					continue;
				}

				// Skip constructor and non-public methods
				if (name === 'constructor' || name.substr(0, 1) === '_') {
					continue;
				}

				// Skip properties
				if (!Jii._.isFunction(behaviorClass.prototype[name])) {
					continue;
				}

				this[name] = this._getProxyBehaviorMethod(behaviorName, name);
			}

			className = behaviorClass.parentClassName();
			behaviorClass = Jii.namespace(className);
		}
	},

	_getProxyBehaviorMethod: function(behaviorName, methodName) {
		var context = this;

		return function() {
			return context.getBehavior(behaviorName)[methodName].apply(context, arguments);
		};
	},

	hasProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		return this.canGetProperty(name, checkVars, checkBehaviors) || this.canSetProperty(name, false, checkBehaviors);
	},

	// @todo move get, set to Object
	set: function(name, value) {
        // Object format support
        if (Jii._.isObject(name)) {
            Jii._.each(name, function(value, name) {
                this.set(name, value);
            }.bind(this));
            return;
        }

		// Generate setter name
		var setter = 'set' + Jii._s.capitalize(name);

		if (Jii._.isFunction(this[setter])) {
			this[setter].call(this, value);
		} else if (this.hasOwnProperty(name)) {
			this[name] = value;
		} else if (name.substr(0, 3) === 'on ') {
            this.on(name.substr(3), value);
		} else if (name.substr(0, 3) === 'as ') {
            this.attachBehavior(name.substr(3), value instanceof Jii.base.Behavior ? value : Jii.createObject(value));
		} else {
			// @todo as, see Component Yii2

			throw new Jii.exceptions.UnknownPropertyException('Setting unknown property: ' + this.className() + '.' + name);
		}
	},

	canSetProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		var setter = 'set' + Jii._s.capitalize(name);
		if (Jii._.isFunction(this[setter]) || (checkVars && this.hasOwnProperty(name))) {
			return true;
		} else if (checkBehaviors) {

		}

		return false;
	},

	get: function(name) {
		// Generate getter name
		var setter = 'get' + Jii._s.capitalize(name);

		if (Jii._.isFunction(this[setter])) {
			return this[setter].call(this);
		} else if (this.hasOwnProperty(name)) {
			return this[name];
		} else {
			throw new Jii.exceptions.UnknownPropertyException('Getting unknown property: ' + this.className() + '.' + name);
		}
	},

	canGetProperty: function(name, checkVars, checkBehaviors) {
		checkVars = checkVars !== false;
		checkBehaviors = checkBehaviors !== false;

		var getter = 'get' + Jii._s.capitalize(key);
		if (Jii._.isFunction(this[getter]) || (checkVars && this.hasOwnProperty(name))) {
			return true;
		} else if (checkBehaviors) {

		}

		return false;
	}

});

},{"../Jii":125,"./Object":138}],132:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Component');

/**
 * @class Jii.base.Context
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Context', /** @lends Jii.base.Context.prototype */{

	__extends: Jii.base.Component,

	/**
	 * Custom context parameters (name => value).
	 * @type {object}
	 */
	params: {},

	/**
	 * @type {object}
	 */
	_components: {},

	/**
	 * Checks whether the named component exists.
	 * @param {string} id component ID
	 * @return {boolean} whether the named component exists. Both loaded and unloaded components
	 * are considered.
	 */
	hasComponent: function (id) {
		return Jii._.has(this._components, id);
	},

	/**
	 * Retrieves the named component.
	 * @param {string} id component ID (case-sensitive)
	 * @return {Jii.base.Component|null} the component instance, null if the component does not exist.
	 */
	getComponent: function (id) {
		return this._components[id] || null;
	},

	/**
	 * Registers a component with this module.
	 * @param {string} id component ID
	 * @param {Jii.base.Component|array|null} component the component to be registered with the module. This can
	 * be one of the followings:
	 *
	 * - a [[Jii.base.Component]] object
	 * - a configuration array: when [[getComponent()]] is called initially for this component, the array
	 *   will be used to instantiate the component via [[Jii.createObject()]].
	 * - null: the named component will be removed from the module
	 */
	setComponent: function (id, component) {
		if (component === null) {
			delete this._components[id];
		} else {
			// Create component instance
			if (!(component instanceof Jii.base.Component)) {
				component = Jii.createObject(component);
			}

			// Add links
			this[id] = this._components[id] = component;
		}
	},

	/**
	 * Returns the registered components.
	 * @return {Jii.base.Component[]} the components (indexed by their IDs)
	 */
	getComponents: function () {
		return this._components;
	},

	/**
	 * Registers a set of components in this module.
	 *
	 * Each component should be specified as a name-value pair, where
	 * name refers to the ID of the component and value the component or a configuration
	 * array that can be used to create the component. In the latter case, [[Jii.createObject()]]
	 * will be used to create the component.
	 *
	 * If a new component has the same ID as an existing one, the existing one will be overwritten silently.
	 *
	 * The following is an example for setting two components:
	 *
	 * ~~~
	 * {
     *     db: {
     *         class: 'Jii.db.Connection',
     *         dsn: 'sqlite:path/to/file.db'
     *     },
     *     cache: {
     *         class: 'Jii.caching.DbCache',
     *         db: 'db'
     *     }
     * }
	 * ~~~
	 *
	 * @param {array} components components (id => component configuration or instance)
	 */
	setComponents: function (components) {
		Jii._.each(components, Jii._.bind(function (component, id) {
			// Extend default class name
			if (!(component instanceof Jii.base.Component) && this._components[id] && !component.className) {
				component.className = this._components[id].className;
			}

			this.setComponent(id, component);
		}, this));
	},

	/**
	 * Loads components that are declared in [[preload]].
	 * @throws {Jii.exceptions.InvalidConfigException} if a component or module to be preloaded is unknown
	 */
	preloadComponents: function () {
		Jii._.each(this.preload, Jii._.bind(function (id) {
			if (this.hasComponent(id)) {
				this.getComponent(id);
			} else if (this.hasModule(id)) {
				this.getModule(id);
			} else {
				throw new Jii.exceptions.InvalidConfigException("Unknown component or module: " + id);
			}
		}, this));
	}

});

},{"../Jii":125,"./Component":131}],133:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Controller
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Controller', /** @lends Jii.base.Controller.prototype */{

	__extends: Jii.base.Component,

    __static: /** @lends Jii.base.Controller */{

        /**
         * @event Jii.base.Module#beforeAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_BEFORE_ACTION: 'beforeAction',

        /**
         * @event Jii.base.Module#afterAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_AFTER_ACTION: 'afterAction'

    },

	/**
	 * @type {string} The ID of this controller.
	 */
	id: null,

	/**
	 * @type {Jii.base.Module} The module that this controller belongs to.
	 */
	module: null,

	/**
	 * @type {string} The ID of the action that is used when the action ID is not specified
	 * in the request. Defaults to 'index'.
	 */
	defaultAction: 'index',

	/**
	 * @type {string|boolean} the name of the layout to be applied to this controller's views.
	 * This property mainly affects the behavior of [[render()]].
	 * Defaults to null, meaning the actual layout value should inherit that from [[module]]'s layout value.
	 * If false, no layout will be applied.
	 */
	layout: null,

	/**
	 * The view object that can be used to render views or view files.
	 * @type {Jii.view.View}
	 */
	_view: null,

	/**
	 * @constructor
	 */
	constructor: function (id, moduleObject, config) {
		this.id = id;
		this.module = moduleObject;
		this.__super(config);
	},

	/**
	 * Declares external actions for the controller.
	 * This method is meant to be overwritten to declare external actions for the controller.
	 * It should return an array, with array keys being action IDs, and array values the corresponding
	 * action class names or action configuration arrays. For example,
	 *
	 * ~~~
	 * return {
     *     'action1': 'app.components.Action1',
     *     'action2': {
     *         'className': 'app.components.Action2',
     *         'property1': 'value1',
     *         'property2': 'value2'
     *     }
     * };
	 * ~~~
	 *
	 * [[Jii.createObject()]] will be used later to create the requested action
	 * using the configuration provided here.
	 * @returns {object}
	 */
	actions: function () {
		return {};
	},

	/**
	 * Runs a request specified in terms of a route.
	 * @param {string} route the route to be handled, e.g., 'view', 'comment/view', 'admin/comment/view'.
	 * @param {Jii.base.Context} context
	 * @return {Promise}
	 */
	run: function (route, context) {
		var slashIndex = route.indexOf('/');
		if (slashIndex === -1) {
			return this.runAction(route, context);
		} else if (slashIndex > 0) {
			return this.module.runAction(route, context);
		}

		route = Jii._s.ltrim(route, '/');
		return Jii.app.runAction(route, context);
	},

	/**
	 * Runs an action within this controller with the specified action ID and parameters.
	 * If the action ID is empty, the method will use [[defaultAction]].
	 * @param {string} id The ID of the action to be executed.
	 * @param {Jii.base.Context} context
	 * @return {Promise} The result of the action.
	 * @throws {Jii.exceptions.InvalidRouteException} if the requested action ID cannot be resolved into an action successfully.
	 */
	runAction: function (id, context) {
		var action = this.createAction(id);
		if (action === null) {
			throw new Jii.exceptions.InvalidRouteException(Jii.t('jii', 'Unable to resolve the request: ' + this.getUniqueId() + '/' + id));
		}

		return Promise.all([
				this.module.beforeAction(action, context),
				this.beforeAction(action, context)
			]).then(function (results) {
				if (results.indexOf(false) !== -1) {
					return Promise.reject();
				}

                return Promise.resolve().then(function() {
                    return action.runWithParams(context);
                }).then(function(data) {
                    if (!Jii._.isUndefined(data) && context.response instanceof Jii.base.Response) {
                        context.response.data = data;
                    }

                    return Promise.all([
                        this.module.afterAction(action, context),
                        this.afterAction(action, context)
                    ]).then(function() {
                        if (context.response instanceof Jii.base.Response) {
                            context.response.send();
                        }

                        return data;
                    })
                }.bind(this));
        }.bind(this)).catch(Jii.catchHandler);
	},

	/**
	 * Creates an action based on the given action ID.
	 * The method first checks if the action ID has been declared in [[actions()]]. If so,
	 * it will use the configuration declared there to create the action object.
	 * If not, it will look for a controller method whose name is in the format of `actionXyz`
	 * where `Xyz` stands for the action ID. If found, an [[InlineAction]] representing that
	 * method will be created and returned.
	 * @param {string} id the action ID.
	 * @return {Jii.base.Action} the newly created action instance. Null if the ID doesn't resolve into any action.
	 */
	createAction: function (id) {
		if (id === '') {
			id = this.defaultAction;
		}

		var actionMap = this.actions();
		if (Jii._.has(actionMap, id)) {
			return Jii.createObject(actionMap[id], id, this);
		} else if (/^[a-z0-9\\-_]+$/.test(id)) {
			var method = 'action' + ('-' + id).replace(/-([a-z])/g, function(m, v) { return v.toUpperCase(); })

			if (Jii._.isFunction(this[method])) {
				return new Jii.request.InlineAction(id, this, method);
			}
		}

		return null;
	},

	/**
	 *
	 * @param {string} id
	 * @return {boolean}
	 */
	hasAction: function(id) {
		if (id === '') {
			id = this.defaultAction;
		}

		var actionMap = this.actions();
		if (Jii._.has(actionMap, id)) {
			return true;
		} else if (/^[a-z0-9\\-_]+$/.test(id)) {
			var method = id.charAt(0).toUpperCase() + id.slice(1);
			method = 'action' + method.replace('-', ' ');

			return Jii._.isFunction(this[method]);
		}

		return false;
	},

	/**
	 * @return string the controller ID that is prefixed with the module ID (if any).
	 */
	getUniqueId: function () {
		return this.module instanceof Jii.base.Application ? this.id : this.module.getUniqueId() + '/' + this.id;
	},

	/**
	 * This method is invoked right before an action is to be executed (after all possible filters).
	 * @param {Jii.base.Action} action
     * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	beforeAction: function (action, context) {
        this.trigger(this.__static.EVENT_BEFORE_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
		return Promise.resolve(true);
	},

	/**
	 * This method is invoked right after an action is executed.
	 * @param {Jii.base.Action} action
	 * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	afterAction: function (action, context) {
        this.trigger(this.__static.EVENT_AFTER_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve();
	},

	/**
	 * Renders a view and applies layout if available.
	 *
	 * The view to be rendered can be specified in one of the following formats:
	 *
	 * - path alias (e.g. "@app/views/site/index");
	 * - absolute path within application (e.g. "//site/index"): the view name starts with double slashes.
	 *   The actual view file will be looked for under the [[Application::viewPath|view path]] of the application.
	 * - absolute path within module (e.g. "/site/index"): the view name starts with a single slash.
	 *   The actual view file will be looked for under the [[Module::viewPath|view path]] of [[module]].
	 * - relative path (e.g. "index"): the actual view file will be looked for under [[viewPath]].
	 *
	 * To determine which layout should be applied, the following two steps are conducted:
	 *
	 * 1. In the first step, it determines the layout name and the context module:
	 *
	 * - If [[layout]] is specified as a string, use it as the layout name and [[module]] as the context module;
	 * - If [[layout]] is null, search through all ancestor modules of this controller and find the first
	 *   module whose [[Module::layout|layout]] is not null. The layout and the corresponding module
	 *   are used as the layout name and the context module, respectively. If such a module is not found
	 *   or the corresponding layout is not a string, it will return false, meaning no applicable layout.
	 *
	 * 2. In the second step, it determines the actual layout file according to the previously found layout name
	 *    and context module. The layout name can be:
	 *
	 * - a path alias (e.g. "@app/views/layouts/main");
	 * - an absolute path (e.g. "/main"): the layout name starts with a slash. The actual layout file will be
	 *   looked for under the [[Application::layoutPath|layout path]] of the application;
	 * - a relative path (e.g. "main"): the actual layout layout file will be looked for under the
	 *   [[Module::layoutPath|layout path]] of the context module.
	 *
	 * If the layout name does not contain a file extension, it will use the default one `.php`.
	 *
	 * @param {string} view   the view name. Please refer to [[findViewFile()]] on how to specify a view name.
	 * @param {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * These parameters will not be available in the layout.
	 * @return {string} the rendering result.
	 */
	render: function (view, params) {
		params = params || {};

		var output = this.getView().render(view, params, this);
		if (this.getView() instanceof Jii.view.WebView) {
			var layoutFile = this._findLayoutFile(this.getView());
			if (layoutFile !== false) {
				params.content = output;
				return this.getView().renderLayout(layoutFile, {content: output}, this);
			}
		}

		return output;
	},

	/**
	 * Renders a view.
	 * This method differs from [[render()]] in that it does not apply any layout.
	 * @param  {string} view   the view name. Please refer to [[render()]] on how to specify a view name.
	 * @param  {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * @return {string} the rendering result.
	 */
	renderPartial: function (view, params) {
		params = params || {};

		return this.getView().render(view, params, this);
	},

	/**
	 * Renders a view file.
	 * @param  {string} file   the view file to be rendered. This can be either a file path or a path alias.
	 * @param  {object} [params] the parameters (name-value pairs) that should be made available in the view.
	 * @return {string} the rendering result.
	 */
	renderFile: function (file, params) {
		params = params || {};

		return this.getView().renderFile(file, params, this);
	},

	/**
	 * Returns the view object that can be used to render views or view files.
	 * The [[render()]], [[renderPartial()]] and [[renderFile()]] methods will use
	 * this view object to implement the actual view rendering.
	 * If not set, it will default to the "view" application component.
	 * @return {Jii.view.View} the view object that can be used to render views or view files.
	 */
	getView: function () {
		if (this._view === null) {
			this._view = Jii.app.view;
		}

		return this._view;
	},

	/**
	 * Sets the view object to be used by this controller.
	 * @param {Jii.view.View} view the view object that can be used to render views or view files.
	 */
	setView: function (view) {
		this._view = view;
	},

	/**
	 * Returns the directory containing view files for this controller.
	 * The default implementation returns the directory named as controller [[id]] under the [[module]]'s
	 * [[viewPath]] directory.
	 * @return {string} the directory containing the view files for this controller.
	 */
	getViewPath: function () {
		return this.module.getViewPath() + '/' + this.id;
	},

	/**
	 * Finds the view file based on the given view name.
	 * @param {string} view the view name or the path alias of the view file. Please refer to [[render()]]
	 * on how to specify this parameter.
	 * @return {string} the view file path. Note that the file may not exist.
	 */
	findViewFile: function (view) {
		return this.getViewPath() + '/' + view;
	},

	/**
	 * Finds the applicable layout file.
	 * @param {Jii.view.View} view the view object to render the layout file.
	 * @return {string|boolean} the layout file path, or false if layout is not needed.
	 * Please refer to [[render()]] on how to specify this parameter.
	 */
	_findLayoutFile: function (view) {
		var module = this.module;
		var layout = null;

		if (Jii._.isString(this.layout)) {
			layout = this.layout;
		} else if (this.layout === null) {
			while (module !== null && module.layout === null) {
				module = module.module;
			}
			if (module !== null && Jii._.isString(module.layout)) {
				layout = module.layout;
			}
		}

		if (!layout) {
			return false;
		}

		var file = null;
		if (layout.indexOf('@') === 0) {
			file = Jii.getAlias(layout);
		} else if (layout.indexOf('/') === 0) {
			file = Jii.app.getLayoutPath() + '/' + layout.substr(1);
		} else {
			file = module.getLayoutPath() + '/' + layout;
		}

		var ext = Jii.helpers.File.getFileExtension(file);
		if (ext !== '') {
			return file;
		}

		var path = file + '.' + view.defaultExtension;
		if (view.defaultExtension !== 'ejs' && ext === '') {
			path = file + '.ejs';
		}

		return path;
	}

});


},{"../Jii":125,"./Object":138}],134:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Object');

/**
 * @class Jii.base.Event
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.base.Event', /** @lends Jii.base.Event.prototype */{

	__extends: Jii.base.Object,

	/**
	 * @var {string} the event name. This property is set by [[Jii.base.Component.trigger()]] and [[trigger()]].
	 * Event handlers may use this property to check what event it is handling.
	 */
	name: null,

	/**
	 * @var {object} the sender of this event. If not set, this property will be
	 * set as the object whose "trigger()" method is called.
	 * This property may also be a `null` when this event is a
	 * class-level event which is triggered in a static context.
	 */
	sender: null,

	/**
	 * @var {boolean} whether the event is handled. Defaults to false.
	 * When a handler sets this to be true, the event processing will stop and
	 * ignore the rest of the uninvoked event handlers.
	 */
	handled: false,

	/**
	 * @var {*} the data that is passed to [[Jii.base.Component.on()]] when attaching an event handler.
	 * Note that this varies according to which event handler is currently executing.
	 */
	data: null,

	params: {},

	__static: /** @lends Jii.base.Event */{

		/**
		 * Convert string/function/object to object handler with context and callback params
		 * @param {string|function|object|[]} handler
		 * @param {object} [context]
		 * @returns {*}
		 */
		normalizeHandler: function (handler, context) {
			context = context || null;

			if (Jii._.isObject(handler) && Jii._.has(handler, 'callback') && Jii._.has(handler, 'context')) {
				return handler;
			}

			if (Jii._.isArray(handler) && handler.length === 2) {
				if (Jii._.isFunction(handler[0]) && Jii._.isObject(handler[1])) {
					return {
						context: handler[1],
						callback: handler[0]
					};
				}

				if (Jii._.isString(handler[0])) {
					handler[0] = Jii.namespace(handler[0]);
				}
				return {
					context: handler[0],
					callback: handler[0][handler[1]]
				};
			}

			if (Jii._.isString(handler)) {
				return {
					context: context,
					callback: this[handler]
				};
			}

			if (Jii._.isFunction(handler)) {
				return {
					context: context,
					callback: handler
				};
			}

			throw new Jii.exceptions.ApplicationException('Wrong handler format:' + JSON.stringify(handler));
		},

		_events: {},

		/**
		 * Attaches an event handler to a class-level event.
		 *
		 * When a class-level event is triggered, event handlers attached
		 * to that class and all parent classes will be invoked.
		 *
		 * For example, the following code attaches an event handler to `ActiveRecord`'s
		 * `afterInsert` event:
		 *
		 * ~~~
		 * Jii.base.Event.on(ActiveRecord.className(), ActiveRecord.EVENT_AFTER_INSERT, function (event) {
		 *     console.log(event.sender.className() + ' is inserted.');
		 * });
		 * ~~~
		 *
		 * The handler will be invoked for EVERY successful ActiveRecord insertion.
		 *
		 * For more details about how to declare an event handler, please refer to [[Jii.base.Component.on()]].
		 *
		 * @param {string} className the fully qualified class name to which the event handler needs to attach.
		 * @param {string} name the event name.
		 * @param {string|function|object} handler the event handler.
		 * @param {*} [data] the data to be passed to the event handler when the event is triggered.
		 * When the event handler is invoked, this data can be accessed via [[Jii.base.Event.data]].
		 * @param {boolean} [isAppend] whether to append new event handler to the end of the existing
		 * handler list. If false, the new handler will be inserted at the beginning of the existing
		 * handler list.
		 * @see off()
		 */
		on: function (className, name, handler, data, isAppend) {
			data = data || null;
			isAppend = Jii._.isUndefined(isAppend) ? true : isAppend;

			if (isAppend || !this._events || !this._events[name] || !this._events[name][className]) {
				this._events = this._events || {};
				this._events[name] = this._events[name] || {};
				this._events[name][className] = this._events[name][className] || [];
				this._events[name][className].push([handler, data]);
			} else {
				this._events[name].unshift([handler, data]);
			}
		},

		/**
		 * Detaches an event handler from a class-level event.
		 *
		 * This method is the opposite of [[on()]].
		 *
		 * @param {string} className the fully qualified class name from which the event handler needs to be detached.
		 * @param {string} name the event name.
		 * @param {string|function|object} [handler] the event handler to be removed.
		 * If it is null, all handlers attached to the named event will be removed.
		 * @return boolean whether a handler is found and detached.
		 * @see on()
		 */
		off: function (className, name, handler) {
			handler = handler || null;

			if (!this._events || !this._events[name] || !this._events[name][className]) {
				return false;
			}

			if (handler === null) {
				delete this._events[name][className];
				return true;
			}

			var newEvents = [];
			var isRemoved = false;
			Jii._.each(this._events[name][className], Jii._.bind(function(event) {
				if (event[0] !== handler) {
					newEvents.push(event);
				} else {
					isRemoved = true;
				}
			}, this));
			if (newEvents.length === 0) {
				delete this._events[name][className];
			} else {
				this._events[name][className] = newEvents;
			}

			return isRemoved;
		},

		/**
		 * Returns a value indicating whether there is any handler attached to the specified class-level event.
		 * Note that this method will also check all parent classes to see if there is any handler attached
		 * to the named event.
		 * @param {string|object} className the object or the fully qualified class name specifying the class-level event.
		 * @param {string} name the event name.
		 * @return boolean whether there is any handler attached to the event.
		 */
		hasHandlers: function (className, name) {
			if (!this._events || !this._events[name]) {
				return false;
			}

			if (Jii._.isObject(className)) {
				className = className.className();
			}

			var currentClass = Jii._.isObject(className) ? className : Jii.namespace(className);
			while (true) {
				if (this._events[name][className]) {
					return true;
				}

				className = currentClass.parentClassName();
				currentClass = className ? Jii.namespace(className) : null;

				if (!currentClass) {
					break;
				}
			}

			return false;
		},

		/**
		 * Triggers a class-level event.
		 * This method will cause invocation of event handlers that are attached to the named event
		 * for the specified class and all its parent classes.
		 * @param {string|object} className the object or the fully qualified class name specifying the class-level event.
		 * @param {string} name the event name.
		 * @param {Jii.base.Event} [event] the event parameter. If not set, a default [[Event]] object will be created.
		 */
		trigger: function (className, name, event) {
			event = event || null;

			if (!this._events || !this._events[name]) {
				return;
			}

			if (event === null) {
				event = new this();
			}
			
			event.handled = false;
			event.name = name;

			if (Jii._.isObject(className)) {
				if (event.sender === null) {
					event.sender = className;
				}
				className = className.className();
			}

			var currentClass = Jii._.isObject(className) ? className : Jii.namespace(className);
			while (true) {
				if (this._events[name][className]) {
					for (var handler, i = 0, l = this._events[name][className].length; i < l; i++) {
						handler = this._events[name][className][i];

						event.data = handler[1];
						handler[0] = this.normalizeHandler(handler[0]);
						handler[0].callback.call(handler[0].context, event);

						if (event.handled) {
							return;
						}
					}
				}

				className = currentClass.parentClassName();
				currentClass = className ? Jii.namespace(className) : null;

				if (!currentClass) {
					break;
				}
			}
		}
	}

});

},{"../Jii":125,"./Object":138}],135:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Request');

/**
 * @class Jii.base.HttpRequest
 * @extends Jii.base.Request
 */
Jii.defineClass('Jii.base.HttpRequest', /** @lends Jii.base.HttpRequest.prototype */{

	__extends: Jii.base.Request,

	/**
	 *
	 * @returns {string}
	 */
	getMethod: function () {
		return 'GET';
	},

	/**
	 * Returns whether this is a GET request.
	 * @return {boolean}
	 */
	isGet: function () {
		return this.getMethod() === 'GET';
	},

	/**
	 * Returns whether this is a OPTIONS request.
	 * @return {boolean}
	 */
	isOptions: function () {
		return this.getMethod() === 'OPTIONS';
	},

	/**
	 * Returns whether this is a HEAD request.
	 * @return {boolean}
	 */
	isHead: function () {
		return this.getMethod() === 'HEAD';
	},

	/**
	 * Returns whether this is a POST request.
	 * @return {boolean}
	 */
	isPost: function () {
		return this.getMethod() === 'POST';
	},

	/**
	 * Returns whether this is a DELETE request.
	 * @return {boolean}
	 */
	isDelete: function () {
		return this.getMethod() === 'DELETE';
	},

	/**
	 * Returns whether this is a PUT request.
	 * @return {boolean}
	 */
	isPut: function () {
		return this.getMethod() === 'PUT';
	},

	/**
	 * Returns whether this is a PATCH request.
	 * @return {boolean}
	 */
	isPatch: function () {
		return this.getMethod() === 'PATCH';
	},

	/**
	 * Returns whether this is an AJAX (XMLHttpRequest) request.
	 * @return boolean whether this is an AJAX (XMLHttpRequest) request.
	 */
	isAjax: function () {
		return false;
	},

	/**
	 * Returns whether this is an Adobe Flash or Flex request.
	 * @return boolean whether this is an Adobe Flash or Adobe Flex request.
	 */
	isFlash: function () {
		return false;
	},

	/**
	 * Returns the named request body parameter value.
	 * @param {string} name the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} the parameter value
	 */
	getBodyParam: function (name, defaultValue) {
		defaultValue = defaultValue || null;

		var bodyParams = this.getBodyParams();
		return Jii._.has(bodyParams, name) ? bodyParams[name] : defaultValue;
	},

	/**
	 * Returns POST parameter with a given name. If name isn't specified, returns an array of all POST parameters.
	 * @param {string} [name] the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} The POST parameter value
	 */
	post: function (name, defaultValue) {
		name = name || null;
		defaultValue = defaultValue || null;

		return name === null ? this.getBodyParams() : this.getBodyParam(name, defaultValue);
	},

	_queryParams: null,

	/**
	 * Returns the request parameters given in the [[queryString]].
	 * @return {object} the request GET parameter values.
	 */
	getQueryParams: function () {
		if (this._queryParams === null) {
			this._queryParams = this._parseQueryParams();
		}
		return this._queryParams;
	},

	/**
	 * Sets the request [[queryString]] parameters.
	 * @param {object} values the request query parameters (name-value pairs)
	 */
	setQueryParams: function (values) {
		this._queryParams = values;
	},

	_parseQueryParams: function () {
	},

	/**
	 * Returns the named GET parameter value.
	 * @param {string} name the parameter name
	 * @param {*} [defaultValue] the default parameter value if the parameter does not exist.
	 * @return {*} the parameter value
	 */
	getQueryParam: function (name, defaultValue) {
		defaultValue = defaultValue || null;

		var queryParams = this.getQueryParams();
		return Jii._.has(queryParams, name) ? queryParams[name] : defaultValue;
	},

	/**
	 * Returns the named GET parameter value.
	 * If the GET parameter does not exist, the second parameter to this method will be returned.
	 * @param {string} [name] the GET parameter name. If not specified, whole all get params is returned.
	 * @param {*} [defaultValue] the default parameter value if the GET parameter does not exist.
	 * @return {*} the GET parameter value
	 */
	get: function (name, defaultValue) {
		name = name || null;
		defaultValue = defaultValue || null;

		return name === null ? this.getQueryParams() : this.getQueryParam(name, defaultValue);
	},

	_pathInfo: null,

	/**
	 * Returns the path info of the currently requested URL.
	 * A path info refers to the part that is after the entry script and before the question mark (query string).
	 * The starting and ending slashes are both removed.
	 * @return {string} Part of the request URL that is after the entry script and before the question mark.
	 * Note, the returned path info is already URL-decoded.
	 */
	getPathInfo: function () {
		if (this._pathInfo === null) {
			this._pathInfo = this._parsePathInfo();
		}
		return this._pathInfo;
	},

	/**
	 * Sets the path info of the current request.
	 * This method is mainly provided for testing purpose.
	 * @param {string} value The path info of the current request
	 */
	setPathInfo: function (value) {
		this._pathInfo = Jii._s.ltrim(value, '/');
	},

	_parsePathInfo: function () {
	},

	_hostInfo: null,

	/**
	 * Returns the schema and host part of the current request URL.
	 * The returned URL does not have an ending slash.
	 * By default this is determined based on the user request information.
	 * You may explicitly specify it by setting the setHostInfo().
	 * @return {string} Schema and hostname part (with port number if needed) of the request URL
	 */
	getHostInfo: function () {
		if (this._hostInfo === null) {
			this._hostInfo = this._parseHostInfo();
		}
		return this._hostInfo;
	},

	/**
	 * Sets the schema and host part of the application URL.
	 * This setter is provided in case the schema and hostname cannot be determined
	 * on certain Web servers.
	 * @param {string} value The schema and host part of the application URL. The trailing slashes will be removed.
	 */
	setHostInfo: function (value) {
		this._hostInfo = Jii._s.rtrim(value, '/');
		return this._hostInfo;
	},

	_parseHostInfo: function () {
	}

});


},{"../Jii":125,"./Request":139}],136:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Event');

/**
 * @class Jii.base.ModelEvent
 * @extends Jii.base.Event
 */
Jii.defineClass('Jii.base.ModelEvent', /** @lends Jii.base.ModelEvent.prototype */{

	__extends: Jii.base.Event,

	/**
	 * A model is in valid status if it passes validations or certain checks.
	 * @type {boolean} Whether the model is in valid status. Defaults to true.
	 */
	isValid: true

});

},{"../Jii":125,"./Event":134}],137:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./Context');

/**
 * @class Jii.base.Module
 * @extends Jii.base.Context
 */
Jii.defineClass('Jii.base.Module', /** @lends Jii.base.Module.prototype */{

	__extends: Jii.base.Context,

    __static: /** @lends Jii.base.Module */{

        /**
         * @event Jii.base.Module#beforeAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_BEFORE_ACTION: 'beforeAction',

        /**
         * @event Jii.base.Module#afterAction
         * @property {Jii.base.ActionEvent} event
         */
        EVENT_AFTER_ACTION: 'afterAction'

    },

	/**
	 * @type {string}
	 */
	id: null,

	/**
	 * The parent module of this module. Null if this module does not have a parent.
	 * @type {Jii.base.Module}
	 */
	module: null,

    /**
     * @type {{string: function}}
     */
    inlineActions: {},

	/**
	 * Mapping from controller ID to controller configurations.
	 * Each name-value pair specifies the configuration of a single controller.
	 * A controller configuration can be either a string or an array.
	 * If the former, the string should be the fully qualified class name of the controller.
	 * If the latter, the array must contain a 'class' element which specifies
	 * the controller's fully qualified class name, and the rest of the name-value pairs
	 * in the array are used to initialize the corresponding controller properties. For example,
	 *
	 * ~~~
	 * {
     *   account: 'app.controllers.UserController',
     *   article: {
     *      className: 'app.controllers.PostController',
     *      pageTitle: 'something new'
     *   }
     * }
	 * ~~~
	 * @type {object}
	 */
	controllerMap: {},

	/**
	 * String the namespace that controller classes are in. If not set,
	 * it will use the "controllers" sub-namespace under the namespace of this module.
	 * For example, if the namespace of this module is "foo\bar", then the default
	 * controller namespace would be "foo\bar\controllers".
	 * @type {string}
	 */
	controllerNamespace: null,

	/**
	 * The default route of this module. Defaults to 'default'.
	 * The route may consist of child module ID, controller ID, and/or action ID.
	 * For example, `help`, `post/create`, `admin/post/create`.
	 * If action ID is not given, it will take the default value as specified in defaultAction.
	 * @type {string}
	 */
	defaultRoute: 'default',

	/**
	 * The layout that should be applied for views within this module. This refers to a view name
	 * relative to [[layoutPath]]. If this is not set, it means the layout value of the [[module|parent module]]
	 * will be taken. If this is false, layout will be disabled within this module.
	 * @type {string|boolean}
	 */
	layout: null,

	/**
	 * @type {object}
	 */
	_modules: null,

	/**
     * Stored controller instances
	 * @type {object}
	 */
    _controllers: {},

	/**
	 */
	constructor: function (id, moduleObject, config) {
		this.id = id;
		this.module = moduleObject;
		this._modules = {};

		this.__super(config);
	},

	init: function () {
		if (this.controllerNamespace === null) {
			var index = Jii._.lastIndexOf(this.className(), '.');
			this.controllerNamespace = this.className().substr(0, index);
		}
	},

    /**
     *
     * @returns {Promise}
     */
    start: function() {
        var promises = [];
        Jii._.each(this._components, function(component) {
            if (Jii._.isFunction(component.start)) {
                promises.push(component.start());
            }
        });
        return Promise.all(promises);
    },

    /**
     *
     * @returns {Promise}
     */
    stop: function() {
        var promises = [];
        Jii._.each(this._components, function(component) {
            if (Jii._.isFunction(component.stop)) {
                promises.push(component.stop());
            }
        });
        return Promise.all(promises);
    },

	getUniqueId: function () {
		if (this.module) {
			var id = this.module.getUniqueId() + '/' + this.id;
			return Jii._s.ltrim(id, '/');
		}
		return this.id;
	},

	/**
	 * The root directory of the module.
	 * @type {string}
	 */
	_basePath: null,

	/**
	 * Returns the root directory of the module.
	 * It defaults to the directory containing the module class file.
	 * @return {string} the root directory of the module.
	 */
	getBasePath: function () {
		if (this._basePath === null) {
			this._basePath = Jii.getAlias('@' + this.className().replace(/\.[^.]+$/, ''))
		}

		return this._basePath;
	},

	/**
	 * Sets the root directory of the module.
	 * This method can only be invoked at the beginning of the constructor.
	 * @param  {string} path the root directory of the module. This can be either a directory name or a path alias.
	 */
	setBasePath: function (path) {
		this._basePath = Jii.getAlias(path);
	},

	/**
	 * Returns the directory that contains the controller classes according to [[controllerNamespace]].
	 * Note that in order for this method to return a value, you must define
	 * an alias for the root namespace of [[controllerNamespace]].
	 * @return {string} the directory that contains the controller classes.
	 */
	getControllerPath: function () {
		return Jii.getAlias('@' + this.controllerNamespace.replace('.', '/'));
	},

	/**
	 * The root directory that contains view files for this module
	 * @type {string}
	 */
	_viewPath: null,

	/**
	 * Returns the directory that contains the view files for this module.
	 * @return {string} the root directory of view files. Defaults to "[[basePath]]/view".
	 */
	getViewPath: function () {
		if (this._viewPath === null) {
			this._viewPath = this.getBasePath() + '/views';
		}
		return this._viewPath;
	},

	/**
	 * Sets the directory that contains the view files.
	 * @param {string} path the root directory of view files.
	 */
	setViewPath: function (path) {
		this._viewPath = Jii.getAlias(path);
	},

	/**
	 * The root directory that contains layout view files for this module.
	 * @type {string}
	 */
	_layoutPath: null,

	/**
	 * Returns the directory that contains layout view files for this module.
	 * @return {string} the root directory of layout files. Defaults to "[[viewPath]]/layouts".
	 */
	getLayoutPath: function () {
		if (this._layoutPath === null) {
			this._layoutPath = this.getViewPath() + '/layouts';
		}
		return this._layoutPath;
	},

	/**
	 * Sets the directory that contains the layout files.
	 * @param  {string} path the root directory of layout files.
	 */
	setLayoutPath: function (path) {
		this._layoutPath = Jii.getAlias(path);
	},

	/**
	 * Checks whether the child module of the specified ID exists.
	 * This method supports checking the existence of both child and grand child modules.
	 * @param {string} id module ID. For grand child modules, use ID path relative to this module (e.g. `admin/content`).
	 * @return {boolean} whether the named module exists. Both loaded and unloaded modules
	 * are considered.
	 */
	hasModule: function (id) {
		var index = Jii._.indexOf(id, '.');
		if (index !== -1) {
			var moduleId = id.substr(0, index);
			var childModuleId = id.substr(index + 1);

			// Check sub-module
			var moduleObject = this.getModule(moduleId);
			return moduleObject !== null ? moduleObject.hasModule(childModuleId) : false;
		}

		return Jii._.has(this._modules[id]);
	},

	/**
	 * Retrieves the child module of the specified ID.
	 * This method supports retrieving both child modules and grand child modules.
	 * @param {string} id module ID (case-sensitive). To retrieve grand child modules,
	 * use ID path relative to this module (e.g. `admin/content`).
	 * @return {Jii.base.Module} the module instance, null if the module does not exist.
	 */
	getModule: function (id) {
		// Get sub-module
		var index = Jii._.indexOf(id, '.');
		if (index !== -1) {
			var moduleId = id.substr(0, index);
			var childModuleId = id.substr(index + 1);

			var moduleObject = this.getModule(moduleId);
			return moduleObject !== null ? moduleObject.getModule(childModuleId) : null;
		}

		return this._modules[id] || null;
	},

	/**
	 * Adds a sub-module to this module.
	 * @param {string} id module ID
	 * @param {Jii.base.Module|array|null} moduleObject the sub-module to be added to this module. This can
	 * be one of the followings:
	 *
	 * - a [[Jii.base.Module]] object
	 * - a configuration array: when [[getModule()]] is called initially, the array
	 *   will be used to instantiate the sub-module
	 * - null: the named sub-module will be removed from this module
	 */
	setModule: function (id, moduleObject) {
		if (moduleObject === null) {
			delete this._modules[id];
        } else {
			// Create module instance
            if (!(moduleObject instanceof Jii.base.Module)) {
                moduleObject = Jii.createObject(moduleObject, id, this);
            }

			// Add link
			this._modules[id] = moduleObject;
		}
	},

	/**
	 * Returns the sub-modules in this module.
	 * @return {Jii.base.Module[]} the modules (indexed by their IDs)
	 */
	getModules: function () {
		return this._modules;
	},

	/**
	 * Registers sub-modules in the current module.
	 *
	 * Each sub-module should be specified as a name-value pair, where
	 * name refers to the ID of the module and value the module or a configuration
	 * array that can be used to create the module. In the latter case, [[Jii.createObject()]]
	 * will be used to create the module.
	 *
	 * If a new sub-module has the same ID as an existing one, the existing one will be overwritten silently.
	 *
	 * The following is an example for registering two sub-modules:
	 *
	 * ~~~
	 * [
	 *     'comment' => [
	 *         'class' => 'app\modules\comment\CommentModule',
	 *         'db' => 'db',
	 *     ],
	 *     'booking' => ['class' => 'app\modules\booking\BookingModule'],
	 * ]
	 * ~~~
	 *
	 * @param {object} modules modules (id => module configuration or instances)
	 */
	setModules: function (modules) {
		Jii._.each(modules, Jii._.bind(function (moduleObject, id) {
			this.setModule(id, moduleObject);
		}, this));
	},

	/**
	 * Runs a controller action specified by a route.
	 * This method parses the specified route and creates the corresponding child module(s), controller and action
	 * instances. It then calls [[Jii.base.Controller::runAction()]] to run the action with the given parameters.
	 * If the route is empty, the method will use [[defaultRoute]].
	 * @param {string} route the route that specifies the action.
	 * @param {Jii.base.Context} context
	 * @return {Promise} the result of the action.
	 * @throws {Jii.exceptions.InvalidRouteException} if the requested route cannot be resolved into an action successfully
	 */
	runAction: function (route, context) {
        var routeParams = this._parseRoute(route);

        var fullRoute = routeParams.id + '/' + (routeParams.route || 'index');
        if (Jii._.has(this.inlineActions, fullRoute)) {
            var action = this.inlineActions[fullRoute] instanceof Jii.base.Action ?
                this.inlineActions[fullRoute] :
                new Jii.request.AnonymousAction(fullRoute, this, this.inlineActions[fullRoute]);

            return this.beforeAction(action, context).then(function (result) {
                if (result === false) {
                    return Promise.reject();
                }

                return Promise.resolve().then(function() {
                    return action.runWithParams(context);
                }).then(function(data) {
                    if (!Jii._.isUndefined(data) && context.response instanceof Jii.base.Response) {
                        context.response.data = data;
                        context.response.send();
                    }

                    return this.beforeAction(action, context).then(function() {
                        return data;
                    });
                }.bind(this));
            }.bind(this)).catch(Jii.catchHandler);
        }

		var parts = this.createController(route);
		if (parts !== null) {
			/** @type {Jii.base.Controller} */
			var controller = parts[0];
			var actionId = parts[1];

			return controller.runAction(actionId, context);
		}

		var id = this.getUniqueId();
		var requestName = id ? id + '/' + route : route;
		//throw new Jii.exceptions.InvalidRouteException('Unable to resolve the request `' + requestName + '`.');
		Jii.info('Unable to resolve the request `' + requestName + '`.');
	},

	/**
	 *
	 * @param {string} route
	 * @return {boolean}
	 */
	existsRoute: function(route) {
        var routeParams = this._parseRoute(route);
        var id = routeParams.id;
        route = routeParams.route;

        if (Jii._.has(this.inlineActions, id + '/' + (route || 'index'))) {
            return true;
        }

		if (Jii._.has(this.controllerMap, id)) {
			return true;
		}

		var moduleObject = this.getModule(id);
		if (moduleObject !== null) {
			return moduleObject.existsRoute(route);
		}

		if (/^[a-z0-9\\-_]+$/.test(id)) {
			var className = id.charAt(0).toUpperCase() + id.slice(1);
			className = className.replace('-', '') + 'Controller';
			className = this.controllerNamespace + '.' + className;

			var controllerClass = Jii.namespace(className);
			if (Jii._.isFunction(controllerClass)) {
				var controller = new controllerClass(id, this);
				return controller.hasAction(route);
			}
		}

		return false;
	},

	/**
	 * Creates a controller instance based on the controller ID.
	 *
	 * The controller is created within this module. The method first attempts to
	 * create the controller based on the [[controllerMap]] of the module.
	 *
	 * @param {string} route the route consisting of module, controller and action IDs.
	 * @return {[]|null} If the controller is created successfully, it will be returned together
	 * with the requested action ID. Otherwise false will be returned.
	 * @throws {Jii.exceptions.InvalidConfigException} if the controller class and its file do not match.
	 */
	createController: function (route) {
        var routeParams = this._parseRoute(route);
        var id = routeParams.id;
        route = routeParams.route;

		var controller = null;
		if (Jii._.has(this.controllerMap, id)) {
			controller = Jii.createObject(this.controllerMap[id], id, this);
			return controller !== null ? [controller, route] : null;
		}

		var moduleObject = this.getModule(id);
		if (moduleObject !== null) {
			return moduleObject.createController(route);
		}

		if (/^[a-z0-9\\-_]+$/.test(id)) {

			var className = id.charAt(0).toUpperCase() + id.slice(1);
			className = className.replace('-', '') + 'Controller';
			className = this.controllerNamespace + '.' + className;

            // Cache controller instances
            if (!this._controllers[className]) {

                var controllerClass = Jii.namespace(className);
                if (Jii._.isFunction(controllerClass)) {
                    this._controllers[className] = new controllerClass(id, this);

                    if (!(this._controllers[className] instanceof Jii.base.Controller)) {
                        throw new Jii.exceptions.InvalidConfigException("Controller class must extend from Jii.base.Controller.");
                    }
                }
			}
            controller = this._controllers[className] || null;
		}

		return controller !== null ? [controller, route] : null;
	},

    _parseRoute: function(route) {
        if (route === '') {
            route = this.defaultRoute;
        }

        route = Jii._s.trim(route, '/');

        var index = route.indexOf('/');
        if (index !== -1) {
            return {
                id: route.substr(0, index),
                route: route.substr(index + 1)
            };
        }
        return {
            id: route,
            route: ''
        }
    },

	/**
	 * This method is invoked right before an action of this module is to be executed (after all possible filters.)
	 * You may override this method to do last-minute preparation for the action.
	 * Make sure you call the parent implementation so that the relevant event is triggered.
	 * @param {Jii.base.Action} action the action to be executed.
	 * @param {Jii.base.Context} context
	 * @return {Promise}
	 */
	beforeAction: function (action, context) {
        this.trigger(this.__static.EVENT_BEFORE_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve(true);
	},

	/**
	 * This method is invoked right after an action of this module has been executed.
	 * You may override this method to do some postprocessing for the action.
	 * Make sure you call the parent implementation so that the relevant event is triggered.
	 * @param {Jii.base.Action} action the action just executed.
     * @param {Jii.base.Context} context
     * @return {Promise}
	 */
	afterAction: function (action, context) {
        this.trigger(this.__static.EVENT_AFTER_ACTION, new Jii.base.ActionEvent({
            action: action,
            context: context
        }));
        return Promise.resolve();
	}

});

},{"../Jii":125,"./Context":132}],138:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 *
 * @class Jii.base.Object
 */
Jii.defineClass('Jii.base.Object', /** @lends Jii.base.Object.prototype */{

	__static: /** @lends Jii.base.Object */{

		/**
		 * Return full class name with namespace
		 * @returns {string}
		 */
		className: function () {
			return this.__className;
		},

		/**
		 * Return extended class name with namespace
		 * @returns {string}
		 */
		parentClassName: function () {
			return this.__parentClassName;
		}

	},

	/**
	 * @param {object} [config]
	 * @constructor
	 */
	constructor: function (config) {
		this.__super.apply(this, arguments);

		// Apply configuration to instance
		if (Jii._.isObject(config)) {
			Jii.configure(this, config);
		}

		// Run custom init method
		this.init();
	},

	/**
	 * Customized initialize method
	 */
	init: function () {
	},

	/**
	 * Method defined jsdoc for hide errors in IDE
	 * @param {...*} [params]
	 * @protected
	 */
	__super: function (params) {
	},

	/**
	 * Return full class name with namespace
	 * @returns {string}
	 */
	className: function () {
		return this.__className;
	},

	/**
	 * Return extended class name with namespace
	 * @returns {string}
	 */
	parentClassName: function () {
		return this.__parentClassName;
	}

});

},{"../Jii":125}],139:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.base.Request
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Request', /** @lends Jii.base.Request.prototype */{

	__extends: Jii.base.Component,

	/**
	 *
	 * @returns {string|null}
	 */
	getMethod: function () {
		return null;
	},

	/**
	 * Resolves the current request into a route and the associated parameters.
	 * @returns {array|null} the first element is the route, and the second is the associated parameters.
	 */
	resolve: function () {
		return null;
	},

	_pathInfo: null,

	/**
	 * Returns the path info of the currently requested URL.
	 * A path info refers to the part that is after the entry script and before the question mark (query string).
	 * The starting and ending slashes are both removed.
	 * @returns {string} Part of the request URL that is after the entry script and before the question mark.
	 * Note, the returned path info is already URL-decoded.
	 */
	getPathInfo: function () {
		if (this._pathInfo === null) {
			this._pathInfo = this._parsePathInfo();
		}
		return this._pathInfo;
	},

	/**
	 * Sets the path info of the current request.
	 * This method is mainly provided for testing purpose.
	 * @param {string} value The path info of the current request
	 */
	setPathInfo: function (value) {
		this._pathInfo = Jii._s.ltrim(value, '/');
	},

	_parsePathInfo: function () {
		return '';
	},

	_hostInfo: null,

	/**
	 * Returns the schema and host part of the current request URL.
	 * The returned URL does not have an ending slash.
	 * By default this is determined based on the user request information.
	 * You may explicitly specify it by setting the setHostInfo().
	 * @return {string} Schema and hostname part (with port number if needed) of the request URL
	 */
	getHostInfo: function () {
		if (this._hostInfo === null) {
			this._hostInfo = this._parseHostInfo();
		}
		return this._hostInfo;
	},

	/**
	 * Sets the schema and host part of the application URL.
	 * This setter is provided in case the schema and hostname cannot be determined
	 * on certain Web servers.
	 * @param {string} value The schema and host part of the application URL. The trailing slashes will be removed.
	 */
	setHostInfo: function (value) {
		this._hostInfo = Jii._s.rtrim(value, '/');
		return this._hostInfo;
	},

	_parseHostInfo: function () {
		return '';
	}

});

},{"../Jii":125}],140:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.base.Response
 * @extends Jii.base.Component
 */
Jii.defineClass('Jii.base.Response', {

	__extends: Jii.base.Component,

	/**
	 * @var {boolean} whether the response has been sent. If this is true, calling [[send()]] will do nothing.
	 */
	isSent: false,

    /**
     * The original response data
     * @type {*}
     */
    data: null,

	/**
	 * Sends the response to client.
	 */
	send: function () {
	}

});

},{"../Jii":125}],141:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * @class Jii.exceptions.ApplicationException
 * @extends Error
 */
Jii.defineClass('Jii.exceptions.ApplicationException', /** @lends Jii.exceptions.ApplicationException.prototype */ {

	__extends: Error,

	constructor: function (message) {
		if (Error.captureStackTrace) {
			Error.captureStackTrace(this, this.__static);
		}
		this.name = this.__className;
		this.message = message || '';
	}
});

},{"../Jii":125}],142:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidCallException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidCallException', /** @lends Jii.exceptions.InvalidCallException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],143:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidConfigException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidConfigException', /** @lends Jii.exceptions.InvalidConfigException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],144:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidParamException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidParamException', /** @lends Jii.exceptions.InvalidParamException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],145:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.InvalidRouteException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.InvalidRouteException', /** @lends Jii.exceptions.InvalidRouteException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],146:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.NotSupportedException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.NotSupportedException', /** @lends Jii.exceptions.NotSupportedException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],147:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('./ApplicationException');

/**
 * @class Jii.exceptions.UnknownPropertyException
 * @extends Jii.exceptions.ApplicationException
 */
Jii.defineClass('Jii.exceptions.UnknownPropertyException', /** @lends Jii.exceptions.UnknownPropertyException.prototype */{

	__extends: Jii.exceptions.ApplicationException

});

},{"../Jii":125,"./ApplicationException":141}],148:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 * BaseFileHelper provides concrete implementation for [[FileHelper]].
 *
 * Do not use BaseFileHelper. Use [[FileHelper]] instead.
 *
 * @class Jii.helpers.File
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.File', /** @lends Jii.helpers.File.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.File */{

		PATTERN_NODIR: 1,
		PATTERN_ENDSWITH: 4,
		PATTERN_MUSTBEDIR: 8,
		PATTERN_NEGATIVE: 16,
		PATTERN_CASE_INSENSITIVE: 32,

		/**
		 * @type {string} the path (or alias) of a PHP file containing MIME type information.
		 */
		mimeMagicFile: '@jii/helpers/mimeTypes.php',

		getFileDirectory: function(path) {
			return path.replace(/\/?[^\/]+$/, '');
		},

		getFileName: function(path) {
			return path.replace(/(.*\/)?([^\/]+)$/, '$2');
		},

		getFileExtension: function(path) {
			var matches = /\.([a-z]+)$/.exec(path);
			return matches !== null ? matches[1] : '';
		},

		isFile: function(path) {
			return path.match(/[^\/]+\.[^\/]+$/) !== null;
		},

		/**
		 * Normalizes a file/directory path.
		 * The normalization does the following work:
		 *
		 * - Convert all directory separators into `DIRECTORY_SEPARATOR` (e.g. "\a/b\c" becomes "/a/b/c")
		 * - Remove trailing directory separators (e.g. "/a/b/c/" becomes "/a/b/c")
		 * - Turn multiple consecutive slashes into a single one (e.g. "/a///b/c" becomes "/a/b/c")
		 * - Remove ".." and "." based on their meanings (e.g. "/a/./b/../c" becomes "/a/c")
		 *
		 * @param {string} path the file/directory path to be normalized
		 * @param {string} [ds] the directory separator to be used in the normalized result. Defaults to `DIRECTORY_SEPARATOR`.
		 * @returns {string} the normalized file/directory path
		 */
		normalizePath: function (path, ds) {
			ds = ds || '/';

			path = Jii._s.rtrim(path.replace(/\/\\/g, ds + ds), ds);
			if ((ds + path).indexOf(ds + '.') === -1 && path.indexOf(ds + ds) === -1) {
				return path;
			}

			// the path may contain ".", ".." or double slashes, need to clean them up
			var parts = [];
			Jii._.each(path.split(ds), function(part) {
				if (part === '..' && parts.length > 0 && parts[parts.length - 1] !== '..') {
					parts.pop();
				}
				if (part === '.' || (part === '' && parts.length > 0)) {
					return;
				}

				parts.push(part);
			});

			path = parts.join(ds);
			return path === '' ? '.' : path;
		}
	}

});
},{"../Jii":125,"../base/Object":138}],149:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 * BaseFileHelper provides concrete implementation for [[FileHelper]].
 *
 * Do not use BaseFileHelper. Use [[FileHelper]] instead.
 *
 * @class Jii.helpers.String
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.String', /** @lends Jii.helpers.String.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.String */{

		/**
		 * Generate unique hash for string. http://jsperf.com/hashcodelordvlad
		 * @param {String} str
		 * @returns {String}
		 */
		hashCode: function(str){
			return str.split("").reduce(function (a, b) {
				a = ((a << 5) - a) + b.charCodeAt(0);
				return a & a;
			}, 0).toString().replace(/-/g, '1');
		},

		generateUid: function () {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random()*16|0;
				var v = c == 'x' ? r : (r&0x3|0x8);

				return v.toString(16);
			});
		}

	}

});
},{"../Jii":125,"../base/Object":138}],150:[function(require,module,exports){
/**
 * @author Vladimir Kozhin <affka@affka.ru>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Object');

/**
 *
 * @class Jii.helpers.Url
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.helpers.Url', /** @lends Jii.helpers.Url.prototype */{

	__extends: Jii.base.Object,

	__static: /** @lends Jii.helpers.Url */{

		/**
		 * Returns a value indicating whether a URL is relative.
		 * A relative URL does not have host info part.
		 * @param {string} url the URL to be checked
		 * @returns {boolean} whether the URL is relative
		 */
		isRelative: function (url) {
			return url.indexOf('//') !== 0 && url.indexOf('://') === -1;
		}
	}

});
},{"../Jii":125,"../base/Object":138}],151:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Action');

/**
 * @class Jii.request.AnonymousAction
 * @extends Jii.base.Action
 */
Jii.defineClass('Jii.request.AnonymousAction', /** @lends Jii.request.AnonymousAction.prototype */{

	__extends: Jii.base.Action,

	/**
	 * @type {string} the controller method that  this inline action is associated with
	 */
	route: null,

    /**
     * @type {function}
     */
    handler: null,

    /**
     * @type {Jii.base.Module}
     */
    module: null,

	constructor: function (route, module, handler, config) {
		this.route = route;
		this.handler = handler;
		this.module = module;

        var id = route.split('/').pop();
		this.__super(id, null, config);
	},

    /**
     * Returns the unique ID of this action among the whole application.
     * @returns {string} the unique ID of this action among the whole application.
     */
    getUniqueId: function () {
        return this.route;
    },

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {*} the result of the action
	 */
	runWithParams: function (context) {
        return Promise.resolve().then(function() {
            return this.handler.call(this.module, context);
        }.bind(this));
	}
});

},{"../Jii":125,"../base/Action":127}],152:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

/**
 * HeaderCollection is used by [[Jii.base.Response]] to maintain the currently registered HTTP headers.
 *
 * @class Jii.request.HeaderCollection
 * @extends Jii.base.Object
 */
Jii.defineClass('Jii.request.HeaderCollection', /** @lends Jii.request.HeaderCollection */{

	__extends: Jii.base.Object,

    _headers: null,

    init: function() {
        this._headers = {};
    },

    /**
     * Returns the named header(s).
     * @param {string} name the name of the header to return
     * @param {*} [defaultValue] the value to return in case the named header does not exist
     * @param {boolean} [isFirst] whether to only return the first header of the specified name.
     * If false, all headers of the specified name will be returned.
     * @return [string|array] the named header(s). If `first` is true, a string will be returned;
     * If `first` is false, an array will be returned.
     */
    get: function(name, defaultValue, isFirst) {
        defaultValue = defaultValue || null;
        if (Jii._.isUndefined(isFirst)) {
            isFirst = true;
        }

        name = name.toLowerCase();
        if (Jii._.has(this._headers, name)) {
            return isFirst ? Jii._.first(this._headers[name]) : this._headers[name];
        }

        return defaultValue;
    },

    /**
     * Adds a new header.
     * If there is already a header with the same name, it will be replaced.
     * @param {string} name the name of the header
     * @param {string} [value] the value of the header
     * @return {static} the collection object itself
     */
    set: function(name, value) {
        value = value || '';

        name = name.toLowerCase();
        this._headers[name] = Jii._.isArray(value) ? value : [value];

        return this;
    },

    /**
     * Adds a new header.
     * If there is already a header with the same name, the new one will
     * be appended to it instead of replacing it.
     * @param {string} name the name of the header
     * @param {string} value the value of the header
     * @return {static} the collection object itself
     */
    add: function(name, value) {
        name = name.toLowerCase();
        if (Jii._.isArray(this._headers[name])) {
            this._headers[name] = this._headers[name].concat(value);
        } else {
            this.set(name, value);
        }

        return this;
    },

    /**
     * Sets a new header only if it does not exist yet.
     * If there is already a header with the same name, the new one will be ignored.
     * @param {string} name the name of the header
     * @param {string} [value] the value of the header
     * @return {static} the collection object itself
     */
    setDefault: function(name, value) {
        value = value || '';

        name = name.toLowerCase();
        if (!this.has(name)) {
            this.set(name, value);
        }

        return this;
    },

    /**
     * Returns a value indicating whether the named header exists.
     * @param {string} name the name of the header
     * @return {boolean} whether the named header exists
     */
    has: function(name) {
        name = name.toLowerCase();
        return Jii._.has(this._headers, name) && this._headers[name].length > 0;
    },

    /**
     * Removes a header.
     * @param {string} name the name of the header to be removed.
     * @return {string|null} the value of the removed header. Null is returned if the header does not exist.
     */
    remove: function(name) {
        name = name.toLowerCase();
        if (Jii._.has(this._headers, name)) {
            var value = this._headers[name];
            delete this._headers[name];

            return value;
        }
        return null;
    },

    /**
     * Removes all headers.
     */
    removeAll: function() {
        this._headers = {};
    },

    /**
     * Returns the collection as a key-value object.
     * @return {object}
     */
    toObject: function() {
        var headers = {};
        Jii._.each(this._headers, Jii._.bind(function(value, key) {
            headers[key] = Jii._.first(value);
        }, this));
        return headers;
    }

});

},{"../Jii":125}],153:[function(require,module,exports){
/**
 * @author <a href="http://www.affka.ru">Vladimir Kozhin</a>
 * @license MIT
 */

'use strict';

/**
 * @namespace Jii
 * @ignore
 */
var Jii = require('../Jii');

require('../base/Action');

/**
 * @class Jii.request.InlineAction
 * @extends Jii.base.Action
 */
Jii.defineClass('Jii.request.InlineAction', /** @lends Jii.request.InlineAction */{

	__extends: Jii.base.Action,

	/**
	 * @type {string} the controller method that  this inline action is associated with
	 */
	actionMethod: null,

	constructor: function (id, controller, actionMethod, config) {
		this.actionMethod = actionMethod;
		this.__super(id, controller, config);
	},

	/**
	 * Runs this action with the specified parameters.
	 * This method is mainly invoked by the controller.
	 * @param {Jii.base.Context} context
	 * @returns {*} the result of the action
	 */
	runWithParams: function (context) {
        return Promise.resolve().then(function() {
            return this.controller[this.actionMethod].call(this.controller, context);
        }.bind(this));
	}
});

},{"../Jii":125,"../base/Action":127}],154:[function(require,module,exports){
//  Underscore.string
//  (c) 2010 Esa-Matti Suuronen <esa-matti aet suuronen dot org>
//  Underscore.string is freely distributable under the terms of the MIT license.
//  Documentation: https://github.com/epeli/underscore.string
//  Some code is borrowed from MooTools and Alexandru Marasteanu.
//  Version '2.4.0'

!function(root, String){
  'use strict';

  // Defining helper functions.

  var nativeTrim = String.prototype.trim;
  var nativeTrimRight = String.prototype.trimRight;
  var nativeTrimLeft = String.prototype.trimLeft;

  var parseNumber = function(source) { return source * 1 || 0; };

  var strRepeat = function(str, qty){
    if (qty < 1) return '';
    var result = '';
    while (qty > 0) {
      if (qty & 1) result += str;
      qty >>= 1, str += str;
    }
    return result;
  };

  var slice = [].slice;

  var defaultToWhiteSpace = function(characters) {
    if (characters == null)
      return '\\s';
    else if (characters.source)
      return characters.source;
    else
      return '[' + _s.escapeRegExp(characters) + ']';
  };

  // Helper for toBoolean
  function boolMatch(s, matchers) {
    var i, matcher, down = s.toLowerCase();
    matchers = [].concat(matchers);
    for (i = 0; i < matchers.length; i += 1) {
      matcher = matchers[i];
      if (!matcher) continue;
      if (matcher.test && matcher.test(s)) return true;
      if (matcher.toLowerCase() === down) return true;
    }
  }

  var escapeChars = {
    lt: '<',
    gt: '>',
    quot: '"',
    amp: '&',
    apos: "'"
  };

  var reversedEscapeChars = {};
  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;
  reversedEscapeChars["'"] = '#39';

  // sprintf() for JavaScript 0.7-beta1
  // http://www.diveintojavascript.com/projects/javascript-sprintf
  //
  // Copyright (c) Alexandru Marasteanu <alexaholic [at) gmail (dot] com>
  // All rights reserved.

  var sprintf = (function() {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }

    var str_repeat = strRepeat;

    var str_format = function() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, node_type = '', arg, output = [], i, k, match, pad, pad_character, pad_length;
      for (i = 0; i < tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === 'string') {
          output.push(parse_tree[i]);
        }
        else if (node_type === 'array') {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) { // keyword argument
            arg = argv[cursor];
            for (k = 0; k < match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw new Error(sprintf('[_.sprintf] property "%s" does not exist', match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          } else if (match[1]) { // positional argument (explicit)
            arg = argv[match[1]];
          }
          else { // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) && (get_type(arg) != 'number')) {
            throw new Error(sprintf('[_.sprintf] expecting number but found %s', get_type(arg)));
          }
          switch (match[8]) {
            case 'b': arg = arg.toString(2); break;
            case 'c': arg = String.fromCharCode(arg); break;
            case 'd': arg = parseInt(arg, 10); break;
            case 'e': arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
            case 'f': arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
            case 'o': arg = arg.toString(8); break;
            case 's': arg = ((arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg); break;
            case 'u': arg = Math.abs(arg); break;
            case 'x': arg = arg.toString(16); break;
            case 'X': arg = arg.toString(16).toUpperCase(); break;
          }
          arg = (/[def]/.test(match[8]) && match[3] && arg >= 0 ? '+'+ arg : arg);
          pad_character = match[4] ? match[4] == '0' ? '0' : match[4].charAt(1) : ' ';
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : '';
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join('');
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        }
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push('%');
        }
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== '') {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else {
                  throw new Error('[_.sprintf] huh?');
                }
              }
            }
            else {
              throw new Error('[_.sprintf] huh?');
            }
            match[2] = field_list;
          }
          else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error('[_.sprintf] mixing positional and named placeholders is not (yet) supported');
          }
          parse_tree.push(match);
        }
        else {
          throw new Error('[_.sprintf] huh?');
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();



  // Defining underscore.string

  var _s = {

    VERSION: '2.4.0',

    isBlank: function(str){
      if (str == null) str = '';
      return (/^\s*$/).test(str);
    },

    stripTags: function(str){
      if (str == null) return '';
      return String(str).replace(/<\/?[^>]+>/g, '');
    },

    capitalize : function(str){
      str = str == null ? '' : String(str);
      return str.charAt(0).toUpperCase() + str.slice(1);
    },

    chop: function(str, step){
      if (str == null) return [];
      str = String(str);
      step = ~~step;
      return step > 0 ? str.match(new RegExp('.{1,' + step + '}', 'g')) : [str];
    },

    clean: function(str){
      return _s.strip(str).replace(/\s+/g, ' ');
    },

    count: function(str, substr){
      if (str == null || substr == null) return 0;

      str = String(str);
      substr = String(substr);

      var count = 0,
        pos = 0,
        length = substr.length;

      while (true) {
        pos = str.indexOf(substr, pos);
        if (pos === -1) break;
        count++;
        pos += length;
      }

      return count;
    },

    chars: function(str) {
      if (str == null) return [];
      return String(str).split('');
    },

    swapCase: function(str) {
      if (str == null) return '';
      return String(str).replace(/\S/g, function(c){
        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
      });
    },

    escapeHTML: function(str) {
      if (str == null) return '';
      return String(str).replace(/[&<>"']/g, function(m){ return '&' + reversedEscapeChars[m] + ';'; });
    },

    unescapeHTML: function(str) {
      if (str == null) return '';
      return String(str).replace(/\&([^;]+);/g, function(entity, entityCode){
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      });
    },

    escapeRegExp: function(str){
      if (str == null) return '';
      return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, '\\$1');
    },

    splice: function(str, i, howmany, substr){
      var arr = _s.chars(str);
      arr.splice(~~i, ~~howmany, substr);
      return arr.join('');
    },

    insert: function(str, i, substr){
      return _s.splice(str, i, 0, substr);
    },

    include: function(str, needle){
      if (needle === '') return true;
      if (str == null) return false;
      return String(str).indexOf(needle) !== -1;
    },

    join: function() {
      var args = slice.call(arguments),
        separator = args.shift();

      if (separator == null) separator = '';

      return args.join(separator);
    },

    lines: function(str) {
      if (str == null) return [];
      return String(str).split("\n");
    },

    reverse: function(str){
      return _s.chars(str).reverse().join('');
    },

    startsWith: function(str, starts){
      if (starts === '') return true;
      if (str == null || starts == null) return false;
      str = String(str); starts = String(starts);
      return str.length >= starts.length && str.slice(0, starts.length) === starts;
    },

    endsWith: function(str, ends){
      if (ends === '') return true;
      if (str == null || ends == null) return false;
      str = String(str); ends = String(ends);
      return str.length >= ends.length && str.slice(str.length - ends.length) === ends;
    },

    succ: function(str){
      if (str == null) return '';
      str = String(str);
      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);
    },

    titleize: function(str){
      if (str == null) return '';
      str  = String(str).toLowerCase();
      return str.replace(/(?:^|\s|-)\S/g, function(c){ return c.toUpperCase(); });
    },

    camelize: function(str){
      return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : ""; });
    },

    underscored: function(str){
      return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, '$1_$2').replace(/[-\s]+/g, '_').toLowerCase();
    },

    dasherize: function(str){
      return _s.trim(str).replace(/([A-Z])/g, '-$1').replace(/[-_\s]+/g, '-').toLowerCase();
    },

    classify: function(str){
      return _s.capitalize(_s.camelize(String(str).replace(/[\W_]/g, ' ')).replace(/\s/g, ''));
    },

    humanize: function(str){
      return _s.capitalize(_s.underscored(str).replace(/_id$/,'').replace(/_/g, ' '));
    },

    trim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrim) return nativeTrim.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp('^' + characters + '+|' + characters + '+$', 'g'), '');
    },

    ltrim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrimLeft) return nativeTrimLeft.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp('^' + characters + '+'), '');
    },

    rtrim: function(str, characters){
      if (str == null) return '';
      if (!characters && nativeTrimRight) return nativeTrimRight.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp(characters + '+$'), '');
    },

    truncate: function(str, length, truncateStr){
      if (str == null) return '';
      str = String(str); truncateStr = truncateStr || '...';
      length = ~~length;
      return str.length > length ? str.slice(0, length) + truncateStr : str;
    },

    /**
     * _s.prune: a more elegant version of truncate
     * prune extra chars, never leaving a half-chopped word.
     * @author github.com/rwz
     */
    prune: function(str, length, pruneStr){
      if (str == null) return '';

      str = String(str); length = ~~length;
      pruneStr = pruneStr != null ? String(pruneStr) : '...';

      if (str.length <= length) return str;

      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? 'A' : ' '; },
        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // 'Hello, world' -> 'HellAA AAAAA'

      if (template.slice(template.length-2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, '');
      else
        template = _s.rtrim(template.slice(0, template.length-1));

      return (template+pruneStr).length > str.length ? str : str.slice(0, template.length)+pruneStr;
    },

    words: function(str, delimiter) {
      if (_s.isBlank(str)) return [];
      return _s.trim(str, delimiter).split(delimiter || /\s+/);
    },

    pad: function(str, length, padStr, type) {
      str = str == null ? '' : String(str);
      length = ~~length;

      var padlen  = 0;

      if (!padStr)
        padStr = ' ';
      else if (padStr.length > 1)
        padStr = padStr.charAt(0);

      switch(type) {
        case 'right':
          padlen = length - str.length;
          return str + strRepeat(padStr, padlen);
        case 'both':
          padlen = length - str.length;
          return strRepeat(padStr, Math.ceil(padlen/2)) + str
                  + strRepeat(padStr, Math.floor(padlen/2));
        default: // 'left'
          padlen = length - str.length;
          return strRepeat(padStr, padlen) + str;
        }
    },

    lpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr);
    },

    rpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, 'right');
    },

    lrpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, 'both');
    },

    sprintf: sprintf,

    vsprintf: function(fmt, argv){
      argv.unshift(fmt);
      return sprintf.apply(null, argv);
    },

    toNumber: function(str, decimals) {
      if (!str) return 0;
      str = _s.trim(str);
      if (!str.match(/^-?\d+(?:\.\d+)?$/)) return NaN;
      return parseNumber(parseNumber(str).toFixed(~~decimals));
    },

    numberFormat : function(number, dec, dsep, tsep) {
      if (isNaN(number) || number == null) return '';

      number = number.toFixed(~~dec);
      tsep = typeof tsep == 'string' ? tsep : ',';

      var parts = number.split('.'), fnums = parts[0],
        decimals = parts[1] ? (dsep || '.') + parts[1] : '';

      return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, '$1' + tsep) + decimals;
    },

    strRight: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strRightBack: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.lastIndexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strLeft: function(str, sep){
      if (str == null) return '';
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    strLeftBack: function(str, sep){
      if (str == null) return '';
      str += ''; sep = sep != null ? ''+sep : sep;
      var pos = str.lastIndexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    toSentence: function(array, separator, lastSeparator, serial) {
      separator = separator || ', ';
      lastSeparator = lastSeparator || ' and ';
      var a = array.slice(), lastMember = a.pop();

      if (array.length > 2 && serial) lastSeparator = _s.rtrim(separator) + lastSeparator;

      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
    },

    toSentenceSerial: function() {
      var args = slice.call(arguments);
      args[3] = true;
      return _s.toSentence.apply(_s, args);
    },

    slugify: function(str) {
      if (str == null) return '';

      var from  = "ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź",
          to    = "aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz",
          regex = new RegExp(defaultToWhiteSpace(from), 'g');

      str = String(str).toLowerCase().replace(regex, function(c){
        var index = from.indexOf(c);
        return to.charAt(index) || '-';
      });

      return _s.dasherize(str.replace(/[^\w\s-]/g, ''));
    },

    surround: function(str, wrapper) {
      return [wrapper, str, wrapper].join('');
    },

    quote: function(str, quoteChar) {
      return _s.surround(str, quoteChar || '"');
    },

    unquote: function(str, quoteChar) {
      quoteChar = quoteChar || '"';
      if (str[0] === quoteChar && str[str.length-1] === quoteChar)
        return str.slice(1,str.length-1);
      else return str;
    },

    exports: function() {
      var result = {};

      for (var prop in this) {
        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
        result[prop] = this[prop];
      }

      return result;
    },

    repeat: function(str, qty, separator){
      if (str == null) return '';

      qty = ~~qty;

      // using faster implementation if separator is not needed;
      if (separator == null) return strRepeat(String(str), qty);

      // this one is about 300x slower in Google Chrome
      for (var repeat = []; qty > 0; repeat[--qty] = str) {}
      return repeat.join(separator);
    },

    naturalCmp: function(str1, str2){
      if (str1 == str2) return 0;
      if (!str1) return -1;
      if (!str2) return 1;

      var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g,
        tokens1 = String(str1).toLowerCase().match(cmpRegex),
        tokens2 = String(str2).toLowerCase().match(cmpRegex),
        count = Math.min(tokens1.length, tokens2.length);

      for(var i = 0; i < count; i++) {
        var a = tokens1[i], b = tokens2[i];

        if (a !== b){
          var num1 = parseInt(a, 10);
          if (!isNaN(num1)){
            var num2 = parseInt(b, 10);
            if (!isNaN(num2) && num1 - num2)
              return num1 - num2;
          }
          return a < b ? -1 : 1;
        }
      }

      if (tokens1.length === tokens2.length)
        return tokens1.length - tokens2.length;

      return str1 < str2 ? -1 : 1;
    },

    levenshtein: function(str1, str2) {
      if (str1 == null && str2 == null) return 0;
      if (str1 == null) return String(str2).length;
      if (str2 == null) return String(str1).length;

      str1 = String(str1); str2 = String(str2);

      var current = [], prev, value;

      for (var i = 0; i <= str2.length; i++)
        for (var j = 0; j <= str1.length; j++) {
          if (i && j)
            if (str1.charAt(j - 1) === str2.charAt(i - 1))
              value = prev;
            else
              value = Math.min(current[j], current[j - 1], prev) + 1;
          else
            value = i + j;

          prev = current[j];
          current[j] = value;
        }

      return current.pop();
    },

    toBoolean: function(str, trueValues, falseValues) {
      if (typeof str === "number") str = "" + str;
      if (typeof str !== "string") return !!str;
      str = _s.trim(str);
      if (boolMatch(str, trueValues || ["true", "1"])) return true;
      if (boolMatch(str, falseValues || ["false", "0"])) return false;
    }
  };

  // Aliases

  _s.strip    = _s.trim;
  _s.lstrip   = _s.ltrim;
  _s.rstrip   = _s.rtrim;
  _s.center   = _s.lrpad;
  _s.rjust    = _s.lpad;
  _s.ljust    = _s.rpad;
  _s.contains = _s.include;
  _s.q        = _s.quote;
  _s.toBool   = _s.toBoolean;

  // Exporting

  // CommonJS module is defined
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports)
      module.exports = _s;

    exports._s = _s;
  }

  // Register as a named module with AMD.
  if (typeof define === 'function' && define.amd)
    define('underscore.string', [], function(){ return _s; });


  // Integrate with Underscore.js if defined
  // or create our own underscore object.
  root._ = root._ || {};
  root._.string = root._.str = _s;
}(this, String);

},{}],155:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"dup":1}],156:[function(require,module,exports){
module.exports={
  "name": "jii",
  "version": "0.7.1",
  "description": "Jii - Full-Stack JavaScript Framework",
  "main": "index.js",
  "browser": "index-client.js",
  "author": "Vladimir Kozhin <affka@affka.ru>",
  "scripts": {
    "test": "nodeunit tests/unit"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/jiisoft/jii"
  },
  "keywords": [
    "yii",
    "php",
    "framework",
    "javascript"
  ],
  "license": "MIT",
  "homepage": "https://github.com/jiisoft/jii",
  "bugs": {
    "url": "https://github.com/jiisoft/jii/issues"
  },
  "dependencies": {
    "neatness": "^1.1.10",
    "require-all": "0.0.8",
    "underscore": "^1.8.3",
    "underscore.string": "^2.4.0"
  },
  "devDependencies": {
    "nodeunit": "*"
  }
}

},{}],157:[function(require,module,exports){
module.exports = require('./src/Neatness');
},{"./src/Neatness":160}],158:[function(require,module,exports){

module.exports = function(Neatness) {

	return Neatness.createClass('Neatness.Exception', /** @lends Neatness.Exception.prototype */{

		__extends: Error,

		/**
		 * Text message
		 * @type {string}
		 */
		message: null,

		/**
		 * Extra information dumps
		 * @type {Array}
		 */
		extra: null,

		/**
		 * Base class for implement exception. This class extend from native Error and support
		 * stack trace and message.
		 * @constructs
		 * @extends Error
		 */
		constructor: function (message) {
			if (Error.captureStackTrace) {
				Error.captureStackTrace(this, this.constructor || this);
			}

			this.name = this.constructor.name;
			this.message = message || '';

			if (arguments.length > 1) {
				this.extra = Array.prototype.slice.call(arguments, 1);
			}

			this.__super();
		},

		/**
		 *
		 * @returns {string}
		 */
		toString: function () {
			return this.message;
		}

	});

};
},{}],159:[function(require,module,exports){

module.exports = function(Neatness) {

	/**
	 * Base class. Extend all you base classes from this class for true navigation in IDE
	 * and support methods such as {@link Neatness.Object#className}
	 * @class Neatness.Object
	 */
	return Neatness.createClass('Neatness.Object', {

		/**
		 * Link to used class. If you access to this property in extends classes, then you give top-level class.
		 * @type {*}
		 */
		__static: null,

		/**
		 * Full current class name with namespace
		 * @example Returns value example
		 *  app.MyClass
		 * @type {string}
		 * @protected
		 */
		__className: null,

		/**
		 * Unique instance name
		 * @example Returns value example
		 *  app.MyClass50
		 * @type {string}
		 * @protected
		 */
		__instanceName: null,

		/**
		 * Full parent (extends) class name with namespace
		 * @example Returns value example
		 *  app.MyBaseClass
		 * @type {string}
		 * @protected
		 */
		__parentClassName: null,

		/**
		 * Returns full class name with namespace
		 * @example
		 *  app.MyClass
		 * @returns {string}
		 */
		className: function() {
			return this.__className;
		},

		/**
		 * Returns unique instance name
		 * @example
		 *  app.MyClass
		 * @returns {string}
		 */
		classInstanceName: function() {
			return this.__instanceName;
		},

		/**
		 * Returns full parent class name with namespace
		 * @example
		 *  app.MyBaseClass
		 * @returns {string}
		 */
		parentClassName: function() {
			return this.__parentClassName;
		},

		/**
		 * Call parent class methods through this method. This method support only synchronous nested calls.
		 * @param {...*}
		 * @protected
		 */
		__super: function () {
		}

	});

};

},{}],160:[function(require,module,exports){

var extendClass = require('./extendClass');
var formats = require('./formats');

// For .noConflict() implementation
var hasPreviousNeatness = typeof window !== 'undefined' && window.hasOwnProperty('Neatness');
var previousNeatness = hasPreviousNeatness ? window.Neatness : null;

/**
 * Neatness class
 * @function Neatness
 */
var Neatness = function() {

	/**
	 *
	 * @type {object}
	 */
	this._context = {};

	this._contextKeys = {};
};

/**
 * @function Neatness.prototype.newContext
 * @param {boolean} [removeGlobal] Set true for remove Neatness object from window (browser global object)
 * @returns {Neatness}
 */
Neatness.prototype.newContext = function(removeGlobal) {
	removeGlobal = removeGlobal || false;

	if (removeGlobal) {
		this.noConflict();
	}

	return new Neatness();
};

/**
 * @function Neatness.prototype.moveContext
 * @param {boolean} newContext New context object
 * @param {boolean} [removeFromOld] Set true for remove keys from old context
 * @returns {Neatness}
 */
Neatness.prototype.moveContext = function(newContext, removeFromOld) {
	removeFromOld = removeFromOld || false;

	for (var key in this._contextKeys) {
		if (this._contextKeys.hasOwnProperty(key)) {
			newContext[key] = this._context[key];
			if (removeFromOld) {
				delete this._context[key];
			}
		}
	}
	this._context = newContext;
};

/**
 * @function Neatness.prototype.noConflict
 * @returns {Neatness}
 */
Neatness.prototype.noConflict = function() {
	// Root namespace object
	var root = typeof window !== 'undefined' ? window : {};

	if (hasPreviousNeatness) {
		root.Neatness = previousNeatness;
	} else {
		delete root.Neatness;
	}

	return this;
};

/**
 * @function Neatness.prototype.namespace
 * @param {string} name Full namespace name
 * @returns {object}
 */
Neatness.prototype.namespace = function (name) {
	name = name || '';

	var nameParts = name.split('.');
	var currentScope = this._context;

	if (!name) {
		return currentScope;
	}

	// Find or create
	for (var i = 0; i < nameParts.length; i++) {
		var scopeName = nameParts[i];
		if (i === 0) {
			this._contextKeys[scopeName] = true;
		}

		if (!currentScope[scopeName]) {
			currentScope[scopeName] = {
				__className: nameParts.slice(0, i).join('.'),
				__parentClassName: null
			};
		}
		currentScope = currentScope[scopeName];
	}

	return currentScope;
};

/**
 * Method for define class
 * @function Neatness.prototype.createClass
 * @param {string} globalName
 * @param {(function|object|null)} optionsOrExtend
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.createClass = function (globalName, optionsOrExtend, prototypeProperties, staticProperties) {
	var params = formats.parseFormat(globalName, optionsOrExtend, prototypeProperties, staticProperties);

	// Support extends and mixins as strings class names
	if (typeof params[2] === 'string') {
		params[2] = this.namespace(params[2]);
	}
	var mixins = params[6];
	for (var i = 0, l = mixins.length; i < l; i++) {
		if (typeof mixins[i] === 'string') {
			mixins[i] = this.namespace(mixins[i]);
		}
	}

	// Show error if not defined extended class
	if (params[2] !== null && typeof params[2] !== 'function') {
		throw new Error('Not found extend class for `' + globalName + '`.');
	}

	var newClass = extendClass(params[0], params[1], params[2], params[6], params[3], params[4], params[7]);
	formats.applyClassConfig(newClass, params[5], params[0], params[1]);

	return newClass;
};

/**
 * Method for define class
 * @function Neatness.prototype.defineClass
 * @param {string} globalName
 * @param {(function|object|null)} optionsOrExtend
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.defineClass = function (globalName, optionsOrExtend, prototypeProperties, staticProperties) {
	var newClass = this.createClass.apply(this, arguments);
	var nameObject = formats.parseFullName(globalName);

	this.namespace(nameObject.namespace)[nameObject.name] = newClass;
	return newClass;
};

/**
 * Method for define enum
 * @function Neatness.prototype.defineClass
 * @param {string} globalName
 * @param {object} [staticProperties]
 * @return {object}
 */
Neatness.prototype.defineEnum = function (globalName, staticProperties) {
	var newClass = this.createClass(globalName, null, {}, staticProperties);
	var nameObject = formats.parseFullName(globalName);

	this.namespace(nameObject.namespace)[nameObject.name] = newClass;
	return newClass;
};

var neatness = module.exports = new Neatness();

// Web browser export
if (typeof window !== 'undefined') {
	window.Neatness = neatness;
}

/**
 * @type {Neatness.prototype.Object}
 */
Neatness.prototype.Object = require('./Neatness.Object')(neatness);

/**
 * @type {Neatness.prototype.Exception}
 */
Neatness.prototype.Exception = require('./Neatness.Exception')(neatness);

/**
 * @type {string}
 */
Neatness.prototype.version = '%JOINTS_CURRENT_VERSION%';

},{"./Neatness.Exception":158,"./Neatness.Object":159,"./extendClass":161,"./formats":162}],161:[function(require,module,exports){
var isEvalEnable = true;
var instanceCounter = 0;

var _noop = function() {
};

var _createFunction = function(nameObject, constructor) {
	if (!isEvalEnable || !nameObject) {
		return function () { return constructor.apply(this, arguments); }
	}

	var nameRegExp = /[^a-z$_\.]/i;
	var name = nameObject.name || 'Function';
	var nameParts = nameObject.globalName.split('.');

	// Create root object
	var rootName = nameParts.shift();
	var cs;

	rootName = rootName.replace(nameRegExp, '');
	eval('var ' + rootName + ' = cs = {};');

	// Create fake namespace object
	for (var i = 0; i < nameParts.length; i++) {
		var scopeName = nameParts[i];
		if (!cs[scopeName]) {
			cs[scopeName] = {};
		}
		cs = cs[scopeName];
	}

	var func;
	var fullName = (nameObject.namespace ? nameObject.namespace + '.' : '') + name;

	fullName = fullName.replace(nameRegExp, '');
	eval('func = ' + fullName + ' = function () { return constructor.apply(this, arguments); }');

	return func;
};

var _isStrictObject = function (obj) {
	if (!obj || typeof obj !== 'object' || obj instanceof RegExp || obj instanceof Date) {
		return false;
	}

	var bool = true;
	for (var key in obj) {
		bool = bool && obj.hasOwnProperty(key);
	}
	return bool;
};

var _clone = function(obj) {
	if (!_isStrictObject(obj)) {
		return obj;
	}

	var copy = obj.constructor();
	for (var key in obj) {
		if (obj.hasOwnProperty(key)) {
			copy[key] = _clone(obj[key]);
		}
	}
	return copy;
};

var _cloneObjInProto = function(obj) {
	for (var key in obj) {
		if (typeof obj === "object") {
			obj[key] = _clone(obj[key]);
		}
	}
};

var _coverVirtual = function (childMethod, parentMethod, superName) {
	return function () {
		var currentSuper = this[superName];
		this[superName] = parentMethod;
		var r = childMethod.apply(this, arguments);
		this[superName] = currentSuper;
		return r;
	};
};

var _extendWithSuper = function (childClass, newProperties, superName) {
	if (!newProperties) {
		return;
	}

	// Extend and setup virtual methods
	for (var key in newProperties) {
		if (!newProperties.hasOwnProperty(key)) {
			continue;
		}

		var value = newProperties[key];
		if (typeof value == 'function' && typeof childClass[key] == 'function' && childClass[key] !== _noop) {
			childClass[key] = _coverVirtual(value, childClass[key], superName);
		} else {
			childClass[key] = _clone(value);
		}
	}

	// Default state
	if (!childClass[superName]) {
		childClass[superName] = _noop;
	}
};

/**
 * Extend class
 * @param {object} nameObject
 * @param {object} parentNameObject
 * @param {function} [parentClass]
 * @param {function} [mixins]
 * @param {object} [prototypeProperties]
 * @param {object} [staticProperties]
 * @returns {function} New class
 */
module.exports = function (nameObject, parentNameObject, parentClass, mixins, prototypeProperties, staticProperties, superName) {
	parentClass = parentClass || _noop;
	mixins = mixins || [];

	// The constructor function for the new subclass is either defined by you
	// (the "constructor" property in your `extend` definition), or defaulted
	// by us to simply call the parent's constructor.
	var constructor = prototypeProperties && prototypeProperties.hasOwnProperty('constructor') ?
		_coverVirtual(prototypeProperties.constructor, parentClass, superName) :
		parentClass;
	var childClass = _createFunction(nameObject, function() {
		if (!this.__instanceName) {
			_cloneObjInProto(this);
			this.__instanceName  = nameObject.globalName + instanceCounter++;
		}
		constructor.apply(this, arguments);
	});

	// Add static properties to the constructor function, if supplied.
	for (var prop in parentClass) {
		childClass[prop] = parentClass[prop];
	}
	_extendWithSuper(childClass, staticProperties, superName);

	// Set the prototype chain to inherit from `parent`, without calling
	// `parent`'s constructor function.
	var Surrogate = _createFunction(parentNameObject, _noop);
	Surrogate.prototype = parentClass.prototype;

	childClass.prototype = new Surrogate();

	// Copy objects from child prototype
	for (var prop2 in parentClass.prototype) {
		if (parentClass.prototype.hasOwnProperty(prop2) && prop2 !== 'constructor') {
			childClass.prototype[prop2] = _clone(parentClass.prototype[prop2]);
		}
	}

	// Add prototype properties (instance properties) to the subclass,
	// if supplied.
	if (prototypeProperties) {
		_extendWithSuper(childClass.prototype, prototypeProperties, superName);
	}

	// Add prototype properties and methods from mixins
	for (var i = 0, l = mixins.length; i < l; i++) {
		for (var mixinProp in mixins[i].prototype) {
			// Skip private
			if (mixinProp.substr(0, 2) === '__') {
				continue;
			}

			// Check for exists property or method. Mixin can only add properties, but no replace it
			if (typeof childClass.prototype[mixinProp] === 'function' || childClass.prototype.hasOwnProperty(mixinProp)) {
				throw new Error('Try to replace prototype property `' + mixinProp + '` in class `' + childClass.__className + '` by mixin `' + mixins[i].__className + '`');
			}
			childClass.prototype[mixinProp] = mixins[i].prototype[mixinProp];
		}
	}
	// Add static properties and methods from mixins
	for (var i = 0, l = mixins.length; i < l; i++) {
		for (var mixinProp in mixins[i]) {
			// Skip private
			if (mixinProp.substr(0, 2) === '__') {
				continue;
			}

			// Check for exists property or method. Mixin can only add properties, but no replace it
			if (typeof childClass[mixinProp] === 'function' || childClass.hasOwnProperty(mixinProp)) {
				throw new Error('Try to replace static property `' + mixinProp + '` in class `' + childClass.__className + '` by mixin `' + mixins[i].__className + '`');
			}
			childClass[mixinProp] = mixins[i][mixinProp];
		}
	}

	return childClass;
};

},{}],162:[function(require,module,exports){
var FORMAT_JOINTS_V02 = 'neatness_v02';
var FORMAT_JOINTS_V10 = 'neatness_v10';

module.exports = {

	/**
	 * Detect format and return class params
	 * @param {string} globalName
	 * @param {(function|object|null)} optionsOrExtend
	 * @param {object} [protoProps]
	 * @param {object} [staticProps]
	 * @returns {object}
	 */
	parseFormat: function (globalName, optionsOrExtend, protoProps, staticProps) {
		var nameObject = this.parseFullName(globalName);
		var parentNameObject = null;
		var parentClass = null;
		var prototypeProperties = null;
		var staticProperties = null;
		var format = null;
		var mixins = [];

		// Neatness v0.2 (old) format
		if (optionsOrExtend === null || typeof optionsOrExtend === 'function') {
			parentClass = optionsOrExtend;
			prototypeProperties = protoProps;
			staticProperties = staticProps;
			format = FORMAT_JOINTS_V02;

			if (parentClass && typeof parentClass.debugClassName === 'string') {
				parentNameObject = this.parseFullName(parentClass.debugClassName);
			}

			// Neatness v1.0 format
		} else if (typeof optionsOrExtend === 'object') {
			if (optionsOrExtend.hasOwnProperty('__extends')) {
				parentClass = optionsOrExtend.__extends;
				delete optionsOrExtend.__extends;
			}

			if (optionsOrExtend.hasOwnProperty('__static')) {
				staticProperties = optionsOrExtend.__static;
				delete optionsOrExtend.__static;
			}

			if (optionsOrExtend.hasOwnProperty('__mixins')) {
				mixins = mixins.concat(optionsOrExtend.__mixins);
				delete optionsOrExtend.__mixins;
			}
			if (optionsOrExtend.hasOwnProperty('__mixin')) {
				mixins = mixins.concat(optionsOrExtend.__mixin);
				delete optionsOrExtend.__mixin;
			}

			format = FORMAT_JOINTS_V10;
			prototypeProperties = optionsOrExtend;

			if (parentClass && typeof parentClass.__className === 'string') {
				parentNameObject = this.parseFullName(parentClass.__className);
			}
		}

		return [
			nameObject,
			parentNameObject,
			parentClass,
			prototypeProperties,
			staticProperties,
			format,
			mixins,
			format === FORMAT_JOINTS_V02 ? '_super' : '__super'
		];
	},

	applyClassConfig: function(newClass, format, nameObject, parentNameObject) {
		// Set __className for all formats
		newClass.__className = newClass.prototype.__className = nameObject.globalName;

		var classNameKey = format === FORMAT_JOINTS_V02 ? 'debugClassName' : '__className';
		var parentClassNameKey = format === FORMAT_JOINTS_V02 ? '' : '__parentClassName';
		var staticNameKey = format === FORMAT_JOINTS_V02 ? '_static' : '__static';

		newClass[classNameKey] = newClass.prototype[classNameKey] = nameObject.globalName;
		if (parentClassNameKey) {
			newClass[parentClassNameKey] = newClass.prototype[parentClassNameKey] = parentNameObject ? (parentNameObject.globalName || null) : null;
		}
		newClass[staticNameKey] = newClass.prototype[staticNameKey] = newClass;

		return newClass;
	},

	parseFullName: function(globalName) {
		// Split namespace
		var pos = globalName.lastIndexOf('.');

		return {
			globalName: globalName,
			name: pos !== -1 ? globalName.substr(pos + 1) : globalName,
			namespace: pos !== -1 ? globalName.substr(0, pos) : ''
		};
	}

};

},{}]},{},[94]);

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiIiwic291cmNlcyI6WyJhcHAtY2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pKHsxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuXG59LHt9XSwyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbndpbmRvdy5fID0gd2luZG93Ll8gfHwgcmVxdWlyZSgndW5kZXJzY29yZScpO1xyXG5cclxucmVxdWlyZSgnLi9saWIvY2xpZW50QmFzZUJyb3dzZXJpZnknKTtcclxucmVxdWlyZSgnLi9saWIvT2JqZWN0Jyk7XHJcbnJlcXVpcmUoJy4vbGliL0V4Y2VwdGlvbicpO1xyXG5yZXF1aXJlKCcuL2xpYi9OZWF0Q29tZXRDbGllbnQnKTtcclxucmVxdWlyZSgnLi9saWIvcm91dGVyL0Nvbm5lY3Rpb25DbGllbnQnKTtcclxucmVxdWlyZSgnLi9saWIvcm91dGVyL09wZW5lZFByb2ZpbGVDbGllbnQnKTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gd2luZG93Lk5lYXRDb21ldDtcbn0se1wiLi9saWIvRXhjZXB0aW9uXCI6MyxcIi4vbGliL05lYXRDb21ldENsaWVudFwiOjQsXCIuL2xpYi9PYmplY3RcIjo1LFwiLi9saWIvY2xpZW50QmFzZUJyb3dzZXJpZnlcIjo2LFwiLi9saWIvcm91dGVyL0Nvbm5lY3Rpb25DbGllbnRcIjo3LFwiLi9saWIvcm91dGVyL09wZW5lZFByb2ZpbGVDbGllbnRcIjo4LFwidW5kZXJzY29yZVwiOjF9XSwzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LkV4Y2VwdGlvblxyXG4gKi9cclxuTmVhdENvbWV0LkV4Y2VwdGlvbiA9IGZ1bmN0aW9uKG1zZykge1xyXG5cclxuICAgIHRoaXMubXNnID0gbXNnO1xyXG59O1xyXG5cclxuTmVhdENvbWV0LkV4Y2VwdGlvbi5wcm90b3R5cGUgPSB7XHJcblxyXG4gICAgbXNnOiBudWxsXHJcblxyXG59O1xyXG5cclxuTmVhdENvbWV0LkV4Y2VwdGlvbi53YXJuaW5nID0gZnVuY3Rpb24obXNnKSB7XHJcblxyXG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJOZWF0Q29tZXQgd2FybmluZzogXCIgKyBtc2cpO1xyXG4gICAgfVxyXG59O1xyXG5cbn0se31dLDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBjYWxsYmFjayBOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50fmNyZWF0ZUNvbGxlY3Rpb25cclxuICogQHBhcmFtIHtzdHJpbmd9IHByb2ZpbGVJZFxyXG4gKiBAcGFyYW0ge3N0cmluZ30gYmluZGluZ0lkXHJcbiAqIEBwYXJhbSB7Kn0gcHJvZmlsZXNEZWZpbml0aW9uXHJcbiAqIEBwYXJhbSB7TmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50fSBvcGVuZWRQcm9maWxlXHJcbiAqIEByZXR1cm5zIHtOZWF0Q29tZXQuYXBpLklDb2xsZWN0aW9uQ2xpZW50fVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0Lk5lYXRDb21ldENsaWVudFxyXG4gKiBAZXh0ZW5kcyBOZWF0Q29tZXQuT2JqZWN0XHJcbiAqL1xyXG5OZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50ID0gTmVhdENvbWV0Lk9iamVjdC5leHRlbmQoLyoqIEBsZW5kcyBOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge05lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50fSAqL1xyXG4gICAgY29tZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtOZWF0Q29tZXQuTmVhdENvbWV0Q2xpZW50fmNyZWF0ZUNvbGxlY3Rpb259ICovXHJcbiAgICBjcmVhdGVDb2xsZWN0aW9uOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7TmVhdENvbWV0Lk5lYXRDb21ldENsaWVudH5jYWxsQ29sbGVjdGlvbn0gKi9cclxuICAgIGNhbGxDb2xsZWN0aW9uOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE9iamVjdC48c3RyaW5nLCAqPj59ICovXHJcbiAgICBwcm9maWxlc0RlZmluaXRpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3R9ICovXHJcbiAgICBfb3BlbmVkUHJvZmlsZVBhcmFtczogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdC48bnVtYmVyLCBOZWF0Q29tZXQucm91dGVyLk9wZW5lZFByb2ZpbGVDbGllbnQ+fSAqL1xyXG4gICAgX29wZW5lZFByb2ZpbGVzOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7T2JqZWN0LjxzdHJpbmcsIE5lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudFtdPn0gKi9cclxuICAgIF9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7TmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50fSAqL1xyXG4gICAgX2Nvbm5lY3Rpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXHJcbiAgICBfbGFzdElkOiAwLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlUGFyYW1zID0gW107XHJcbiAgICAgICAgdGhpcy5fb3BlbmVkUHJvZmlsZXMgPSB7fTtcclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkID0ge307XHJcbiAgICAgICAgdGhpcy5jYWxsQ29sbGVjdGlvbiA9IHRoaXMuY2FsbENvbGxlY3Rpb24gfHwgdGhpcy5fY2FsbENvbGxlY3Rpb24uYmluZCh0aGlzKTtcclxuXHJcbiAgICAgICAgLy8gU2V0dXAgY2hhbm5lbFxyXG4gICAgICAgIHRoaXMuX2Nvbm5lY3Rpb24gPSBuZXcgTmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50KHtcclxuICAgICAgICAgICAgY29tZXQ6IHRoaXMuY29tZXQsXHJcbiAgICAgICAgICAgIG9uQ29ubmVjdGlvblJlc3RvcmU6IF8uYmluZCh0aGlzLnJlZnJlc2gsIHRoaXMpLFxyXG4gICAgICAgICAgICBvbkluaXQ6IF8uYmluZCh0aGlzLl9vblJlZnJlc2hSZXNwb25zZSwgdGhpcyksXHJcbiAgICAgICAgICAgIG9uTWVzc2FnZTogXy5iaW5kKHRoaXMuX29uQ2hhbm5lbE1lc3NhZ2UsIHRoaXMpXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG5cclxuICAgIHJlZnJlc2g6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBDYWxsIHNlcnZlclxyXG4gICAgICAgIGlmICh0aGlzLl9vcGVuZWRQcm9maWxlUGFyYW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uLnNlbmRPcGVuKHRoaXMuX29wZW5lZFByb2ZpbGVQYXJhbXMpO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2ZpbGVJZFxyXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdXHJcbiAgICAgKiBAcmV0dXJucyB7TmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50fVxyXG4gICAgICovXHJcbiAgICBvcGVuUHJvZmlsZTogZnVuY3Rpb24ocHJvZmlsZUlkLCBwYXJhbXMpIHtcclxuXHJcbiAgICAgICAgdmFyIG9wZW5lZFByb2ZpbGVJZCA9ICsrdGhpcy5fbGFzdElkO1xyXG5cclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlUGFyYW1zLnB1c2goW29wZW5lZFByb2ZpbGVJZCwgcHJvZmlsZUlkLCBwYXJhbXMgfHwge31dKTtcclxuXHJcbiAgICAgICAgLy8gSW5pdCBvcGVuZWRQcm9maWxlXHJcbiAgICAgICAgdmFyIG9wZW5lZFByb2ZpbGUgPSBuZXcgTmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50KCk7XHJcbiAgICAgICAgb3BlbmVkUHJvZmlsZS5pZCA9IG9wZW5lZFByb2ZpbGVJZDtcclxuICAgICAgICBvcGVuZWRQcm9maWxlLnByb2ZpbGVJZCA9IHByb2ZpbGVJZDtcclxuICAgICAgICBvcGVuZWRQcm9maWxlLmNyZWF0ZUNvbGxlY3Rpb24gPSB0aGlzLmNyZWF0ZUNvbGxlY3Rpb24gfHwgLyogbGVnYWN5ICovIHRoaXMuZ2V0Q29sbGVjdGlvbjtcclxuICAgICAgICBvcGVuZWRQcm9maWxlLnByb2ZpbGVEZWZpbml0aW9uID0gdGhpcy5wcm9maWxlc0RlZmluaXRpb25bcHJvZmlsZUlkXTtcclxuICAgICAgICBvcGVuZWRQcm9maWxlLmluaXQoKTtcclxuICAgICAgICB0aGlzLl9vcGVuZWRQcm9maWxlc1tvcGVuZWRQcm9maWxlSWRdID0gb3BlbmVkUHJvZmlsZTtcclxuXHJcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkW3Byb2ZpbGVJZF0pIHtcclxuICAgICAgICAgICAgdGhpcy5fb3BlbmVkUHJvZmlsZXNCeVByb2ZpbGVJZFtwcm9maWxlSWRdID0gW107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX29wZW5lZFByb2ZpbGVzQnlQcm9maWxlSWRbcHJvZmlsZUlkXS5wdXNoKG9wZW5lZFByb2ZpbGUpO1xyXG5cclxuICAgICAgICAvLyBDb25uZWN0XHJcbiAgICAgICAgLy8gVE9ETzogb3B0aW1pemVcclxuICAgICAgICBpZiAodGhpcy5fY29ubmVjdGlvbiAmJiB0aGlzLl9jb25uZWN0aW9uLmlzUmVhZHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gb3BlbmVkUHJvZmlsZTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZXNcclxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgb3BlbjogZnVuY3Rpb24ocHJvZmlsZXMsIGNhbGxiYWNrKSB7XHJcblxyXG4gICAgICAgIC8vIE1hcmtcclxuICAgICAgICBfLmVhY2gocHJvZmlsZXMsIGZ1bmN0aW9uKHBhcmFtcywgcHJvZmlsZUlkKSB7XHJcblxyXG4gICAgICAgICAgICB2YXIgb3BlbmVkUHJvZmlsZSA9IHRoaXMub3BlblByb2ZpbGUocHJvZmlsZUlkLCBwYXJhbXMpO1xyXG5cclxuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhvcGVuZWRQcm9maWxlLCBvcGVuZWRQcm9maWxlLnByb2ZpbGVJZCwgb3BlbmVkUHJvZmlsZS5pZCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vblJlZnJlc2hSZXNwb25zZTogZnVuY3Rpb24ocHJvZmlsZURhdGEpIHtcclxuXHJcbiAgICAgICAgLy8gU2V0dXAgZW5hYmxlZCBiaW5kaW5nc1xyXG4gICAgICAgIF8uZWFjaChwcm9maWxlRGF0YSwgZnVuY3Rpb24ocHJvZmlsZUJpbmRpbmdzLCBwcm9maWxlSWQpIHtcclxuXHJcbiAgICAgICAgICAgIF8uZWFjaChwcm9maWxlQmluZGluZ3MsIGZ1bmN0aW9uKGJpbmRpbmdJZF9kYXRhKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmdJZCA9IGJpbmRpbmdJZF9kYXRhWzBdO1xyXG5cclxuICAgICAgICAgICAgICAgIF8uZWFjaCh0aGlzLl9vcGVuZWRQcm9maWxlc0J5UHJvZmlsZUlkW3Byb2ZpbGVJZF0sIGZ1bmN0aW9uKG9wZW5lZFByb2ZpbGUpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5pdCBjYWxsXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBvcGVuZWRQcm9maWxlLmdldENvbGxlY3Rpb24oYmluZGluZ0lkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxDb2xsZWN0aW9uLmNhbGwobnVsbCwgY29sbGVjdGlvbiwgJ3Jlc2V0JywgYmluZGluZ0lkX2RhdGFbMV0pO1xyXG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XHJcblxyXG4gICAgICAgICAgICB9LCB0aGlzKTtcclxuXHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNoYW5uZWxNZXNzYWdlOiBmdW5jdGlvbihjaGFubmVsLCBkYXRhKSB7XHJcblxyXG4gICAgICAgIHZhciByZWdzID0gY2hhbm5lbC5tYXRjaCgvXihbXjpdKyk6KFteOl0rKSg6LispPy8pO1xyXG4gICAgICAgIHRoaXMuX2NhbGxDb2xsZWN0aW9ucyhyZWdzWzFdLCByZWdzWzJdLCBkYXRhKTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NhbGxDb2xsZWN0aW9uczogZnVuY3Rpb24ocHJvZmlsZVJlZiwgYmluZGluZ0lkLCBhcmdzKSB7XHJcbiAgICAgICAgdmFyIGNhbGxDb2xsZWN0aW9uID0gZnVuY3Rpb24gKG9wZW5lZFByb2ZpbGUpIHtcclxuICAgICAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSBvcGVuZWRQcm9maWxlLmdldENvbGxlY3Rpb24oYmluZGluZ0lkKTtcclxuICAgICAgICAgICAgdGhpcy5jYWxsQ29sbGVjdGlvbi5hcHBseShudWxsLCBbY29sbGVjdGlvbl0uY29uY2F0KGFyZ3MpKTtcclxuICAgICAgICB9LmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgIGlmIChwcm9maWxlUmVmLnN1YnN0cigwLCAxKSA9PT0gJyEnKSB7XHJcbiAgICAgICAgICAgIGNhbGxDb2xsZWN0aW9uKHRoaXMuX29wZW5lZFByb2ZpbGVzW3Byb2ZpbGVSZWYuc3Vic3RyKDEpXSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5fb3BlbmVkUHJvZmlsZXNCeVByb2ZpbGVJZFtwcm9maWxlUmVmXSwgY2FsbENvbGxlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtOZWF0Q29tZXQuYXBpLklDb2xsZWN0aW9uQ2xpZW50fSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0gey4uLip9IHBhcmFtMVxyXG4gICAgICogQHByb3RlY3RlZFxyXG4gICAgICovXHJcbiAgICBfY2FsbENvbGxlY3Rpb246IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIG1ldGhvZCwgcGFyYW0xKSB7XHJcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdLmFwcGx5KGNvbGxlY3Rpb24sIF8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDIpKTtcclxuICAgIH1cclxuXHJcbn0pO1xyXG5cbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBjb3B5cmlnaHQgQ29weXJpZ2h0IDIwMTQgPGEgaHJlZj1cImh0dHA6Ly93d3cuZXh0cG9pbnQuY29tXCI+RXh0UG9pbnQ8L2E+XHJcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly9rb3J5YWdpbi5jb21cIj5QYXZlbCBLb3J5YWdpbjwvYT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIEJhc2ljIGNsYXNzIHN1cHBvcnRzIHR3byB0eXBlcyBvZiBpbml0aWFsaXphdGlvblxyXG4gKlxyXG4gKiBJLiBTaW5nbGUgb3BlcmF0b3IgY2FsbC4gTm90ZTogaW5pdCgpIGlzIGJlaW5nIGNhbGxlZCBpbnRlcm5hbGx5XHJcbiAqIHZhciB4ID0gbmV3IFgoe1xyXG4gKiAgICAgYWJjOiAxMjNcclxuICogfSk7XHJcbiAqXHJcbiAqIElJLiBFeHBsaWNpdCBpbml0aWFsaXphdGlvblxyXG4gKiB2YXIgeCA9IG5ldyBYOyAvLyBEb24ndCBwYXNzIGFueSBwYXJhbWV0ZXIgaW4gY29uc3RydWN0b3IuIGluaXQoKSB3b24ndCBiZSBjYWxsZWQgaW1wbGljaXRseS5cclxuICogeC5hYmMgPSAxMjM7XHJcbiAqIHguaW5pdCgpO1xyXG4gKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0Lk9iamVjdFxyXG4gKlxyXG4gKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCAqPn0gW2NvbmZpZ11cclxuICovXHJcbk5lYXRDb21ldC5PYmplY3QgPSBmdW5jdGlvbihjb25maWcpIHtcclxuXHJcbiAgICBpZiAoY29uZmlnKSB7XHJcbiAgICAgICAgXy5hc3NpZ24odGhpcywgY29uZmlnKTtcclxuICAgICAgICB0aGlzLmluaXQoKTtcclxuICAgIH1cclxufTtcclxuXHJcbk5lYXRDb21ldC5PYmplY3QucHJvdG90eXBlID0ge1xyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgfVxyXG5cclxufTtcclxuXHJcbi8qKlxyXG4gKiBGdW5jdGlvbiB0byBkZWZpbmUgc3ViY2xhc3Nlc1xyXG4gKlxyXG4gKiBJdCBpcyBhIHBhcnQgb2YgQmFja2JvbmUuanMgMS4yLjMgaHR0cDovL2JhY2tib25lanMub3JnXHJcbiAqIChjKSAyMDEwLTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHByb3RvUHJvcHNcclxuICogQHBhcmFtIHtPYmplY3R9IFtzdGF0aWNQcm9wc11cclxuICovXHJcbk5lYXRDb21ldC5PYmplY3QuZXh0ZW5kID0gZnVuY3Rpb24ocHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcclxuICAgIHZhciBjaGlsZDtcclxuXHJcbiAgICAvLyBUaGUgY29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBuZXcgc3ViY2xhc3MgaXMgZWl0aGVyIGRlZmluZWQgYnkgeW91XHJcbiAgICAvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcclxuICAgIC8vIGJ5IHVzIHRvIHNpbXBseSBjYWxsIHRoZSBwYXJlbnQgY29uc3RydWN0b3IuXHJcbiAgICBpZiAocHJvdG9Qcm9wcyAmJiBfLmhhcyhwcm90b1Byb3BzLCAnY29uc3RydWN0b3InKSkge1xyXG4gICAgICAgIGNoaWxkID0gcHJvdG9Qcm9wcy5jb25zdHJ1Y3RvcjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY2hpbGQgPSBmdW5jdGlvbigpeyByZXR1cm4gcGFyZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIHRvIHRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgaWYgc3VwcGxpZWQuXHJcbiAgICBfLmV4dGVuZChjaGlsZCwgcGFyZW50LCBzdGF0aWNQcm9wcyk7XHJcblxyXG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgY2hhaW4gdG8gaW5oZXJpdCBmcm9tIGBwYXJlbnRgLCB3aXRob3V0IGNhbGxpbmdcclxuICAgIC8vIGBwYXJlbnRgIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxyXG4gICAgdmFyIFN1cnJvZ2F0ZSA9IGZ1bmN0aW9uKCl7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfTtcclxuICAgIFN1cnJvZ2F0ZS5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IFN1cnJvZ2F0ZTtcclxuXHJcbiAgICAvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgKGluc3RhbmNlIHByb3BlcnRpZXMpIHRvIHRoZSBzdWJjbGFzcyxcclxuICAgIC8vIGlmIHN1cHBsaWVkLlxyXG4gICAgaWYgKHByb3RvUHJvcHMpIF8uZXh0ZW5kKGNoaWxkLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XHJcblxyXG4gICAgLy8gU2V0IGEgY29udmVuaWVuY2UgcHJvcGVydHkgaW4gY2FzZSB0aGUgcGFyZW50J3MgcHJvdG90eXBlIGlzIG5lZWRlZFxyXG4gICAgLy8gbGF0ZXIuXHJcbiAgICBjaGlsZC5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG5cclxuICAgIHJldHVybiBjaGlsZDtcclxufTtcbn0se31dLDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLy8gRW5vdWdoIGpzZG9jIGlzIGluIHNlcnZlckJhc2UuanNcclxud2luZG93Lk5lYXRDb21ldCA9IHtcclxuICAgIGFkYXB0ZXJzOiB7fSxcclxuICAgIHJvdXRlcjoge31cclxufTtcclxuXG59LHt9XSw3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50XHJcbiAqIEBleHRlbmRzIE5lYXRDb21ldC5PYmplY3RcclxuICovXHJcbk5lYXRDb21ldC5yb3V0ZXIuQ29ubmVjdGlvbkNsaWVudCA9IE5lYXRDb21ldC5PYmplY3QuZXh0ZW5kKC8qKiBAbGVuZHMgTmVhdENvbWV0LnJvdXRlci5Db25uZWN0aW9uQ2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge05lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50fSAqL1xyXG4gICAgY29tZXQ6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cclxuICAgIG9uQ29ubmVjdGlvblJlc3RvcmU6IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtGdW5jdGlvbn0gKi9cclxuICAgIG9uSW5pdDogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge0Z1bmN0aW9ufSAqL1xyXG4gICAgb25NZXNzYWdlOiBudWxsLFxyXG5cclxuICAgIGlzUmVhZHk6IGZhbHNlLFxyXG5cclxuICAgIF9sYXN0SW5pdElkOiAwLFxyXG4gICAgX3dhaXRpbmdGb3I6IDEsIC8vIExvY2sgaW5pdGlhbGx5LiBOdWxsID0gbm90IHdhaXRpbmdcclxuICAgIF9tZXNzYWdlUXVldWU6IFtdLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBJbnN0YWxsIGNvbWV0IGxpc3RlbmVyc1xyXG4gICAgICAgIHRoaXMuY29tZXQuYmluZEV2ZW50cyh7XHJcbiAgICAgICAgICAgIG9uQ29ubmVjdGlvblJlc3RvcmU6IF8uYmluZCh0aGlzLl9vbkNvbWV0Q29ubmVjdGlvblJlc3RvcmUsIHRoaXMpLFxyXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IF8uYmluZCh0aGlzLl9vbkNvbWV0TWVzc2FnZSwgdGhpcylcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX29uQ29tZXRDb25uZWN0aW9uUmVzdG9yZTogZnVuY3Rpb24oKSB7XHJcblxyXG4gICAgICAgIHRoaXMuaXNSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25SZXN0b3JlKCk7XHJcbiAgICB9LFxyXG5cclxuICAgIF9vbkNvbWV0TWVzc2FnZTogZnVuY3Rpb24oY2hhbm5lbCwgZGF0YSkge1xyXG5cclxuICAgICAgICBpZiAodGhpcy5fd2FpdGluZ0Zvcikge1xyXG4gICAgICAgICAgICB0aGlzLl9tZXNzYWdlUXVldWUucHVzaChbY2hhbm5lbCwgZGF0YV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5vbk1lc3NhZ2UoY2hhbm5lbCwgZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuXHJcbiAgICBzZW5kT3BlbjogZnVuY3Rpb24ocGFyYW1zKSB7XHJcblxyXG4gICAgICAgIC8vIEZvcmNlIGluaXRpYWxpemF0aW9uLXRpbWUgbWVzc2FnZXMgdG8gcnVuIGFmdGVyIGluaXRpYWxpemF0aW9uXHJcbiAgICAgICAgdmFyIHJlcXVlc3RJZCA9ICsrdGhpcy5fbGFzdEluaXRJZDtcclxuICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gcmVxdWVzdElkO1xyXG4gICAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB0aGlzLmNvbWV0LnNlbmRPcGVuKHBhcmFtcywgXy5iaW5kKGZ1bmN0aW9uKGRhdGEpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIERyb3AgdGhlIHJlc3VsdCBvZiBhIHdyb25nIGNhbGxcclxuICAgICAgICAgICAgaWYgKHRoaXMuX3dhaXRpbmdGb3IgIT0gcmVxdWVzdElkKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFN0b3Agd2FpdGluZ1xyXG4gICAgICAgICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcclxuXHJcbiAgICAgICAgICAgIC8vIEVmZmVjdGl2ZSBpbml0XHJcbiAgICAgICAgICAgIHRoaXMub25Jbml0KGRhdGEpO1xyXG5cclxuICAgICAgICAgICAgLy8gRmx1c2ggcGVuZGluZyBtZXNzYWdlc1xyXG4gICAgICAgICAgICBfLmVhY2godGhpcy5fbWVzc2FnZVF1ZXVlLCBmdW5jdGlvbihtZXNzYWdlKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uTWVzc2FnZS5hcHBseSh0aGlzLCBtZXNzYWdlKTtcclxuICAgICAgICAgICAgfSwgdGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VRdWV1ZSA9IFtdO1xyXG5cclxuICAgICAgICB9LCB0aGlzKSk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHt9XSw4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAY29weXJpZ2h0IENvcHlyaWdodCAyMDE0IDxhIGhyZWY9XCJodHRwOi8vd3d3LmV4dHBvaW50LmNvbVwiPkV4dFBvaW50PC9hPlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8va29yeWFnaW4uY29tXCI+UGF2ZWwgS29yeWFnaW48L2E+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgTmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50XHJcbiAqIEBleHRlbmRzIE5lYXRDb21ldC5PYmplY3RcclxuICovXHJcbk5lYXRDb21ldC5yb3V0ZXIuT3BlbmVkUHJvZmlsZUNsaWVudCA9IE5lYXRDb21ldC5PYmplY3QuZXh0ZW5kKC8qKiBAbGVuZHMgTmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlU2VydmVyLnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICAvKiogQHR5cGUge051bWJlcn0gKi9cclxuICAgIGlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7U3RyaW5nfSAqL1xyXG4gICAgcHJvZmlsZUlkOiBudWxsLFxyXG5cclxuICAgIC8qKiBAdHlwZSB7TmVhdENvbWV0Lk5lYXRDb21ldENsaWVudH5jcmVhdGVDb2xsZWN0aW9ufSAqL1xyXG4gICAgY3JlYXRlQ29sbGVjdGlvbjogbnVsbCxcclxuXHJcbiAgICAvKiogQHR5cGUge09iamVjdC48c3RyaW5nLCBPYmplY3QuPHN0cmluZywgKj4+fSAqL1xyXG4gICAgcHJvZmlsZURlZmluaXRpb246IG51bGwsXHJcblxyXG4gICAgLyoqIEB0eXBlIHtPYmplY3QuPHN0cmluZywgTmVhdENvbWV0LmFwaS5JQ29sbGVjdGlvbkNsaWVudD59ICovXHJcbiAgICBjb2xsZWN0aW9uczogbnVsbCxcclxuXHJcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcclxuICAgICAgICB0aGlzLmNvbGxlY3Rpb25zID0ge307XHJcbiAgICB9LFxyXG5cclxuICAgIGdldENvbGxlY3Rpb246IGZ1bmN0aW9uKGJpbmRpbmdJZCkge1xyXG5cclxuICAgICAgICAvLyBMYXp5IGluaXRcclxuICAgICAgICBpZiAoIV8uaGFzKHRoaXMuY29sbGVjdGlvbnMsIGJpbmRpbmdJZCkpIHtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGlmICghXy5oYXModGhpcy5wcm9maWxlRGVmaW5pdGlvbiwgYmluZGluZ0lkKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE5lYXRDb21ldC5FeGNlcHRpb24oJ1dyb25nIGJpbmRpbmdJZCAnICsgYmluZGluZ0lkKTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgdGhpcy5jb2xsZWN0aW9uc1tiaW5kaW5nSWRdID0gdGhpcy5jcmVhdGVDb2xsZWN0aW9uKFxyXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9maWxlSWQsXHJcbiAgICAgICAgICAgICAgICBiaW5kaW5nSWQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnByb2ZpbGVEZWZpbml0aW9uW2JpbmRpbmdJZF0sXHJcbiAgICAgICAgICAgICAgICB0aGlzXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0aW9uc1tiaW5kaW5nSWRdO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXRcclxuICAgICAqL1xyXG4gICAgcG9wdWxhdGVOYW1lc3BhY2U6IGZ1bmN0aW9uKHRhcmdldCkge1xyXG5cclxuICAgICAgICBfLmVhY2godGhpcy5wcm9maWxlRGVmaW5pdGlvbiwgZnVuY3Rpb24gKHBhcmFtcywgYmluZGluZ0lkKSB7XHJcbiAgICAgICAgICAgIHRhcmdldFtiaW5kaW5nSWRdID0gdGhpcy5nZXRDb2xsZWN0aW9uKGJpbmRpbmdJZCkuZ2V0TmF0aXZlKCk7XHJcbiAgICAgICAgfSwgdGhpcyk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHt9XSw5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnamlpJyk7XG5yZXF1aXJlKCdqaWktbW9kZWwnKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL0FjdGl2ZVJlY29yZCcpO1xucmVxdWlyZSgnLi9saWIvRXhwcmVzc2lvbicpO1xucmVxdWlyZSgnLi9saWIvQWZ0ZXJTYXZlRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL3JlbW90ZS9Db21tYW5kJyk7XG5yZXF1aXJlKCcuL2xpYi9yZW1vdGUvQ29ubmVjdGlvbicpO1xucmVxdWlyZSgnLi9saWIvcmVtb3RlL1NjaGVtYScpO1xucmVxdWlyZSgnLi9saWIvcmVtb3RlL1RyYW5zcG9ydEludGVyZmFjZScpO1xufSx7XCIuL2xpYi9BY3RpdmVSZWNvcmRcIjoxMCxcIi4vbGliL0FmdGVyU2F2ZUV2ZW50XCI6MTEsXCIuL2xpYi9FeHByZXNzaW9uXCI6MTIsXCIuL2xpYi9yZW1vdGUvQ29tbWFuZFwiOjEzLFwiLi9saWIvcmVtb3RlL0Nvbm5lY3Rpb25cIjoxNCxcIi4vbGliL3JlbW90ZS9TY2hlbWFcIjoxNSxcIi4vbGliL3JlbW90ZS9UcmFuc3BvcnRJbnRlcmZhY2VcIjoxNixcImppaVwiOjEyNCxcImppaS1tb2RlbFwiOjk2fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBKaWkuc3FsLkFjdGl2ZVJlY29yZFxuICogQGV4dGVuZHMgSmlpLmJhc2UuQWN0aXZlUmVjb3JkXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnNxbC5BY3RpdmVSZWNvcmQnLCAvKiogQGxlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkFjdGl2ZVJlY29yZCxcblx0XG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkICove1xuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbiB1c2VkIGJ5IHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQnkgZGVmYXVsdCwgdGhlIFwiZGJcIiBhcHBsaWNhdGlvbiBjb21wb25lbnQgaXMgdXNlZCBhcyB0aGUgZGF0YWJhc2UgY29ubmVjdGlvbi5cblx0XHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIGlmIHlvdSB3YW50IHRvIHVzZSBhIGRpZmZlcmVudCBkYXRhYmFzZSBjb25uZWN0aW9uLlxuXHRcdCAqIEByZXR1cm5zIHtKaWkuc3FsLkNvbm5lY3Rpb259IHRoZSBkYXRhYmFzZSBjb25uZWN0aW9uIHVzZWQgYnkgdGhpcyBBUiBjbGFzcy5cblx0XHQgKi9cblx0XHRnZXREYjogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIEppaS5hcHAuZ2V0Q29tcG9uZW50KCdkYicpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBDcmVhdGVzIGFuIFtbQWN0aXZlUXVlcnldXSBpbnN0YW5jZSB3aXRoIGEgZ2l2ZW4gU1FMIHN0YXRlbWVudC5cblx0XHQgKlxuXHRcdCAqIE5vdGUgdGhhdCBiZWNhdXNlIHRoZSBTUUwgc3RhdGVtZW50IGlzIGFscmVhZHkgc3BlY2lmaWVkLCBjYWxsaW5nIGFkZGl0aW9uYWxcblx0XHQgKiBxdWVyeSBtb2RpZmljYXRpb24gbWV0aG9kcyAoc3VjaCBhcyBgd2hlcmUoKWAsIGBvcmRlcigpYCkgb24gdGhlIGNyZWF0ZWQgW1tBY3RpdmVRdWVyeV1dXG5cdFx0ICogaW5zdGFuY2Ugd2lsbCBoYXZlIG5vIGVmZmVjdC4gSG93ZXZlciwgY2FsbGluZyBgd2l0aCgpYCwgYGFzQXJyYXkoKWAgb3IgYGluZGV4QnkoKWAgaXNcblx0XHQgKiBzdGlsbCBmaW5lLlxuXHRcdCAqXG5cdFx0ICogQmVsb3cgaXMgYW4gZXhhbXBsZTpcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIGN1c3RvbWVycyA9IEN1c3RvbWVyLmZpbmRCeVNxbCgnU0VMRUNUICogRlJPTSBjdXN0b21lcicpLmFsbCgpO1xuXHRcdCAqIH5+flxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHNxbCB0aGUgU1FMIHN0YXRlbWVudCB0byBiZSBleGVjdXRlZFxuXHRcdCAqIEBwYXJhbSB7W119IHBhcmFtcyBwYXJhbWV0ZXJzIHRvIGJlIGJvdW5kIHRvIHRoZSBTUUwgc3RhdGVtZW50IGR1cmluZyBleGVjdXRpb24uXG5cdFx0ICogQHJldHVybnMge0ppaS5zcWwuQWN0aXZlUXVlcnl9IHRoZSBuZXdseSBjcmVhdGVkIFtbQWN0aXZlUXVlcnldXSBpbnN0YW5jZVxuXHRcdCAqL1xuXHRcdGZpbmRCeVNxbDogZnVuY3Rpb24gKHNxbCwgcGFyYW1zKSB7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cblx0XHRcdHZhciBxdWVyeSA9IHRoaXMuZmluZCgpO1xuXHRcdFx0cXVlcnkuc2V0U3FsKHNxbCk7XG5cblx0XHRcdHJldHVybiBxdWVyeS5wYXJhbXMocGFyYW1zKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVXBkYXRlcyB0aGUgd2hvbGUgdGFibGUgdXNpbmcgdGhlIHByb3ZpZGVkIGF0dHJpYnV0ZSB2YWx1ZXMgYW5kIGNvbmRpdGlvbnMuXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGNoYW5nZSB0aGUgc3RhdHVzIHRvIGJlIDEgZm9yIGFsbCBjdXN0b21lcnMgd2hvc2Ugc3RhdHVzIGlzIDI6XG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci51cGRhdGVBbGwoe3N0YXR1czogMX0sICdzdGF0dXMgPSAyJyk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHNhdmVkIGludG8gdGhlIHRhYmxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSB0aGUgcGFyYW1ldGVycyAobmFtZSA9PiB2YWx1ZSkgdG8gYmUgYm91bmQgdG8gdGhlIHF1ZXJ5LlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZFxuXHRcdCAqL1xuXHRcdHVwZGF0ZUFsbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLnVwZGF0ZSh0aGlzLnRhYmxlTmFtZSgpLCBhdHRyaWJ1dGVzLCBjb25kaXRpb24sIHBhcmFtcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFVwZGF0ZXMgdGhlIHdob2xlIHRhYmxlIHVzaW5nIHRoZSBwcm92aWRlZCBjb3VudGVyIGNoYW5nZXMgYW5kIGNvbmRpdGlvbnMuXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGluY3JlbWVudCBhbGwgY3VzdG9tZXJzJyBhZ2UgYnkgMSxcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIEN1c3RvbWVyLnVwZGF0ZUFsbENvdW50ZXJzKHthZ2U6IDF9KTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7W119IGNvdW50ZXJzIHRoZSBjb3VudGVycyB0byBiZSB1cGRhdGVkIChhdHRyaWJ1dGUgbmFtZSA9PiBpbmNyZW1lbnQgdmFsdWUpLlxuXHRcdCAqIFVzZSBuZWdhdGl2ZSB2YWx1ZXMgaWYgeW91IHdhbnQgdG8gZGVjcmVtZW50IHRoZSBjb3VudGVycy5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xbXX0gW2NvbmRpdGlvbl0gdGhlIGNvbmRpdGlvbnMgdGhhdCB3aWxsIGJlIHB1dCBpbiB0aGUgV0hFUkUgcGFydCBvZiB0aGUgVVBEQVRFIFNRTC5cblx0XHQgKiBQbGVhc2UgcmVmZXIgdG8gW1tRdWVyeS53aGVyZSgpXV0gb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIChuYW1lID0+IHZhbHVlKSB0byBiZSBib3VuZCB0byB0aGUgcXVlcnkuXG5cdFx0ICogRG8gbm90IG5hbWUgdGhlIHBhcmFtZXRlcnMgYXMgYDpicDBgLCBgOmJwMWAsIGV0Yy4sIGJlY2F1c2UgdGhleSBhcmUgdXNlZCBpbnRlcm5hbGx5IGJ5IHRoaXMgbWV0aG9kLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlQWxsQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycywgY29uZGl0aW9uLCBwYXJhbXMpIHtcblx0XHRcdGNvbmRpdGlvbiA9IGNvbmRpdGlvbiB8fCAnJztcblx0XHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuXHRcdFx0dmFyIG4gPSAwO1xuXHRcdFx0SmlpLl8uZWFjaChjb3VudGVycywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHR2YXIgcGFyYW1zID0ge307XG5cdFx0XHRcdHBhcmFtc1snOmJweycgKyBuICsgJ30nXSA9IHZhbHVlO1xuXHRcdFx0XHRjb3VudGVyc1tuYW1lXSA9IG5ldyBKaWkuc3FsLkV4cHJlc3Npb24oJ1tbJyArIG5hbWUgKyAnXV0rOmJweycgKyBuICsgJ30nLCBwYXJhbXMpO1xuXHRcdFx0XHRuKys7XG5cdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLnVwZGF0ZSh0aGlzLnRhYmxlTmFtZSgpLCBjb3VudGVycywgY29uZGl0aW9uLCBwYXJhbXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWxldGVzIHJvd3MgaW4gdGhlIHRhYmxlIHVzaW5nIHRoZSBwcm92aWRlZCBjb25kaXRpb25zLlxuXHRcdCAqIFdBUk5JTkc6IElmIHlvdSBkbyBub3Qgc3BlY2lmeSBhbnkgY29uZGl0aW9uLCB0aGlzIG1ldGhvZCB3aWxsIGRlbGV0ZSBBTEwgcm93cyBpbiB0aGUgdGFibGUuXG5cdFx0ICpcblx0XHQgKiBGb3IgZXhhbXBsZSwgdG8gZGVsZXRlIGFsbCBjdXN0b21lcnMgd2hvc2Ugc3RhdHVzIGlzIDM6XG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci5kZWxldGVBbGwoJ3N0YXR1cyA9IDMnKTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfFtdfSBbY29uZGl0aW9uXSB0aGUgY29uZGl0aW9ucyB0aGF0IHdpbGwgYmUgcHV0IGluIHRoZSBXSEVSRSBwYXJ0IG9mIHRoZSBERUxFVEUgU1FMLlxuXHRcdCAqIFBsZWFzZSByZWZlciB0byBbW1F1ZXJ5LndoZXJlKCldXSBvbiBob3cgdG8gc3BlY2lmeSB0aGlzIHBhcmFtZXRlci5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgKG5hbWUgPT4gdmFsdWUpIHRvIGJlIGJvdW5kIHRvIHRoZSBxdWVyeS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIHJvd3MgZGVsZXRlZFxuXHRcdCAqL1xuXHRcdGRlbGV0ZUFsbDogZnVuY3Rpb24gKGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRcdHJldHVybiB0aGlzLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmRlbGV0ZSh0aGlzLnRhYmxlTmFtZSgpLCBjb25kaXRpb24sIHBhcmFtcyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEBpbmhlcml0ZG9jXG5cdFx0ICovXG5cdFx0ZmluZDogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KHRoaXMpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBEZWNsYXJlcyB0aGUgbmFtZSBvZiB0aGUgZGF0YWJhc2UgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQnkgZGVmYXVsdCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjbGFzcyBuYW1lIGFzIHRoZSB0YWJsZSBuYW1lIGJ5IGNhbGxpbmcgW1tJbmZsZWN0b3IuY2FtZWwyaWQoKV1dXG5cdFx0ICogd2l0aCBwcmVmaXggW1tDb25uZWN0aW9uLnRhYmxlUHJlZml4XV0uIEZvciBleGFtcGxlIGlmIFtbQ29ubmVjdGlvbi50YWJsZVByZWZpeF1dIGlzICd0YmxfJyxcblx0XHQgKiAnQ3VzdG9tZXInIGJlY29tZXMgJ3RibF9jdXN0b21lcicsIGFuZCAnT3JkZXJJdGVtJyBiZWNvbWVzICd0Ymxfb3JkZXJfaXRlbScuIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2Rcblx0XHQgKiBpZiB0aGUgdGFibGUgaXMgbm90IG5hbWVkIGFmdGVyIHRoaXMgY29udmVudGlvbi5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgdGFibGUgbmFtZVxuXHRcdCAqL1xuXHRcdHRhYmxlTmFtZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IHRoaXMuY2xhc3NOYW1lKCk7XG5cdFx0XHR2YXIgbmFtZSA9IGNsYXNzTmFtZS5zdWJzdHIoY2xhc3NOYW1lLmxhc3RJbmRleE9mKCcuJykgKyAxKTtcblxuXHRcdFx0cmV0dXJuICd7eyUnICsgSmlpLl9zLnVuZGVyc2NvcmVkKG5hbWUpICsgJ319Jztcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyB0aGUgc2NoZW1hIGluZm9ybWF0aW9uIG9mIHRoZSBEQiB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUiBjbGFzcy5cblx0XHQgKiBAcmV0dXJucyB7SmlpLnNxbC5UYWJsZVNjaGVtYX0gdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBvZiB0aGUgREIgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbn0gaWYgdGhlIHRhYmxlIGZvciB0aGUgQVIgY2xhc3MgZG9lcyBub3QgZXhpc3QuXG5cdFx0ICovXG5cdFx0Z2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHZhciBzY2hlbWEgPSB0aGlzLmdldERiKCkuZ2V0VGFibGVTY2hlbWEodGhpcy50YWJsZU5hbWUoKSk7XG5cdFx0XHRpZiAoc2NoZW1hID09PSBudWxsKSB7XG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKFwiVGhlIHRhYmxlIGRvZXMgbm90IGV4aXN0OiBcIiArIHRoaXMudGFibGVOYW1lKCkpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2NoZW1hO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGtleSBuYW1lKHMpIGZvciB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgcmV0dXJuIHRoZSBwcmltYXJ5IGtleShzKSBhcyBkZWNsYXJlZFxuXHRcdCAqIGluIHRoZSBEQiB0YWJsZSB0aGF0IGlzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqXG5cdFx0ICogSWYgdGhlIERCIHRhYmxlIGRvZXMgbm90IGRlY2xhcmUgYW55IHByaW1hcnkga2V5LCB5b3Ugc2hvdWxkIG92ZXJyaWRlXG5cdFx0ICogdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRoZSBhdHRyaWJ1dGVzIHRoYXQgeW91IHdhbnQgdG8gdXNlIGFzIHByaW1hcnkga2V5c1xuXHRcdCAqIGZvciB0aGlzIEFSIGNsYXNzLlxuXHRcdCAqXG5cdFx0ICogTm90ZSB0aGF0IGFuIGFycmF5IHNob3VsZCBiZSByZXR1cm5lZCBldmVuIGZvciBhIHRhYmxlIHdpdGggc2luZ2xlIHByaW1hcnkga2V5LlxuXHRcdCAqXG5cdFx0ICogQHJldHVybnMge3N0cmluZ1tdfSB0aGUgcHJpbWFyeSBrZXlzIG9mIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHRcdCAqL1xuXHRcdHByaW1hcnlLZXk6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFRhYmxlU2NoZW1hKCkucHJpbWFyeUtleTtcblx0XHR9LFxuXG5cdFx0cG9wdWxhdGVSZWNvcmQ6IGZ1bmN0aW9uIChyZWNvcmQsIHJvdykge1xuXG5cdFx0XHR2YXIgY29sdW1ucyA9IHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKS5jb2x1bW5zO1xuXHRcdFx0SmlpLl8uZWFjaChyb3csIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdGlmIChKaWkuXy5oYXMoY29sdW1ucywgbmFtZSkpIHtcblx0XHRcdFx0XHRyb3dbbmFtZV0gPSBjb2x1bW5zW25hbWVdLnR5cGVjYXN0KHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX19zdXBlcihyZWNvcmQsIHJvdyk7XG5cdFx0fVxuXG5cdH0sXG5cblxuXHQvKipcblx0ICogTG9hZHMgZGVmYXVsdCB2YWx1ZXMgZnJvbSBkYXRhYmFzZSB0YWJsZSBzY2hlbWFcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbc2tpcElmU2V0XSBpZiBleGlzdGluZyB2YWx1ZSBzaG91bGQgYmUgcHJlc2VydmVkXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfSBtb2RlbCBpbnN0YW5jZVxuXHQgKi9cblx0bG9hZERlZmF1bHRWYWx1ZXM6IGZ1bmN0aW9uIChza2lwSWZTZXQpIHtcblx0XHRza2lwSWZTZXQgPSBza2lwSWZTZXQgIT09IGZhbHNlO1xuXG5cdFx0SmlpLl8uZWFjaCh0aGlzLl9fc3RhdGljLmdldFRhYmxlU2NoZW1hKCkuY29sdW1ucywgZnVuY3Rpb24oY29sdW1uKSB7XG5cdFx0XHRpZiAoY29sdW1uLmRlZmF1bHRWYWx1ZSAhPT0gbnVsbCAmJiAoIXNraXBJZlNldCB8fCB0aGlzLmdldChjb2x1bW4ubmFtZSkgPT09IG51bGwpKSB7XG5cdFx0XHRcdHRoaXMuc2V0KGNvbHVtbi5uYW1lLCBjb2x1bW4uZGVmYXVsdFZhbHVlKTtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGFsbCBhdHRyaWJ1dGUgbmFtZXMgb2YgdGhlIG1vZGVsLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHJldHVybiBhbGwgY29sdW1uIG5hbWVzIG9mIHRoZSB0YWJsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBBUiBjbGFzcy5cblx0ICogQHJldHVybnMge1tdfSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcy5cblx0ICovXG5cdGF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gSmlpLl8ua2V5cyh0aGlzLl9fc3RhdGljLmdldFRhYmxlU2NoZW1hKCkuY29sdW1ucyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEluc2VydHMgYSByb3cgaW50byB0aGUgYXNzb2NpYXRlZCBkYXRhYmFzZSB0YWJsZSB1c2luZyB0aGUgYXR0cmlidXRlIHZhbHVlcyBvZiB0aGlzIHJlY29yZC5cblx0ICpcblx0ICogVGhpcyBtZXRob2QgcGVyZm9ybXMgdGhlIGZvbGxvd2luZyBzdGVwcyBpbiBvcmRlcjpcblx0ICpcblx0ICogMS4gY2FsbCBbW2JlZm9yZVZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLiBJZiB2YWxpZGF0aW9uXG5cdCAqICAgIGZhaWxzLCBpdCB3aWxsIHNraXAgdGhlIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBjYWxsIFtbYWZ0ZXJWYWxpZGF0ZSgpXV0gd2hlbiBgcnVuVmFsaWRhdGlvbmAgaXMgdHJ1ZS5cblx0ICogMy4gY2FsbCBbW2JlZm9yZVNhdmUoKV1dLiBJZiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UsIGl0IHdpbGwgc2tpcCB0aGVcblx0ICogICAgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDQuIGluc2VydCB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfSU5TRVJUXV0sIFtbRVZFTlRfQUZURVJfSU5TRVJUXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIGluc2VydGVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIElmIHRoZSB0YWJsZSdzIHByaW1hcnkga2V5IGlzIGF1dG8taW5jcmVtZW50YWwgYW5kIGlzIG51bGwgZHVyaW5nIGluc2VydGlvbixcblx0ICogaXQgd2lsbCBiZSBwb3B1bGF0ZWQgd2l0aCB0aGUgYWN0dWFsIHZhbHVlIGFmdGVyIGluc2VydGlvbi5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRvIGluc2VydCBhIGN1c3RvbWVyIHJlY29yZDpcblx0ICpcblx0ICogfn5+XG5cdCAqIGN1c3RvbWVyID0gbmV3IEN1c3RvbWVyKCk7XG5cdCAqIGN1c3RvbWVyLm5hbWUgPSBuYW1lO1xuXHQgKiBjdXN0b21lci5lbWFpbCA9IGVtYWlsO1xuXHQgKiBjdXN0b21lci5pbnNlcnQoKTtcblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gcnVuVmFsaWRhdGlvbiB3aGV0aGVyIHRvIHBlcmZvcm0gdmFsaWRhdGlvbiBiZWZvcmUgc2F2aW5nIHRoZSByZWNvcmQuXG5cdCAqIElmIHRoZSB2YWxpZGF0aW9uIGZhaWxzLCB0aGUgcmVjb3JkIHdpbGwgbm90IGJlIGluc2VydGVkIGludG8gdGhlIGRhdGFiYXNlLlxuXHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZXMgYXJlIHZhbGlkIGFuZCB0aGUgcmVjb3JkIGlzIGluc2VydGVkIHN1Y2Nlc3NmdWxseS5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGluc2VydCBmYWlsZWQuXG5cdCAqL1xuXHRpbnNlcnQ6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVzKSB7XG5cdFx0cnVuVmFsaWRhdGlvbiA9IHJ1blZhbGlkYXRpb24gIT09IGZhbHNlO1xuXHRcdGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzIHx8IG51bGw7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGlmIChydW5WYWxpZGF0aW9uKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLnZhbGlkYXRlKGF0dHJpYnV0ZXMpO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24oaXNWYWxpZGF0ZSkge1xuXHRcdFx0aWYgKCFpc1ZhbGlkYXRlKSB7XG5cdFx0XHRcdEppaS5pbmZvKCdNb2RlbCBub3QgaW5zZXJ0ZWQgZHVlIHRvIHZhbGlkYXRpb24gZXJyb3IuJyk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0Lyp2YXIgZGIgPSB0aGlzLl9fc3RhdGljLmdldERiKCk7XG5cdFx0XHQgaWYgKHRoaXMuaXNUcmFuc2FjdGlvbmFsKHNlbGYuT1BfSU5TRVJUKSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uID0gZGIuYmVnaW5UcmFuc2FjdGlvbigpO1xuXHRcdFx0IHRyeSB7XG5cdFx0XHQgcmVzdWx0ID0gdGhpcy5pbnNlcnRJbnRlcm5hbChhdHRyaWJ1dGVzKTtcblx0XHRcdCBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHQgfSBlbHNlIHtcblx0XHRcdCB0cmFuc2FjdGlvbi5jb21taXQoKTtcblx0XHRcdCB9XG5cdFx0XHQgfSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0IHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHQgdGhyb3cgZTtcblx0XHRcdCB9XG5cdFx0XHQgfSBlbHNlIHsqL1xuXHRcdFx0cmV0dXJuIHRoaXMuX2luc2VydEludGVybmFsKGF0dHJpYnV0ZXMpO1xuXHRcdFx0Ly99XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogSW5zZXJ0cyBhbiBBY3RpdmVSZWNvcmQgaW50byBEQiB3aXRob3V0IGNvbnNpZGVyaW5nIHRyYW5zYWN0aW9uLlxuXHQgKiBAcGFyYW0ge1tdfSBhdHRyaWJ1dGVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBpcyBpbnNlcnRlZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRfaW5zZXJ0SW50ZXJuYWw6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cdFx0YXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgbnVsbDtcblxuXHRcdHJldHVybiB0aGlzLmJlZm9yZVNhdmUodHJ1ZSkudGhlbihmdW5jdGlvbihib29sKSB7XG5cdFx0XHRpZiAoIWJvb2wpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdmFsdWVzID0gdGhpcy5nZXREaXJ0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG5cdFx0XHRpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG5cdFx0XHRcdEppaS5fLmVhY2godGhpcy5nZXRQcmltYXJ5S2V5KHRydWUpLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0dmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmluc2VydE1vZGVsKHRoaXMsIHZhbHVlcykudGhlbihmdW5jdGlvbihpbnNlcnRJbmZvKSB7XG5cdFx0XHRcdGlmICghaW5zZXJ0SW5mbykge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB0YWJsZSA9IHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKTtcblx0XHRcdFx0aWYgKHRhYmxlLnNlcXVlbmNlTmFtZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGFibGUucHJpbWFyeUtleS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBuYW1lID0gdGFibGUucHJpbWFyeUtleVtpXTtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmdldEF0dHJpYnV0ZShuYW1lKSA9PT0gbnVsbCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgaWQgPSB0YWJsZS5jb2x1bW5zW25hbWVdLnR5cGVjYXN0KGluc2VydEluZm8uaW5zZXJ0SWQpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZShuYW1lLCBpZCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlc1tuYW1lXSA9IGlkO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuICAgICAgICAgICAgICAgIEppaS5fLmVhY2godmFsdWVzLCBmdW5jdGlvbihudW0sIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBjaGFuZ2VkQXR0cmlidXRlc1trZXldID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9KTtcblx0XHRcdFx0dGhpcy5zZXRPbGRBdHRyaWJ1dGVzKHZhbHVlcyk7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyU2F2ZSh0cnVlLCBjaGFuZ2VkQXR0cmlidXRlcykudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNhdmVzIHRoZSBjaGFuZ2VzIHRvIHRoaXMgYWN0aXZlIHJlY29yZCBpbnRvIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlVmFsaWRhdGUoKV1dIHdoZW4gYHJ1blZhbGlkYXRpb25gIGlzIHRydWUuIElmIHZhbGlkYXRpb25cblx0ICogICAgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDIuIGNhbGwgW1thZnRlclZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLlxuXHQgKiAzLiBjYWxsIFtbYmVmb3JlU2F2ZSgpXV0uIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBza2lwIHRoZVxuXHQgKiAgICByZXN0IG9mIHRoZSBzdGVwcztcblx0ICogNC4gc2F2ZSB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfVVBEQVRFXV0sIFtbRVZFTlRfQUZURVJfVVBEQVRFXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byB1cGRhdGUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IEN1c3RvbWVyLmZpbmRPbmUoaWQpO1xuXHQgKiBjdXN0b21lci5uYW1lID0gbmFtZTtcblx0ICogY3VzdG9tZXIuZW1haWwgPSBlbWFpbDtcblx0ICogY3VzdG9tZXIudXBkYXRlKCk7XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIHVwZGF0ZSBkb2VzIG5vdCBhZmZlY3QgYW55IHJvdyBpbiB0aGUgdGFibGUuXG5cdCAqIEluIHRoaXMgY2FzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gMC4gRm9yIHRoaXMgcmVhc29uLCB5b3Ugc2hvdWxkIHVzZSB0aGUgZm9sbG93aW5nXG5cdCAqIGNvZGUgdG8gY2hlY2sgaWYgdXBkYXRlKCkgaXMgc3VjY2Vzc2Z1bCBvciBub3Q6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBpZiAodGhpcy51cGRhdGUoKSAhPT0gZmFsc2UpIHtcbiAgICAgKiAgICAgLy8gdXBkYXRlIHN1Y2Nlc3NmdWxcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgICAvLyB1cGRhdGUgZmFpbGVkXG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBydW5WYWxpZGF0aW9uIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgaW5zZXJ0ZWQgaW50byB0aGUgZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7W119IGF0dHJpYnV0ZU5hbWVzIGxpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge251bWJlcnxib29sZWFufSB0aGUgbnVtYmVyIG9mIHJvd3MgYWZmZWN0ZWQsIG9yIGZhbHNlIGlmIHZhbGlkYXRpb24gZmFpbHNcblx0ICogb3IgW1tiZWZvcmVTYXZlKCldXSBzdG9wcyB0aGUgdXBkYXRpbmcgcHJvY2Vzcy5cblx0ICogQHRocm93cyBTdGFsZU9iamVjdEV4Y2VwdGlvbiBpZiBbW29wdGltaXN0aWNMb2NrfG9wdGltaXN0aWMgbG9ja2luZ11dIGlzIGVuYWJsZWQgYW5kIHRoZSBkYXRhXG5cdCAqIGJlaW5nIHVwZGF0ZWQgaXMgb3V0ZGF0ZWQuXG5cdCAqIEB0aHJvd3MgXFxFeGNlcHRpb24gaW4gY2FzZSB1cGRhdGUgZmFpbGVkLlxuXHQgKi9cblx0dXBkYXRlOiBmdW5jdGlvbiAocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpIHtcblx0XHRydW5WYWxpZGF0aW9uID0gcnVuVmFsaWRhdGlvbiAhPT0gZmFsc2U7XG5cdFx0YXR0cmlidXRlTmFtZXMgPSBhdHRyaWJ1dGVOYW1lcyB8fCBudWxsO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAocnVuVmFsaWRhdGlvbikge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lcyk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbihpc1ZhbGlkYXRlKSB7XG5cdFx0XHRpZiAoIWlzVmFsaWRhdGUpIHtcblx0XHRcdFx0SmlpLmluZm8oJ01vZGVsIG5vdCB1cGRhdGVkIGR1ZSB0byB2YWxpZGF0aW9uIGVycm9yLicpO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdC8qZGIgPSBzdGF0aWMuZ2V0RGIoKTtcblx0XHRcdGlmICh0aGlzLmlzVHJhbnNhY3Rpb25hbChzZWxmLk9QX1VQREFURSkpIHtcblx0XHRcdFx0dHJhbnNhY3Rpb24gPSBkYi5iZWdpblRyYW5zYWN0aW9uKCk7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cmVzdWx0ID0gdGhpcy51cGRhdGVJbnRlcm5hbChhdHRyaWJ1dGVOYW1lcyk7XG5cdFx0XHRcdFx0aWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyYW5zYWN0aW9uLmNvbW1pdCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0XHRcdHRyYW5zYWN0aW9uLnJvbGxCYWNrKCk7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHsqL1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdXBkYXRlSW50ZXJuYWwoYXR0cmlidXRlTmFtZXMpO1xuXHRcdFx0Ly99XG5cblx0XHR9LmJpbmQodGhpcykpO1xuXG5cblx0fSxcblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGUgdGFibGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3RpdmUgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlRGVsZXRlKCldXS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIGZhbHNlLCBpdCB3aWxsIHNraXAgdGhlXG5cdCAqICAgIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBkZWxldGUgdGhlIHJlY29yZCBmcm9tIHRoZSBkYXRhYmFzZTtcblx0ICogMy4gY2FsbCBbW2FmdGVyRGVsZXRlKCldXS5cblx0ICpcblx0ICogSW4gdGhlIGFib3ZlIHN0ZXAgMSBhbmQgMywgZXZlbnRzIG5hbWVkIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGFuZCBbW0VWRU5UX0FGVEVSX0RFTEVURV1dXG5cdCAqIHdpbGwgYmUgcmFpc2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8Ym9vbGVhbn0gdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQsIG9yIGZhbHNlIGlmIHRoZSBkZWxldGlvbiBpcyB1bnN1Y2Nlc3NmdWwgZm9yIHNvbWUgcmVhc29uLlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQgaXMgMCwgZXZlbiB0aG91Z2ggdGhlIGRlbGV0aW9uIGV4ZWN1dGlvbiBpcyBzdWNjZXNzZnVsLlxuXHQgKiBAdGhyb3dzIFN0YWxlT2JqZWN0RXhjZXB0aW9uIGlmIFtbb3B0aW1pc3RpY0xvY2t8b3B0aW1pc3RpYyBsb2NraW5nXV0gaXMgZW5hYmxlZCBhbmQgdGhlIGRhdGFcblx0ICogYmVpbmcgZGVsZXRlZCBpcyBvdXRkYXRlZC5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGRlbGV0ZSBmYWlsZWQuXG5cdCAqL1xuXHRkZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHQvKmRiID0gc3RhdGljLmdldERiKCk7XG5cdFx0aWYgKHRoaXMuaXNUcmFuc2FjdGlvbmFsKHNlbGYuT1BfREVMRVRFKSkge1xuXHRcdFx0dHJhbnNhY3Rpb24gPSBkYi5iZWdpblRyYW5zYWN0aW9uKCk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXN1bHQgPSB0aGlzLmRlbGV0ZUludGVybmFsKCk7XG5cdFx0XHRcdGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0dHJhbnNhY3Rpb24ucm9sbEJhY2soKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0cmFuc2FjdGlvbi5jb21taXQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoXFxFeGNlcHRpb24gZSkge1xuXHRcdFx0XHR0cmFuc2FjdGlvbi5yb2xsQmFjaygpO1xuXHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7Ki9cblx0XHRcdHJldHVybiB0aGlzLl9kZWxldGVJbnRlcm5hbCgpO1xuXHRcdC8vfVxuXG5cdFx0Ly9yZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWxldGVzIGFuIEFjdGl2ZVJlY29yZCB3aXRob3V0IGNvbnNpZGVyaW5nIHRyYW5zYWN0aW9uLlxuXHQgKiBAcmV0dXJucyB7bnVtYmVyfGJvb2xlYW59IHRoZSBudW1iZXIgb2Ygcm93cyBkZWxldGVkLCBvciBmYWxzZSBpZiB0aGUgZGVsZXRpb24gaXMgdW5zdWNjZXNzZnVsIGZvciBzb21lIHJlYXNvbi5cblx0ICogTm90ZSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRoZSBudW1iZXIgb2Ygcm93cyBkZWxldGVkIGlzIDAsIGV2ZW4gdGhvdWdoIHRoZSBkZWxldGlvbiBleGVjdXRpb24gaXMgc3VjY2Vzc2Z1bC5cblx0ICogQHRocm93cyBTdGFsZU9iamVjdEV4Y2VwdGlvblxuXHQgKi9cblx0X2RlbGV0ZUludGVybmFsOiBmdW5jdGlvbiAoKSB7XG5cblx0XHRyZXR1cm4gdGhpcy5iZWZvcmVEZWxldGUoKS50aGVuKGZ1bmN0aW9uKGJvb2wpIHtcblx0XHRcdGlmICghYm9vbCkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpLmRlbGV0ZU1vZGVsKHRoaXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdC8qaWYgKGxvY2sgIT09IG51bGwgJiYgIXJlc3VsdCkge1xuXHRcdFx0XHQgdGhyb3cgbmV3IFN0YWxlT2JqZWN0RXhjZXB0aW9uKCdUaGUgb2JqZWN0IGJlaW5nIGRlbGV0ZWQgaXMgb3V0ZGF0ZWQuJyk7XG5cdFx0XHRcdCB9Ki9cblx0XHRcdFx0dGhpcy5zZXRPbGRBdHRyaWJ1dGVzKG51bGwpO1xuXG5cdFx0XHRcdHJldHVybiB0aGlzLmFmdGVyRGVsZXRlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHR9KTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gYWN0aXZlIHJlY29yZCBpcyB0aGUgc2FtZSBhcyB0aGUgY3VycmVudCBvbmUuXG5cdCAqIFRoZSBjb21wYXJpc29uIGlzIG1hZGUgYnkgY29tcGFyaW5nIHRoZSB0YWJsZSBuYW1lcyBhbmQgdGhlIHByaW1hcnkga2V5IHZhbHVlcyBvZiB0aGUgdHdvIGFjdGl2ZSByZWNvcmRzLlxuXHQgKiBJZiBvbmUgb2YgdGhlIHJlY29yZHMgW1tpc05ld1JlY29yZHxpcyBuZXddXSB0aGV5IGFyZSBhbHNvIGNvbnNpZGVyZWQgbm90IGVxdWFsLlxuXHQgKiBAcGFyYW0ge0ppaS5zcWwuQWN0aXZlUmVjb3JkfSByZWNvcmQgcmVjb3JkIHRvIGNvbXBhcmUgdG9cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHR3byBhY3RpdmUgcmVjb3JkcyByZWZlciB0byB0aGUgc2FtZSByb3cgaW4gdGhlIHNhbWUgZGF0YWJhc2UgdGFibGUuXG5cdCAqL1xuXHRlcXVhbHM6IGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IHJlY29yZC5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMudGFibGVOYW1lKCkgPT09IHJlY29yZC5fX3N0YXRpYy50YWJsZU5hbWUoKSAmJiB0aGlzLmdldFByaW1hcnlLZXkoKSA9PT0gcmVjb3JkLmdldFByaW1hcnlLZXkoKTtcblx0fVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwuQWZ0ZXJTYXZlRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk1vZGVsRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50JywgLyoqIEBsZW5kcyBKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk1vZGVsRXZlbnQsXG5cblx0LyoqXG5cdCAqIFRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgaGFkIGNoYW5nZWQgYW5kIHdlcmUgc2F2ZWQuXG5cdCAqIEB0eXBlIHtzdHJpbmdbXX1cblx0ICovXG5cdGNoYW5nZWRBdHRyaWJ1dGVzOiBudWxsXG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICpcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogRXhwcmVzc2lvbiByZXByZXNlbnRzIGEgREIgZXhwcmVzc2lvbiB0aGF0IGRvZXMgbm90IG5lZWQgZXNjYXBpbmcgb3IgcXVvdGluZy5cbiAqIFdoZW4gYW4gRXhwcmVzc2lvbiBvYmplY3QgaXMgZW1iZWRkZWQgd2l0aGluIGEgU1FMIHN0YXRlbWVudCBvciBmcmFnbWVudCxcbiAqIGl0IHdpbGwgYmUgcmVwbGFjZWQgd2l0aCB0aGUgW1tleHByZXNzaW9uXV0gcHJvcGVydHkgdmFsdWUgd2l0aG91dCBhbnlcbiAqIERCIGVzY2FwaW5nIG9yIHF1b3RpbmcuIEZvciBleGFtcGxlLFxuICpcbiAqIH5+flxuICogZXhwcmVzc2lvbiA9IG5ldyBFeHByZXNzaW9uKCdOT1coKScpO1xuICogc3FsID0gJ1NFTEVDVCAnIC4gZXhwcmVzc2lvbjsgIC8vIFNFTEVDVCBOT1coKVxuICogfn5+XG4gKlxuICogQW4gZXhwcmVzc2lvbiBjYW4gYWxzbyBiZSBib3VuZCB3aXRoIHBhcmFtZXRlcnMgc3BlY2lmaWVkIHZpYSBbW3BhcmFtc11dLlxuICpcbiAqIEBjbGFzcyBKaWkuc3FsLkV4cHJlc3Npb25cbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwuRXhwcmVzc2lvbicsIC8qKiBAbGVuZHMgSmlpLnNxbC5FeHByZXNzaW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ30gdGhlIERCIGV4cHJlc3Npb25cblx0ICovXG5cdGV4cHJlc3Npb246IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtvYmplY3R9IGxpc3Qgb2YgcGFyYW1ldGVycyB0aGF0IHNob3VsZCBiZSBib3VuZCBmb3IgdGhpcyBleHByZXNzaW9uLlxuXHQgKiBUaGUga2V5cyBhcmUgcGxhY2Vob2xkZXJzIGFwcGVhcmluZyBpbiBbW2V4cHJlc3Npb25dXSBhbmQgdGhlIHZhbHVlc1xuXHQgKiBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgcGFyYW1ldGVyIHZhbHVlcy5cblx0ICovXG5cdHBhcmFtczogbnVsbCxcblxuXHQvKipcblx0ICogQ29uc3RydWN0b3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBleHByZXNzaW9uIHRoZSBEQiBleHByZXNzaW9uXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgcGFyYW1ldGVyc1xuXHQgKiBAcGFyYW0ge1tdfSBjb25maWcgbmFtZS12YWx1ZSBwYWlycyB0aGF0IHdpbGwgYmUgdXNlZCB0byBpbml0aWFsaXplIHRoZSBvYmplY3QgcHJvcGVydGllc1xuXHQgKiBAY29uc3RydWN0b3Jcblx0ICovXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoZXhwcmVzc2lvbiwgcGFyYW1zLCBjb25maWcpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cdFx0Y29uZmlnID0gY29uZmlnIHx8IFtdO1xuXG5cdFx0dGhpcy5leHByZXNzaW9uID0gZXhwcmVzc2lvbjtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcztcblx0XHR0aGlzLl9fc3VwZXIoY29uZmlnKTtcblx0fSxcblxuXHQvKipcblx0ICogU3RyaW5nIG1hZ2ljIG1ldGhvZFxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgREIgZXhwcmVzc2lvblxuXHQgKi9cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmV4cHJlc3Npb247XG5cdH1cblxufSk7XG59LHtcImppaVwiOjEyNH1dLDEzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwucmVtb3RlLkNvbW1hbmRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLkNvbW1hbmQnLCAvKiogQGxlbmRzIEppaS5zcWwucmVtb3RlLkNvbW1hbmQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG4gICAgX19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuQ29tbWFuZCAqL3tcblxuICAgICAgICBNRVRIT0RfSU5TRVJUOiAnaW5zZXJ0JyxcbiAgICAgICAgTUVUSE9EX1VQREFURTogJ3VwZGF0ZScsXG4gICAgICAgIE1FVEhPRF9ERUxFVEU6ICdkZWxldGUnXG5cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLnNxbC5CYXNlQ29ubmVjdGlvbn0gdGhlIERCIGNvbm5lY3Rpb24gdGhhdCB0aGlzIGNvbW1hbmQgaXMgYXNzb2NpYXRlZCB3aXRoXG5cdCAqL1xuXHRkYjogbnVsbCxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeUFsbDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdhbGwnKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeU9uZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdvbmUnKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeVNjYWxhcjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdzY2FsYXInKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRxdWVyeUNvbHVtbjogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9xdWVyeUludGVybmFsKCdjb2x1bW4nKTtcblx0fSxcblxuXHQvKipcblx0ICogUGVyZm9ybXMgdGhlIGFjdHVhbCBEQiBxdWVyeSBvZiBhIFNRTCBzdGF0ZW1lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXRob2Rcblx0ICogQHJldHVybnMge1Byb21pc2V9IHRoZSBtZXRob2QgZXhlY3V0aW9uIHJlc3VsdFxuXHQgKiBAdGhyb3dzIEV4Y2VwdGlvbiBpZiB0aGUgcXVlcnkgY2F1c2VzIGFueSBwcm9ibGVtXG5cdCAqL1xuXHRfcXVlcnlJbnRlcm5hbDogZnVuY3Rpb24gKG1ldGhvZCkge1xuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ppaS5zcWwuQWN0aXZlUmVjb3JkfSBtb2RlbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXNcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBpbnNlcnRNb2RlbDogZnVuY3Rpb24obW9kZWwsIHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdGhpcy5kYi5leGVjKHRoaXMuX19zdGF0aWMuTUVUSE9EX0lOU0VSVCwgbW9kZWwuY2xhc3NOYW1lKCksIHtcbiAgICAgICAgICAgIHZhbHVlczogdmFsdWVzXG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkocmVzdWx0LmVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRFcnJvcnMocmVzdWx0LmVycm9ycyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0LmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5zZXRBdHRyaWJ1dGVzKHJlc3VsdC5hdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRJZDogbW9kZWwuZ2V0UHJpbWFyeUtleSgpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgdXBkYXRlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGIuZXhlYyh0aGlzLl9fc3RhdGljLk1FVEhPRF9VUERBVEUsIG1vZGVsLmNsYXNzTmFtZSgpLCB7XG4gICAgICAgICAgICBwcmltYXJ5S2V5OiBtb2RlbC5nZXRPbGRQcmltYXJ5S2V5KHRydWUpLFxuICAgICAgICAgICAgdmFsdWVzOiB2YWx1ZXNcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbihyZXN1bHQpIHtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghSmlpLl8uaXNFbXB0eShyZXN1bHQuZXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNldEVycm9ycyhyZXN1bHQuZXJyb3JzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IG1vZGVsXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG4gICAgZGVsZXRlTW9kZWw6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRiLmV4ZWModGhpcy5fX3N0YXRpYy5NRVRIT0RfREVMRVRFLCBtb2RlbC5jbGFzc05hbWUoKSwge1xuICAgICAgICAgICAgcHJpbWFyeUtleTogbW9kZWwuZ2V0T2xkUHJpbWFyeUtleSh0cnVlKVxuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKHJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHQuc3VjY2VzcyA/IDEgOiAwO1xuICAgICAgICB9KTtcbiAgICB9XG5cbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwxNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcclxuXHJcbi8qKlxyXG4gKlxyXG4gKiBAY2xhc3MgSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvblxyXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcclxuICovXHJcbkppaS5kZWZpbmVDbGFzcygnSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvbicsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuQ29ubmVjdGlvbi5wcm90b3R5cGUgKi97XHJcblxyXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5zcWwucmVtb3RlLlNjaGVtYX0gdGhlIGRhdGFiYXNlIHNjaGVtYVxyXG4gICAgICovXHJcbiAgICBzY2hlbWE6IHtcclxuICAgICAgICBjbGFzc05hbWU6ICdKaWkuc3FsLnJlbW90ZS5TY2hlbWEnXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZX1cclxuICAgICAqL1xyXG4gICAgdHJhbnNwb3J0OiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge3N0cmluZ31cclxuICAgICAqL1xyXG4gICAgcm91dGU6ICdhcGkvYXInLFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICAgIHRoaXMuc2NoZW1hID0gSmlpLmNyZWF0ZU9iamVjdCh0aGlzLnNjaGVtYSk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFRyYW5zcG9ydDogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0ID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0ID0gSmlpLmFwcC5nZXQoJ2NvbWV0Jyk7XHJcbiAgICAgICAgfSBlbHNlIGlmICghKHRoaXMudHJhbnNwb3J0IGluc3RhbmNlb2YgSmlpLmJhc2UuQ29tcG9uZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IEppaS5jcmVhdGVPYmplY3QodGhpcy50cmFuc3BvcnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy50cmFuc3BvcnQ7XHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGNvbW1hbmQgZm9yIGV4ZWN1dGlvbi5cclxuICAgICAqIEByZXR1cm5zIHtKaWkuc3FsLnJlbW90ZS5Db21tYW5kfSB0aGUgREIgY29tbWFuZFxyXG4gICAgICovXHJcbiAgICBjcmVhdGVDb21tYW5kOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBKaWkuc3FsLnJlbW90ZS5Db21tYW5kKHtcclxuICAgICAgICAgICAgZGI6IHRoaXNcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZFxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vZGVsQ2xhc3NOYW1lXHJcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc11cclxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxyXG4gICAgICovXHJcbiAgICBleGVjOiBmdW5jdGlvbihtZXRob2QsIG1vZGVsQ2xhc3NOYW1lLCBwYXJhbXMpIHtcclxuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XHJcbiAgICAgICAgcGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcclxuICAgICAgICBwYXJhbXMubW9kZWxDbGFzc05hbWUgPSBtb2RlbENsYXNzTmFtZTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VHJhbnNwb3J0KCkucmVxdWVzdCh0aGlzLnJvdXRlLCBwYXJhbXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBmb3IgdGhlIGRhdGFiYXNlIG9wZW5lZCBieSB0aGlzIGNvbm5lY3Rpb24uXHJcbiAgICAgKiBAcmV0dXJucyB7SmlpLnNxbC5yZW1vdGUuU2NoZW1hfSB0aGUgc2NoZW1hIGluZm9ybWF0aW9uIGZvciB0aGUgZGF0YWJhc2Ugb3BlbmVkIGJ5IHRoaXMgY29ubmVjdGlvbi5cclxuICAgICAqL1xyXG4gICAgZ2V0U2NoZW1hOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NoZW1hO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIE9idGFpbnMgdGhlIHNjaGVtYSBpbmZvcm1hdGlvbiBmb3IgdGhlIG5hbWVkIHRhYmxlLlxyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGFibGUgbmFtZS5cclxuICAgICAqIEByZXR1cm5zIHsqfSB0YWJsZSBzY2hlbWEgaW5mb3JtYXRpb24uIE51bGwgaWYgdGhlIG5hbWVkIHRhYmxlIGRvZXMgbm90IGV4aXN0LlxyXG4gICAgICovXHJcbiAgICBnZXRUYWJsZVNjaGVtYTogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTY2hlbWEoKS5nZXRUYWJsZVNjaGVtYShuYW1lKTtcclxuICAgIH1cclxuXHJcbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwxNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuc3FsLnJlbW90ZS5TY2hlbWFcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLlNjaGVtYScsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuU2NoZW1hLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXG4gICAgdGFibGVzOiB7fSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuTW9kZWxTY2hlbWF9XG4gICAgICovXG4gICAgZ2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdCh0aGlzLnRhYmxlc1tuYW1lXSkgJiYgISh0aGlzLnRhYmxlc1tuYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsU2NoZW1hKSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZXNbbmFtZV0gPSBKaWkuYmFzZS5Nb2RlbFNjaGVtYS5jcmVhdGVGcm9tT2JqZWN0KHRoaXMudGFibGVzW25hbWVdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnRhYmxlc1tuYW1lXSB8fCBudWxsO1xuICAgIH0sXG5cbiAgICBnZXRUYWJsZU5hbWVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5rZXlzKHRoaXMudGFibGVzKTtcbiAgICB9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDE2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZVxuICogQGludGVyZmFjZSBKaWkuc3FsLnJlbW90ZS5UcmFuc3BvcnRJbnRlcmZhY2VcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZScsIC8qKiBAbGVuZHMgSmlpLnNxbC5yZW1vdGUuVHJhbnNwb3J0SW50ZXJmYWNlLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcblxuICAgIC8qKlxuICAgICAqIFNlbmQgcmVxdWVzdCB0byBiYWNrZW5kXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICovXG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKHJvdXRlLCBwYXJhbXMpIHtcblx0fVxuXG59KTtcbn0se1wiamlpXCI6MTI0fV0sMTc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdqaWknKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL2NsaWVudC9wbHVnaW4vQXV0b1JlY29ubmVjdCcpO1xucmVxdWlyZSgnLi9saWIvY2xpZW50L3BsdWdpbi9QbHVnaW5JbnRlcmZhY2UnKTtcbnJlcXVpcmUoJy4vbGliL2NsaWVudC90cmFuc3BvcnQvVHJhbnNwb3J0SW50ZXJmYWNlJyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvQ2xpZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvTG9nTWVzc2FnZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvTWVzc2FnZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9jbGllbnQvUmVxdWVzdEV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9DaGFubmVsRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL0xvZ0V2ZW50Jyk7XG5cbn0se1wiLi9saWIvQ2hhbm5lbEV2ZW50XCI6MTgsXCIuL2xpYi9Mb2dFdmVudFwiOjE5LFwiLi9saWIvY2xpZW50L0NsaWVudFwiOjIwLFwiLi9saWIvY2xpZW50L0xvZ01lc3NhZ2VFdmVudFwiOjIxLFwiLi9saWIvY2xpZW50L01lc3NhZ2VFdmVudFwiOjIyLFwiLi9saWIvY2xpZW50L1JlcXVlc3RFdmVudFwiOjI0LFwiLi9saWIvY2xpZW50L3BsdWdpbi9BdXRvUmVjb25uZWN0XCI6MjUsXCIuL2xpYi9jbGllbnQvcGx1Z2luL1BsdWdpbkludGVyZmFjZVwiOjI2LFwiLi9saWIvY2xpZW50L3RyYW5zcG9ydC9UcmFuc3BvcnRJbnRlcmZhY2VcIjoyOCxcImppaVwiOjEyNH1dLDE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LkNoYW5uZWxFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuQ2hhbm5lbEV2ZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuQ2hhbm5lbEV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0Y2hhbm5lbDogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdG1lc3NhZ2U6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuTG9nRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmNvbWV0LkxvZ0V2ZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuTG9nRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqIExldmVsOiBkZWJ1Zy9pbmZvL3dhcm5pbmcvZXJyb3Jcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGxldmVsOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBMb2cgbWVzc2FnZVxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0bWVzc2FnZTogbnVsbFxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwyMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogUmVhZC1vbmx5IGZyb20gYXBpIHN0YXRpb25VaWRcbiAqIEB0eXBlIHtudWxsfVxuICovXG52YXIgc3RhdGlvblVpZCA9IG51bGw7XG5cbi8qKlxuICogQGNsYXNzIEppaS5jb21ldC5jbGllbnQuQ2xpZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqIEBpbXBsZW1lbnRzIEppaS5zcWwucmVtb3RlLlRyYW5zcG9ydEludGVyZmFjZVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQuQ2xpZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LkNsaWVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQgKi97XG5cblx0XHQvKipcblx0XHQgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQjb3BlblxuXHRcdCAqIEBwcm9wZXJ0eSB7SmlpLmJhc2UuRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfT1BFTjogJ29wZW4nLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2Nsb3NlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9DTE9TRTogJ2Nsb3NlJyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNiZWZvcmVTZW5kXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9CRUZPUkVfU0VORDogJ2JlZm9yZVNlbmQnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2NoYW5uZWxcblx0XHQgKiBAcHJvcGVydHkge0ppaS5jb21ldC5DaGFubmVsRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfQ0hBTk5FTDogJ2NoYW5uZWwnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQuQ2xpZW50I2NoYW5uZWw6XG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuQ2hhbm5lbEV2ZW50fSBldmVudFxuXHRcdCAqL1xuXHRcdEVWRU5UX0NIQU5ORUxfTkFNRTogJ2NoYW5uZWw6JyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNtZXNzYWdlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9NRVNTQUdFOiAnbWVzc2FnZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LkNsaWVudCNiZWZvcmVSZXF1ZXN0XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9CRUZPUkVfUkVRVUVTVDogJ2JlZm9yZVJlcXVlc3QnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC5DbGllbnQjcmVxdWVzdFxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5jb21ldC5jbGllbnQuUmVxdWVzdEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfUkVRVUVTVDogJ3JlcXVlc3QnXG5cblx0fSxcblxuXHQvKipcblx0ICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZX1cblx0ICovXG5cdHRyYW5zcG9ydDoge1xuXHRcdGNsYXNzTmFtZTogJ0ppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlNvY2tqcydcblx0fSxcblxuXHRwbHVnaW5zOiB7XG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7SmlpLmNvbWV0LmNsaWVudC5wbHVnaW4uQXV0b1JlY29ubmVjdH1cblx0XHQgKi9cblx0XHRhdXRvUmVjb25uZWN0OiB7XG5cdFx0XHRjbGFzc05hbWU6ICdKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5BdXRvUmVjb25uZWN0J1xuXHRcdH1cblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYXggY29tZXQgd29ya2VycyBudW1iZXIuIFVzZWQgZm9yIGF1dG8gZ2VuZXJhdGUgZGlmZmVyZW50IHNlcnZlciB1cmxzIChiYWxhbmNlcikuXG5cdCAqL1xuXHR3b3JrZXJzQ291bnQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0YXV0b09wZW46IHRydWUsXG5cblx0LyoqXG5cdCAqIFVybCB0byBjb21ldCBzZXJ2ZXJcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdF9zZXJ2ZXJVcmw6ICcnLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn1cblx0ICovXG5cdF9pc09wZW5lZDogZmFsc2UsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtib29sZWFufVxuXHQgKi9cblx0X2ZvcmNlQ2xvc2VkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICovXG4gICAgX3JlcXVlc3RzSW5Qcm9jZXNzOiB7fSxcblxuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0c3RhdGlvblVpZCA9IEppaS5oZWxwZXJzLlN0cmluZy5nZW5lcmF0ZVVpZCgpO1xuXG5cdFx0Ly8gSW5pdCB0cmFuc3BvcnRcblx0XHR0aGlzLnRyYW5zcG9ydCA9IEppaS5jcmVhdGVPYmplY3QodGhpcy50cmFuc3BvcnQpO1xuXHRcdHRoaXMudHJhbnNwb3J0Lm9uKEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5FVkVOVF9PUEVOLCB0aGlzLl9vbk9wZW4uYmluZCh0aGlzKSk7XG5cdFx0dGhpcy50cmFuc3BvcnQub24oSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlLkVWRU5UX0NMT1NFLCB0aGlzLl9vbkNsb3NlLmJpbmQodGhpcykpO1xuXHRcdHRoaXMudHJhbnNwb3J0Lm9uKEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5FVkVOVF9NRVNTQUdFLCB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKSk7XG5cblx0XHQvLyBJbml0IHBsdWdpbnNcblx0XHRKaWkuXy5lYWNoKHRoaXMucGx1Z2lucywgZnVuY3Rpb24oY29uZmlnLCBuYW1lKSB7XG5cdFx0XHRjb25maWcuY29tZXQgPSB0aGlzO1xuXHRcdFx0dGhpcy5wbHVnaW5zW25hbWVdID0gSmlpLmNyZWF0ZU9iamVjdChjb25maWcpO1xuXHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHQvLyBBdXRvIG9wZW5cblx0XHRpZiAodGhpcy5hdXRvT3Blbikge1xuXHRcdFx0dGhpcy5vcGVuKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXQgdXJsIHRvIGNvbWV0IHNlcnZlclxuXHQgKiBEZXRlY3Qgc2VydmVyIHVybCBieSBwYXR0ZXJuLCBpZiBzZXQuIFVzZWQgZm9yIGJhbGFuY2VyIHNlcnZlciBieSBjbGllbnRzIHJhbmRvbSgpLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcblx0ICovXG5cdHNldFNlcnZlclVybDogZnVuY3Rpb24odmFsdWUpIHtcblx0XHQvLyBOb3JtYWxpemVcblx0XHRpZiAodmFsdWUuaW5kZXhPZignLy8nKSA9PT0gMCkge1xuXHRcdFx0dmFyIHNzbFN1ZmZpeCA9IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnID8gJ3MnIDogJydcblx0XHRcdHZhbHVlID0gJ2h0dHAnICsgc3NsU3VmZml4ICsgJzonICsgdmFsdWU7XG5cdFx0fVxuXG5cdFx0Ly8gQmFsYW5jZXJcblx0XHRpZiAodmFsdWUuaW5kZXhPZigne3dvcmtlckluZGV4fScpICE9PSAtMSkge1xuXHRcdFx0dmFyIG1pbiA9IDA7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgodGhpcy53b3JrZXJzQ291bnQgfHwgMCwgMSkgLSAxO1xuXHRcdFx0dmFyIHdvcmtlckluZGV4ID0gbWluICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpKTtcblx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgne3dvcmtlckluZGV4fScsIFN0cmluZyh3b3JrZXJJbmRleCkpO1xuXHRcdH1cblxuXHRcdC8vIFN3aXRjaCBzZXJ2ZXIgVVJMIHByb3RvY29sIHRvIEhUVFAgaW5zdGVhZCBvZiBIVFRQUyBpZiBicm93c2VyIGlzIElFOSBvciBsZXNzZXJcblx0XHR2YXIgaXNJRSA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgKC9NU0lFLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvb3BlcmEvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKTtcblx0XHRpZiAoaXNJRSAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2IpIHtcblx0XHRcdHZhciBpc1NzbCA9IC9eKGh0dHB8d3Mpcy8udGVzdCh2YWx1ZSk7XG5cdFx0XHRpZiAoaXNTc2wgPT09IGxvY2F0aW9uLnByb3RvY29sID09PSAnaHR0cHMnKSB7XG5cdFx0XHRcdHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihodHRwfHdzKXMvLCAnJDEnKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9zZXJ2ZXJVcmwgPSB2YWx1ZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIGNvbWV0IHNlcnZlciB1cmxcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldFNlcnZlclVybDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlcnZlclVybDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJuIHN0YXRpb24gVUlEIC0gdW5pcXVlIGlkIG9mIGN1cnJlbnQgamF2YXNjcmlwdCBlbnZpcm9ubWVudCAoYnJvd3NlciB0YWIpXG5cdCAqIEByZXR1cm5zIHtudWxsfVxuXHQgKi9cblx0Z2V0U3RhdGlvblVpZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHN0YXRpb25VaWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlLCBpZiBjb25uZWN0aW9uIGlzIG9wZW5lZFxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzT3BlbmVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faXNPcGVuZWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiB0cnVlLCBpZiBjb25uZWN0aW9uIGNsb3NlZCBieSBjbGllbnQgKG1hbnVhbGx5KVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGlzRm9yY2VDbG9zZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9mb3JjZUNsb3NlZDtcblx0fSxcblxuXHQvKipcblx0ICogT3BlbiBjb25uZWN0aW9uXG5cdCAqL1xuXHRvcGVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9mb3JjZUNsb3NlZCA9IGZhbHNlO1xuXHRcdGlmICghdGhpcy5faXNPcGVuZWQpIHtcblx0XHRcdHRoaXMudHJhbnNwb3J0Lm9wZW4odGhpcy5fc2VydmVyVXJsKTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIENsb3NlIGNvbm5lY3Rpb25cblx0ICovXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9mb3JjZUNsb3NlZCA9IHRydWU7XG5cdFx0aWYgKHRoaXMuX2lzT3BlbmVkKSB7XG5cdFx0XHR0aGlzLnRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNoYW5uZWxcblx0ICogQHBhcmFtIHtvYmplY3R9IGRhdGFcblx0ICovXG5cdHNlbmQ6IGZ1bmN0aW9uKGNoYW5uZWwsIGRhdGEpIHtcblx0XHR0aGlzLl9zZW5kSW50ZXJuYWwoJ2NoYW5uZWwgJyArIGNoYW5uZWwgKyAnICcgKyBKU09OLnN0cmluZ2lmeShkYXRhKSk7XG5cdH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSByb3V0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbZGF0YV1cbiAgICAgKi9cbiAgICByZXF1ZXN0OiBmdW5jdGlvbiAocm91dGUsIGRhdGEpIHtcbiAgICAgICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgICAgIGRhdGEucmVxdWVzdFVpZCA9IEppaS5oZWxwZXJzLlN0cmluZy5nZW5lcmF0ZVVpZCgpO1xuXG4gICAgICAgIC8vIFRyaWdnZXIgZXZlbnQgZm9yIGFwcGVuZCBkYXRhXG4gICAgICAgIHZhciBldmVudCA9IG5ldyBKaWkuY29tZXQuY2xpZW50LlJlcXVlc3RFdmVudCh7XG4gICAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgICBwYXJhbXM6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0JFRk9SRV9SRVFVRVNULCBldmVudCk7XG4gICAgICAgIGRhdGEgPSBldmVudC5wYXJhbXM7XG5cbiAgICAgICAgLy8gR2VuZXJhdGUgcHJvbWlzZSBmb3Igd2FpdCByZXNwb25zZVxuICAgICAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzSW5Qcm9jZXNzW2RhdGEucmVxdWVzdFVpZF0gPSB7XG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IHJlc29sdmVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gU2VuZCByZXF1ZXN0XG4gICAgICAgIHRoaXMuX3NlbmRJbnRlcm5hbCgnYWN0aW9uICcgKyByb3V0ZSArICcgJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcblxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X3NlbmRJbnRlcm5hbDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8vIFRyaWdnZXIgZXZlbnQgYmVmb3JlIHNlbmQgbWVzc2FnZVxuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgSmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnQoe1xuICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICB9KTtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfU0VORCwgZXZlbnQpO1xuICAgICAgICBtZXNzYWdlID0gZXZlbnQubWVzc2FnZTtcblxuXHRcdGlmICh0aGlzLl9pc09wZW5lZCkge1xuXHRcdFx0dGhpcy50cmFuc3BvcnQuc2VuZChtZXNzYWdlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BlbjogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKCF0aGlzLl9pc09wZW5lZCkge1xuXHRcdFx0dGhpcy5faXNPcGVuZWQgPSB0cnVlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfT1BFTiwgZXZlbnQpO1xuXHRcdH1cblx0fSxcblxuXHRfb25DbG9zZTogZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0aWYgKHRoaXMuX2lzT3BlbmVkKSB7XG5cdFx0XHR0aGlzLl9pc09wZW5lZCA9IGZhbHNlO1xuXHRcdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQ0xPU0UsIGV2ZW50KTtcblx0XHR9XG5cdH0sXG5cbiAgICBfb25NZXNzYWdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50Lm1lc3NhZ2UuaW5kZXhPZignYWN0aW9uICcpID09PSAwKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSBKU09OLnBhcnNlKGV2ZW50Lm1lc3NhZ2Uuc3Vic3RyKDcpKTtcbiAgICAgICAgICAgIGlmIChyZXNwb25zZS5yZXF1ZXN0VWlkICYmIHRoaXMuX3JlcXVlc3RzSW5Qcm9jZXNzW3Jlc3BvbnNlLnJlcXVlc3RVaWRdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF0ucmVzb2x2ZShyZXNwb25zZSk7XG5cbiAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIHJlcXVlc3QgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9SRVFVRVNULCBuZXcgSmlpLmNvbWV0LmNsaWVudC5SZXF1ZXN0RXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICByb3V0ZTogdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF0ucm91dGUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtczogcmVzcG9uc2VcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fcmVxdWVzdHNJblByb2Nlc3NbcmVzcG9uc2UucmVxdWVzdFVpZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuXHRcdGlmIChldmVudC5tZXNzYWdlLmluZGV4T2YoJ2NoYW5uZWwgJykgPT09IDApIHtcblx0XHRcdHZhciBtZXNzYWdlID0gZXZlbnQubWVzc2FnZS5zdWJzdHIoOCk7XG5cdFx0XHR2YXIgaSA9IG1lc3NhZ2UuaW5kZXhPZignICcpO1xuXHRcdFx0dmFyIGNoYW5uZWxFdmVudCA9IG5ldyBKaWkuY29tZXQuQ2hhbm5lbEV2ZW50KHtcblx0XHRcdFx0Y2hhbm5lbDogbWVzc2FnZS5zdWJzdHIoMCwgaSksXG5cdFx0XHRcdHBhcmFtczogSlNPTi5wYXJzZShtZXNzYWdlLnN1YnN0cihpICsgMSkpXG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gVHJpZ2dlciBjaGFubmVsIGFuZCBjaGFubmVsOiogZXZlbnRzXG5cdFx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOTkVMX05BTUUgKyBjaGFubmVsRXZlbnQuY2hhbm5lbCwgY2hhbm5lbEV2ZW50KTtcblx0XHRcdHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5ORUwsIGNoYW5uZWxFdmVudCk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJpZ2dlciBtZXNzYWdlIGV2ZW50XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfTUVTU0FHRSwgbmV3IEppaS5jb21ldC5jbGllbnQuTWVzc2FnZUV2ZW50KHtcblx0XHRcdG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2Vcblx0XHR9KSk7XG5cdH1cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMjE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50LkxvZ01lc3NhZ2VFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LkxvZ01lc3NhZ2VFdmVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5Mb2dNZXNzYWdlRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqICBMZXZlbDogZGVidWcvaW5mby93YXJuaW5nL2Vycm9yXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRsZXZlbDogbnVsbCxcblxuXHQvKipcblx0ICogTG9nIG1lc3NhZ2Vcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdG1lc3NhZ2U6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuRXZlbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50Lk1lc3NhZ2VFdmVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRtZXNzYWdlOiBudWxsXG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDIzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlIEppaVxyXG4gKiBAaWdub3JlXHJcbiAqL1xyXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XHJcblxyXG52YXIgTmVhdENvbWV0ID0gcmVxdWlyZSgnbmVhdGNvbWV0Jyk7XHJcblxyXG5cclxuLyoqXHJcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnRcclxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50XHJcbiAqIEBpbXBsZW1lbnRzIE5lYXRDb21ldC5hcGkuSUNvbWV0Q2xpZW50XHJcbiAqL1xyXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQuTmVhdENsaWVudCcsIC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC5OZWF0Q2xpZW50LnByb3RvdHlwZSAqL3tcclxuXHJcbiAgICBfX2V4dGVuZHM6IEppaS5iYXNlLkNvbXBvbmVudCxcclxuXHJcbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnQgKi97XHJcblxyXG4gICAgICAgIFJPVVRFX1BSRUZJWDogJ3Byb2ZpbGVzOidcclxuXHJcbiAgICB9LFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5jb21ldC5jbGllbnQuQ2xpZW50fVxyXG4gICAgICovXHJcbiAgICBjb21ldDogbnVsbCxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEB0eXBlIHtvYmplY3R9XHJcbiAgICAgKi9cclxuICAgIGJpbmRpbmdzOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge05lYXRDb21ldC5OZWF0Q29tZXRDbGllbnR9XHJcbiAgICAgKi9cclxuICAgIGVuZ2luZToge1xyXG4gICAgICAgIGNsYXNzTmFtZTogJ05lYXRDb21ldC5OZWF0Q29tZXRDbGllbnQnXHJcbiAgICB9LFxyXG5cclxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcclxuXHJcbiAgICAgICAgdGhpcy5jb21ldCA9IHRoaXMuY29tZXQgPT09IG51bGwgP1xyXG4gICAgICAgICAgICBKaWkuYXBwLmdldCgnY29tZXQnKSA6XHJcbiAgICAgICAgICAgIChcclxuICAgICAgICAgICAgICAgIHRoaXMuY29tZXQgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db21wb25lbnQgP1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tZXQgOlxyXG4gICAgICAgICAgICAgICAgICAgIEppaS5jcmVhdGVPYmplY3QodGhpcy5jb21ldClcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gTW92ZSBOZWF0Q29tZXQgdG8gSmlpIG5hbWVzcGFjZVxyXG4gICAgICAgIEppaS5fLmV4dGVuZChKaWkubmFtZXNwYWNlKCdOZWF0Q29tZXQnKSwgTmVhdENvbWV0KTtcclxuXHJcbiAgICAgICAgdGhpcy5lbmdpbmUuY29tZXQgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLnByb2ZpbGVzRGVmaW5pdGlvbiA9IHRoaXMuYmluZGluZ3M7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUuY3JlYXRlQ29sbGVjdGlvbiA9IHRoaXMuZW5naW5lLmNyZWF0ZUNvbGxlY3Rpb24gfHwgdGhpcy5fY3JlYXRlQ29sbGVjdGlvbi5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLmNhbGxDb2xsZWN0aW9uID0gdGhpcy5lbmdpbmUuY2FsbENvbGxlY3Rpb24gfHwgdGhpcy5fY2FsbENvbGxlY3Rpb24uYmluZCh0aGlzKTtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IEppaS5jcmVhdGVPYmplY3QodGhpcy5lbmdpbmUpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcHJvZmlsZUlkXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1zXHJcbiAgICAgKiBAcmV0dXJucyB7TmVhdENvbWV0LnJvdXRlci5PcGVuZWRQcm9maWxlQ2xpZW50fVxyXG4gICAgICovXHJcbiAgICBvcGVuUHJvZmlsZTogZnVuY3Rpb24ocHJvZmlsZUlkLCBwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5lbmdpbmUub3BlblByb2ZpbGUocHJvZmlsZUlkLCBwYXJhbXMpO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEFsbG93ZWQgdG8gZXhwZWN0IHRoYXQgaXQgd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIHBlciBJQ29tZXRTZXJ2ZXIgaW5zdGFuY2VcclxuICAgICAqIEBwYXJhbSB7TmVhdENvbWV0LmFwaS5JQ29tZXRDbGllbnRFdmVudHN9IGV2ZW50c0hhbmRsZXJcclxuICAgICAqL1xyXG4gICAgYmluZEV2ZW50czogZnVuY3Rpb24oZXZlbnRzSGFuZGxlcikge1xyXG4gICAgICAgIHRoaXMuY29tZXQub24oSmlpLmNvbWV0LmNsaWVudC5DbGllbnQuRVZFTlRfQ0hBTk5FTCwgZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LmNoYW5uZWwuaW5kZXhPZih0aGlzLl9fc3RhdGljLlJPVVRFX1BSRUZJWCkgPT09IDApIHtcclxuICAgICAgICAgICAgICAgIGV2ZW50c0hhbmRsZXIub25NZXNzYWdlKGV2ZW50LmNoYW5uZWwuc3Vic3RyKHRoaXMuX19zdGF0aWMuUk9VVEVfUFJFRklYLmxlbmd0aCksIGV2ZW50LnBhcmFtcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LmJpbmQodGhpcykpO1xyXG5cclxuICAgICAgICB0aGlzLmNvbWV0Lm9uKCdvcGVuJywgZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgIGV2ZW50c0hhbmRsZXIub25Db25uZWN0aW9uUmVzdG9yZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfSxcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXNcclxuICAgICAqIEBwYXJhbSB7TmVhdENvbWV0LmFwaS5JQ29tZXRDbGllbnR+b3BlblN1Y2Nlc3N9IHN1Y2Nlc3NDYWxsYmFja1xyXG4gICAgICovXHJcbiAgICBzZW5kT3BlbjogZnVuY3Rpb24ocGFyYW1zLCBzdWNjZXNzQ2FsbGJhY2spIHtcclxuICAgICAgICB0aGlzLmNvbWV0LnJlcXVlc3QoJ25lYXQvb3BlbicsIHsgbmVhdDogcGFyYW1zIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xyXG5cclxuICAgICAgICAgICAgLy8gQ2hhaW4gd2l0aCBOZWF0Q29tZXQgaGFuZGxlclxyXG4gICAgICAgICAgICBzdWNjZXNzQ2FsbGJhY2soZGF0YS5uZWF0KTtcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBpZHNcclxuICAgICAqL1xyXG4gICAgc2VuZENsb3NlOiBmdW5jdGlvbihpZHMpIHtcclxuICAgICAgICB0aGlzLmNvbWV0LnJlcXVlc3QoJ25lYXQvY2xvc2UnLCB7IG5lYXQ6IGlkcyB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgX2NyZWF0ZUNvbGxlY3Rpb246IGZ1bmN0aW9uKHByb2ZpbGVJZCwgYmluZGluZ0lkLCBkZWZpbml0aW9uLCBvcGVuZWRQcm9maWxlKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsQ2xhc3NOYW1lID0gZGVmaW5pdGlvbi5jbGllbnRNb2RlbCB8fCBkZWZpbml0aW9uLnNlcnZlck1vZGVsIHx8IEppaS5iYXNlLkFjdGl2ZVJlY29yZDtcclxuICAgICAgICByZXR1cm4gbmV3IEppaS5iYXNlLkNvbGxlY3Rpb24oW10sIHtcclxuICAgICAgICAgICAgbW9kZWxDbGFzczogSmlpLm5hbWVzcGFjZShtb2RlbENsYXNzTmFtZSlcclxuICAgICAgICB9KTtcclxuICAgIH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtKaWkuYmFzZS5Db2xsZWN0aW9ufSBjb2xsZWN0aW9uXHJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXHJcbiAgICAgKiBAcGFyYW0geyp9IHBhcmFtMVxyXG4gICAgICogQHBhcmFtIHsuLi4qfSBwYXJhbTJcclxuICAgICAqIEBwcm90ZWN0ZWRcclxuICAgICAqL1xyXG4gICAgX2NhbGxDb2xsZWN0aW9uOiBmdW5jdGlvbihjb2xsZWN0aW9uLCBtZXRob2QsIHBhcmFtMSwgcGFyYW0yKSB7XHJcbiAgICAgICAgdmFyIG1vZGVsO1xyXG5cclxuICAgICAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIEppaS5iYXNlLkNvbGxlY3Rpb24pIHtcclxuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2FkZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwgPSBjb2xsZWN0aW9uLmNyZWF0ZU1vZGVsKHBhcmFtMSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIC8vIE1hcmsgYXMgZXhpc3RzIHJlY29yZCAobm90IGlzTmV3KVxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldE9sZEF0dHJpYnV0ZXMoSmlpLl8uY2xvbmUobW9kZWwuZ2V0QXR0cmlidXRlcygpKSk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uYWRkKG1vZGVsKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcblxyXG4gICAgICAgICAgICAgICAgY2FzZSAncmVzZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgIEppaS5fLmVhY2gocGFyYW0xLCBmdW5jdGlvbihkYXRhKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxDb2xsZWN0aW9uKGNvbGxlY3Rpb24sICdhZGQnLCBkYXRhKTtcclxuICAgICAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuXHJcbiAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxyXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsID0gY29sbGVjdGlvbi5nZXRCeUlkKHBhcmFtMik7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLnNldChwYXJhbTEpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uYWRkKHBhcmFtMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29sbGVjdGlvblttZXRob2RdLmFwcGx5KGNvbGxlY3Rpb24sIEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgyKSk7XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHtcImppaVwiOjEyNCxcIm5lYXRjb21ldFwiOjJ9XSwyNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5jb21ldC5jbGllbnQuUmVxdWVzdEV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5jb21ldC5jbGllbnQuUmVxdWVzdEV2ZW50JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LlJlcXVlc3RFdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5FdmVudCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG4gICAgcm91dGU6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1BsdWdpbkludGVyZmFjZScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5BdXRvUmVjb25uZWN0XG4gKiBAZXh0ZW5kcyBKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5QbHVnaW5JbnRlcmZhY2VcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5BdXRvUmVjb25uZWN0JywgLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5BdXRvUmVjb25uZWN0LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5jb21ldC5jbGllbnQucGx1Z2luLlBsdWdpbkludGVyZmFjZSxcblxuXHQvKipcblx0ICogQHR5cGUge2Jvb2xlYW59XG5cdCAqL1xuXHRlbmFibGU6IHRydWUsXG5cblx0LyoqXG5cdCAqIE1pbmltYWwgcmV0cnkgaW50ZXJ2YWwgaW4gbWlsbGlzZWNvbmRzXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRtaW5SZXRyeUludGVydmFsOiAyMDAwLFxuXG5cdC8qKlxuXHQgKiBNYXhpbWFsIHJldHJ5IGludGVydmFsIGluIG1pbGxpc2Vjb25kc1xuXHQgKiBAdHlwZSB7bnVtYmVyfVxuXHQgKi9cblx0bWF4UmV0cnlJbnRlcnZhbDogMjAwMDAsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtudW1iZXJ9XG5cdCAqL1xuXHRfdHJ5UmVjb25uZWN0TnVtYmVyOiAwLFxuXG5cdGluaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY29tZXQub24oSmlpLmNvbWV0LmNsaWVudC5DbGllbnQuRVZFTlRfT1BFTiwgdGhpcy5fb25PcGVuLmJpbmQodGhpcykpO1xuXHRcdHRoaXMuY29tZXQudHJhbnNwb3J0Lm9uKEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5FVkVOVF9DTE9TRSwgdGhpcy5fb25DbG9zZS5iaW5kKHRoaXMpKTtcblx0fSxcblxuXHRfb25PcGVuOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cnlSZWNvbm5lY3ROdW1iZXIgPSAwO1xuXHR9LFxuXG5cdF9vbkNsb3NlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5lbmFibGUgJiYgIXRoaXMuY29tZXQuaXNGb3JjZUNsb3NlZCgpKSB7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl90cnlSZWNvbm5lY3ROdW1iZXIrKztcblx0XHRcdFx0dGhpcy5jb21ldC5vcGVuKCk7XG5cdFx0XHR9LmJpbmQodGhpcyksIHRoaXMuX3RyeVJlY29ubmVjdE51bWJlciA+IDEwID8gdGhpcy5tYXhSZXRyeUludGVydmFsIDogdGhpcy5taW5SZXRyeUludGVydmFsKTtcblx0XHR9XG5cdH1cblxufSk7XG59LHtcIi4vUGx1Z2luSW50ZXJmYWNlXCI6MjYsXCJqaWlcIjoxMjR9XSwyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5jb21ldC5jbGllbnQucGx1Z2luLlBsdWdpbkludGVyZmFjZVxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmNvbWV0LmNsaWVudC5wbHVnaW4uUGx1Z2luSW50ZXJmYWNlJywgLyoqIEBsZW5kcyBKaWkuY29tZXQuY2xpZW50LnBsdWdpbi5QbHVnaW5JbnRlcmZhY2UucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLmNvbWV0LmNsaWVudC5DbGllbnR9XG5cdCAqL1xuXHRjb21ldDogbnVsbFxuXG59KTtcbn0se1wiamlpXCI6MTI0fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLy8gc29ja2pzIGdsb2JhbCBmaXg6IHNvY2tqcyBleHBlY3QgdGhhdCBnbG9iYWwgb2JqZWN0IGlzIGVxdWFsIHdpbmRvdywgYnV0IGl0IGlzIG5vdCBhbHdheXMsIGZvciBleGFtcGxlIGluIG5vZGUtd2Via2l0XG5pZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsICE9PSB3aW5kb3cpIHtcbiAgICB2YXIgdXNlZFdpbmRvd0tleXMgPSBbJ2RvY3VtZW50JywgJ2xvY2F0aW9uJywgJ1hNTEh0dHBSZXF1ZXN0JywgJ0V2ZW50U291cmNlJywgJ1dlYlNvY2tldCcsICdNb3pXZWJTb2NrZXQnLFxuICAgICAgICAnWERvbWFpblJlcXVlc3QnLCAnY3J5cHRvJywgJ25hdmlnYXRvcicsICdjaHJvbWUnLCAnYWRkRXZlbnRMaXN0ZW5lcicsICdhdHRhY2hFdmVudCcsXG4gICAgICAgICdyZW1vdmVFdmVudExpc3RlbmVyJywgJ2RldGFjaEV2ZW50JywgJ3BhcmVudCcsICdwb3N0TWVzc2FnZScsICdjb25zb2xlJ107XG4gICAgSmlpLl8uZWFjaCh1c2VkV2luZG93S2V5cywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGdsb2JhbFtrZXldID0gd2luZG93W2tleV07XG4gICAgfSk7XG59XG4vLyBAdG9kbyBqc29ucCBjYWxsYmFja3NcblxudmFyIFNvY2tKUyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuU29ja2pzXG4gKiBAZXh0ZW5kcyBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2VcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5Tb2NranMnLCAvKiogQGxlbmRzIEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlNvY2tqcy5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2UsXG5cbiAgICAvKipcbiAgICAgKiBBdmFpbGFibGU6XG4gICAgICogLSB3ZWJzb2NrZXRcbiAgICAgKiAtIHhkci1wb2xsaW5nXG4gICAgICogLSB4ZHItc3RyZWFtaW5nXG4gICAgICogLSB4aHItcG9sbGluZ1xuICAgICAqIC0geGhyLXN0cmVhbWluZ1xuICAgICAqIC0gZXZlbnRzb3VyY2VcbiAgICAgKiAtIGh0bWxmaWxlXG4gICAgICogLSBpZnJhbWVcbiAgICAgKiAtIGpzb25wLXBvbGxpbmdcbiAgICAgKi9cbiAgICB0cmFuc3BvcnRzOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7U29ja0pTfVxuXHQgKi9cblx0X3dlYnNvY2tldDogbnVsbCxcblxuXHQvKipcblx0ICogT3BlbiBjb25uZWN0aW9uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcblx0ICovXG5cdG9wZW46IGZ1bmN0aW9uKHVybCkge1xuXHRcdHRoaXMuX3dlYnNvY2tldCA9IG5ldyBTb2NrSlModXJsLCBudWxsLCB7XG5cdFx0XHQvL2RlYnVnOiBIZWxwT25DbGljay5kZWJ1ZyxcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IHRoaXMudHJhbnNwb3J0c1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IHRoaXMuX29uT3Blbi5iaW5kKHRoaXMpO1xuXHRcdHRoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLl9vbk1lc3NhZ2UuYmluZCh0aGlzKTtcblx0XHR0aGlzLl93ZWJzb2NrZXQub25jbG9zZSA9IHRoaXMuX29uQ2xvc2UuYmluZCh0aGlzKTtcblx0fSxcblxuXHQvKipcblx0ICogQ2xvc2UgY29ubmVjdGlvblxuXHQgKi9cblx0Y2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl93ZWJzb2NrZXQpIHtcblx0XHRcdHRoaXMuX3dlYnNvY2tldC5jbG9zZSgpO1xuXHRcdFx0dGhpcy5fd2Vic29ja2V0ID0gbnVsbDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNlbmQgbWVzc2FnZSB0byBzZXJ2ZXJcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2Vcblx0ICovXG5cdHNlbmQ6IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRpZiAodGhpcy5fd2Vic29ja2V0KSB7XG5cdFx0XHR0aGlzLl93ZWJzb2NrZXQuc2VuZChtZXNzYWdlKTtcblx0XHR9XG5cdH0sXG5cblx0X29uT3BlbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfT1BFTiwgbmV3IEppaS5iYXNlLkV2ZW50KCkpO1xuXHR9LFxuXG5cdF9vbkNsb3NlOiBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQ0xPU0UsIG5ldyBKaWkuYmFzZS5FdmVudCgpKTtcblx0fSxcblxuXHRfb25NZXNzYWdlOiBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRpZiAoZXZlbnQudHlwZSA9PT0gJ21lc3NhZ2UnKSB7XG5cdFx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9NRVNTQUdFLCBuZXcgSmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnQoe1xuXHRcdFx0XHRtZXNzYWdlOiBldmVudC5kYXRhXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9XG5cbn0pO1xufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcImppaVwiOjEyNCxcInNvY2tqcy1jbGllbnRcIjozMX1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5Db21wb25lbnRcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2UnLCAvKiogQGxlbmRzIEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZS5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlICove1xuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZSNvcGVuXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9PUEVOOiAnb3BlbicsXG5cblx0XHQvKipcblx0XHQgKiBAZXZlbnQgSmlpLmNvbWV0LmNsaWVudC50cmFuc3BvcnQuVHJhbnNwb3J0SW50ZXJmYWNlI2Nsb3NlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnRcblx0XHQgKi9cblx0XHRFVkVOVF9DTE9TRTogJ2Nsb3NlJyxcblxuXHRcdC8qKlxuXHRcdCAqIEBldmVudCBKaWkuY29tZXQuY2xpZW50LnRyYW5zcG9ydC5UcmFuc3BvcnRJbnRlcmZhY2UjbWVzc2FnZVxuXHRcdCAqIEBwcm9wZXJ0eSB7SmlpLmNvbWV0LmNsaWVudC5NZXNzYWdlRXZlbnR9IGV2ZW50XG5cdFx0ICovXG5cdFx0RVZFTlRfTUVTU0FHRTogJ21lc3NhZ2UnLFxuXG5cdFx0LyoqXG5cdFx0ICogQGV2ZW50IEppaS5jb21ldC5jbGllbnQudHJhbnNwb3J0LlRyYW5zcG9ydEludGVyZmFjZSNsb2dcblx0XHQgKiBAcHJvcGVydHkge0ppaS5jb21ldC5jbGllbnQuTG9nTWVzc2FnZUV2ZW50fSBldmVudFxuXHRcdCAqL1xuXHRcdEVWRU5UX0xPRzogJ2xvZydcblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBPcGVuIGNvbm5lY3Rpb25cblx0ICogQHBhcmFtIHtzdHJpbmd9IHVybFxuXHQgKi9cblx0b3BlbjogZnVuY3Rpb24odXJsKSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIENsb3NlIGNvbm5lY3Rpb25cblx0ICovXG5cdGNsb3NlOiBmdW5jdGlvbigpIHtcblx0fSxcblxuXHQvKipcblx0ICogU2VuZCBtZXNzYWdlIHRvIHNlcnZlclxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVxuXHQgKi9cblx0c2VuZDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHR9XG5cbn0pO1xufSx7XCJqaWlcIjoxMjR9XSwyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuL2luZGV4LWNsaWVudCcpO1xucmVxdWlyZSgnLi9saWIvY2xpZW50L05lYXRDbGllbnQnKTtcbn0se1wiLi9pbmRleC1jbGllbnRcIjoxNyxcIi4vbGliL2NsaWVudC9OZWF0Q2xpZW50XCI6MjN9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxufSx7fV0sMzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhbnNwb3J0TGlzdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0LWxpc3QnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL21haW4nKSh0cmFuc3BvcnRMaXN0KTtcblxuLy8gVE9ETyBjYW4ndCBnZXQgcmlkIG9mIHRoaXMgdW50aWwgYWxsIHNlcnZlcnMgZG9cbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIGdsb2JhbCkge1xuICBzZXRUaW1lb3V0KGdsb2JhbC5fc29ja2pzX29ubG9hZCwgMSk7XG59XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL21haW5cIjo0NCxcIi4vdHJhbnNwb3J0LWxpc3RcIjo0Nn1dLDMyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gQ2xvc2VFdmVudCgpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ2Nsb3NlJywgZmFsc2UsIGZhbHNlKTtcbiAgdGhpcy53YXNDbGVhbiA9IGZhbHNlO1xuICB0aGlzLmNvZGUgPSAwO1xuICB0aGlzLnJlYXNvbiA9ICcnO1xufVxuXG5pbmhlcml0cyhDbG9zZUV2ZW50LCBFdmVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2xvc2VFdmVudDtcblxufSx7XCIuL2V2ZW50XCI6MzQsXCJpbmhlcml0c1wiOjg3fV0sMzM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRUYXJnZXQgPSByZXF1aXJlKCcuL2V2ZW50dGFyZ2V0JylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50VGFyZ2V0LmNhbGwodGhpcyk7XG59XG5cbmluaGVyaXRzKEV2ZW50RW1pdHRlciwgRXZlbnRUYXJnZXQpO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHR5cGUpIHtcbiAgICBkZWxldGUgdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICBzZWxmLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICB0aGlzLm9uKHR5cGUsIGcpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzW3R5cGVdO1xuICBpZiAoIWxpc3RlbmVycykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IEV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cy5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbn0se1wiLi9ldmVudHRhcmdldFwiOjM1LFwiaW5oZXJpdHNcIjo4N31dLDM0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gRXZlbnQoZXZlbnRUeXBlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbn1cblxuRXZlbnQucHJvdG90eXBlLmluaXRFdmVudCA9IGZ1bmN0aW9uKGV2ZW50VHlwZSwgY2FuQnViYmxlLCBjYW5jZWxhYmxlKSB7XG4gIHRoaXMudHlwZSA9IGV2ZW50VHlwZTtcbiAgdGhpcy5idWJibGVzID0gY2FuQnViYmxlO1xuICB0aGlzLmNhbmNlbGFibGUgPSBjYW5jZWxhYmxlO1xuICB0aGlzLnRpbWVTdGFtcCA9ICtuZXcgRGF0ZSgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbigpIHt9O1xuRXZlbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ICA9IGZ1bmN0aW9uKCkge307XG5cbkV2ZW50LkNBUFRVUklOR19QSEFTRSA9IDE7XG5FdmVudC5BVF9UQVJHRVQgICAgICAgPSAyO1xuRXZlbnQuQlVCQkxJTkdfUEhBU0UgID0gMztcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudDtcblxufSx7fV0sMzU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xuXG5mdW5jdGlvbiBFdmVudFRhcmdldCgpIHtcbiAgdGhpcy5fbGlzdGVuZXJzID0ge307XG59XG5cbkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIShldmVudFR5cGUgaW4gdGhpcy5fbGlzdGVuZXJzKSkge1xuICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gIH1cbiAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAvLyAjNFxuICBpZiAoYXJyLmluZGV4T2YobGlzdGVuZXIpID09PSAtMSkge1xuICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICBhcnIgPSBhcnIuY29uY2F0KFtsaXN0ZW5lcl0pO1xuICB9XG4gIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyO1xufTtcblxuRXZlbnRUYXJnZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgaWYgKCFhcnIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGlkeCA9IGFyci5pbmRleE9mKGxpc3RlbmVyKTtcbiAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgIC8vIE1ha2UgYSBjb3B5IHNvIGFzIG5vdCB0byBpbnRlcmZlcmUgd2l0aCBhIGN1cnJlbnQgZGlzcGF0Y2hFdmVudC5cbiAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gYXJyLnNsaWNlKDAsIGlkeCkuY29uY2F0KGFyci5zbGljZShpZHggKyAxKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuXG5FdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICAvLyBUT0RPOiBUaGlzIGRvZXNuJ3QgbWF0Y2ggdGhlIHJlYWwgYmVoYXZpb3I7IHBlciBzcGVjLCBvbmZvbyBnZXRcbiAgLy8gdGhlaXIgcGxhY2UgaW4gbGluZSBmcm9tIHRoZSAvZmlyc3QvIHRpbWUgdGhleSdyZSBzZXQgZnJvbVxuICAvLyBub24tbnVsbC4gQWx0aG91Z2ggV2ViS2l0IGJ1bXBzIGl0IHRvIHRoZSBlbmQgZXZlcnkgdGltZSBpdCdzXG4gIC8vIHNldC5cbiAgaWYgKHRoaXNbJ29uJyArIHRdKSB7XG4gICAgdGhpc1snb24nICsgdF0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cbiAgaWYgKHQgaW4gdGhpcy5fbGlzdGVuZXJzKSB7XG4gICAgLy8gR3JhYiBhIHJlZmVyZW5jZSB0byB0aGUgbGlzdGVuZXJzIGxpc3QuIHJlbW92ZUV2ZW50TGlzdGVuZXIgbWF5IGFsdGVyIHRoZSBsaXN0LlxuICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9saXN0ZW5lcnNbdF07XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRUYXJnZXQ7XG5cbn0se31dLDM2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50ID0gcmVxdWlyZSgnLi9ldmVudCcpXG4gIDtcblxuZnVuY3Rpb24gVHJhbnNwb3J0TWVzc2FnZUV2ZW50KGRhdGEpIHtcbiAgRXZlbnQuY2FsbCh0aGlzKTtcbiAgdGhpcy5pbml0RXZlbnQoJ21lc3NhZ2UnLCBmYWxzZSwgZmFsc2UpO1xuICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5pbmhlcml0cyhUcmFuc3BvcnRNZXNzYWdlRXZlbnQsIEV2ZW50KTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc3BvcnRNZXNzYWdlRXZlbnQ7XG5cbn0se1wiLi9ldmVudFwiOjM0LFwiaW5oZXJpdHNcIjo4N31dLDM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIGlmcmFtZVV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9pZnJhbWUnKVxuICA7XG5cbmZ1bmN0aW9uIEZhY2FkZUpTKHRyYW5zcG9ydCkge1xuICB0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIHRyYW5zcG9ydC5vbignbWVzc2FnZScsIHRoaXMuX3RyYW5zcG9ydE1lc3NhZ2UuYmluZCh0aGlzKSk7XG4gIHRyYW5zcG9ydC5vbignY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbn1cblxuRmFjYWRlSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBpZnJhbWVVdGlscy5wb3N0TWVzc2FnZSgnYycsIEpTT04zLnN0cmluZ2lmeShbY29kZSwgcmVhc29uXSkpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fdHJhbnNwb3J0TWVzc2FnZSA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gIGlmcmFtZVV0aWxzLnBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcbiAgdGhpcy5fdHJhbnNwb3J0LnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBGYWNhZGVKUztcblxufSx7XCIuL3V0aWxzL2lmcmFtZVwiOjc3LFwianNvbjNcIjo4OH1dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciB1cmxVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvdXJsJylcbiAgLCBldmVudFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy9ldmVudCcpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRmFjYWRlSlMgPSByZXF1aXJlKCcuL2ZhY2FkZScpXG4gICwgSW5mb0lmcmFtZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9pbmZvLWlmcmFtZS1yZWNlaXZlcicpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2lmcmFtZScpXG4gICwgbG9jID0gcmVxdWlyZSgnLi9sb2NhdGlvbicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppZnJhbWUtYm9vdHN0cmFwJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oU29ja0pTLCBhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHZhciB0cmFuc3BvcnRNYXAgPSB7fTtcbiAgYXZhaWxhYmxlVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uKGF0KSB7XG4gICAgaWYgKGF0LmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgdHJhbnNwb3J0TWFwW2F0LmZhY2FkZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lXSA9IGF0LmZhY2FkZVRyYW5zcG9ydDtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIGhhcmQtY29kZWQgZm9yIHRoZSBpbmZvIGlmcmFtZVxuICAvLyBUT0RPIHNlZSBpZiB3ZSBjYW4gbWFrZSB0aGlzIG1vcmUgZHluYW1pY1xuICB0cmFuc3BvcnRNYXBbSW5mb0lmcmFtZVJlY2VpdmVyLnRyYW5zcG9ydE5hbWVdID0gSW5mb0lmcmFtZVJlY2VpdmVyO1xuICB2YXIgcGFyZW50T3JpZ2luO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICBTb2NrSlMuYm9vdHN0cmFwX2lmcmFtZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG4gICAgdmFyIGZhY2FkZTtcbiAgICBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQgPSBsb2MuaGFzaC5zbGljZSgxKTtcbiAgICB2YXIgb25NZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgaWYgKGUuc291cmNlICE9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBwYXJlbnRPcmlnaW4gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHBhcmVudE9yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgfVxuICAgICAgaWYgKGUub3JpZ2luICE9PSBwYXJlbnRPcmlnaW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaWZyYW1lTWVzc2FnZTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBlLmRhdGEpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChpZnJhbWVNZXNzYWdlLndpbmRvd0lkICE9PSBpZnJhbWVVdGlscy5jdXJyZW50V2luZG93SWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChpZnJhbWVNZXNzYWdlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ3MnOlxuICAgICAgICB2YXIgcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBwID0gSlNPTjMucGFyc2UoaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gcFsxXTtcbiAgICAgICAgdmFyIHRyYW5zVXJsID0gcFsyXTtcbiAgICAgICAgdmFyIGJhc2VVcmwgPSBwWzNdO1xuICAgICAgICBkZWJ1Zyh2ZXJzaW9uLCB0cmFuc3BvcnQsIHRyYW5zVXJsLCBiYXNlVXJsKTtcbiAgICAgICAgLy8gY2hhbmdlIHRoaXMgdG8gc2VtdmVyIGxvZ2ljXG4gICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW5jb21wYXRpYmlsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOicgK1xuICAgICAgICAgICAgICAgICAgICAnIFwiJyArIHZlcnNpb24gKyAnXCIsIHRoZSBpZnJhbWU6JyArXG4gICAgICAgICAgICAgICAgICAgICcgXCInICsgU29ja0pTLnZlcnNpb24gKyAnXCIuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwodHJhbnNVcmwsIGxvYy5ocmVmKSB8fFxuICAgICAgICAgICAgIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoYmFzZVVybCwgbG9jLmhyZWYpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5cXCd0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS4gKCcgKyBsb2MuaHJlZiArICcsICcgKyB0cmFuc1VybCArICcsICcgKyBiYXNlVXJsICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgICBmYWNhZGUgPSBuZXcgRmFjYWRlSlMobmV3IHRyYW5zcG9ydE1hcFt0cmFuc3BvcnRdKHRyYW5zVXJsLCBiYXNlVXJsKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIGZhY2FkZS5fc2VuZChpZnJhbWVNZXNzYWdlLmRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2MnOlxuICAgICAgICBpZiAoZmFjYWRlKSB7XG4gICAgICAgICAgZmFjYWRlLl9jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgb25NZXNzYWdlKTtcblxuICAgIC8vIFN0YXJ0XG4gICAgaWZyYW1lVXRpbHMucG9zdE1lc3NhZ2UoJ3MnKTtcbiAgfTtcbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCIuL2ZhY2FkZVwiOjM3LFwiLi9pbmZvLWlmcmFtZS1yZWNlaXZlclwiOjQwLFwiLi9sb2NhdGlvblwiOjQzLFwiLi91dGlscy9ldmVudFwiOjc2LFwiLi91dGlscy9pZnJhbWVcIjo3NyxcIi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImpzb24zXCI6ODh9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgb2JqZWN0VXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL29iamVjdCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDppbmZvLWFqYXgnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0FqYXgodXJsLCBBamF4T2JqZWN0KSB7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIHQwID0gK25ldyBEYXRlKCk7XG4gIHRoaXMueG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgdXJsKTtcblxuICB0aGlzLnhvLm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgIHZhciBpbmZvLCBydHQ7XG4gICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICBydHQgPSAoK25ldyBEYXRlKCkpIC0gdDA7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluZm8gPSBKU09OMy5wYXJzZSh0ZXh0KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGRlYnVnKCdiYWQganNvbicsIHRleHQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghb2JqZWN0VXRpbHMuaXNPYmplY3QoaW5mbykpIHtcbiAgICAgICAgaW5mbyA9IHt9O1xuICAgICAgfVxuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9BamF4LCBFdmVudEVtaXR0ZXIpO1xuXG5JbmZvQWpheC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy54by5jbG9zZSgpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbmZvQWpheDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4vdXRpbHMvb2JqZWN0XCI6NzksXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4NyxcImpzb24zXCI6ODh9XSw0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItbG9jYWwnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbmZ1bmN0aW9uIEluZm9SZWNlaXZlcklmcmFtZSh0cmFuc1VybCkge1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaXIgPSBuZXcgSW5mb0FqYXgodHJhbnNVcmwsIFhIUkxvY2FsT2JqZWN0KTtcbiAgdGhpcy5pci5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICBzZWxmLmlyID0gbnVsbDtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBKU09OMy5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKEluZm9SZWNlaXZlcklmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb1JlY2VpdmVySWZyYW1lLnRyYW5zcG9ydE5hbWUgPSAnaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuXG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGlmICh0aGlzLmlyKSB7XG4gICAgdGhpcy5pci5jbG9zZSgpO1xuICAgIHRoaXMuaXIgPSBudWxsO1xuICB9XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9SZWNlaXZlcklmcmFtZTtcblxufSx7XCIuL2luZm8tYWpheFwiOjM5LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbFwiOjY3LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3LFwianNvbjNcIjo4OH1dLDQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL2V2ZW50JylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9pZnJhbWUnKVxuICAsIEluZm9SZWNlaXZlcklmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUtcmVjZWl2ZXInKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1pZnJhbWUnKTtcbn1cblxuZnVuY3Rpb24gSW5mb0lmcmFtZShiYXNlVXJsLCB1cmwpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgZ28gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgaWZyID0gc2VsZi5pZnIgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KEluZm9SZWNlaXZlcklmcmFtZS50cmFuc3BvcnROYW1lLCB1cmwsIGJhc2VVcmwpO1xuXG4gICAgaWZyLm9uY2UoJ21lc3NhZ2UnLCBmdW5jdGlvbihtc2cpIHtcbiAgICAgIGlmIChtc2cpIHtcbiAgICAgICAgdmFyIGQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZCA9IEpTT04zLnBhcnNlKG1zZyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBkZWJ1ZygnYmFkIGpzb24nLCBtc2cpO1xuICAgICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgc2VsZi5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgfVxuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuXG4gICAgaWZyLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24oKSB7XG4gICAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgc2VsZi5jbG9zZSgpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFRPRE8gdGhpcyBzZWVtcyB0aGUgc2FtZSBhcyB0aGUgJ25lZWRCb2R5JyBmcm9tIHRyYW5zcG9ydHNcbiAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSkge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZ28pO1xuICB9IGVsc2Uge1xuICAgIGdvKCk7XG4gIH1cbn1cblxuaW5oZXJpdHMoSW5mb0lmcmFtZSwgRXZlbnRFbWl0dGVyKTtcblxuSW5mb0lmcmFtZS5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSW5mb0lmcmFtZS5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuaWZyKSB7XG4gICAgdGhpcy5pZnIuY2xvc2UoKTtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLmlmciA9IG51bGw7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEluZm9JZnJhbWU7XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vaW5mby1pZnJhbWUtcmVjZWl2ZXJcIjo0MCxcIi4vdHJhbnNwb3J0L2lmcmFtZVwiOjUyLFwiLi91dGlscy9ldmVudFwiOjc2LFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODcsXCJqc29uM1wiOjg4fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi91dGlscy91cmwnKVxuICAsIFhEUiA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94ZHInKVxuICAsIFhIUkNvcnMgPSByZXF1aXJlKCcuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWNvcnMnKVxuICAsIFhIUkxvY2FsID0gcmVxdWlyZSgnLi90cmFuc3BvcnQvc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgWEhSRmFrZSA9IHJlcXVpcmUoJy4vdHJhbnNwb3J0L3NlbmRlci94aHItZmFrZScpXG4gICwgSW5mb0lmcmFtZSA9IHJlcXVpcmUoJy4vaW5mby1pZnJhbWUnKVxuICAsIEluZm9BamF4ID0gcmVxdWlyZSgnLi9pbmZvLWFqYXgnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6aW5mby1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBJbmZvUmVjZWl2ZXIoYmFzZVVybCwgdXJsSW5mbykge1xuICBkZWJ1ZyhiYXNlVXJsKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuZG9YaHIoYmFzZVVybCwgdXJsSW5mbyk7XG4gIH0sIDApO1xufVxuXG5pbmhlcml0cyhJbmZvUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbi8vIFRPRE8gdGhpcyBpcyBjdXJyZW50bHkgaWdub3JpbmcgdGhlIGxpc3Qgb2YgYXZhaWxhYmxlIHRyYW5zcG9ydHMgYW5kIHRoZSB3aGl0ZWxpc3RcblxuSW5mb1JlY2VpdmVyLl9nZXRSZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VVcmwsIHVybCwgdXJsSW5mbykge1xuICAvLyBkZXRlcm1pbmUgbWV0aG9kIG9mIENPUlMgc3VwcG9ydCAoaWYgbmVlZGVkKVxuICBpZiAodXJsSW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkxvY2FsKTtcbiAgfVxuICBpZiAoWEhSQ29ycy5lbmFibGVkKSB7XG4gICAgcmV0dXJuIG5ldyBJbmZvQWpheCh1cmwsIFhIUkNvcnMpO1xuICB9XG4gIGlmIChYRFIuZW5hYmxlZCAmJiB1cmxJbmZvLnNhbWVTY2hlbWUpIHtcbiAgICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWERSKTtcbiAgfVxuICBpZiAoSW5mb0lmcmFtZS5lbmFibGVkKCkpIHtcbiAgICByZXR1cm4gbmV3IEluZm9JZnJhbWUoYmFzZVVybCwgdXJsKTtcbiAgfVxuICByZXR1cm4gbmV3IEluZm9BamF4KHVybCwgWEhSRmFrZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZVVybCwgdXJsSW5mbykge1xuICB2YXIgc2VsZiA9IHRoaXNcbiAgICAsIHVybCA9IHVybFV0aWxzLmFkZFBhdGgoYmFzZVVybCwgJy9pbmZvJylcbiAgICA7XG4gIGRlYnVnKCdkb1hocicsIHVybCk7XG5cbiAgdGhpcy54byA9IEluZm9SZWNlaXZlci5fZ2V0UmVjZWl2ZXIoYmFzZVVybCwgdXJsLCB1cmxJbmZvKTtcblxuICB0aGlzLnRpbWVvdXRSZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd0aW1lb3V0Jyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnKTtcbiAgfSwgSW5mb1JlY2VpdmVyLnRpbWVvdXQpO1xuXG4gIHRoaXMueG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oaW5mbywgcnR0KSB7XG4gICAgZGVidWcoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgc2VsZi5fY2xlYW51cCh0cnVlKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gIH0pO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKHdhc0NsZWFuKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICBjbGVhclRpbWVvdXQodGhpcy50aW1lb3V0UmVmKTtcbiAgdGhpcy50aW1lb3V0UmVmID0gbnVsbDtcbiAgaWYgKCF3YXNDbGVhbiAmJiB0aGlzLnhvKSB7XG4gICAgdGhpcy54by5jbG9zZSgpO1xuICB9XG4gIHRoaXMueG8gPSBudWxsO1xufTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdGhpcy5fY2xlYW51cChmYWxzZSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIudGltZW91dCA9IDgwMDA7XG5cbm1vZHVsZS5leHBvcnRzID0gSW5mb1JlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi9pbmZvLWFqYXhcIjozOSxcIi4vaW5mby1pZnJhbWVcIjo0MSxcIi4vdHJhbnNwb3J0L3NlbmRlci94ZHJcIjo2NCxcIi4vdHJhbnNwb3J0L3NlbmRlci94aHItY29yc1wiOjY1LFwiLi90cmFuc3BvcnQvc2VuZGVyL3hoci1mYWtlXCI6NjYsXCIuL3RyYW5zcG9ydC9zZW5kZXIveGhyLWxvY2FsXCI6NjcsXCIuL3V0aWxzL3VybFwiOjgyLFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw0MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmxvY2F0aW9uIHx8IHtcbiAgb3JpZ2luOiAnaHR0cDovL2xvY2FsaG9zdDo4MCdcbiwgcHJvdG9jb2w6ICdodHRwJ1xuLCBob3N0OiAnbG9jYWxob3N0J1xuLCBwb3J0OiA4MFxuLCBocmVmOiAnaHR0cDovL2xvY2FsaG9zdC8nXG4sIGhhc2g6ICcnXG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCcuL3NoaW1zJyk7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4vdXRpbHMvcmFuZG9tJylcbiAgLCBlc2NhcGUgPSByZXF1aXJlKCcuL3V0aWxzL2VzY2FwZScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzL3VybCcpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvZXZlbnQnKVxuICAsIHRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vdXRpbHMvdHJhbnNwb3J0JylcbiAgLCBvYmplY3RVdGlscyA9IHJlcXVpcmUoJy4vdXRpbHMvb2JqZWN0JylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi91dGlscy9icm93c2VyJylcbiAgLCBsb2cgPSByZXF1aXJlKCcuL3V0aWxzL2xvZycpXG4gICwgRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2V2ZW50JylcbiAgLCBFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZXZlbnQvZXZlbnR0YXJnZXQnKVxuICAsIGxvYyA9IHJlcXVpcmUoJy4vbG9jYXRpb24nKVxuICAsIENsb3NlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L2Nsb3NlJylcbiAgLCBUcmFuc3BvcnRNZXNzYWdlRXZlbnQgPSByZXF1aXJlKCcuL2V2ZW50L3RyYW5zLW1lc3NhZ2UnKVxuICAsIEluZm9SZWNlaXZlciA9IHJlcXVpcmUoJy4vaW5mby1yZWNlaXZlcicpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIE1ha2UgZGVidWcgbW9kdWxlIGF2YWlsYWJsZSBnbG9iYWxseSBzbyB5b3UgY2FuIGVuYWJsZSB2aWEgdGhlIGNvbnNvbGUgZWFzaWx5XG4gIGdsb2JhbC5kYmcgPSByZXF1aXJlKCdkZWJ1ZycpO1xuICBkZWJ1ZyA9IGdsb2JhbC5kYmcoJ3NvY2tqcy1jbGllbnQ6bWFpbicpO1xufVxuXG52YXIgdHJhbnNwb3J0cztcblxuLy8gZm9sbG93IGNvbnN0cnVjdG9yIHN0ZXBzIGRlZmluZWQgYXQgaHR0cDovL2Rldi53My5vcmcvaHRtbDUvd2Vic29ja2V0cy8jdGhlLXdlYnNvY2tldC1pbnRlcmZhY2VcbmZ1bmN0aW9uIFNvY2tKUyh1cmwsIHByb3RvY29scywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU29ja0pTKSkge1xuICAgIHJldHVybiBuZXcgU29ja0pTKHVybCwgcHJvdG9jb2xzLCBvcHRpb25zKTtcbiAgfVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA8IDEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmFpbGVkIHRvIGNvbnN0cnVjdCAnU29ja0pTOiAxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnRcIik7XG4gIH1cbiAgRXZlbnRUYXJnZXQuY2FsbCh0aGlzKTtcblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgdGhpcy5leHRlbnNpb25zID0gJyc7XG4gIHRoaXMucHJvdG9jb2wgPSAnJztcblxuICAvLyBub24tc3RhbmRhcmQgZXh0ZW5zaW9uXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAob3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgbG9nLndhcm4oXCIncHJvdG9jb2xzX3doaXRlbGlzdCcgaXMgREVQUkVDQVRFRC4gVXNlICd0cmFuc3BvcnRzJyBpbnN0ZWFkLlwiKTtcbiAgfVxuICB0aGlzLl90cmFuc3BvcnRzV2hpdGVsaXN0ID0gb3B0aW9ucy50cmFuc3BvcnRzO1xuXG4gIHZhciBzZXNzaW9uSWQgPSBvcHRpb25zLnNlc3Npb25JZCB8fCA4O1xuICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRoaXMuX2dlbmVyYXRlU2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICdudW1iZXInKSB7XG4gICAgdGhpcy5fZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByYW5kb20uc3RyaW5nKHNlc3Npb25JZCk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSWYgc2Vzc2lvbklkIGlzIHVzZWQgaW4gdGhlIG9wdGlvbnMsIGl0IG5lZWRzIHRvIGJlIGEgbnVtYmVyIG9yIGEgZnVuY3Rpb24uXCIpO1xuICB9XG5cbiAgdGhpcy5fc2VydmVyID0gb3B0aW9ucy5zZXJ2ZXIgfHwgcmFuZG9tLm51bWJlclN0cmluZygxMDAwKTtcblxuICAvLyBTdGVwIDEgb2YgV1Mgc3BlYyAtIHBhcnNlIGFuZCB2YWxpZGF0ZSB0aGUgdXJsLiBJc3N1ZSAjOFxuICB2YXIgcGFyc2VkVXJsID0gbmV3IFVSTCh1cmwpO1xuICBpZiAoIXBhcnNlZFVybC5ob3N0IHx8ICFwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMICdcIiArIHVybCArIFwiJyBpcyBpbnZhbGlkXCIpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5oYXNoKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdUaGUgVVJMIG11c3Qgbm90IGNvbnRhaW4gYSBmcmFnbWVudCcpO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ2h0dHA6JyAmJiBwYXJzZWRVcmwucHJvdG9jb2wgIT09ICdodHRwczonKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIFVSTCdzIHNjaGVtZSBtdXN0IGJlIGVpdGhlciAnaHR0cDonIG9yICdodHRwczonLiAnXCIgKyBwYXJzZWRVcmwucHJvdG9jb2wgKyBcIicgaXMgbm90IGFsbG93ZWQuXCIpO1xuICB9XG5cbiAgdmFyIHNlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIC8vIFN0ZXAgMiAtIGRvbid0IGFsbG93IHNlY3VyZSBvcmlnaW4gd2l0aCBhbiBpbnNlY3VyZSBwcm90b2NvbFxuICBpZiAobG9jLnByb3RvY29sID09PSAnaHR0cHMnICYmICFzZWN1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1NlY3VyaXR5RXJyb3I6IEFuIGluc2VjdXJlIFNvY2tKUyBjb25uZWN0aW9uIG1heSBub3QgYmUgaW5pdGlhdGVkIGZyb20gYSBwYWdlIGxvYWRlZCBvdmVyIEhUVFBTJyk7XG4gIH1cblxuICAvLyBTdGVwIDMgLSBjaGVjayBwb3J0IGFjY2VzcyAtIG5vIG5lZWQgaGVyZVxuICAvLyBTdGVwIDQgLSBwYXJzZSBwcm90b2NvbHMgYXJndW1lbnRcbiAgaWYgKCFwcm90b2NvbHMpIHtcbiAgICBwcm90b2NvbHMgPSBbXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gIH1cblxuICAvLyBTdGVwIDUgLSBjaGVjayBwcm90b2NvbHMgYXJndW1lbnRcbiAgdmFyIHNvcnRlZFByb3RvY29scyA9IHByb3RvY29scy5zb3J0KCk7XG4gIHNvcnRlZFByb3RvY29scy5mb3JFYWNoKGZ1bmN0aW9uKHByb3RvLCBpKSB7XG4gICAgaWYgKCFwcm90bykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiVGhlIHByb3RvY29scyBlbnRyeSAnXCIgKyBwcm90byArIFwiJyBpcyBpbnZhbGlkLlwiKTtcbiAgICB9XG4gICAgaWYgKGkgPCAoc29ydGVkUHJvdG9jb2xzLmxlbmd0aCAtIDEpICYmIHByb3RvID09PSBzb3J0ZWRQcm90b2NvbHNbaSArIDFdKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgcHJvdG9jb2xzIGVudHJ5ICdcIiArIHByb3RvICsgXCInIGlzIGR1cGxpY2F0ZWQuXCIpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gU3RlcCA2IC0gY29udmVydCBvcmlnaW5cbiAgdmFyIG8gPSB1cmxVdGlscy5nZXRPcmlnaW4obG9jLmhyZWYpO1xuICB0aGlzLl9vcmlnaW4gPSBvID8gby50b0xvd2VyQ2FzZSgpIDogbnVsbDtcblxuICAvLyByZW1vdmUgdGhlIHRyYWlsaW5nIHNsYXNoXG4gIHBhcnNlZFVybC5zZXQoJ3BhdGhuYW1lJywgcGFyc2VkVXJsLnBhdGhuYW1lLnJlcGxhY2UoL1xcLyskLywgJycpKTtcblxuICAvLyBzdG9yZSB0aGUgc2FuaXRpemVkIHVybFxuICB0aGlzLnVybCA9IHBhcnNlZFVybC5ocmVmO1xuICBkZWJ1ZygndXNpbmcgdXJsJywgdGhpcy51cmwpO1xuXG4gIC8vIFN0ZXAgNyAtIHN0YXJ0IGNvbm5lY3Rpb24gaW4gYmFja2dyb3VuZFxuICAvLyBvYnRhaW4gc2VydmVyIGluZm9cbiAgLy8gaHR0cDovL3NvY2tqcy5naXRodWIuaW8vc29ja2pzLXByb3RvY29sL3NvY2tqcy1wcm90b2NvbC0wLjMuMy5odG1sI3NlY3Rpb24tMjZcbiAgdGhpcy5fdXJsSW5mbyA9IHtcbiAgICBudWxsT3JpZ2luOiAhYnJvd3Nlci5oYXNEb21haW4oKVxuICAsIHNhbWVPcmlnaW46IHVybFV0aWxzLmlzT3JpZ2luRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICAsIHNhbWVTY2hlbWU6IHVybFV0aWxzLmlzU2NoZW1lRXF1YWwodGhpcy51cmwsIGxvYy5ocmVmKVxuICB9O1xuXG4gIHRoaXMuX2lyID0gbmV3IEluZm9SZWNlaXZlcih0aGlzLnVybCwgdGhpcy5fdXJsSW5mbyk7XG4gIHRoaXMuX2lyLm9uY2UoJ2ZpbmlzaCcsIHRoaXMuX3JlY2VpdmVJbmZvLmJpbmQodGhpcykpO1xufVxuXG5pbmhlcml0cyhTb2NrSlMsIEV2ZW50VGFyZ2V0KTtcblxuZnVuY3Rpb24gdXNlclNldENvZGUoY29kZSkge1xuICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgLy8gU3RlcCAxXG4gIGlmIChjb2RlICYmICF1c2VyU2V0Q29kZShjb2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZEFjY2Vzc0Vycm9yOiBJbnZhbGlkIGNvZGUnKTtcbiAgfVxuICAvLyBTdGVwIDIuNCBzdGF0ZXMgdGhlIG1heCBpcyAxMjMgYnl0ZXMsIGJ1dCB3ZSBhcmUganVzdCBjaGVja2luZyBsZW5ndGhcbiAgaWYgKHJlYXNvbiAmJiByZWFzb24ubGVuZ3RoID4gMTIzKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdyZWFzb24gYXJndW1lbnQgaGFzIGFuIGludmFsaWQgbGVuZ3RoJyk7XG4gIH1cblxuICAvLyBTdGVwIDMuMVxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0lORyB8fCB0aGlzLnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DTE9TRUQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBUT0RPIGxvb2sgYXQgZG9jcyB0byBkZXRlcm1pbmUgaG93IHRvIHNldCB0aGlzXG4gIHZhciB3YXNDbGVhbiA9IHRydWU7XG4gIHRoaXMuX2Nsb3NlKGNvZGUgfHwgMTAwMCwgcmVhc29uIHx8ICdOb3JtYWwgY2xvc3VyZScsIHdhc0NsZWFuKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgLy8gIzEzIC0gY29udmVydCBhbnl0aGluZyBub24tc3RyaW5nIHRvIHN0cmluZ1xuICAvLyBUT0RPIHRoaXMgY3VycmVudGx5IHR1cm5zIG9iamVjdHMgaW50byBbb2JqZWN0IE9iamVjdF1cbiAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWRTdGF0ZUVycm9yOiBUaGUgY29ubmVjdGlvbiBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgeWV0Jyk7XG4gIH1cbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5fdHJhbnNwb3J0LnNlbmQoZXNjYXBlLnF1b3RlKGRhdGEpKTtcbn07XG5cblNvY2tKUy52ZXJzaW9uID0gcmVxdWlyZSgnLi92ZXJzaW9uJyk7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9yZWNlaXZlSW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICBkZWJ1ZygnX3JlY2VpdmVJbmZvJywgcnR0KTtcbiAgdGhpcy5faXIgPSBudWxsO1xuICBpZiAoIWluZm8pIHtcbiAgICB0aGlzLl9jbG9zZSgxMDAyLCAnQ2Fubm90IGNvbm5lY3QgdG8gc2VydmVyJyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZXN0YWJsaXNoIGEgcm91bmQtdHJpcCB0aW1lb3V0IChSVE8pIGJhc2VkIG9uIHRoZVxuICAvLyByb3VuZC10cmlwIHRpbWUgKFJUVClcbiAgdGhpcy5fcnRvID0gdGhpcy5jb3VudFJUTyhydHQpO1xuICAvLyBhbGxvdyBzZXJ2ZXIgdG8gb3ZlcnJpZGUgdXJsIHVzZWQgZm9yIHRoZSBhY3R1YWwgdHJhbnNwb3J0XG4gIHRoaXMuX3RyYW5zVXJsID0gaW5mby5iYXNlX3VybCA/IGluZm8uYmFzZV91cmwgOiB0aGlzLnVybDtcbiAgaW5mbyA9IG9iamVjdFV0aWxzLmV4dGVuZChpbmZvLCB0aGlzLl91cmxJbmZvKTtcbiAgZGVidWcoJ2luZm8nLCBpbmZvKTtcbiAgLy8gZGV0ZXJtaW5lIGxpc3Qgb2YgZGVzaXJlZCBhbmQgc3VwcG9ydGVkIHRyYW5zcG9ydHNcbiAgdmFyIGVuYWJsZWRUcmFuc3BvcnRzID0gdHJhbnNwb3J0cy5maWx0ZXJUb0VuYWJsZWQodGhpcy5fdHJhbnNwb3J0c1doaXRlbGlzdCwgaW5mbyk7XG4gIHRoaXMuX3RyYW5zcG9ydHMgPSBlbmFibGVkVHJhbnNwb3J0cy5tYWluO1xuICBkZWJ1Zyh0aGlzLl90cmFuc3BvcnRzLmxlbmd0aCArICcgZW5hYmxlZCB0cmFuc3BvcnRzJyk7XG5cbiAgdGhpcy5fY29ubmVjdCgpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuICBmb3IgKHZhciBUcmFuc3BvcnQgPSB0aGlzLl90cmFuc3BvcnRzLnNoaWZ0KCk7IFRyYW5zcG9ydDsgVHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0cy5zaGlmdCgpKSB7XG4gICAgZGVidWcoJ2F0dGVtcHQnLCBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSk7XG4gICAgaWYgKFRyYW5zcG9ydC5uZWVkQm9keSkge1xuICAgICAgaWYgKCFnbG9iYWwuZG9jdW1lbnQuYm9keSB8fFxuICAgICAgICAgICh0eXBlb2YgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBnbG9iYWwuZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJyAmJlxuICAgICAgICAgICAgZ2xvYmFsLmRvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdpbnRlcmFjdGl2ZScpKSB7XG4gICAgICAgIGRlYnVnKCd3YWl0aW5nIGZvciBib2R5Jyk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydHMudW5zaGlmdChUcmFuc3BvcnQpO1xuICAgICAgICBldmVudFV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgdGhpcy5fY29ubmVjdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGNhbGN1bGF0ZSB0aW1lb3V0IGJhc2VkIG9uIFJUTyBhbmQgcm91bmQgdHJpcHMuIERlZmF1bHQgdG8gNXNcbiAgICB2YXIgdGltZW91dE1zID0gKHRoaXMuX3J0byAqIFRyYW5zcG9ydC5yb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IHNldFRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dC5iaW5kKHRoaXMpLCB0aW1lb3V0TXMpO1xuICAgIGRlYnVnKCd1c2luZyB0aW1lb3V0JywgdGltZW91dE1zKTtcblxuICAgIHZhciB0cmFuc3BvcnRVcmwgPSB1cmxVdGlscy5hZGRQYXRoKHRoaXMuX3RyYW5zVXJsLCAnLycgKyB0aGlzLl9zZXJ2ZXIgKyAnLycgKyB0aGlzLl9nZW5lcmF0ZVNlc3Npb25JZCgpKTtcbiAgICBkZWJ1ZygndHJhbnNwb3J0IHVybCcsIHRyYW5zcG9ydFVybCk7XG4gICAgdmFyIHRyYW5zcG9ydE9iaiA9IG5ldyBUcmFuc3BvcnQodHJhbnNwb3J0VXJsLCB0aGlzLl90cmFuc1VybCk7XG4gICAgdHJhbnNwb3J0T2JqLm9uKCdtZXNzYWdlJywgdGhpcy5fdHJhbnNwb3J0TWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoub25jZSgnY2xvc2UnLCB0aGlzLl90cmFuc3BvcnRDbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0cmFuc3BvcnRPYmoudHJhbnNwb3J0TmFtZSA9IFRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydE9iajtcblxuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLl9jbG9zZSgyMDAwLCAnQWxsIHRyYW5zcG9ydHMgZmFpbGVkJywgZmFsc2UpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJhbnNwb3J0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3RyYW5zcG9ydFRpbWVvdXQnKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICB0aGlzLl90cmFuc3BvcnRDbG9zZSgyMDA3LCAnVHJhbnNwb3J0IHRpbWVkIG91dCcpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG4gIGRlYnVnKCdfdHJhbnNwb3J0TWVzc2FnZScsIG1zZyk7XG4gIHZhciBzZWxmID0gdGhpc1xuICAgICwgdHlwZSA9IG1zZy5zbGljZSgwLCAxKVxuICAgICwgY29udGVudCA9IG1zZy5zbGljZSgxKVxuICAgICwgcGF5bG9hZFxuICAgIDtcblxuICAvLyBmaXJzdCBjaGVjayBmb3IgbWVzc2FnZXMgdGhhdCBkb24ndCBuZWVkIGEgcGF5bG9hZFxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgIHRoaXMuX29wZW4oKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICdoJzpcbiAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ2hlYXJ0YmVhdCcpKTtcbiAgICAgIGRlYnVnKCdoZWFydGJlYXQnLCB0aGlzLnRyYW5zcG9ydCk7XG4gICAgICByZXR1cm47XG4gIH1cblxuICBpZiAoY29udGVudCkge1xuICAgIHRyeSB7XG4gICAgICBwYXlsb2FkID0gSlNPTjMucGFyc2UoY29udGVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgY29udGVudCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAndW5kZWZpbmVkJykge1xuICAgIGRlYnVnKCdlbXB0eSBwYXlsb2FkJywgY29udGVudCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYSc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSkge1xuICAgICAgICBwYXlsb2FkLmZvckVhY2goZnVuY3Rpb24ocCkge1xuICAgICAgICAgIGRlYnVnKCdtZXNzYWdlJywgc2VsZi50cmFuc3BvcnQsIHApO1xuICAgICAgICAgIHNlbGYuZGlzcGF0Y2hFdmVudChuZXcgVHJhbnNwb3J0TWVzc2FnZUV2ZW50KHApKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgdGhpcy50cmFuc3BvcnQsIHBheWxvYWQpO1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBUcmFuc3BvcnRNZXNzYWdlRXZlbnQocGF5bG9hZCkpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYyc6XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLl9jbG9zZShwYXlsb2FkWzBdLCBwYXlsb2FkWzFdLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cmFuc3BvcnRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICBkZWJ1ZygnX3RyYW5zcG9ydENsb3NlJywgdGhpcy50cmFuc3BvcnQsIGNvZGUsIHJlYXNvbik7XG4gIGlmICh0aGlzLl90cmFuc3BvcnQpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAoIXVzZXJTZXRDb2RlKGNvZGUpICYmIGNvZGUgIT09IDIwMDAgJiYgdGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgIHRoaXMuX2Nvbm5lY3QoKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzLl9jbG9zZShjb2RlLCByZWFzb24pO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fb3BlbiA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX29wZW4nLCB0aGlzLl90cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdGhpcy5yZWFkeVN0YXRlKTtcbiAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdHJhbnNwb3J0VGltZW91dElkKTtcbiAgICAgIHRoaXMuX3RyYW5zcG9ydFRpbWVvdXRJZCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgIHRoaXMudHJhbnNwb3J0ID0gdGhpcy5fdHJhbnNwb3J0LnRyYW5zcG9ydE5hbWU7XG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnb3BlbicpKTtcbiAgICBkZWJ1ZygnY29ubmVjdGVkJywgdGhpcy50cmFuc3BvcnQpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBzZXJ2ZXIgbWlnaHQgaGF2ZSBiZWVuIHJlc3RhcnRlZCwgYW5kIGxvc3QgdHJhY2sgb2Ygb3VyXG4gICAgLy8gY29ubmVjdGlvbi5cbiAgICB0aGlzLl9jbG9zZSgxMDA2LCAnU2VydmVyIGxvc3Qgc2Vzc2lvbicpO1xuICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgd2FzQ2xlYW4pIHtcbiAgZGVidWcoJ19jbG9zZScsIHRoaXMudHJhbnNwb3J0LCBjb2RlLCByZWFzb24sIHdhc0NsZWFuLCB0aGlzLnJlYWR5U3RhdGUpO1xuICB2YXIgZm9yY2VGYWlsID0gZmFsc2U7XG5cbiAgaWYgKHRoaXMuX2lyKSB7XG4gICAgZm9yY2VGYWlsID0gdHJ1ZTtcbiAgICB0aGlzLl9pci5jbG9zZSgpO1xuICAgIHRoaXMuX2lyID0gbnVsbDtcbiAgfVxuICBpZiAodGhpcy5fdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zcG9ydCA9IG51bGw7XG4gIH1cblxuICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ0xPU0VEKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkU3RhdGVFcnJvcjogU29ja0pTIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkJyk7XG4gIH1cblxuICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICB0aGlzLnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgaWYgKGZvcmNlRmFpbCkge1xuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnZXJyb3InKSk7XG4gICAgfVxuXG4gICAgdmFyIGUgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnKTtcbiAgICBlLndhc0NsZWFuID0gd2FzQ2xlYW4gfHwgZmFsc2U7XG4gICAgZS5jb2RlID0gY29kZSB8fCAxMDAwO1xuICAgIGUucmVhc29uID0gcmVhc29uO1xuXG4gICAgdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIHRoaXMub25tZXNzYWdlID0gdGhpcy5vbmNsb3NlID0gdGhpcy5vbmVycm9yID0gbnVsbDtcbiAgICBkZWJ1ZygnZGlzY29ubmVjdGVkJyk7XG4gIH0uYmluZCh0aGlzKSwgMCk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG5Tb2NrSlMucHJvdG90eXBlLmNvdW50UlRPID0gZnVuY3Rpb24ocnR0KSB7XG4gIC8vIEluIGEgbG9jYWwgZW52aXJvbm1lbnQsIHdoZW4gdXNpbmcgSUU4LzkgYW5kIHRoZSBganNvbnAtcG9sbGluZ2BcbiAgLy8gdHJhbnNwb3J0IHRoZSB0aW1lIG5lZWRlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uICh0aGUgdGltZSB0aGF0IHBhc3NcbiAgLy8gZnJvbSB0aGUgb3BlbmluZyBvZiB0aGUgdHJhbnNwb3J0IHRvIHRoZSBjYWxsIG9mIGBfZGlzcGF0Y2hPcGVuYCkgaXNcbiAgLy8gYXJvdW5kIDIwMG1zZWMgKHRoZSBsb3dlciBib3VuZCB1c2VkIGluIHRoZSBhcnRpY2xlIGFib3ZlKSBhbmQgdGhpc1xuICAvLyBjYXVzZXMgc3B1cmlvdXMgdGltZW91dHMuIEZvciB0aGlzIHJlYXNvbiB3ZSBjYWxjdWxhdGUgYSB2YWx1ZSBzbGlnaHRseVxuICAvLyBsYXJnZXIgdGhhbiB0aGF0IHVzZWQgaW4gdGhlIGFydGljbGUuXG4gIGlmIChydHQgPiAxMDApIHtcbiAgICByZXR1cm4gNCAqIHJ0dDsgLy8gcnRvID4gNDAwbXNlY1xuICB9XG4gIHJldHVybiAzMDAgKyBydHQ7IC8vIDMwMG1zZWMgPCBydG8gPD0gNDAwbXNlY1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhdmFpbGFibGVUcmFuc3BvcnRzKSB7XG4gIHRyYW5zcG9ydHMgPSB0cmFuc3BvcnQoYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJlcXVpcmUoJy4vaWZyYW1lLWJvb3RzdHJhcCcpKFNvY2tKUywgYXZhaWxhYmxlVHJhbnNwb3J0cyk7XG4gIHJldHVybiBTb2NrSlM7XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL2V2ZW50L2Nsb3NlXCI6MzIsXCIuL2V2ZW50L2V2ZW50XCI6MzQsXCIuL2V2ZW50L2V2ZW50dGFyZ2V0XCI6MzUsXCIuL2V2ZW50L3RyYW5zLW1lc3NhZ2VcIjozNixcIi4vaWZyYW1lLWJvb3RzdHJhcFwiOjM4LFwiLi9pbmZvLXJlY2VpdmVyXCI6NDIsXCIuL2xvY2F0aW9uXCI6NDMsXCIuL3NoaW1zXCI6NDUsXCIuL3V0aWxzL2Jyb3dzZXJcIjo3NCxcIi4vdXRpbHMvZXNjYXBlXCI6NzUsXCIuL3V0aWxzL2V2ZW50XCI6NzYsXCIuL3V0aWxzL2xvZ1wiOjc4LFwiLi91dGlscy9vYmplY3RcIjo3OSxcIi4vdXRpbHMvcmFuZG9tXCI6ODAsXCIuL3V0aWxzL3RyYW5zcG9ydFwiOjgxLFwiLi91dGlscy91cmxcIjo4MixcIi4vdmVyc2lvblwiOjgzLFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJpbmhlcml0c1wiOjg3LFwianNvbjNcIjo4OCxcInVybC1wYXJzZVwiOjg5fV0sNDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qIGpzY3M6IGRpc2FibGUgKi9cbid1c2Ugc3RyaWN0JztcblxuLy8gcHVsbGVkIHNwZWNpZmljIHNoaW1zIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2VzLXNoaW1zL2VzNS1zaGltXG5cbnZhciBBcnJheVByb3RvdHlwZSA9IEFycmF5LnByb3RvdHlwZTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIFN0cmluZ1Byb3RvdHlwZSA9IFN0cmluZy5wcm90b3R5cGU7XG52YXIgYXJyYXlfc2xpY2UgPSBBcnJheVByb3RvdHlwZS5zbGljZTtcblxudmFyIF90b1N0cmluZyA9IE9iamVjdFByb3RvdHlwZS50b1N0cmluZztcbnZhciBpc0Z1bmN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHJldHVybiBPYmplY3RQcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcbnZhciBpc0FycmF5ID0gZnVuY3Rpb24gaXNBcnJheShvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG52YXIgaXNTdHJpbmcgPSBmdW5jdGlvbiBpc1N0cmluZyhvYmopIHtcbiAgICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXSc7XG59O1xuXG52YXIgc3VwcG9ydHNEZXNjcmlwdG9ycyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAoZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7fSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHsgLyogdGhpcyBpcyBFUzMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn0oKSk7XG5cbi8vIERlZmluZSBjb25maWd1cmFibGUsIHdyaXRhYmxlIGFuZCBub24tZW51bWVyYWJsZSBwcm9wc1xuLy8gaWYgdGhleSBkb24ndCBleGlzdC5cbnZhciBkZWZpbmVQcm9wZXJ0eTtcbmlmIChzdXBwb3J0c0Rlc2NyaXB0b3JzKSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwge1xuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBtZXRob2RcbiAgICAgICAgfSk7XG4gICAgfTtcbn0gZWxzZSB7XG4gICAgZGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lLCBtZXRob2QsIGZvcmNlQXNzaWduKSB7XG4gICAgICAgIGlmICghZm9yY2VBc3NpZ24gJiYgKG5hbWUgaW4gb2JqZWN0KSkgeyByZXR1cm47IH1cbiAgICAgICAgb2JqZWN0W25hbWVdID0gbWV0aG9kO1xuICAgIH07XG59XG52YXIgZGVmaW5lUHJvcGVydGllcyA9IGZ1bmN0aW9uIChvYmplY3QsIG1hcCwgZm9yY2VBc3NpZ24pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG1hcCkge1xuICAgICAgICBpZiAoT2JqZWN0UHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwLCBuYW1lKSkge1xuICAgICAgICAgIGRlZmluZVByb3BlcnR5KG9iamVjdCwgbmFtZSwgbWFwW25hbWVdLCBmb3JjZUFzc2lnbik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgdG9PYmplY3QgPSBmdW5jdGlvbiAobykge1xuICAgIGlmIChvID09IG51bGwpIHsgLy8gdGhpcyBtYXRjaGVzIGJvdGggbnVsbCBhbmQgdW5kZWZpbmVkXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJjYW4ndCBjb252ZXJ0IFwiICsgbyArICcgdG8gb2JqZWN0Jyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3Qobyk7XG59O1xuXG4vL1xuLy8gVXRpbFxuLy8gPT09PT09XG4vL1xuXG4vLyBFUzUgOS40XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3g5LjRcbi8vIGh0dHA6Ly9qc3BlcmYuY29tL3RvLWludGVnZXJcblxuZnVuY3Rpb24gdG9JbnRlZ2VyKG51bSkge1xuICAgIHZhciBuID0gK251bTtcbiAgICBpZiAobiAhPT0gbikgeyAvLyBpc05hTlxuICAgICAgICBuID0gMDtcbiAgICB9IGVsc2UgaWYgKG4gIT09IDAgJiYgbiAhPT0gKDEgLyAwKSAmJiBuICE9PSAtKDEgLyAwKSkge1xuICAgICAgICBuID0gKG4gPiAwIHx8IC0xKSAqIE1hdGguZmxvb3IoTWF0aC5hYnMobikpO1xuICAgIH1cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gVG9VaW50MzIoeCkge1xuICAgIHJldHVybiB4ID4+PiAwO1xufVxuXG4vL1xuLy8gRnVuY3Rpb25cbi8vID09PT09PT09XG4vL1xuXG4vLyBFUy01IDE1LjMuNC41XG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4zLjQuNVxuXG5mdW5jdGlvbiBFbXB0eSgpIHt9XG5cbmRlZmluZVByb3BlcnRpZXMoRnVuY3Rpb25Qcm90b3R5cGUsIHtcbiAgICBiaW5kOiBmdW5jdGlvbiBiaW5kKHRoYXQpIHsgLy8gLmxlbmd0aCBpcyAxXG4gICAgICAgIC8vIDEuIExldCBUYXJnZXQgYmUgdGhlIHRoaXMgdmFsdWUuXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzO1xuICAgICAgICAvLyAyLiBJZiBJc0NhbGxhYmxlKFRhcmdldCkgaXMgZmFsc2UsIHRocm93IGEgVHlwZUVycm9yIGV4Y2VwdGlvbi5cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKHRhcmdldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Z1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgJyArIHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gMy4gTGV0IEEgYmUgYSBuZXcgKHBvc3NpYmx5IGVtcHR5KSBpbnRlcm5hbCBsaXN0IG9mIGFsbCBvZiB0aGVcbiAgICAgICAgLy8gICBhcmd1bWVudCB2YWx1ZXMgcHJvdmlkZWQgYWZ0ZXIgdGhpc0FyZyAoYXJnMSwgYXJnMiBldGMpLCBpbiBvcmRlci5cbiAgICAgICAgLy8gWFhYIHNsaWNlZEFyZ3Mgd2lsbCBzdGFuZCBpbiBmb3IgXCJBXCIgaWYgdXNlZFxuICAgICAgICB2YXIgYXJncyA9IGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTsgLy8gZm9yIG5vcm1hbCBjYWxsXG4gICAgICAgIC8vIDQuIExldCBGIGJlIGEgbmV3IG5hdGl2ZSBFQ01BU2NyaXB0IG9iamVjdC5cbiAgICAgICAgLy8gMTEuIFNldCB0aGUgW1tQcm90b3R5cGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRoZSBzdGFuZGFyZFxuICAgICAgICAvLyAgIGJ1aWx0LWluIEZ1bmN0aW9uIHByb3RvdHlwZSBvYmplY3QgYXMgc3BlY2lmaWVkIGluIDE1LjMuMy4xLlxuICAgICAgICAvLyAxMi4gU2V0IHRoZSBbW0NhbGxdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIGFzIGRlc2NyaWJlZCBpblxuICAgICAgICAvLyAgIDE1LjMuNC41LjEuXG4gICAgICAgIC8vIDEzLiBTZXQgdGhlIFtbQ29uc3RydWN0XV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4yLlxuICAgICAgICAvLyAxNC4gU2V0IHRoZSBbW0hhc0luc3RhbmNlXV0gaW50ZXJuYWwgcHJvcGVydHkgb2YgRiBhcyBkZXNjcmliZWQgaW5cbiAgICAgICAgLy8gICAxNS4zLjQuNS4zLlxuICAgICAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xuXG4gICAgICAgICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMiBbW0NvbnN0cnVjdF1dXG4gICAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2Qgb2YgYSBmdW5jdGlvbiBvYmplY3QsXG4gICAgICAgICAgICAgICAgLy8gRiB0aGF0IHdhcyBjcmVhdGVkIHVzaW5nIHRoZSBiaW5kIGZ1bmN0aW9uIGlzIGNhbGxlZCB3aXRoIGFcbiAgICAgICAgICAgICAgICAvLyBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmcgc3RlcHMgYXJlIHRha2VuOlxuICAgICAgICAgICAgICAgIC8vIDEuIExldCB0YXJnZXQgYmUgdGhlIHZhbHVlIG9mIEYncyBbW1RhcmdldEZ1bmN0aW9uXV1cbiAgICAgICAgICAgICAgICAvLyAgIGludGVybmFsIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIElmIHRhcmdldCBoYXMgbm8gW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbCBtZXRob2QsIGFcbiAgICAgICAgICAgICAgICAvLyAgIFR5cGVFcnJvciBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgICAgICAgICAgICAgIC8vIDMuIExldCBib3VuZEFyZ3MgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kQXJnc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDb25zdHJ1Y3RdXSBpbnRlcm5hbFxuICAgICAgICAgICAgICAgIC8vICAgbWV0aG9kIG9mIHRhcmdldCBwcm92aWRpbmcgYXJncyBhcyB0aGUgYXJndW1lbnRzLlxuXG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRhcmdldC5hcHBseShcbiAgICAgICAgICAgICAgICAgICAgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgYXJncy5jb25jYXQoYXJyYXlfc2xpY2UuY2FsbChhcmd1bWVudHMpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChyZXN1bHQpID09PSByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gMTUuMy40LjUuMSBbW0NhbGxdXVxuICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIFtbQ2FsbF1dIGludGVybmFsIG1ldGhvZCBvZiBhIGZ1bmN0aW9uIG9iamVjdCwgRixcbiAgICAgICAgICAgICAgICAvLyB3aGljaCB3YXMgY3JlYXRlZCB1c2luZyB0aGUgYmluZCBmdW5jdGlvbiBpcyBjYWxsZWQgd2l0aCBhXG4gICAgICAgICAgICAgICAgLy8gdGhpcyB2YWx1ZSBhbmQgYSBsaXN0IG9mIGFyZ3VtZW50cyBFeHRyYUFyZ3MsIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgICAgICAgICAvLyBzdGVwcyBhcmUgdGFrZW46XG4gICAgICAgICAgICAgICAgLy8gMS4gTGV0IGJvdW5kQXJncyBiZSB0aGUgdmFsdWUgb2YgRidzIFtbQm91bmRBcmdzXV0gaW50ZXJuYWxcbiAgICAgICAgICAgICAgICAvLyAgIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIC8vIDIuIExldCBib3VuZFRoaXMgYmUgdGhlIHZhbHVlIG9mIEYncyBbW0JvdW5kVGhpc11dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyAzLiBMZXQgdGFyZ2V0IGJlIHRoZSB2YWx1ZSBvZiBGJ3MgW1tUYXJnZXRGdW5jdGlvbl1dIGludGVybmFsXG4gICAgICAgICAgICAgICAgLy8gICBwcm9wZXJ0eS5cbiAgICAgICAgICAgICAgICAvLyA0LiBMZXQgYXJncyBiZSBhIG5ldyBsaXN0IGNvbnRhaW5pbmcgdGhlIHNhbWUgdmFsdWVzIGFzIHRoZVxuICAgICAgICAgICAgICAgIC8vICAgbGlzdCBib3VuZEFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIgZm9sbG93ZWQgYnkgdGhlIHNhbWVcbiAgICAgICAgICAgICAgICAvLyAgIHZhbHVlcyBhcyB0aGUgbGlzdCBFeHRyYUFyZ3MgaW4gdGhlIHNhbWUgb3JkZXIuXG4gICAgICAgICAgICAgICAgLy8gNS4gUmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGUgW1tDYWxsXV0gaW50ZXJuYWwgbWV0aG9kXG4gICAgICAgICAgICAgICAgLy8gICBvZiB0YXJnZXQgcHJvdmlkaW5nIGJvdW5kVGhpcyBhcyB0aGUgdGhpcyB2YWx1ZSBhbmRcbiAgICAgICAgICAgICAgICAvLyAgIHByb3ZpZGluZyBhcmdzIGFzIHRoZSBhcmd1bWVudHMuXG5cbiAgICAgICAgICAgICAgICAvLyBlcXVpdjogdGFyZ2V0LmNhbGwodGhpcywgLi4uYm91bmRBcmdzLCAuLi5hcmdzKVxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQuYXBwbHkoXG4gICAgICAgICAgICAgICAgICAgIHRoYXQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KGFycmF5X3NsaWNlLmNhbGwoYXJndW1lbnRzKSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfTtcblxuICAgICAgICAvLyAxNS4gSWYgdGhlIFtbQ2xhc3NdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBUYXJnZXQgaXMgXCJGdW5jdGlvblwiLCB0aGVuXG4gICAgICAgIC8vICAgICBhLiBMZXQgTCBiZSB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIFRhcmdldCBtaW51cyB0aGUgbGVuZ3RoIG9mIEEuXG4gICAgICAgIC8vICAgICBiLiBTZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byBlaXRoZXIgMCBvciBMLCB3aGljaGV2ZXIgaXNcbiAgICAgICAgLy8gICAgICAgbGFyZ2VyLlxuICAgICAgICAvLyAxNi4gRWxzZSBzZXQgdGhlIGxlbmd0aCBvd24gcHJvcGVydHkgb2YgRiB0byAwLlxuXG4gICAgICAgIHZhciBib3VuZExlbmd0aCA9IE1hdGgubWF4KDAsIHRhcmdldC5sZW5ndGggLSBhcmdzLmxlbmd0aCk7XG5cbiAgICAgICAgLy8gMTcuIFNldCB0aGUgYXR0cmlidXRlcyBvZiB0aGUgbGVuZ3RoIG93biBwcm9wZXJ0eSBvZiBGIHRvIHRoZSB2YWx1ZXNcbiAgICAgICAgLy8gICBzcGVjaWZpZWQgaW4gMTUuMy41LjEuXG4gICAgICAgIHZhciBib3VuZEFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib3VuZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBib3VuZEFyZ3MucHVzaCgnJCcgKyBpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFhYWCBCdWlsZCBhIGR5bmFtaWMgZnVuY3Rpb24gd2l0aCBkZXNpcmVkIGFtb3VudCBvZiBhcmd1bWVudHMgaXMgdGhlIG9ubHlcbiAgICAgICAgLy8gd2F5IHRvIHNldCB0aGUgbGVuZ3RoIHByb3BlcnR5IG9mIGEgZnVuY3Rpb24uXG4gICAgICAgIC8vIEluIGVudmlyb25tZW50cyB3aGVyZSBDb250ZW50IFNlY3VyaXR5IFBvbGljaWVzIGVuYWJsZWQgKENocm9tZSBleHRlbnNpb25zLFxuICAgICAgICAvLyBmb3IgZXguKSBhbGwgdXNlIG9mIGV2YWwgb3IgRnVuY3Rpb24gY29zdHJ1Y3RvciB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICAgICAgICAvLyBIb3dldmVyIGluIGFsbCBvZiB0aGVzZSBlbnZpcm9ubWVudHMgRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgZXhpc3RzXG4gICAgICAgIC8vIGFuZCBzbyB0aGlzIGNvZGUgd2lsbCBuZXZlciBiZSBleGVjdXRlZC5cbiAgICAgICAgdmFyIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpKGJpbmRlcik7XG5cbiAgICAgICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcbiAgICAgICAgICAgIEVtcHR5LnByb3RvdHlwZSA9IHRhcmdldC5wcm90b3R5cGU7XG4gICAgICAgICAgICBib3VuZC5wcm90b3R5cGUgPSBuZXcgRW1wdHkoKTtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGRhbmdsaW5nIHJlZmVyZW5jZXMuXG4gICAgICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOC4gU2V0IHRoZSBbW0V4dGVuc2libGVdXSBpbnRlcm5hbCBwcm9wZXJ0eSBvZiBGIHRvIHRydWUuXG5cbiAgICAgICAgLy8gVE9ET1xuICAgICAgICAvLyAxOS4gTGV0IHRocm93ZXIgYmUgdGhlIFtbVGhyb3dUeXBlRXJyb3JdXSBmdW5jdGlvbiBPYmplY3QgKDEzLjIuMykuXG4gICAgICAgIC8vIDIwLiBDYWxsIHRoZSBbW0RlZmluZU93blByb3BlcnR5XV0gaW50ZXJuYWwgbWV0aG9kIG9mIEYgd2l0aFxuICAgICAgICAvLyAgIGFyZ3VtZW50cyBcImNhbGxlclwiLCBQcm9wZXJ0eURlc2NyaXB0b3Ige1tbR2V0XV06IHRocm93ZXIsIFtbU2V0XV06XG4gICAgICAgIC8vICAgdGhyb3dlciwgW1tFbnVtZXJhYmxlXV06IGZhbHNlLCBbW0NvbmZpZ3VyYWJsZV1dOiBmYWxzZX0sIGFuZFxuICAgICAgICAvLyAgIGZhbHNlLlxuICAgICAgICAvLyAyMS4gQ2FsbCB0aGUgW1tEZWZpbmVPd25Qcm9wZXJ0eV1dIGludGVybmFsIG1ldGhvZCBvZiBGIHdpdGhcbiAgICAgICAgLy8gICBhcmd1bWVudHMgXCJhcmd1bWVudHNcIiwgUHJvcGVydHlEZXNjcmlwdG9yIHtbW0dldF1dOiB0aHJvd2VyLFxuICAgICAgICAvLyAgIFtbU2V0XV06IHRocm93ZXIsIFtbRW51bWVyYWJsZV1dOiBmYWxzZSwgW1tDb25maWd1cmFibGVdXTogZmFsc2V9LFxuICAgICAgICAvLyAgIGFuZCBmYWxzZS5cblxuICAgICAgICAvLyBUT0RPXG4gICAgICAgIC8vIE5PVEUgRnVuY3Rpb24gb2JqZWN0cyBjcmVhdGVkIHVzaW5nIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIGRvIG5vdFxuICAgICAgICAvLyBoYXZlIGEgcHJvdG90eXBlIHByb3BlcnR5IG9yIHRoZSBbW0NvZGVdXSwgW1tGb3JtYWxQYXJhbWV0ZXJzXV0sIGFuZFxuICAgICAgICAvLyBbW1Njb3BlXV0gaW50ZXJuYWwgcHJvcGVydGllcy5cbiAgICAgICAgLy8gWFhYIGNhbid0IGRlbGV0ZSBwcm90b3R5cGUgaW4gcHVyZS1qcy5cblxuICAgICAgICAvLyAyMi4gUmV0dXJuIEYuXG4gICAgICAgIHJldHVybiBib3VuZDtcbiAgICB9XG59KTtcblxuLy9cbi8vIEFycmF5XG4vLyA9PT09PVxuLy9cblxuLy8gRVM1IDE1LjQuMy4yXG4vLyBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS40LjMuMlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvQXJyYXkvaXNBcnJheVxuZGVmaW5lUHJvcGVydGllcyhBcnJheSwgeyBpc0FycmF5OiBpc0FycmF5IH0pO1xuXG5cbnZhciBib3hlZFN0cmluZyA9IE9iamVjdCgnYScpO1xudmFyIHNwbGl0U3RyaW5nID0gYm94ZWRTdHJpbmdbMF0gIT09ICdhJyB8fCAhKDAgaW4gYm94ZWRTdHJpbmcpO1xuXG52YXIgcHJvcGVybHlCb3hlc0NvbnRleHQgPSBmdW5jdGlvbiBwcm9wZXJseUJveGVkKG1ldGhvZCkge1xuICAgIC8vIENoZWNrIG5vZGUgMC42LjIxIGJ1ZyB3aGVyZSB0aGlyZCBwYXJhbWV0ZXIgaXMgbm90IGJveGVkXG4gICAgdmFyIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgPSB0cnVlO1xuICAgIHZhciBwcm9wZXJseUJveGVzU3RyaWN0ID0gdHJ1ZTtcbiAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgIG1ldGhvZC5jYWxsKCdmb28nLCBmdW5jdGlvbiAoXywgX18sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY29udGV4dCAhPT0gJ29iamVjdCcpIHsgcHJvcGVybHlCb3hlc05vblN0cmljdCA9IGZhbHNlOyB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIG1ldGhvZC5jYWxsKFsxXSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuICAgICAgICAgICAgcHJvcGVybHlCb3hlc1N0cmljdCA9IHR5cGVvZiB0aGlzID09PSAnc3RyaW5nJztcbiAgICAgICAgfSwgJ3gnKTtcbiAgICB9XG4gICAgcmV0dXJuICEhbWV0aG9kICYmIHByb3Blcmx5Qm94ZXNOb25TdHJpY3QgJiYgcHJvcGVybHlCb3hlc1N0cmljdDtcbn07XG5cbmRlZmluZVByb3BlcnRpZXMoQXJyYXlQcm90b3R5cGUsIHtcbiAgICBmb3JFYWNoOiBmdW5jdGlvbiBmb3JFYWNoKGZ1biAvKiwgdGhpc3AqLykge1xuICAgICAgICB2YXIgb2JqZWN0ID0gdG9PYmplY3QodGhpcyksXG4gICAgICAgICAgICBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IG9iamVjdCxcbiAgICAgICAgICAgIHRoaXNwID0gYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgaSA9IC0xLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgZnVuY3Rpb24gb3IgaWYgY2FsbGJhY2sgaXMgbm90IGEgY2FsbGFibGUgZnVuY3Rpb25cbiAgICAgICAgaWYgKCFpc0Z1bmN0aW9uKGZ1bikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoKTsgLy8gVE9ETyBtZXNzYWdlXG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoKytpIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmKSB7XG4gICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGNhbGwsIHBhc3NpbmcgYXJndW1lbnRzOlxuICAgICAgICAgICAgICAgIC8vIGNvbnRleHQsIHByb3BlcnR5IHZhbHVlLCBwcm9wZXJ0eSBrZXksIHRoaXNBcmcgb2JqZWN0XG4gICAgICAgICAgICAgICAgLy8gY29udGV4dFxuICAgICAgICAgICAgICAgIGZ1bi5jYWxsKHRoaXNwLCBzZWxmW2ldLCBpLCBvYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSwgIXByb3Blcmx5Qm94ZXNDb250ZXh0KEFycmF5UHJvdG90eXBlLmZvckVhY2gpKTtcblxuLy8gRVM1IDE1LjQuNC4xNFxuLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuNC40LjE0XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9BcnJheS9pbmRleE9mXG52YXIgaGFzRmlyZWZveDJJbmRleE9mQnVnID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YgJiYgWzAsIDFdLmluZGV4T2YoMSwgMikgIT09IC0xO1xuZGVmaW5lUHJvcGVydGllcyhBcnJheVByb3RvdHlwZSwge1xuICAgIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc291Z2h0IC8qLCBmcm9tSW5kZXggKi8gKSB7XG4gICAgICAgIHZhciBzZWxmID0gc3BsaXRTdHJpbmcgJiYgaXNTdHJpbmcodGhpcykgPyB0aGlzLnNwbGl0KCcnKSA6IHRvT2JqZWN0KHRoaXMpLFxuICAgICAgICAgICAgbGVuZ3RoID0gc2VsZi5sZW5ndGggPj4+IDA7XG5cbiAgICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBpID0gdG9JbnRlZ2VyKGFyZ3VtZW50c1sxXSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBoYW5kbGUgbmVnYXRpdmUgaW5kaWNlc1xuICAgICAgICBpID0gaSA+PSAwID8gaSA6IE1hdGgubWF4KDAsIGxlbmd0aCArIGkpO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSBpbiBzZWxmICYmIHNlbGZbaV0gPT09IHNvdWdodCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG59LCBoYXNGaXJlZm94MkluZGV4T2ZCdWcpO1xuXG4vL1xuLy8gU3RyaW5nXG4vLyA9PT09PT1cbi8vXG5cbi8vIEVTNSAxNS41LjQuMTRcbi8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDE1LjUuNC4xNFxuXG4vLyBbYnVnZml4LCBJRSBsdCA5LCBmaXJlZm94IDQsIEtvbnF1ZXJvciwgT3BlcmEsIG9ic2N1cmUgYnJvd3NlcnNdXG4vLyBNYW55IGJyb3dzZXJzIGRvIG5vdCBzcGxpdCBwcm9wZXJseSB3aXRoIHJlZ3VsYXIgZXhwcmVzc2lvbnMgb3IgdGhleVxuLy8gZG8gbm90IHBlcmZvcm0gdGhlIHNwbGl0IGNvcnJlY3RseSB1bmRlciBvYnNjdXJlIGNvbmRpdGlvbnMuXG4vLyBTZWUgaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Nyb3NzLWJyb3dzZXItc3BsaXRcbi8vIEkndmUgdGVzdGVkIGluIG1hbnkgYnJvd3NlcnMgYW5kIHRoaXMgc2VlbXMgdG8gY292ZXIgdGhlIGRldmlhbnQgb25lczpcbi8vICAgICdhYicuc3BsaXQoLyg/OmFiKSovKSBzaG91bGQgYmUgW1wiXCIsIFwiXCJdLCBub3QgW1wiXCJdXG4vLyAgICAnLicuc3BsaXQoLyguPykoLj8pLykgc2hvdWxkIGJlIFtcIlwiLCBcIi5cIiwgXCJcIiwgXCJcIl0sIG5vdCBbXCJcIiwgXCJcIl1cbi8vICAgICd0ZXNzdCcuc3BsaXQoLyhzKSovKSBzaG91bGQgYmUgW1widFwiLCB1bmRlZmluZWQsIFwiZVwiLCBcInNcIiwgXCJ0XCJdLCBub3Rcbi8vICAgICAgIFt1bmRlZmluZWQsIFwidFwiLCB1bmRlZmluZWQsIFwiZVwiLCAuLi5dXG4vLyAgICAnJy5zcGxpdCgvLj8vKSBzaG91bGQgYmUgW10sIG5vdCBbXCJcIl1cbi8vICAgICcuJy5zcGxpdCgvKCkoKS8pIHNob3VsZCBiZSBbXCIuXCJdLCBub3QgW1wiXCIsIFwiXCIsIFwiLlwiXVxuXG52YXIgc3RyaW5nX3NwbGl0ID0gU3RyaW5nUHJvdG90eXBlLnNwbGl0O1xuaWYgKFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT09IDIgfHxcbiAgICAnLicuc3BsaXQoLyguPykoLj8pLykubGVuZ3RoICE9PSA0IHx8XG4gICAgJ3Rlc3N0Jy5zcGxpdCgvKHMpKi8pWzFdID09PSAndCcgfHxcbiAgICAndGVzdCcuc3BsaXQoLyg/OikvLCAtMSkubGVuZ3RoICE9PSA0IHx8XG4gICAgJycuc3BsaXQoLy4/LykubGVuZ3RoIHx8XG4gICAgJy4nLnNwbGl0KC8oKSgpLykubGVuZ3RoID4gMVxuKSB7XG4gICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNvbXBsaWFudEV4ZWNOcGNnID0gLygpPz8vLmV4ZWMoJycpWzFdID09PSB2b2lkIDA7IC8vIE5QQ0c6IG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwXG5cbiAgICAgICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gKHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgICAgICAgIHZhciBzdHJpbmcgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdm9pZCAwICYmIGxpbWl0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBgc2VwYXJhdG9yYCBpcyBub3QgYSByZWdleCwgdXNlIG5hdGl2ZSBzcGxpdFxuICAgICAgICAgICAgaWYgKF90b1N0cmluZy5jYWxsKHNlcGFyYXRvcikgIT09ICdbb2JqZWN0IFJlZ0V4cF0nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZ19zcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3V0cHV0ID0gW10sXG4gICAgICAgICAgICAgICAgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgID8gJ20nIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3IuZXh0ZW5kZWQgICA/ICd4JyA6ICcnKSArIC8vIFByb3Bvc2VkIGZvciBFUzZcbiAgICAgICAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ICAgICA/ICd5JyA6ICcnKSwgLy8gRmlyZWZveCAzK1xuICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSAwLFxuICAgICAgICAgICAgICAgIC8vIE1ha2UgYGdsb2JhbGAgYW5kIGF2b2lkIGBsYXN0SW5kZXhgIGlzc3VlcyBieSB3b3JraW5nIHdpdGggYSBjb3B5XG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yMiwgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgICAgICAgIHNlcGFyYXRvciA9IG5ldyBSZWdFeHAoc2VwYXJhdG9yLnNvdXJjZSwgZmxhZ3MgKyAnZycpO1xuICAgICAgICAgICAgc3RyaW5nICs9ICcnOyAvLyBUeXBlLWNvbnZlcnRcbiAgICAgICAgICAgIGlmICghY29tcGxpYW50RXhlY05wY2cpIHtcbiAgICAgICAgICAgICAgICAvLyBEb2Vzbid0IG5lZWQgZmxhZ3MgZ3ksIGJ1dCB0aGV5IGRvbid0IGh1cnRcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IyID0gbmV3IFJlZ0V4cCgnXicgKyBzZXBhcmF0b3Iuc291cmNlICsgJyQoPyFcXFxccyknLCBmbGFncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBWYWx1ZXMgZm9yIGBsaW1pdGAsIHBlciB0aGUgc3BlYzpcbiAgICAgICAgICAgICAqIElmIHVuZGVmaW5lZDogNDI5NDk2NzI5NSAvLyBNYXRoLnBvdygyLCAzMikgLSAxXG4gICAgICAgICAgICAgKiBJZiAwLCBJbmZpbml0eSwgb3IgTmFOOiAwXG4gICAgICAgICAgICAgKiBJZiBwb3NpdGl2ZSBudW1iZXI6IGxpbWl0ID0gTWF0aC5mbG9vcihsaW1pdCk7IGlmIChsaW1pdCA+IDQyOTQ5NjcyOTUpIGxpbWl0IC09IDQyOTQ5NjcyOTY7XG4gICAgICAgICAgICAgKiBJZiBuZWdhdGl2ZSBudW1iZXI6IDQyOTQ5NjcyOTYgLSBNYXRoLmZsb29yKE1hdGguYWJzKGxpbWl0KSlcbiAgICAgICAgICAgICAqIElmIG90aGVyOiBUeXBlLWNvbnZlcnQsIHRoZW4gdXNlIHRoZSBhYm92ZSBydWxlc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsaW1pdCA9IGxpbWl0ID09PSB2b2lkIDAgP1xuICAgICAgICAgICAgICAgIC0xID4+PiAwIDogLy8gTWF0aC5wb3coMiwgMzIpIC0gMVxuICAgICAgICAgICAgICAgIFRvVWludDMyKGxpbWl0KTtcbiAgICAgICAgICAgIHdoaWxlIChtYXRjaCA9IHNlcGFyYXRvci5leGVjKHN0cmluZykpIHtcbiAgICAgICAgICAgICAgICAvLyBgc2VwYXJhdG9yLmxhc3RJbmRleGAgaXMgbm90IHJlbGlhYmxlIGNyb3NzLWJyb3dzZXJcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQucHVzaChzdHJpbmcuc2xpY2UobGFzdExhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRml4IGJyb3dzZXJzIHdob3NlIGBleGVjYCBtZXRob2RzIGRvbid0IGNvbnNpc3RlbnRseSByZXR1cm4gYHVuZGVmaW5lZGAgZm9yXG4gICAgICAgICAgICAgICAgICAgIC8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3Vwc1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbXBsaWFudEV4ZWNOcGNnICYmIG1hdGNoLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoWzBdLnJlcGxhY2Uoc2VwYXJhdG9yMiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJndW1lbnRzW2ldID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoW2ldID0gdm9pZCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLmxlbmd0aCA+IDEgJiYgbWF0Y2guaW5kZXggPCBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBBcnJheVByb3RvdHlwZS5wdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RMYXN0SW5kZXggPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvdXRwdXQubGVuZ3RoID49IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2VwYXJhdG9yLmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VwYXJhdG9yLmxhc3RJbmRleCsrOyAvLyBBdm9pZCBhbiBpbmZpbml0ZSBsb29wXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxhc3RMYXN0SW5kZXggPT09IHN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCB8fCAhc2VwYXJhdG9yLnRlc3QoJycpKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0Lmxlbmd0aCA+IGxpbWl0ID8gb3V0cHV0LnNsaWNlKDAsIGxpbWl0KSA6IG91dHB1dDtcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4vLyBbYnVnZml4LCBjaHJvbWVdXG4vLyBJZiBzZXBhcmF0b3IgaXMgdW5kZWZpbmVkLCB0aGVuIHRoZSByZXN1bHQgYXJyYXkgY29udGFpbnMganVzdCBvbmUgU3RyaW5nLFxuLy8gd2hpY2ggaXMgdGhlIHRoaXMgdmFsdWUgKGNvbnZlcnRlZCB0byBhIFN0cmluZykuIElmIGxpbWl0IGlzIG5vdCB1bmRlZmluZWQsXG4vLyB0aGVuIHRoZSBvdXRwdXQgYXJyYXkgaXMgdHJ1bmNhdGVkIHNvIHRoYXQgaXQgY29udGFpbnMgbm8gbW9yZSB0aGFuIGxpbWl0XG4vLyBlbGVtZW50cy5cbi8vIFwiMFwiLnNwbGl0KHVuZGVmaW5lZCwgMCkgLT4gW11cbn0gZWxzZSBpZiAoJzAnLnNwbGl0KHZvaWQgMCwgMCkubGVuZ3RoKSB7XG4gICAgU3RyaW5nUHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgICBpZiAoc2VwYXJhdG9yID09PSB2b2lkIDAgJiYgbGltaXQgPT09IDApIHsgcmV0dXJuIFtdOyB9XG4gICAgICAgIHJldHVybiBzdHJpbmdfc3BsaXQuY2FsbCh0aGlzLCBzZXBhcmF0b3IsIGxpbWl0KTtcbiAgICB9O1xufVxuXG4vLyBFUzUgMTUuNS40LjIwXG4vLyB3aGl0ZXNwYWNlIGZyb206IGh0dHA6Ly9lczUuZ2l0aHViLmlvLyN4MTUuNS40LjIwXG52YXIgd3MgPSAnXFx4MDlcXHgwQVxceDBCXFx4MENcXHgwRFxceDIwXFx4QTBcXHUxNjgwXFx1MTgwRVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDMnICtcbiAgICAnXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjgnICtcbiAgICAnXFx1MjAyOVxcdUZFRkYnO1xudmFyIHplcm9XaWR0aCA9ICdcXHUyMDBiJztcbnZhciB3c1JlZ2V4Q2hhcnMgPSAnWycgKyB3cyArICddJztcbnZhciB0cmltQmVnaW5SZWdleHAgPSBuZXcgUmVnRXhwKCdeJyArIHdzUmVnZXhDaGFycyArIHdzUmVnZXhDaGFycyArICcqJyk7XG52YXIgdHJpbUVuZFJlZ2V4cCA9IG5ldyBSZWdFeHAod3NSZWdleENoYXJzICsgd3NSZWdleENoYXJzICsgJyokJyk7XG52YXIgaGFzVHJpbVdoaXRlc3BhY2VCdWcgPSBTdHJpbmdQcm90b3R5cGUudHJpbSAmJiAod3MudHJpbSgpIHx8ICF6ZXJvV2lkdGgudHJpbSgpKTtcbmRlZmluZVByb3BlcnRpZXMoU3RyaW5nUHJvdG90eXBlLCB7XG4gICAgLy8gaHR0cDovL2Jsb2cuc3RldmVubGV2aXRoYW4uY29tL2FyY2hpdmVzL2Zhc3Rlci10cmltLWphdmFzY3JpcHRcbiAgICAvLyBodHRwOi8vcGVyZmVjdGlvbmtpbGxzLmNvbS93aGl0ZXNwYWNlLWRldmlhdGlvbnMvXG4gICAgdHJpbTogZnVuY3Rpb24gdHJpbSgpIHtcbiAgICAgICAgaWYgKHRoaXMgPT09IHZvaWQgMCB8fCB0aGlzID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiY2FuJ3QgY29udmVydCBcIiArIHRoaXMgKyAnIHRvIG9iamVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcykucmVwbGFjZSh0cmltQmVnaW5SZWdleHAsICcnKS5yZXBsYWNlKHRyaW1FbmRSZWdleHAsICcnKTtcbiAgICB9XG59LCBoYXNUcmltV2hpdGVzcGFjZUJ1Zyk7XG5cbi8vIEVDTUEtMjYyLCAzcmQgQi4yLjNcbi8vIE5vdCBhbiBFQ01BU2NyaXB0IHN0YW5kYXJkLCBhbHRob3VnaCBFQ01BU2NyaXB0IDNyZCBFZGl0aW9uIGhhcyBhXG4vLyBub24tbm9ybWF0aXZlIHNlY3Rpb24gc3VnZ2VzdGluZyB1bmlmb3JtIHNlbWFudGljcyBhbmQgaXQgc2hvdWxkIGJlXG4vLyBub3JtYWxpemVkIGFjcm9zcyBhbGwgYnJvd3NlcnNcbi8vIFtidWdmaXgsIElFIGx0IDldIElFIDwgOSBzdWJzdHIoKSB3aXRoIG5lZ2F0aXZlIHZhbHVlIG5vdCB3b3JraW5nIGluIElFXG52YXIgc3RyaW5nX3N1YnN0ciA9IFN0cmluZ1Byb3RvdHlwZS5zdWJzdHI7XG52YXIgaGFzTmVnYXRpdmVTdWJzdHJCdWcgPSAnJy5zdWJzdHIgJiYgJzBiJy5zdWJzdHIoLTEpICE9PSAnYic7XG5kZWZpbmVQcm9wZXJ0aWVzKFN0cmluZ1Byb3RvdHlwZSwge1xuICAgIHN1YnN0cjogZnVuY3Rpb24gc3Vic3RyKHN0YXJ0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ19zdWJzdHIuY2FsbChcbiAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICBzdGFydCA8IDAgPyAoKHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydCkgPCAwID8gMCA6IHN0YXJ0KSA6IHN0YXJ0LFxuICAgICAgICAgICAgbGVuZ3RoXG4gICAgICAgICk7XG4gICAgfVxufSwgaGFzTmVnYXRpdmVTdWJzdHJCdWcpO1xuXG59LHt9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gW1xuICAvLyBzdHJlYW1pbmcgdHJhbnNwb3J0c1xuICByZXF1aXJlKCcuL3RyYW5zcG9ydC93ZWJzb2NrZXQnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItc3RyZWFtaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQveGRyLXN0cmVhbWluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L2V2ZW50c291cmNlJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQvZXZlbnRzb3VyY2UnKSlcblxuICAvLyBwb2xsaW5nIHRyYW5zcG9ydHNcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvaHRtbGZpbGUnKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC9saWIvaWZyYW1lLXdyYXAnKShyZXF1aXJlKCcuL3RyYW5zcG9ydC9odG1sZmlsZScpKVxuLCByZXF1aXJlKCcuL3RyYW5zcG9ydC94aHItcG9sbGluZycpXG4sIHJlcXVpcmUoJy4vdHJhbnNwb3J0L3hkci1wb2xsaW5nJylcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwJykocmVxdWlyZSgnLi90cmFuc3BvcnQveGhyLXBvbGxpbmcnKSlcbiwgcmVxdWlyZSgnLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZycpXG5dO1xuXG59LHtcIi4vdHJhbnNwb3J0L2V2ZW50c291cmNlXCI6NTAsXCIuL3RyYW5zcG9ydC9odG1sZmlsZVwiOjUxLFwiLi90cmFuc3BvcnQvanNvbnAtcG9sbGluZ1wiOjUzLFwiLi90cmFuc3BvcnQvbGliL2lmcmFtZS13cmFwXCI6NTYsXCIuL3RyYW5zcG9ydC93ZWJzb2NrZXRcIjo2OCxcIi4vdHJhbnNwb3J0L3hkci1wb2xsaW5nXCI6NjksXCIuL3RyYW5zcG9ydC94ZHItc3RyZWFtaW5nXCI6NzAsXCIuL3RyYW5zcG9ydC94aHItcG9sbGluZ1wiOjcxLFwiLi90cmFuc3BvcnQveGhyLXN0cmVhbWluZ1wiOjcyfV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCB1dGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2V2ZW50JylcbiAgLCB1cmxVdGlscyA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3VybCcpXG4gICwgWEhSID0gZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0XG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpicm93c2VyOnhocicpO1xufVxuXG5mdW5jdGlvbiBBYnN0cmFjdFhIUk9iamVjdChtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICBkZWJ1ZyhtZXRob2QsIHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIG9wdHMpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoQWJzdHJhY3RYSFJPYmplY3QsIEV2ZW50RW1pdHRlcik7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdHJ5IHtcbiAgICB0aGlzLnhociA9IG5ldyBYSFIoKTtcbiAgfSBjYXRjaCAoeCkge31cblxuICBpZiAoIXRoaXMueGhyKSB7XG4gICAgZGVidWcoJ25vIHhocicpO1xuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJ25vIHhociBzdXBwb3J0Jyk7XG4gICAgdGhpcy5fY2xlYW51cCgpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHNldmVyYWwgYnJvd3NlcnMgY2FjaGUgUE9TVHNcbiAgdXJsID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAndD0nICsgKCtuZXcgRGF0ZSgpKSk7XG5cbiAgLy8gRXhwbG9yZXIgdGVuZHMgdG8ga2VlcCBjb25uZWN0aW9uIG9wZW4sIGV2ZW4gYWZ0ZXIgdGhlXG4gIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICB0aGlzLnVubG9hZFJlZiA9IHV0aWxzLnVubG9hZEFkZChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndW5sb2FkIGNsZWFudXAnKTtcbiAgICBzZWxmLl9jbGVhbnVwKHRydWUpO1xuICB9KTtcbiAgdHJ5IHtcbiAgICB0aGlzLnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICBpZiAodGhpcy50aW1lb3V0ICYmICd0aW1lb3V0JyBpbiB0aGlzLnhocikge1xuICAgICAgdGhpcy54aHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICAgIHRoaXMueGhyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWJ1ZygneGhyIHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgfTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBkZWJ1ZygnZXhjZXB0aW9uJywgZSk7XG4gICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgIHRoaXMuX2NsZWFudXAoZmFsc2UpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICgoIW9wdHMgfHwgIW9wdHMubm9DcmVkZW50aWFscykgJiYgQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTKSB7XG4gICAgZGVidWcoJ3dpdGhDcmVkZW50aWFscycpO1xuICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAvLyBcIlRoaXMgbmV2ZXIgYWZmZWN0cyBzYW1lLXNpdGUgcmVxdWVzdHMuXCJcblxuICAgIHRoaXMueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgfVxuICBpZiAob3B0cyAmJiBvcHRzLmhlYWRlcnMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0cy5oZWFkZXJzKSB7XG4gICAgICB0aGlzLnhoci5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgb3B0cy5oZWFkZXJzW2tleV0pO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChzZWxmLnhocikge1xuICAgICAgdmFyIHggPSBzZWxmLnhocjtcbiAgICAgIHZhciB0ZXh0LCBzdGF0dXM7XG4gICAgICBkZWJ1ZygncmVhZHlTdGF0ZScsIHgucmVhZHlTdGF0ZSk7XG4gICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgY2FzZSAzOlxuICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgLy8gb24gTWljcm9zb2Z0LlhNTEhUVFAgYW5kIHJlYWR5c3RhdGU9M1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgIHRleHQgPSB4LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgZGVidWcoJ3N0YXR1cycsIHN0YXR1cyk7XG4gICAgICAgIC8vIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDEyMjMpIHtcbiAgICAgICAgICBzdGF0dXMgPSAyMDQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJRSBkb2VzIHJldHVybiByZWFkeXN0YXRlID09IDMgZm9yIDQwNCBhbnN3ZXJzLlxuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDAgJiYgdGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBkZWJ1ZygnY2h1bmsnKTtcbiAgICAgICAgICBzZWxmLmVtaXQoJ2NodW5rJywgc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNDpcbiAgICAgICAgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgIGRlYnVnKCdzdGF0dXMnLCBzdGF0dXMpO1xuICAgICAgICAvLyBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MFxuICAgICAgICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgICAgICAgc3RhdHVzID0gMjA0O1xuICAgICAgICB9XG4gICAgICAgIC8vIElFIHJldHVybnMgdGhpcyBmb3IgYSBiYWQgcG9ydFxuICAgICAgICAvLyBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvd2luZG93cy9kZXNrdG9wL2FhMzgzNzcwKHY9dnMuODUpLmFzcHhcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMTIwMDUgfHwgc3RhdHVzID09PSAxMjAyOSkge1xuICAgICAgICAgIHN0YXR1cyA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuZW1pdCgnZmluaXNoJywgc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoZmFsc2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgdHJ5IHtcbiAgICBzZWxmLnhoci5zZW5kKHBheWxvYWQpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH1cbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gIGRlYnVnKCdjbGVhbnVwJyk7XG4gIGlmICghdGhpcy54aHIpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcblxuICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgdGhpcy54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7fTtcbiAgaWYgKHRoaXMueGhyLm9udGltZW91dCkge1xuICAgIHRoaXMueGhyLm9udGltZW91dCA9IG51bGw7XG4gIH1cblxuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54aHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54aHIgPSBudWxsO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICB0aGlzLl9jbGVhbnVwKHRydWUpO1xufTtcblxuQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCA9ICEhWEhSO1xuLy8gb3ZlcnJpZGUgWE1MSHR0cFJlcXVlc3QgZm9yIElFNi83XG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmICghQWJzdHJhY3RYSFJPYmplY3QuZW5hYmxlZCAmJiAoYXhvIGluIGdsb2JhbCkpIHtcbiAgZGVidWcoJ292ZXJyaWRpbmcgeG1saHR0cHJlcXVlc3QnKTtcbiAgWEhSID0gZnVuY3Rpb24oKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBuZXcgZ2xvYmFsW2F4b10oJ01pY3Jvc29mdC5YTUxIVFRQJyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBBYnN0cmFjdFhIUk9iamVjdC5lbmFibGVkID0gISFuZXcgWEhSKCk7XG59XG5cbnZhciBjb3JzID0gZmFsc2U7XG50cnkge1xuICBjb3JzID0gJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhIUigpO1xufSBjYXRjaCAoaWdub3JlZCkge31cblxuQWJzdHJhY3RYSFJPYmplY3Quc3VwcG9ydHNDT1JTID0gY29ycztcblxubW9kdWxlLmV4cG9ydHMgPSBBYnN0cmFjdFhIUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vdXRpbHMvZXZlbnRcIjo3NixcIi4uLy4uL3V0aWxzL3VybFwiOjgyLFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5FdmVudFNvdXJjZTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG5tb2R1bGUuZXhwb3J0cyA9IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldDtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBFdmVudFNvdXJjZVJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlci9ldmVudHNvdXJjZScpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBFdmVudFNvdXJjZURyaXZlciA9IHJlcXVpcmUoJ2V2ZW50c291cmNlJylcbiAgO1xuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVRyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIUV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoRXZlbnRTb3VyY2VUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkV2ZW50U291cmNlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuICEhRXZlbnRTb3VyY2VEcml2ZXI7XG59O1xuXG5FdmVudFNvdXJjZVRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2V2ZW50c291cmNlJztcbkV2ZW50U291cmNlVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50U291cmNlVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIvZXZlbnRzb3VyY2VcIjo1OSxcIi4vc2VuZGVyL3hoci1jb3JzXCI6NjUsXCJldmVudHNvdXJjZVwiOjQ4LFwiaW5oZXJpdHNcIjo4N31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEh0bWxmaWxlUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL2h0bWxmaWxlJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gIDtcblxuZnVuY3Rpb24gSHRtbEZpbGVUcmFuc3BvcnQodHJhbnNVcmwpIHtcbiAgaWYgKCFIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIFhIUkxvY2FsT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoSHRtbEZpbGVUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cbkh0bWxGaWxlVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIHJldHVybiBIdG1sZmlsZVJlY2VpdmVyLmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luO1xufTtcblxuSHRtbEZpbGVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdodG1sZmlsZSc7XG5IdG1sRmlsZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sRmlsZVRyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6NTQsXCIuL3JlY2VpdmVyL2h0bWxmaWxlXCI6NjAsXCIuL3NlbmRlci94aHItbG9jYWxcIjo2NyxcImluaGVyaXRzXCI6ODd9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29yayBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZyb20gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSB1c2luZyBwb3N0TWVzc2FnZSgpLiBJbiBJRSBpdCB3YXMgaW1wbGVtZW50ZWRcbi8vIGZyb20gSUUgOCssIGJ1dCBvZiBjb3Vyc2UsIElFIGdvdCBzb21lIGRldGFpbHMgd3Jvbmc6XG4vLyAgICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MxOTcwMTUodj1WUy44NSkuYXNweFxuLy8gICAgaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgSlNPTjMgPSByZXF1aXJlKCdqc29uMycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgdmVyc2lvbiA9IHJlcXVpcmUoJy4uL3ZlcnNpb24nKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvdXJsJylcbiAgLCBpZnJhbWVVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2lmcmFtZScpXG4gICwgZXZlbnRVdGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzL2V2ZW50JylcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dHJhbnNwb3J0OmlmcmFtZScpO1xufVxuXG5mdW5jdGlvbiBJZnJhbWVUcmFuc3BvcnQodHJhbnNwb3J0LCB0cmFuc1VybCwgYmFzZVVybCkge1xuICBpZiAoIUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMub3JpZ2luID0gdXJsVXRpbHMuZ2V0T3JpZ2luKGJhc2VVcmwpO1xuICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICB0aGlzLnRyYW5zVXJsID0gdHJhbnNVcmw7XG4gIHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICB0aGlzLndpbmRvd0lkID0gcmFuZG9tLnN0cmluZyg4KTtcblxuICB2YXIgaWZyYW1lVXJsID0gdXJsVXRpbHMuYWRkUGF0aChiYXNlVXJsLCAnL2lmcmFtZS5odG1sJykgKyAnIycgKyB0aGlzLndpbmRvd0lkO1xuICBkZWJ1Zyh0cmFuc3BvcnQsIHRyYW5zVXJsLCBpZnJhbWVVcmwpO1xuXG4gIHRoaXMuaWZyYW1lT2JqID0gaWZyYW1lVXRpbHMuY3JlYXRlSWZyYW1lKGlmcmFtZVVybCwgZnVuY3Rpb24ocikge1xuICAgIGRlYnVnKCdlcnIgY2FsbGJhY2snKTtcbiAgICBzZWxmLmVtaXQoJ2Nsb3NlJywgMTAwNiwgJ1VuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoJyArIHIgKyAnKScpO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG5cbiAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuX21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgZXZlbnRVdGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIHRoaXMub25tZXNzYWdlQ2FsbGJhY2spO1xufVxuXG5pbmhlcml0cyhJZnJhbWVUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2Nsb3NlJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIGV2ZW50VXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCB0aGlzLm9ubWVzc2FnZUNhbGxiYWNrKTtcbiAgICB0cnkge1xuICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgIHRoaXMucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gICAgdGhpcy5vbm1lc3NhZ2VDYWxsYmFjayA9IHRoaXMuaWZyYW1lT2JqID0gbnVsbDtcbiAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5fbWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgZGVidWcoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICBpZiAoIXVybFV0aWxzLmlzT3JpZ2luRXF1YWwoZS5vcmlnaW4sIHRoaXMub3JpZ2luKSkge1xuICAgIGRlYnVnKCdub3Qgc2FtZSBvcmlnaW4nLCBlLm9yaWdpbiwgdGhpcy5vcmlnaW4pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBpZnJhbWVNZXNzYWdlO1xuICB0cnkge1xuICAgIGlmcmFtZU1lc3NhZ2UgPSBKU09OMy5wYXJzZShlLmRhdGEpO1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgZGVidWcoJ2JhZCBqc29uJywgZS5kYXRhKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoaWZyYW1lTWVzc2FnZS53aW5kb3dJZCAhPT0gdGhpcy53aW5kb3dJZCkge1xuICAgIGRlYnVnKCdtaXNtYXRjaGVkIHdpbmRvdyBpZCcsIGlmcmFtZU1lc3NhZ2Uud2luZG93SWQsIHRoaXMud2luZG93SWQpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAoaWZyYW1lTWVzc2FnZS50eXBlKSB7XG4gIGNhc2UgJ3MnOlxuICAgIHRoaXMuaWZyYW1lT2JqLmxvYWRlZCgpO1xuICAgIC8vIHdpbmRvdyBnbG9iYWwgZGVwZW5kZW5jeVxuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ3MnLCBKU09OMy5zdHJpbmdpZnkoW1xuICAgICAgdmVyc2lvblxuICAgICwgdGhpcy50cmFuc3BvcnRcbiAgICAsIHRoaXMudHJhbnNVcmxcbiAgICAsIHRoaXMuYmFzZVVybFxuICAgIF0pKTtcbiAgICBicmVhaztcbiAgY2FzZSAndCc6XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICBicmVhaztcbiAgY2FzZSAnYyc6XG4gICAgdmFyIGNkYXRhO1xuICAgIHRyeSB7XG4gICAgICBjZGF0YSA9IEpTT04zLnBhcnNlKGlmcmFtZU1lc3NhZ2UuZGF0YSk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgICAgZGVidWcoJ2JhZCBqc29uJywgaWZyYW1lTWVzc2FnZS5kYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIGNkYXRhWzBdLCBjZGF0YVsxXSk7XG4gICAgdGhpcy5jbG9zZSgpO1xuICAgIGJyZWFrO1xuICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICBkZWJ1ZygncG9zdE1lc3NhZ2UnLCB0eXBlLCBkYXRhKTtcbiAgdGhpcy5pZnJhbWVPYmoucG9zdChKU09OMy5zdHJpbmdpZnkoe1xuICAgIHdpbmRvd0lkOiB0aGlzLndpbmRvd0lkXG4gICwgdHlwZTogdHlwZVxuICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgfSksIHRoaXMub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgZGVidWcoJ3NlbmQnLCBtZXNzYWdlKTtcbiAgdGhpcy5wb3N0TWVzc2FnZSgnbScsIG1lc3NhZ2UpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIGlmcmFtZVV0aWxzLmlmcmFtZUVuYWJsZWQ7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUnO1xuSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IElmcmFtZVRyYW5zcG9ydDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIi4uL3V0aWxzL2V2ZW50XCI6NzYsXCIuLi91dGlscy9pZnJhbWVcIjo3NyxcIi4uL3V0aWxzL3JhbmRvbVwiOjgwLFwiLi4vdXRpbHMvdXJsXCI6ODIsXCIuLi92ZXJzaW9uXCI6ODMsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4NyxcImpzb24zXCI6ODh9XSw1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoZSBzaW1wbGVzdCBhbmQgbW9zdCByb2J1c3QgdHJhbnNwb3J0LCB1c2luZyB0aGUgd2VsbC1rbm93IGNyb3NzXG4vLyBkb21haW4gaGFjayAtIEpTT05QLiBUaGlzIHRyYW5zcG9ydCBpcyBxdWl0ZSBpbmVmZmljaWVudCAtIG9uZVxuLy8gbWVzc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3NlbmRlci1yZWNlaXZlcicpXG4gICwgSnNvbnBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIvanNvbnAnKVxuICAsIGpzb25wU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXIvanNvbnAnKVxuICA7XG5cbmZ1bmN0aW9uIEpzb25QVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghSnNvblBUcmFuc3BvcnQuZW5hYmxlZCgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgU2VuZGVyUmVjZWl2ZXIuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy9qc29ucCcsIGpzb25wU2VuZGVyLCBKc29ucFJlY2VpdmVyKTtcbn1cblxuaW5oZXJpdHMoSnNvblBUcmFuc3BvcnQsIFNlbmRlclJlY2VpdmVyKTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gISFnbG9iYWwuZG9jdW1lbnQ7XG59O1xuXG5Kc29uUFRyYW5zcG9ydC50cmFuc3BvcnROYW1lID0gJ2pzb25wLXBvbGxpbmcnO1xuSnNvblBUcmFuc3BvcnQucm91bmRUcmlwcyA9IDE7XG5Kc29uUFRyYW5zcG9ydC5uZWVkQm9keSA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvblBUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuL2xpYi9zZW5kZXItcmVjZWl2ZXJcIjo1OCxcIi4vcmVjZWl2ZXIvanNvbnBcIjo2MSxcIi4vc2VuZGVyL2pzb25wXCI6NjMsXCJpbmhlcml0c1wiOjg3fV0sNTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBTZW5kZXJSZWNlaXZlciA9IHJlcXVpcmUoJy4vc2VuZGVyLXJlY2VpdmVyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OmFqYXgtYmFzZWQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSB7XG4gIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgZGVidWcoJ2NyZWF0ZSBhamF4IHNlbmRlcicsIHVybCwgcGF5bG9hZCk7XG4gICAgdmFyIG9wdCA9IHt9O1xuICAgIGlmICh0eXBlb2YgcGF5bG9hZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG9wdC5oZWFkZXJzID0geydDb250ZW50LXR5cGUnOid0ZXh0L3BsYWluJ307XG4gICAgfVxuICAgIHZhciBhamF4VXJsID0gdXJsVXRpbHMuYWRkUGF0aCh1cmwsICcveGhyX3NlbmQnKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIGFqYXhVcmwsIHBheWxvYWQsIG9wdCk7XG4gICAgeG8ub25jZSgnZmluaXNoJywgZnVuY3Rpb24oc3RhdHVzKSB7XG4gICAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzKTtcbiAgICAgIHhvID0gbnVsbDtcblxuICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwICYmIHN0YXR1cyAhPT0gMjA0KSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoJ2h0dHAgc3RhdHVzICcgKyBzdGF0dXMpKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ2Fib3J0Jyk7XG4gICAgICB4by5jbG9zZSgpO1xuICAgICAgeG8gPSBudWxsO1xuXG4gICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdBYm9ydGVkJyk7XG4gICAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH07XG4gIH07XG59XG5cbmZ1bmN0aW9uIEFqYXhCYXNlZFRyYW5zcG9ydCh0cmFuc1VybCwgdXJsU3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICBTZW5kZXJSZWNlaXZlci5jYWxsKHRoaXMsIHRyYW5zVXJsLCB1cmxTdWZmaXgsIGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCksIFJlY2VpdmVyLCBBamF4T2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoQWpheEJhc2VkVHJhbnNwb3J0LCBTZW5kZXJSZWNlaXZlcik7XG5cbm1vZHVsZS5leHBvcnRzID0gQWpheEJhc2VkVHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCIuL3NlbmRlci1yZWNlaXZlclwiOjU4LFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJpbmhlcml0c1wiOjg3fV0sNTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6YnVmZmVyZWQtc2VuZGVyJyk7XG59XG5cbmZ1bmN0aW9uIEJ1ZmZlcmVkU2VuZGVyKHVybCwgc2VuZGVyKSB7XG4gIGRlYnVnKHVybCk7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuICB0aGlzLnNlbmRCdWZmZXIgPSBbXTtcbiAgdGhpcy5zZW5kZXIgPSBzZW5kZXI7XG4gIHRoaXMudXJsID0gdXJsO1xufVxuXG5pbmhlcml0cyhCdWZmZXJlZFNlbmRlciwgRXZlbnRFbWl0dGVyKTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG4gIGRlYnVnKCdzZW5kJywgbWVzc2FnZSk7XG4gIHRoaXMuc2VuZEJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICBpZiAoIXRoaXMuc2VuZFN0b3ApIHtcbiAgICB0aGlzLnNlbmRTY2hlZHVsZSgpO1xuICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZFNjaGVkdWxlV2FpdCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc2VuZFNjaGVkdWxlV2FpdCcpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0cmVmO1xuICB0aGlzLnNlbmRTdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3NlbmRTdG9wJyk7XG4gICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICB9O1xuICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICBkZWJ1ZygndGltZW91dCcpO1xuICAgIHNlbGYuc2VuZFN0b3AgPSBudWxsO1xuICAgIHNlbGYuc2VuZFNjaGVkdWxlKCk7XG4gIH0sIDI1KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kU2NoZWR1bGUgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ3NlbmRTY2hlZHVsZScsIHRoaXMuc2VuZEJ1ZmZlci5sZW5ndGgpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIGlmICh0aGlzLnNlbmRCdWZmZXIubGVuZ3RoID4gMCkge1xuICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhpcy5zZW5kQnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICB0aGlzLnNlbmRTdG9wID0gdGhpcy5zZW5kZXIodGhpcy51cmwsIHBheWxvYWQsIGZ1bmN0aW9uKGVycikge1xuICAgICAgc2VsZi5zZW5kU3RvcCA9IG51bGw7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIGRlYnVnKCdlcnJvcicsIGVycik7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSB8fCAxMDA2LCAnU2VuZGluZyBlcnJvcjogJyArIGVycik7XG4gICAgICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuc2VuZFNjaGVkdWxlV2FpdCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc2VuZEJ1ZmZlciA9IFtdO1xuICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1Zygnc3RvcCcpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG4gIGlmICh0aGlzLnNlbmRTdG9wKSB7XG4gICAgdGhpcy5zZW5kU3RvcCgpO1xuICAgIHRoaXMuc2VuZFN0b3AgPSBudWxsO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEJ1ZmZlcmVkU2VuZGVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw1NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBJZnJhbWVUcmFuc3BvcnQgPSByZXF1aXJlKCcuLi9pZnJhbWUnKVxuICAsIG9iamVjdFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvb2JqZWN0JylcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXG4gIGZ1bmN0aW9uIElmcmFtZVdyYXBUcmFuc3BvcnQodHJhbnNVcmwsIGJhc2VVcmwpIHtcbiAgICBJZnJhbWVUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc3BvcnQudHJhbnNwb3J0TmFtZSwgdHJhbnNVcmwsIGJhc2VVcmwpO1xuICB9XG5cbiAgaW5oZXJpdHMoSWZyYW1lV3JhcFRyYW5zcG9ydCwgSWZyYW1lVHJhbnNwb3J0KTtcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbih1cmwsIGluZm8pIHtcbiAgICBpZiAoIWdsb2JhbC5kb2N1bWVudCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBpZnJhbWVJbmZvID0gb2JqZWN0VXRpbHMuZXh0ZW5kKHt9LCBpbmZvKTtcbiAgICBpZnJhbWVJbmZvLnNhbWVPcmlnaW4gPSB0cnVlO1xuICAgIHJldHVybiB0cmFuc3BvcnQuZW5hYmxlZChpZnJhbWVJbmZvKSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xuICB9O1xuXG4gIElmcmFtZVdyYXBUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICdpZnJhbWUtJyArIHRyYW5zcG9ydC50cmFuc3BvcnROYW1lO1xuICBJZnJhbWVXcmFwVHJhbnNwb3J0Lm5lZWRCb2R5ID0gdHJ1ZTtcbiAgSWZyYW1lV3JhcFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgKyB0cmFuc3BvcnQucm91bmRUcmlwcyAtIDE7IC8vIGh0bWwsIGphdmFzY3JpcHQgKDIpICsgdHJhbnNwb3J0IC0gbm8gQ09SUyAoMSlcblxuICBJZnJhbWVXcmFwVHJhbnNwb3J0LmZhY2FkZVRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcblxuICByZXR1cm4gSWZyYW1lV3JhcFRyYW5zcG9ydDtcbn07XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9vYmplY3RcIjo3OSxcIi4uL2lmcmFtZVwiOjUyLFwiaW5oZXJpdHNcIjo4N31dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnBvbGxpbmcnKTtcbn1cblxuZnVuY3Rpb24gUG9sbGluZyhSZWNlaXZlciwgcmVjZWl2ZVVybCwgQWpheE9iamVjdCkge1xuICBkZWJ1ZyhyZWNlaXZlVXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHRoaXMuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgdGhpcy5yZWNlaXZlVXJsID0gcmVjZWl2ZVVybDtcbiAgdGhpcy5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgdGhpcy5fc2NoZWR1bGVSZWNlaXZlcigpO1xufVxuXG5pbmhlcml0cyhQb2xsaW5nLCBFdmVudEVtaXR0ZXIpO1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWNlaXZlciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjaGVkdWxlUmVjZWl2ZXInKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgcG9sbCA9IHRoaXMucG9sbCA9IG5ldyB0aGlzLlJlY2VpdmVyKHRoaXMucmVjZWl2ZVVybCwgdGhpcy5BamF4T2JqZWN0KTtcblxuICBwb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIHNlbGYuZW1pdCgnbWVzc2FnZScsIG1zZyk7XG4gIH0pO1xuXG4gIHBvbGwub25jZSgnY2xvc2UnLCBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICBkZWJ1ZygnY2xvc2UnLCBjb2RlLCByZWFzb24sIHNlbGYucG9sbElzQ2xvc2luZyk7XG4gICAgc2VsZi5wb2xsID0gcG9sbCA9IG51bGw7XG5cbiAgICBpZiAoIXNlbGYucG9sbElzQ2xvc2luZykge1xuICAgICAgaWYgKHJlYXNvbiA9PT0gJ25ldHdvcmsnKSB7XG4gICAgICAgIHNlbGYuX3NjaGVkdWxlUmVjZWl2ZXIoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlIHx8IDEwMDYsIHJlYXNvbik7XG4gICAgICAgIHNlbGYucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICB0aGlzLnBvbGxJc0Nsb3NpbmcgPSB0cnVlO1xuICBpZiAodGhpcy5wb2xsKSB7XG4gICAgdGhpcy5wb2xsLmFib3J0KCk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9sbGluZztcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3fV0sNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChwcm9jZXNzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBCdWZmZXJlZFNlbmRlciA9IHJlcXVpcmUoJy4vYnVmZmVyZWQtc2VuZGVyJylcbiAgLCBQb2xsaW5nID0gcmVxdWlyZSgnLi9wb2xsaW5nJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlci1yZWNlaXZlcicpO1xufVxuXG5mdW5jdGlvbiBTZW5kZXJSZWNlaXZlcih0cmFuc1VybCwgdXJsU3VmZml4LCBzZW5kZXJGdW5jLCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICB2YXIgcG9sbFVybCA9IHVybFV0aWxzLmFkZFBhdGgodHJhbnNVcmwsIHVybFN1ZmZpeCk7XG4gIGRlYnVnKHBvbGxVcmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEJ1ZmZlcmVkU2VuZGVyLmNhbGwodGhpcywgdHJhbnNVcmwsIHNlbmRlckZ1bmMpO1xuXG4gIHRoaXMucG9sbCA9IG5ldyBQb2xsaW5nKFJlY2VpdmVyLCBwb2xsVXJsLCBBamF4T2JqZWN0KTtcbiAgdGhpcy5wb2xsLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24obXNnKSB7XG4gICAgZGVidWcoJ3BvbGwgbWVzc2FnZScsIG1zZyk7XG4gICAgc2VsZi5lbWl0KCdtZXNzYWdlJywgbXNnKTtcbiAgfSk7XG4gIHRoaXMucG9sbC5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uKGNvZGUsIHJlYXNvbikge1xuICAgIGRlYnVnKCdwb2xsIGNsb3NlJywgY29kZSwgcmVhc29uKTtcbiAgICBzZWxmLnBvbGwgPSBudWxsO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBjb2RlLCByZWFzb24pO1xuICAgIHNlbGYuY2xvc2UoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFNlbmRlclJlY2VpdmVyLCBCdWZmZXJlZFNlbmRlcik7XG5cblNlbmRlclJlY2VpdmVyLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgaWYgKHRoaXMucG9sbCkge1xuICAgIHRoaXMucG9sbC5hYm9ydCgpO1xuICAgIHRoaXMucG9sbCA9IG51bGw7XG4gIH1cbiAgdGhpcy5zdG9wKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCIuL2J1ZmZlcmVkLXNlbmRlclwiOjU1LFwiLi9wb2xsaW5nXCI6NTcsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImluaGVyaXRzXCI6ODd9XSw1OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG4gICwgRXZlbnRTb3VyY2VEcml2ZXIgPSByZXF1aXJlKCdldmVudHNvdXJjZScpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDpyZWNlaXZlcjpldmVudHNvdXJjZScpO1xufVxuXG5mdW5jdGlvbiBFdmVudFNvdXJjZVJlY2VpdmVyKHVybCkge1xuICBkZWJ1Zyh1cmwpO1xuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBlcyA9IHRoaXMuZXMgPSBuZXcgRXZlbnRTb3VyY2VEcml2ZXIodXJsKTtcbiAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkZWNvZGVVUkkoZS5kYXRhKSk7XG4gIH07XG4gIGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Vycm9yJywgZXMucmVhZHlTdGF0ZSwgZSk7XG4gICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgIC8vIG9uIG5ldHdvcmsgZXJyb3IgaXQncyBDTE9TRUQgPSAyXG4gICAgdmFyIHJlYXNvbiA9IChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZShyZWFzb24pO1xuICB9O1xufVxuXG5pbmhlcml0cyhFdmVudFNvdXJjZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ2NsZWFudXAnKTtcbiAgdmFyIGVzID0gdGhpcy5lcztcbiAgaWYgKGVzKSB7XG4gICAgZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgZXMuY2xvc2UoKTtcbiAgICB0aGlzLmVzID0gbnVsbDtcbiAgfVxufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuX2Nsb3NlID0gZnVuY3Rpb24ocmVhc29uKSB7XG4gIGRlYnVnKCdjbG9zZScsIHJlYXNvbik7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTg5MTU1XG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gICAgc2VsZi5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgfSwgMjAwKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRTb3VyY2VSZWNlaXZlcjtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXG59LHtcIl9wcm9jZXNzXCI6MzAsXCJkZWJ1Z1wiOjg0LFwiZXZlbnRzXCI6MzMsXCJldmVudHNvdXJjZVwiOjQ4LFwiaW5oZXJpdHNcIjo4N31dLDYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgaWZyYW1lVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCByYW5kb20gPSByZXF1aXJlKCcuLi8uLi91dGlscy9yYW5kb20nKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6cmVjZWl2ZXI6aHRtbGZpbGUnKTtcbn1cblxuZnVuY3Rpb24gSHRtbGZpbGVSZWNlaXZlcih1cmwpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWZyYW1lVXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICdjPScgKyBkZWNvZGVVUklDb21wb25lbnQoaWZyYW1lVXRpbHMuV1ByZWZpeCArICcuJyArIHRoaXMuaWQpKTtcblxuICBkZWJ1ZygndXNpbmcgaHRtbGZpbGUnLCBIdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCk7XG4gIHZhciBjb25zdHJ1Y3RGdW5jID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgP1xuICAgICAgaWZyYW1lVXRpbHMuY3JlYXRlSHRtbGZpbGUgOiBpZnJhbWVVdGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgZ2xvYmFsW2lmcmFtZVV0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0ge1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdzdGFydCcpO1xuICAgICAgc2VsZi5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgfVxuICAsIG1lc3NhZ2U6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBkYXRhKTtcbiAgICB9XG4gICwgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnc3RvcCcpO1xuICAgICAgc2VsZi5fY2xlYW51cCgpO1xuICAgICAgc2VsZi5fY2xvc2UoJ25ldHdvcmsnKTtcbiAgICB9XG4gIH07XG4gIHRoaXMuaWZyYW1lT2JqID0gY29uc3RydWN0RnVuYyh1cmwsIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdjYWxsYmFjaycpO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgICBzZWxmLl9jbG9zZSgncGVybWFuZW50Jyk7XG4gIH0pO1xufVxuXG5pbmhlcml0cyhIdG1sZmlsZVJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnYWJvcnQnKTtcbiAgdGhpcy5fY2xlYW51cCgpO1xuICB0aGlzLl9jbG9zZSgndXNlcicpO1xufTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGlmICh0aGlzLmlmcmFtZU9iaikge1xuICAgIHRoaXMuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICB0aGlzLmlmcmFtZU9iaiA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFtpZnJhbWVVdGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlLl9jbG9zZSA9IGZ1bmN0aW9uKHJlYXNvbikge1xuICBkZWJ1ZygnX2Nsb3NlJywgcmVhc29uKTtcbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsIHJlYXNvbik7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLmh0bWxmaWxlRW5hYmxlZCA9IGZhbHNlO1xuXG4vLyBvYmZ1c2NhdGUgdG8gYXZvaWQgZmlyZXdhbGxzXG52YXIgYXhvID0gWydBY3RpdmUnXS5jb25jYXQoJ09iamVjdCcpLmpvaW4oJ1gnKTtcbmlmIChheG8gaW4gZ2xvYmFsKSB7XG4gIHRyeSB7XG4gICAgSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgPSAhIW5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgfSBjYXRjaCAoeCkge31cbn1cblxuSHRtbGZpbGVSZWNlaXZlci5lbmFibGVkID0gSHRtbGZpbGVSZWNlaXZlci5odG1sZmlsZUVuYWJsZWQgfHwgaWZyYW1lVXRpbHMuaWZyYW1lRW5hYmxlZDtcblxubW9kdWxlLmV4cG9ydHMgPSBIdG1sZmlsZVJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9pZnJhbWVcIjo3NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjgwLFwiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9pZnJhbWUnKVxuICAsIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOmpzb25wJyk7XG59XG5cbmZ1bmN0aW9uIEpzb25wUmVjZWl2ZXIodXJsKSB7XG4gIGRlYnVnKHVybCk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuXG4gIHRoaXMuaWQgPSAnYScgKyByYW5kb20uc3RyaW5nKDYpO1xuICB2YXIgdXJsV2l0aElkID0gdXJsVXRpbHMuYWRkUXVlcnkodXJsLCAnYz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHV0aWxzLldQcmVmaXggKyAnLicgKyB0aGlzLmlkKSk7XG5cbiAgZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdID0gdGhpcy5fY2FsbGJhY2suYmluZCh0aGlzKTtcbiAgdGhpcy5fY3JlYXRlU2NyaXB0KHVybFdpdGhJZCk7XG5cbiAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICB0aGlzLnRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ3RpbWVvdXQnKTtcbiAgICBzZWxmLl9hYm9ydChuZXcgRXJyb3IoJ0pTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dCknKSk7XG4gIH0sIEpzb25wUmVjZWl2ZXIudGltZW91dCk7XG59XG5cbmluaGVyaXRzKEpzb25wUmVjZWl2ZXIsIEV2ZW50RW1pdHRlcik7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAoZ2xvYmFsW3V0aWxzLldQcmVmaXhdW3RoaXMuaWRdKSB7XG4gICAgdmFyIGVyciA9IG5ldyBFcnJvcignSlNPTlAgdXNlciBhYm9ydGVkIHJlYWQnKTtcbiAgICBlcnIuY29kZSA9IDEwMDA7XG4gICAgdGhpcy5fYWJvcnQoZXJyKTtcbiAgfVxufTtcblxuSnNvbnBSZWNlaXZlci50aW1lb3V0ID0gMzUwMDA7XG5Kc29ucFJlY2VpdmVyLnNjcmlwdEVycm9yVGltZW91dCA9IDEwMDA7XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgZGVidWcoJ19jYWxsYmFjaycsIGRhdGEpO1xuICB0aGlzLl9jbGVhbnVwKCk7XG5cbiAgaWYgKHRoaXMuYWJvcnRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZGF0YSkge1xuICAgIGRlYnVnKCdtZXNzYWdlJywgZGF0YSk7XG4gICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSk7XG4gIH1cbiAgdGhpcy5lbWl0KCdjbG9zZScsIG51bGwsICduZXR3b3JrJyk7XG4gIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG59O1xuXG5Kc29ucFJlY2VpdmVyLnByb3RvdHlwZS5fYWJvcnQgPSBmdW5jdGlvbihlcnIpIHtcbiAgZGVidWcoJ19hYm9ydCcsIGVycik7XG4gIHRoaXMuX2NsZWFudXAoKTtcbiAgdGhpcy5hYm9ydGluZyA9IHRydWU7XG4gIHRoaXMuZW1pdCgnY2xvc2UnLCBlcnIuY29kZSwgZXJyLm1lc3NhZ2UpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuSnNvbnBSZWNlaXZlci5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgZGVidWcoJ19jbGVhbnVwJyk7XG4gIGNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXRJZCk7XG4gIGlmICh0aGlzLnNjcmlwdDIpIHtcbiAgICB0aGlzLnNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnNjcmlwdDIpO1xuICAgIHRoaXMuc2NyaXB0MiA9IG51bGw7XG4gIH1cbiAgaWYgKHRoaXMuc2NyaXB0KSB7XG4gICAgdmFyIHNjcmlwdCA9IHRoaXMuc2NyaXB0O1xuICAgIC8vIFVuZm9ydHVuYXRlbHksIHlvdSBjYW4ndCByZWFsbHkgYWJvcnQgc2NyaXB0IGxvYWRpbmcgb2ZcbiAgICAvLyB0aGUgc2NyaXB0LlxuICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgc2NyaXB0Lm9ubG9hZCA9IHNjcmlwdC5vbmNsaWNrID0gbnVsbDtcbiAgICB0aGlzLnNjcmlwdCA9IG51bGw7XG4gIH1cbiAgZGVsZXRlIGdsb2JhbFt1dGlscy5XUHJlZml4XVt0aGlzLmlkXTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9zY3JpcHRFcnJvciA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnX3NjcmlwdEVycm9yJyk7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuZXJyb3JUaW1lcikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyb3JUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgaWYgKCFzZWxmLmxvYWRlZE9rYXkpIHtcbiAgICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKScpKTtcbiAgICB9XG4gIH0sIEpzb25wUmVjZWl2ZXIuc2NyaXB0RXJyb3JUaW1lb3V0KTtcbn07XG5cbkpzb25wUmVjZWl2ZXIucHJvdG90eXBlLl9jcmVhdGVTY3JpcHQgPSBmdW5jdGlvbih1cmwpIHtcbiAgZGVidWcoJ19jcmVhdGVTY3JpcHQnLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgdmFyIHNjcmlwdDI7ICAvLyBPcGVyYSBzeW5jaHJvbm91cyBsb2FkIHRyaWNrLlxuXG4gIHNjcmlwdC5pZCA9ICdhJyArIHJhbmRvbS5zdHJpbmcoOCk7XG4gIHNjcmlwdC5zcmMgPSB1cmw7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgc2NyaXB0Lm9uZXJyb3IgPSB0aGlzLl9zY3JpcHRFcnJvci5iaW5kKHRoaXMpO1xuICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcpO1xuICAgIHNlbGYuX2Fib3J0KG5ldyBFcnJvcignSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpJykpO1xuICB9O1xuXG4gIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9ucmVhZHlzdGF0ZWNoYW5nZSBvciBiZWZvcmUsIGluIHJhbmRvbSBvcmRlci5cbiAgLy8gVXNlIGxvYWRlZE9rYXkgdG8gZGV0ZXJtaW5lIGlmIGFjdHVhbGx5IGVycm9yZWRcbiAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnJlYWR5c3RhdGVjaGFuZ2UnLCBzY3JpcHQucmVhZHlTdGF0ZSk7XG4gICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICBzZWxmLmxvYWRlZE9rYXkgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEluIElFLCBhY3R1YWxseSBleGVjdXRlIHRoZSBzY3JpcHQuXG4gICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgIH1cbiAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgc2VsZi5fYWJvcnQobmV3IEVycm9yKCdKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSknKSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgLy8gbWFrZSBzdXJlLCBzZXQgYSAnaHRtbEZvcicgYW5kICdldmVudCcgcHJvcGVydGllcywgc28gdGhhdFxuICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAvLyBjb2RlLiBGRiBhbmQgQ2hyb21lIGRvZXNuJ3Qgd29yayB3aXRoICdldmVudCcgYW5kICdodG1sRm9yJ1xuICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAvLyBBbHNvLCByZWFkIG9uIHRoYXQgYWJvdXQgc2NyaXB0IG9yZGVyaW5nOlxuICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAvLyB0byAndHJ1ZScsIHNvIHdlIG1heSB1c2UgaXQgdG8gZGV0ZWN0IGEgZ29vZCBicm93c2VyOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICBpZiAoIWJyb3dzZXIuaXNPcGVyYSgpKSB7XG4gICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgdHJ5IHtcbiAgICAgICAgc2NyaXB0Lmh0bWxGb3IgPSBzY3JpcHQuaWQ7XG4gICAgICAgIHNjcmlwdC5ldmVudCA9ICdvbmNsaWNrJztcbiAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgIHNjcmlwdDIgPSB0aGlzLnNjcmlwdDIgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIiArIHNjcmlwdC5pZCArIFwiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGlmICh0eXBlb2Ygc2NyaXB0LmFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gIH1cblxuICB2YXIgaGVhZCA9IGdsb2JhbC5kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gIGlmIChzY3JpcHQyKSB7XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBKc29ucFJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9icm93c2VyXCI6NzQsXCIuLi8uLi91dGlscy9pZnJhbWVcIjo3NyxcIi4uLy4uL3V0aWxzL3JhbmRvbVwiOjgwLFwiLi4vLi4vdXRpbHMvdXJsXCI6ODIsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAocHJvY2Vzcyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnJlY2VpdmVyOnhocicpO1xufVxuXG5mdW5jdGlvbiBYaHJSZWNlaXZlcih1cmwsIEFqYXhPYmplY3QpIHtcbiAgZGVidWcodXJsKTtcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIHZhciBzZWxmID0gdGhpcztcblxuICB0aGlzLmJ1ZmZlclBvc2l0aW9uID0gMDtcblxuICB0aGlzLnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICB0aGlzLnhvLm9uKCdjaHVuaycsIHRoaXMuX2NodW5rSGFuZGxlci5iaW5kKHRoaXMpKTtcbiAgdGhpcy54by5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICBkZWJ1ZygnZmluaXNoJywgc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLl9jaHVua0hhbmRsZXIoc3RhdHVzLCB0ZXh0KTtcbiAgICBzZWxmLnhvID0gbnVsbDtcbiAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICBkZWJ1ZygnY2xvc2UnLCByZWFzb24pO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCBudWxsLCByZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfSk7XG59XG5cbmluaGVyaXRzKFhoclJlY2VpdmVyLCBFdmVudEVtaXR0ZXIpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuX2NodW5rSGFuZGxlciA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICBkZWJ1ZygnX2NodW5rSGFuZGxlcicsIHN0YXR1cyk7XG4gIGlmIChzdGF0dXMgIT09IDIwMCB8fCAhdGV4dCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGZvciAodmFyIGlkeCA9IC0xOyA7IHRoaXMuYnVmZmVyUG9zaXRpb24gKz0gaWR4ICsgMSkge1xuICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKHRoaXMuYnVmZmVyUG9zaXRpb24pO1xuICAgIGlkeCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgaWR4KTtcbiAgICBpZiAobXNnKSB7XG4gICAgICBkZWJ1ZygnbWVzc2FnZScsIG1zZyk7XG4gICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBtc2cpO1xuICAgIH1cbiAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdhYm9ydCcpO1xuICBpZiAodGhpcy54bykge1xuICAgIHRoaXMueG8uY2xvc2UoKTtcbiAgICBkZWJ1ZygnY2xvc2UnKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbnVsbCwgJ3VzZXInKTtcbiAgICB0aGlzLnhvID0gbnVsbDtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhoclJlY2VpdmVyO1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw2MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL3JhbmRvbScpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy91cmwnKVxuICA7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6c2VuZGVyOmpzb25wJyk7XG59XG5cbnZhciBmb3JtLCBhcmVhO1xuXG5mdW5jdGlvbiBjcmVhdGVJZnJhbWUoaWQpIHtcbiAgZGVidWcoJ2NyZWF0ZUlmcmFtZScsIGlkKTtcbiAgdHJ5IHtcbiAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICByZXR1cm4gZ2xvYmFsLmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicgKyBpZCArICdcIj4nKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHZhciBpZnJhbWUgPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICByZXR1cm4gaWZyYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZvcm0oKSB7XG4gIGRlYnVnKCdjcmVhdGVGb3JtJyk7XG4gIGZvcm0gPSBnbG9iYWwuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICBmb3JtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIGZvcm0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICBmb3JtLm1ldGhvZCA9ICdQT1NUJztcbiAgZm9ybS5lbmN0eXBlID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gIGZvcm0uYWNjZXB0Q2hhcnNldCA9ICdVVEYtOCc7XG5cbiAgYXJlYSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICBhcmVhLm5hbWUgPSAnZCc7XG4gIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG5cbiAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZm9ybSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICBkZWJ1Zyh1cmwsIHBheWxvYWQpO1xuICBpZiAoIWZvcm0pIHtcbiAgICBjcmVhdGVGb3JtKCk7XG4gIH1cbiAgdmFyIGlkID0gJ2EnICsgcmFuZG9tLnN0cmluZyg4KTtcbiAgZm9ybS50YXJnZXQgPSBpZDtcbiAgZm9ybS5hY3Rpb24gPSB1cmxVdGlscy5hZGRRdWVyeSh1cmxVdGlscy5hZGRQYXRoKHVybCwgJy9qc29ucF9zZW5kJyksICdpPScgKyBpZCk7XG5cbiAgdmFyIGlmcmFtZSA9IGNyZWF0ZUlmcmFtZShpZCk7XG4gIGlmcmFtZS5pZCA9IGlkO1xuICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuXG4gIHRyeSB7XG4gICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBzZXJpb3VzbHkgYnJva2VuIGJyb3dzZXJzIGdldCBoZXJlXG4gIH1cbiAgZm9ybS5zdWJtaXQoKTtcblxuICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZXJyKSB7XG4gICAgZGVidWcoJ2NvbXBsZXRlZCcsIGlkLCBlcnIpO1xuICAgIGlmICghaWZyYW1lLm9uZXJyb3IpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGlmcmFtZS5vbmVycm9yID0gaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1ZygnY2xlYW5pbmcgdXAnLCBpZCk7XG4gICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICB9LCA1MDApO1xuICAgIGFyZWEudmFsdWUgPSAnJztcbiAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gZGV0ZWN0IGlmIHRoZSBpZnJhbWUgc3VjY2VlZGVkIG9yXG4gICAgLy8gZmFpbGVkIHRvIHN1Ym1pdCBvdXIgZm9ybS5cbiAgICBjYWxsYmFjayhlcnIpO1xuICB9O1xuICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJywgaWQpO1xuICAgIGNvbXBsZXRlZCgpO1xuICB9O1xuICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ29ubG9hZCcsIGlkKTtcbiAgICBjb21wbGV0ZWQoKTtcbiAgfTtcbiAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICBkZWJ1Zygnb25yZWFkeXN0YXRlY2hhbmdlJywgaWQsIGlmcmFtZS5yZWFkeVN0YXRlLCBlKTtcbiAgICBpZiAoaWZyYW1lLnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNvbXBsZXRlZCgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdhYm9ydGVkJywgaWQpO1xuICAgIGNvbXBsZXRlZChuZXcgRXJyb3IoJ0Fib3J0ZWQnKSk7XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi8uLi91dGlscy9yYW5kb21cIjo4MCxcIi4uLy4uL3V0aWxzL3VybFwiOjgyLFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODR9XSw2NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuLi8uLi91dGlscy9ldmVudCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uLy4uL3V0aWxzL2Jyb3dzZXInKVxuICAsIHVybFV0aWxzID0gcmVxdWlyZSgnLi4vLi4vdXRpbHMvdXJsJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnNlbmRlcjp4ZHInKTtcbn1cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxuXG5mdW5jdGlvbiBYRFJPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgZGVidWcobWV0aG9kLCB1cmwpO1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIEV2ZW50RW1pdHRlci5jYWxsKHRoaXMpO1xuXG4gIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO1xuICB9LCAwKTtcbn1cblxuaW5oZXJpdHMoWERST2JqZWN0LCBFdmVudEVtaXR0ZXIpO1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gIGRlYnVnKCdfc3RhcnQnKTtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGRyID0gbmV3IGdsb2JhbC5YRG9tYWluUmVxdWVzdCgpO1xuICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICB1cmwgPSB1cmxVdGlscy5hZGRRdWVyeSh1cmwsICd0PScgKyAoK25ldyBEYXRlKCkpKTtcblxuICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbmVycm9yJyk7XG4gICAgc2VsZi5fZXJyb3IoKTtcbiAgfTtcbiAgeGRyLm9udGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdvbnRpbWVvdXQnKTtcbiAgICBzZWxmLl9lcnJvcigpO1xuICB9O1xuICB4ZHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCdwcm9ncmVzcycsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIHNlbGYuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICB9O1xuICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgZGVidWcoJ2xvYWQnKTtcbiAgICBzZWxmLmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgc2VsZi5fY2xlYW51cChmYWxzZSk7XG4gIH07XG4gIHRoaXMueGRyID0geGRyO1xuICB0aGlzLnVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIHNlbGYuX2NsZWFudXAodHJ1ZSk7XG4gIH0pO1xuICB0cnkge1xuICAgIC8vIEZhaWxzIHdpdGggQWNjZXNzRGVuaWVkIGlmIHBvcnQgbnVtYmVyIGlzIGJvZ3VzXG4gICAgdGhpcy54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgaWYgKHRoaXMudGltZW91dCkge1xuICAgICAgdGhpcy54ZHIudGltZW91dCA9IHRoaXMudGltZW91dDtcbiAgICB9XG4gICAgdGhpcy54ZHIuc2VuZChwYXlsb2FkKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHRoaXMuX2Vycm9yKCk7XG4gIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2Vycm9yID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICB0aGlzLl9jbGVhbnVwKGZhbHNlKTtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICBkZWJ1ZygnY2xlYW51cCcsIGFib3J0KTtcbiAgaWYgKCF0aGlzLnhkcikge1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuICBldmVudFV0aWxzLnVubG9hZERlbCh0aGlzLnVubG9hZFJlZik7XG5cbiAgdGhpcy54ZHIub250aW1lb3V0ID0gdGhpcy54ZHIub25lcnJvciA9IHRoaXMueGRyLm9ucHJvZ3Jlc3MgPSB0aGlzLnhkci5vbmxvYWQgPSBudWxsO1xuICBpZiAoYWJvcnQpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy54ZHIuYWJvcnQoKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9XG4gIHRoaXMudW5sb2FkUmVmID0gdGhpcy54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBkZWJ1ZygnY2xvc2UnKTtcbiAgdGhpcy5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIElFIDgvOSBpZiB0aGUgcmVxdWVzdCB0YXJnZXQgdXNlcyB0aGUgc2FtZSBzY2hlbWUgLSAjNzlcblhEUk9iamVjdC5lbmFibGVkID0gISEoZ2xvYmFsLlhEb21haW5SZXF1ZXN0ICYmIGJyb3dzZXIuaGFzRG9tYWluKCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhEUk9iamVjdDtcblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi4vLi4vdXRpbHMvYnJvd3NlclwiOjc0LFwiLi4vLi4vdXRpbHMvZXZlbnRcIjo3NixcIi4uLy4uL3V0aWxzL3VybFwiOjgyLFwiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODQsXCJldmVudHNcIjozMyxcImluaGVyaXRzXCI6ODd9XSw2NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBYaHJEcml2ZXIgPSByZXF1aXJlKCcuLi9kcml2ZXIveGhyJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJDb3JzT2JqZWN0KG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gIFhockRyaXZlci5jYWxsKHRoaXMsIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKTtcbn1cblxuaW5oZXJpdHMoWEhSQ29yc09iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSQ29yc09iamVjdC5lbmFibGVkID0gWGhyRHJpdmVyLmVuYWJsZWQgJiYgWGhyRHJpdmVyLnN1cHBvcnRzQ09SUztcblxubW9kdWxlLmV4cG9ydHMgPSBYSFJDb3JzT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjo0NyxcImluaGVyaXRzXCI6ODd9XSw2NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXJcbiAgLCBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgO1xuXG5mdW5jdGlvbiBYSFJGYWtlKC8qIG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzICovKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgdGhpcy50byA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5lbWl0KCdmaW5pc2gnLCAyMDAsICd7fScpO1xuICB9LCBYSFJGYWtlLnRpbWVvdXQpO1xufVxuXG5pbmhlcml0cyhYSFJGYWtlLCBFdmVudEVtaXR0ZXIpO1xuXG5YSFJGYWtlLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICBjbGVhclRpbWVvdXQodGhpcy50byk7XG59O1xuXG5YSFJGYWtlLnRpbWVvdXQgPSAyMDAwO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkZha2U7XG5cbn0se1wiZXZlbnRzXCI6MzMsXCJpbmhlcml0c1wiOjg3fV0sNjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgWGhyRHJpdmVyID0gcmVxdWlyZSgnLi4vZHJpdmVyL3hocicpXG4gIDtcblxuZnVuY3Rpb24gWEhSTG9jYWxPYmplY3QobWV0aG9kLCB1cmwsIHBheWxvYWQgLyosIG9wdHMgKi8pIHtcbiAgWGhyRHJpdmVyLmNhbGwodGhpcywgbWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICBub0NyZWRlbnRpYWxzOiB0cnVlXG4gIH0pO1xufVxuXG5pbmhlcml0cyhYSFJMb2NhbE9iamVjdCwgWGhyRHJpdmVyKTtcblxuWEhSTG9jYWxPYmplY3QuZW5hYmxlZCA9IFhockRyaXZlci5lbmFibGVkO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFhIUkxvY2FsT2JqZWN0O1xuXG59LHtcIi4uL2RyaXZlci94aHJcIjo0NyxcImluaGVyaXRzXCI6ODd9XSw2ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9ldmVudCcpXG4gICwgdXJsVXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy91cmwnKVxuICAsIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlclxuICAsIFdlYnNvY2tldERyaXZlciA9IHJlcXVpcmUoJy4vZHJpdmVyL3dlYnNvY2tldCcpXG4gIDtcblxudmFyIGRlYnVnID0gZnVuY3Rpb24oKSB7fTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKSgnc29ja2pzLWNsaWVudDp3ZWJzb2NrZXQnKTtcbn1cblxuZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG5cbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gIGRlYnVnKCdjb25zdHJ1Y3RvcicsIHRyYW5zVXJsKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB1cmwgPSB1cmxVdGlscy5hZGRQYXRoKHRyYW5zVXJsLCAnL3dlYnNvY2tldCcpO1xuICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gIH0gZWxzZSB7XG4gICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgfVxuICB0aGlzLnVybCA9IHVybDtcblxuICB0aGlzLndzID0gbmV3IFdlYnNvY2tldERyaXZlcih0aGlzLnVybCk7XG4gIHRoaXMud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdtZXNzYWdlIGV2ZW50JywgZS5kYXRhKTtcbiAgICBzZWxmLmVtaXQoJ21lc3NhZ2UnLCBlLmRhdGEpO1xuICB9O1xuICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgLy8gY3JlYXRlZCBhZnRlciBvbnVubG9hZCwgaXQgc3RheXMgYWxpdmUgZXZlbiB3aGVuIHVzZXJcbiAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NranMvc29ja2pzLWNsaWVudC9pc3N1ZXMvMjhcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gIHRoaXMudW5sb2FkUmVmID0gdXRpbHMudW5sb2FkQWRkKGZ1bmN0aW9uKCkge1xuICAgIGRlYnVnKCd1bmxvYWQnKTtcbiAgICBzZWxmLndzLmNsb3NlKCk7XG4gIH0pO1xuICB0aGlzLndzLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgZGVidWcoJ2Nsb3NlIGV2ZW50JywgZS5jb2RlLCBlLnJlYXNvbik7XG4gICAgc2VsZi5lbWl0KCdjbG9zZScsIGUuY29kZSwgZS5yZWFzb24pO1xuICAgIHNlbGYuX2NsZWFudXAoKTtcbiAgfTtcbiAgdGhpcy53cy5vbmVycm9yID0gZnVuY3Rpb24oZSkge1xuICAgIGRlYnVnKCdlcnJvciBldmVudCcsIGUpO1xuICAgIHNlbGYuZW1pdCgnY2xvc2UnLCAxMDA2LCAnV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuJyk7XG4gICAgc2VsZi5fY2xlYW51cCgpO1xuICB9O1xufVxuXG5pbmhlcml0cyhXZWJTb2NrZXRUcmFuc3BvcnQsIEV2ZW50RW1pdHRlcik7XG5cbldlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIG1zZyA9ICdbJyArIGRhdGEgKyAnXSc7XG4gIGRlYnVnKCdzZW5kJywgbXNnKTtcbiAgdGhpcy53cy5zZW5kKG1zZyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdjbG9zZScpO1xuICBpZiAodGhpcy53cykge1xuICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgfVxuICB0aGlzLl9jbGVhbnVwKCk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdfY2xlYW51cCcpO1xuICB2YXIgd3MgPSB0aGlzLndzO1xuICBpZiAod3MpIHtcbiAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gd3Mub25lcnJvciA9IG51bGw7XG4gIH1cbiAgdXRpbHMudW5sb2FkRGVsKHRoaXMudW5sb2FkUmVmKTtcbiAgdGhpcy51bmxvYWRSZWYgPSB0aGlzLndzID0gbnVsbDtcbiAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gIGRlYnVnKCdlbmFibGVkJyk7XG4gIHJldHVybiAhIVdlYnNvY2tldERyaXZlcjtcbn07XG5XZWJTb2NrZXRUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd3ZWJzb2NrZXQnO1xuXG4vLyBJbiB0aGVvcnksIHdzIHNob3VsZCByZXF1aXJlIDEgcm91bmQgdHJpcC4gQnV0IGluIGNocm9tZSwgdGhpcyBpc1xuLy8gbm90IHZlcnkgc3RhYmxlIG92ZXIgU1NMLiBNb3N0IGxpa2VseSBhIHdzIGNvbm5lY3Rpb24gcmVxdWlyZXMgYVxuLy8gc2VwYXJhdGUgU1NMIGNvbm5lY3Rpb24sIGluIHdoaWNoIGNhc2UgMiByb3VuZCB0cmlwcyBhcmUgYW5cbi8vIGFic29sdXRlIG1pbnVtdW0uXG5XZWJTb2NrZXRUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiLi4vdXRpbHMvZXZlbnRcIjo3NixcIi4uL3V0aWxzL3VybFwiOjgyLFwiLi9kcml2ZXIvd2Vic29ja2V0XCI6NDksXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImV2ZW50c1wiOjMzLFwiaW5oZXJpdHNcIjo4N31dLDY5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKVxuICAsIEFqYXhCYXNlZFRyYW5zcG9ydCA9IHJlcXVpcmUoJy4vbGliL2FqYXgtYmFzZWQnKVxuICAsIFhkclN0cmVhbWluZ1RyYW5zcG9ydCA9IHJlcXVpcmUoJy4veGRyLXN0cmVhbWluZycpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWERST2JqZWN0ID0gcmVxdWlyZSgnLi9zZW5kZXIveGRyJylcbiAgO1xuXG5mdW5jdGlvbiBYZHJQb2xsaW5nVHJhbnNwb3J0KHRyYW5zVXJsKSB7XG4gIGlmICghWERST2JqZWN0LmVuYWJsZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydCBjcmVhdGVkIHdoZW4gZGlzYWJsZWQnKTtcbiAgfVxuICBBamF4QmFzZWRUcmFuc3BvcnQuY2FsbCh0aGlzLCB0cmFuc1VybCwgJy94aHInLCBYaHJSZWNlaXZlciwgWERST2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGRyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXBvbGxpbmcnO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cbm1vZHVsZS5leHBvcnRzID0gWGRyUG9sbGluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6NTQsXCIuL3JlY2VpdmVyL3hoclwiOjYyLFwiLi9zZW5kZXIveGRyXCI6NjQsXCIuL3hkci1zdHJlYW1pbmdcIjo3MCxcImluaGVyaXRzXCI6ODd9XSw3MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbiAgLCBBamF4QmFzZWRUcmFuc3BvcnQgPSByZXF1aXJlKCcuL2xpYi9hamF4LWJhc2VkJylcbiAgLCBYaHJSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXIveGhyJylcbiAgLCBYRFJPYmplY3QgPSByZXF1aXJlKCcuL3NlbmRlci94ZHInKVxuICA7XG5cbi8vIEFjY29yZGluZyB0bzpcbi8vICAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xNjQxNTA3L2RldGVjdC1icm93c2VyLXN1cHBvcnQtZm9yLWNyb3NzLWRvbWFpbi14bWxodHRwcmVxdWVzdHNcbi8vICAgaHR0cDovL2hhY2tzLm1vemlsbGEub3JnLzIwMDkvMDcvY3Jvc3Mtc2l0ZS14bWxodHRwcmVxdWVzdC13aXRoLWNvcnMvXG5cbmZ1bmN0aW9uIFhkclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhEUk9iamVjdC5lbmFibGVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQgY3JlYXRlZCB3aGVuIGRpc2FibGVkJyk7XG4gIH1cbiAgQWpheEJhc2VkVHJhbnNwb3J0LmNhbGwodGhpcywgdHJhbnNVcmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCBYRFJPYmplY3QpO1xufVxuXG5pbmhlcml0cyhYZHJTdHJlYW1pbmdUcmFuc3BvcnQsIEFqYXhCYXNlZFRyYW5zcG9ydCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5jb29raWVfbmVlZGVkIHx8IGluZm8ubnVsbE9yaWdpbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gWERST2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lU2NoZW1lO1xufTtcblxuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGRyLXN0cmVhbWluZyc7XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5tb2R1bGUuZXhwb3J0cyA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydDtcblxufSx7XCIuL2xpYi9hamF4LWJhc2VkXCI6NTQsXCIuL3JlY2VpdmVyL3hoclwiOjYyLFwiLi9zZW5kZXIveGRyXCI6NjQsXCJpbmhlcml0c1wiOjg3fV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gIDtcblxuZnVuY3Rpb24gWGhyUG9sbGluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCBYSFJDb3JzT2JqZWN0KTtcbn1cblxuaW5oZXJpdHMoWGhyUG9sbGluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oaW5mbykge1xuICBpZiAoaW5mby5udWxsT3JpZ2luKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKFhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgaW5mby5zYW1lT3JpZ2luKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIFhIUkNvcnNPYmplY3QuZW5hYmxlZDtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQudHJhbnNwb3J0TmFtZSA9ICd4aHItcG9sbGluZyc7XG5YaHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJQb2xsaW5nVHJhbnNwb3J0O1xuXG59LHtcIi4vbGliL2FqYXgtYmFzZWRcIjo1NCxcIi4vcmVjZWl2ZXIveGhyXCI6NjIsXCIuL3NlbmRlci94aHItY29yc1wiOjY1LFwiLi9zZW5kZXIveGhyLWxvY2FsXCI6NjcsXCJpbmhlcml0c1wiOjg3fV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpXG4gICwgQWpheEJhc2VkVHJhbnNwb3J0ID0gcmVxdWlyZSgnLi9saWIvYWpheC1iYXNlZCcpXG4gICwgWGhyUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyL3hocicpXG4gICwgWEhSQ29yc09iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1jb3JzJylcbiAgLCBYSFJMb2NhbE9iamVjdCA9IHJlcXVpcmUoJy4vc2VuZGVyL3hoci1sb2NhbCcpXG4gICwgYnJvd3NlciA9IHJlcXVpcmUoJy4uL3V0aWxzL2Jyb3dzZXInKVxuICA7XG5cbmZ1bmN0aW9uIFhoclN0cmVhbWluZ1RyYW5zcG9ydCh0cmFuc1VybCkge1xuICBpZiAoIVhIUkxvY2FsT2JqZWN0LmVuYWJsZWQgJiYgIVhIUkNvcnNPYmplY3QuZW5hYmxlZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNwb3J0IGNyZWF0ZWQgd2hlbiBkaXNhYmxlZCcpO1xuICB9XG4gIEFqYXhCYXNlZFRyYW5zcG9ydC5jYWxsKHRoaXMsIHRyYW5zVXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgWEhSQ29yc09iamVjdCk7XG59XG5cbmluaGVyaXRzKFhoclN0cmVhbWluZ1RyYW5zcG9ydCwgQWpheEJhc2VkVHJhbnNwb3J0KTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbihpbmZvKSB7XG4gIGlmIChpbmZvLm51bGxPcmlnaW4pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gT3BlcmEgZG9lc24ndCBzdXBwb3J0IHhoci1zdHJlYW1pbmcgIzYwXG4gIC8vIEJ1dCBpdCBtaWdodCBiZSBhYmxlIHRvICM5MlxuICBpZiAoYnJvd3Nlci5pc09wZXJhKCkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gWEhSQ29yc09iamVjdC5lbmFibGVkO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnRyYW5zcG9ydE5hbWUgPSAneGhyLXN0cmVhbWluZyc7XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG4vLyBPbmx5IHJlcXVpcmUgYm9keSB3aGVuIHVzZWQgaW4gYSBicm93c2VyXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZEJvZHkgPSAhIWdsb2JhbC5kb2N1bWVudDtcblxubW9kdWxlLmV4cG9ydHMgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQ7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7XCIuLi91dGlscy9icm93c2VyXCI6NzQsXCIuL2xpYi9hamF4LWJhc2VkXCI6NTQsXCIuL3JlY2VpdmVyL3hoclwiOjYyLFwiLi9zZW5kZXIveGhyLWNvcnNcIjo2NSxcIi4vc2VuZGVyL3hoci1sb2NhbFwiOjY3LFwiaW5oZXJpdHNcIjo4N31dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxuaWYgKGdsb2JhbC5jcnlwdG8gJiYgZ2xvYmFsLmNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcbiAgbW9kdWxlLmV4cG9ydHMucmFuZG9tQnl0ZXMgPSBmdW5jdGlvbihsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIGdsb2JhbC5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cy5yYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBieXRlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGJ5dGVzW2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDc0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT3BlcmE6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBnbG9iYWwubmF2aWdhdG9yICYmXG4gICAgICAvb3BlcmEvaS50ZXN0KGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxuXG4sIGlzS29ucXVlcm9yOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gZ2xvYmFsLm5hdmlnYXRvciAmJlxuICAgICAgL2tvbnF1ZXJvci9pLnRlc3QoZ2xvYmFsLm5hdmlnYXRvci51c2VyQWdlbnQpO1xuICB9XG5cbiAgLy8gIzE4NyB3cmFwIGRvY3VtZW50LmRvbWFpbiBpbiB0cnkvY2F0Y2ggYmVjYXVzZSBvZiBXUDggZnJvbSBmaWxlOi8vL1xuLCBoYXNEb21haW46IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBub24tYnJvd3NlciBjbGllbnQgYWx3YXlzIGhhcyBhIGRvbWFpblxuICAgIGlmICghZ2xvYmFsLmRvY3VtZW50KSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgcmV0dXJuICEhZ2xvYmFsLmRvY3VtZW50LmRvbWFpbjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIEpTT04zID0gcmVxdWlyZSgnanNvbjMnKTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbnZhciBleHRyYUVzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nXG4gICwgZXh0cmFMb29rdXA7XG5cbi8vIFRoaXMgbWF5IGJlIHF1aXRlIHNsb3csIHNvIGxldCdzIGRlbGF5IHVudGlsIHVzZXIgYWN0dWFsbHkgdXNlcyBiYWRcbi8vIGNoYXJhY3RlcnMuXG52YXIgdW5yb2xsTG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gIHZhciBpO1xuICB2YXIgdW5yb2xsZWQgPSB7fTtcbiAgdmFyIGMgPSBbXTtcbiAgZm9yIChpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICBjLnB1c2goIFN0cmluZy5mcm9tQ2hhckNvZGUoaSkgKTtcbiAgfVxuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgYy5qb2luKCcnKS5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICByZXR1cm4gJyc7XG4gIH0pO1xuICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgcmV0dXJuIHVucm9sbGVkO1xufTtcblxuLy8gUXVvdGUgc3RyaW5nLCBhbHNvIHRha2luZyBjYXJlIG9mIHVuaWNvZGUgY2hhcmFjdGVycyB0aGF0IGJyb3dzZXJzXG4vLyBvZnRlbiBicmVhay4gRXNwZWNpYWxseSwgdGFrZSBjYXJlIG9mIHVuaWNvZGUgc3Vycm9nYXRlczpcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTWFwcGluZ19vZl9Vbmljb2RlX2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHF1b3RlOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICB2YXIgcXVvdGVkID0gSlNPTjMuc3RyaW5naWZ5KHN0cmluZyk7XG5cbiAgICAvLyBJbiBtb3N0IGNhc2VzIHRoaXMgc2hvdWxkIGJlIHZlcnkgZmFzdCBhbmQgZ29vZCBlbm91Z2guXG4gICAgZXh0cmFFc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoIWV4dHJhRXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgcmV0dXJuIHF1b3RlZDtcbiAgICB9XG5cbiAgICBpZiAoIWV4dHJhTG9va3VwKSB7XG4gICAgICBleHRyYUxvb2t1cCA9IHVucm9sbExvb2t1cChleHRyYUVzY2FwYWJsZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhRXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICByZXR1cm4gZXh0cmFMb29rdXBbYV07XG4gICAgfSk7XG4gIH1cbn07XG5cbn0se1wianNvbjNcIjo4OH1dLDc2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbihmdW5jdGlvbiAoZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIHJhbmRvbSA9IHJlcXVpcmUoJy4vcmFuZG9tJyk7XG5cbnZhciBvblVubG9hZCA9IHt9XG4gICwgYWZ0ZXJVbmxvYWQgPSBmYWxzZVxuICAgIC8vIGRldGVjdCBnb29nbGUgY2hyb21lIHBhY2thZ2VkIGFwcHMgYmVjYXVzZSB0aGV5IGRvbid0IGFsbG93IHRoZSAndW5sb2FkJyBldmVudFxuICAsIGlzQ2hyb21lUGFja2FnZWRBcHAgPSBnbG9iYWwuY2hyb21lICYmIGdsb2JhbC5jaHJvbWUuYXBwICYmIGdsb2JhbC5jaHJvbWUuYXBwLnJ1bnRpbWVcbiAgO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgYXR0YWNoRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5kb2N1bWVudCAmJiBnbG9iYWwuYXR0YWNoRXZlbnQpIHtcbiAgICAgIC8vIElFIHF1aXJrcy5cbiAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICBnbG9iYWwuZG9jdW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfVxuXG4sIGRldGFjaEV2ZW50OiBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChnbG9iYWwuZG9jdW1lbnQgJiYgZ2xvYmFsLmRldGFjaEV2ZW50KSB7XG4gICAgICBnbG9iYWwuZG9jdW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICBnbG9iYWwuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxuICB9XG5cbiwgdW5sb2FkQWRkOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIGlmIChpc0Nocm9tZVBhY2thZ2VkQXBwKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcmVmID0gcmFuZG9tLnN0cmluZyg4KTtcbiAgICBvblVubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyVW5sb2FkKSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMudHJpZ2dlclVubG9hZENhbGxiYWNrcywgMCk7XG4gICAgfVxuICAgIHJldHVybiByZWY7XG4gIH1cblxuLCB1bmxvYWREZWw6IGZ1bmN0aW9uKHJlZikge1xuICAgIGlmIChyZWYgaW4gb25VbmxvYWQpIHtcbiAgICAgIGRlbGV0ZSBvblVubG9hZFtyZWZdO1xuICAgIH1cbiAgfVxuXG4sIHRyaWdnZXJVbmxvYWRDYWxsYmFja3M6IGZ1bmN0aW9uKCkge1xuICAgIGZvciAodmFyIHJlZiBpbiBvblVubG9hZCkge1xuICAgICAgb25VbmxvYWRbcmVmXSgpO1xuICAgICAgZGVsZXRlIG9uVW5sb2FkW3JlZl07XG4gICAgfVxuICB9XG59O1xuXG52YXIgdW5sb2FkVHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gIGlmIChhZnRlclVubG9hZCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhZnRlclVubG9hZCA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzLnRyaWdnZXJVbmxvYWRDYWxsYmFja3MoKTtcbn07XG5cbi8vICd1bmxvYWQnIGFsb25lIGlzIG5vdCByZWxpYWJsZSBpbiBvcGVyYSB3aXRoaW4gYW4gaWZyYW1lLCBidXQgd2Vcbi8vIGNhbid0IHVzZSBgYmVmb3JldW5sb2FkYCBhcyBJRSBmaXJlcyBpdCBvbiBqYXZhc2NyaXB0OiBsaW5rcy5cbmlmICghaXNDaHJvbWVQYWNrYWdlZEFwcCkge1xuICBtb2R1bGUuZXhwb3J0cy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkVHJpZ2dlcmVkKTtcbn1cblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vcmFuZG9tXCI6ODB9XSw3NzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcbid1c2Ugc3RyaWN0JztcblxudmFyIGV2ZW50VXRpbHMgPSByZXF1aXJlKCcuL2V2ZW50JylcbiAgLCBKU09OMyA9IHJlcXVpcmUoJ2pzb24zJylcbiAgLCBicm93c2VyID0gcmVxdWlyZSgnLi9icm93c2VyJylcbiAgO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOmlmcmFtZScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgV1ByZWZpeDogJ19qcCdcbiwgY3VycmVudFdpbmRvd0lkOiBudWxsXG5cbiwgcG9sbHV0ZUdsb2JhbE5hbWVzcGFjZTogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEobW9kdWxlLmV4cG9ydHMuV1ByZWZpeCBpbiBnbG9iYWwpKSB7XG4gICAgICBnbG9iYWxbbW9kdWxlLmV4cG9ydHMuV1ByZWZpeF0gPSB7fTtcbiAgICB9XG4gIH1cblxuLCBwb3N0TWVzc2FnZTogZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIGlmIChnbG9iYWwucGFyZW50ICE9PSBnbG9iYWwpIHtcbiAgICAgIGdsb2JhbC5wYXJlbnQucG9zdE1lc3NhZ2UoSlNPTjMuc3RyaW5naWZ5KHtcbiAgICAgICAgd2luZG93SWQ6IG1vZHVsZS5leHBvcnRzLmN1cnJlbnRXaW5kb3dJZFxuICAgICAgLCB0eXBlOiB0eXBlXG4gICAgICAsIGRhdGE6IGRhdGEgfHwgJydcbiAgICAgIH0pLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWJ1ZygnQ2Fubm90IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LicsIHR5cGUsIGRhdGEpO1xuICAgIH1cbiAgfVxuXG4sIGNyZWF0ZUlmcmFtZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgZGVidWcoJ3VuYXR0YWNoJyk7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgdHJ5IHtcbiAgICAgICAgaWZyYW1lLm9ubG9hZCA9IG51bGw7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgIGRlYnVnKCdjbGVhbnVwJyk7XG4gICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAvLyB3aXRoaW4gaWZyYW1lLiBXaXRob3V0IHRoZSB0aW1lb3V0IGl0IGdvZXMgc3RyYWlnaHQgdG9cbiAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGV2ZW50VXRpbHMudW5sb2FkRGVsKHVubG9hZFJlZik7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCBlcnIpO1xuICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIGVycm9yQ2FsbGJhY2soZXJyKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgIGRlYnVnKCdwb3N0JywgbXNnLCBvcmlnaW4pO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIDApO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCdvbmVycm9yJyk7XG4gICAgfTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICBkZWJ1Zygnb25sb2FkJyk7XG4gICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgIC8vIGV4ZWN1dGVkLiBHaXZlIGl0IGZldyBzZWNvbmRzIHRvIGFjdHVhbGx5IGxvYWQgc3R1ZmYuXG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgb25lcnJvcignb25sb2FkIHRpbWVvdXQnKTtcbiAgICAgIH0sIDIwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsLmRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgIG9uZXJyb3IoJ3RpbWVvdXQnKTtcbiAgICB9LCAxNTAwMCk7XG4gICAgdW5sb2FkUmVmID0gZXZlbnRVdGlscy51bmxvYWRBZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvc3Q6IHBvc3RcbiAgICAsIGNsZWFudXA6IGNsZWFudXBcbiAgICAsIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xuICB9XG5cbi8qIGpzaGludCB1bmRlZjogZmFsc2UsIG5ld2NhcDogZmFsc2UgKi9cbi8qIGVzbGludCBuby11bmRlZjogMCwgbmV3LWNhcDogMCAqL1xuLCBjcmVhdGVIdG1sZmlsZTogZnVuY3Rpb24oaWZyYW1lVXJsLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgdmFyIGF4byA9IFsnQWN0aXZlJ10uY29uY2F0KCdPYmplY3QnKS5qb2luKCdYJyk7XG4gICAgdmFyIGRvYyA9IG5ldyBnbG9iYWxbYXhvXSgnaHRtbGZpbGUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkUmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICBpZnJhbWUub25lcnJvciA9IG51bGw7XG4gICAgfTtcbiAgICB2YXIgY2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB1bmF0dGFjaCgpO1xuICAgICAgICBldmVudFV0aWxzLnVubG9hZERlbCh1bmxvYWRSZWYpO1xuICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICBpZnJhbWUgPSBkb2MgPSBudWxsO1xuICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbihyKSAge1xuICAgICAgZGVidWcoJ29uZXJyb3InLCByKTtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBlcnJvckNhbGxiYWNrKHIpO1xuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgMCk7XG4gICAgICB9IGNhdGNoICh4KSB7fVxuICAgIH07XG5cbiAgICBkb2Mub3BlbigpO1xuICAgIGRvYy53cml0ZSgnPGh0bWw+PHMnICsgJ2NyaXB0PicgK1xuICAgICAgICAgICAgICAnZG9jdW1lbnQuZG9tYWluPVwiJyArIGdsb2JhbC5kb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W21vZHVsZS5leHBvcnRzLldQcmVmaXhdID0gZ2xvYmFsW21vZHVsZS5leHBvcnRzLldQcmVmaXhdO1xuICAgIHZhciBjID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGMpO1xuICAgIGlmcmFtZSA9IGRvYy5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICBjLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZVVybDtcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCkge1xuICAgICAgb25lcnJvcignb25lcnJvcicpO1xuICAgIH07XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICBvbmVycm9yKCd0aW1lb3V0Jyk7XG4gICAgfSwgMTUwMDApO1xuICAgIHVubG9hZFJlZiA9IGV2ZW50VXRpbHMudW5sb2FkQWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICBwb3N0OiBwb3N0XG4gICAgLCBjbGVhbnVwOiBjbGVhbnVwXG4gICAgLCBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9IGZhbHNlO1xuaWYgKGdsb2JhbC5kb2N1bWVudCkge1xuICAvLyBwb3N0TWVzc2FnZSBtaXNiZWhhdmVzIGluIGtvbnF1ZXJvciA0LjYuNSAtIHRoZSBtZXNzYWdlcyBhcmUgZGVsaXZlcmVkIHdpdGhcbiAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgbW9kdWxlLmV4cG9ydHMuaWZyYW1lRW5hYmxlZCA9ICh0eXBlb2YgZ2xvYmFsLnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgdHlwZW9mIGdsb2JhbC5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICghYnJvd3Nlci5pc0tvbnF1ZXJvcigpKTtcbn1cblxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se1wiLi9icm93c2VyXCI6NzQsXCIuL2V2ZW50XCI6NzYsXCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcImpzb24zXCI6ODh9XSw3ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBsb2dPYmplY3QgPSB7fTtcblsnbG9nJywgJ2RlYnVnJywgJ3dhcm4nXS5mb3JFYWNoKGZ1bmN0aW9uIChsZXZlbCkge1xuICB2YXIgbGV2ZWxFeGlzdHMgPSBnbG9iYWwuY29uc29sZSAmJiBnbG9iYWwuY29uc29sZVtsZXZlbF0gJiYgZ2xvYmFsLmNvbnNvbGVbbGV2ZWxdLmFwcGx5O1xuICBsb2dPYmplY3RbbGV2ZWxdID0gbGV2ZWxFeGlzdHMgPyBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdsb2JhbC5jb25zb2xlW2xldmVsXS5hcHBseShnbG9iYWwuY29uc29sZSwgYXJndW1lbnRzKTtcbiAgfSA6IChsZXZlbCA9PT0gJ2xvZycgPyBmdW5jdGlvbiAoKSB7fSA6IGxvZ09iamVjdC5sb2cpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gbG9nT2JqZWN0O1xuXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB7fSlcbn0se31dLDc5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiBvYmo7XG4gICAgcmV0dXJuIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZSA9PT0gJ29iamVjdCcgJiYgISFvYmo7XG4gIH1cblxuLCBleHRlbmQ6IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghdGhpcy5pc09iamVjdChvYmopKSB7XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICB2YXIgc291cmNlLCBwcm9wO1xuICAgIGZvciAodmFyIGkgPSAxLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAocHJvcCBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIHByb3ApKSB7XG4gICAgICAgICAgb2JqW3Byb3BdID0gc291cmNlW3Byb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbn07XG5cbn0se31dLDgwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIGNyeXB0bzp0cnVlICovXG52YXIgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbi8vIFRoaXMgc3RyaW5nIGhhcyBsZW5ndGggMzIsIGEgcG93ZXIgb2YgMiwgc28gdGhlIG1vZHVsdXMgZG9lc24ndCBpbnRyb2R1Y2UgYVxuLy8gYmlhcy5cbnZhciBfcmFuZG9tU3RyaW5nQ2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDUnO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHN0cmluZzogZnVuY3Rpb24obGVuZ3RoKSB7XG4gICAgdmFyIG1heCA9IF9yYW5kb21TdHJpbmdDaGFycy5sZW5ndGg7XG4gICAgdmFyIGJ5dGVzID0gY3J5cHRvLnJhbmRvbUJ5dGVzKGxlbmd0aCk7XG4gICAgdmFyIHJldCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHJldC5wdXNoKF9yYW5kb21TdHJpbmdDaGFycy5zdWJzdHIoYnl0ZXNbaV0gJSBtYXgsIDEpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldC5qb2luKCcnKTtcbiAgfVxuXG4sIG51bWJlcjogZnVuY3Rpb24obWF4KSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIG1heCk7XG4gIH1cblxuLCBudW1iZXJTdHJpbmc6IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnICsgKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBuZXcgQXJyYXkodCArIDEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB0aGlzLm51bWJlcihtYXgpKS5zbGljZSgtdCk7XG4gIH1cbn07XG5cbn0se1wiY3J5cHRvXCI6NzN9XSw4MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVidWcgPSBmdW5jdGlvbigpIHt9O1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdzb2NranMtY2xpZW50OnV0aWxzOnRyYW5zcG9ydCcpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGF2YWlsYWJsZVRyYW5zcG9ydHMpIHtcbiAgcmV0dXJuIHtcbiAgICBmaWx0ZXJUb0VuYWJsZWQ6IGZ1bmN0aW9uKHRyYW5zcG9ydHNXaGl0ZWxpc3QsIGluZm8pIHtcbiAgICAgIHZhciB0cmFuc3BvcnRzID0ge1xuICAgICAgICBtYWluOiBbXVxuICAgICAgLCBmYWNhZGU6IFtdXG4gICAgICB9O1xuICAgICAgaWYgKCF0cmFuc3BvcnRzV2hpdGVsaXN0KSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbXTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QgPSBbdHJhbnNwb3J0c1doaXRlbGlzdF07XG4gICAgICB9XG5cbiAgICAgIGF2YWlsYWJsZVRyYW5zcG9ydHMuZm9yRWFjaChmdW5jdGlvbih0cmFucykge1xuICAgICAgICBpZiAoIXRyYW5zKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYW5zLnRyYW5zcG9ydE5hbWUgPT09ICd3ZWJzb2NrZXQnICYmIGluZm8ud2Vic29ja2V0ID09PSBmYWxzZSkge1xuICAgICAgICAgIGRlYnVnKCdkaXNhYmxlZCBmcm9tIHNlcnZlcicsICd3ZWJzb2NrZXQnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhbnNwb3J0c1doaXRlbGlzdC5sZW5ndGggJiZcbiAgICAgICAgICAgIHRyYW5zcG9ydHNXaGl0ZWxpc3QuaW5kZXhPZih0cmFucy50cmFuc3BvcnROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICBkZWJ1Zygnbm90IGluIHdoaXRlbGlzdCcsIHRyYW5zLnRyYW5zcG9ydE5hbWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFucy5lbmFibGVkKGluZm8pKSB7XG4gICAgICAgICAgZGVidWcoJ2VuYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICB0cmFuc3BvcnRzLm1haW4ucHVzaCh0cmFucyk7XG4gICAgICAgICAgaWYgKHRyYW5zLmZhY2FkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0cy5mYWNhZGUucHVzaCh0cmFucy5mYWNhZGVUcmFuc3BvcnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1ZygnZGlzYWJsZWQnLCB0cmFucy50cmFuc3BvcnROYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgICB9XG4gIH07XG59O1xuXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcbn0se1wiX3Byb2Nlc3NcIjozMCxcImRlYnVnXCI6ODR9XSw4MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVVJMID0gcmVxdWlyZSgndXJsLXBhcnNlJyk7XG5cbnZhciBkZWJ1ZyA9IGZ1bmN0aW9uKCkge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ3NvY2tqcy1jbGllbnQ6dXRpbHM6dXJsJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRPcmlnaW46IGZ1bmN0aW9uKHVybCkge1xuICAgIGlmICghdXJsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgcCA9IG5ldyBVUkwodXJsKTtcbiAgICBpZiAocC5wcm90b2NvbCA9PT0gJ2ZpbGU6Jykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHBvcnQgPSBwLnBvcnQ7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICBwb3J0ID0gKHAucHJvdG9jb2wgPT09ICdodHRwczonKSA/ICc0NDMnIDogJzgwJztcbiAgICB9XG5cbiAgICByZXR1cm4gcC5wcm90b2NvbCArICcvLycgKyBwLmhvc3RuYW1lICsgJzonICsgcG9ydDtcbiAgfVxuXG4sIGlzT3JpZ2luRXF1YWw6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICB2YXIgcmVzID0gdGhpcy5nZXRPcmlnaW4oYSkgPT09IHRoaXMuZ2V0T3JpZ2luKGIpO1xuICAgIGRlYnVnKCdzYW1lJywgYSwgYiwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiwgaXNTY2hlbWVFcXVhbDogZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoYS5zcGxpdCgnOicpWzBdID09PSBiLnNwbGl0KCc6JylbMF0pO1xuICB9XG5cbiwgYWRkUGF0aDogZnVuY3Rpb24gKHVybCwgcGF0aCkge1xuICAgIHZhciBxcyA9IHVybC5zcGxpdCgnPycpO1xuICAgIHJldHVybiBxc1swXSArIHBhdGggKyAocXNbMV0gPyAnPycgKyBxc1sxXSA6ICcnKTtcbiAgfVxuXG4sIGFkZFF1ZXJ5OiBmdW5jdGlvbiAodXJsLCBxKSB7XG4gICAgcmV0dXJuIHVybCArICh1cmwuaW5kZXhPZignPycpID09PSAtMSA/ICgnPycgKyBxKSA6ICgnJicgKyBxKSk7XG4gIH1cbn07XG5cbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxufSx7XCJfcHJvY2Vzc1wiOjMwLFwiZGVidWdcIjo4NCxcInVybC1wYXJzZVwiOjg5fV0sODM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHMgPSAnMS4wLjMnO1xufSx7fV0sODQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqXG4gKiBFeHBvc2UgYGRlYnVnKClgIGFzIHRoZSBtb2R1bGUuXG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kZWJ1ZycpO1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9ICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWVcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxuICAgICAgICAgICAgICAgICAgPyBjaHJvbWUuc3RvcmFnZS5sb2NhbFxuICAgICAgICAgICAgICAgICAgOiBsb2NhbHN0b3JhZ2UoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG4gICdsaWdodHNlYWdyZWVuJyxcbiAgJ2ZvcmVzdGdyZWVuJyxcbiAgJ2dvbGRlbnJvZCcsXG4gICdkb2RnZXJibHVlJyxcbiAgJ2RhcmtvcmNoaWQnLFxuICAnY3JpbXNvbidcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuICByZXR1cm4gKCdXZWJraXRBcHBlYXJhbmNlJyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUpIHx8XG4gICAgLy8gaXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuICAgICh3aW5kb3cuY29uc29sZSAmJiAoY29uc29sZS5maXJlYnVnIHx8IChjb25zb2xlLmV4Y2VwdGlvbiAmJiBjb25zb2xlLnRhYmxlKSkpIHx8XG4gICAgLy8gaXMgZmlyZWZveCA+PSB2MzE/XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gICAgKG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKTtcbn1cblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbn07XG5cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKCkge1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIHVzZUNvbG9ycyA9IHRoaXMudXNlQ29sb3JzO1xuXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxuICAgICsgdGhpcy5uYW1lc3BhY2VcbiAgICArICh1c2VDb2xvcnMgPyAnICVjJyA6ICcgJylcbiAgICArIGFyZ3NbMF1cbiAgICArICh1c2VDb2xvcnMgPyAnJWMgJyA6ICcgJylcbiAgICArICcrJyArIGV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuICBpZiAoIXVzZUNvbG9ycykgcmV0dXJuIGFyZ3M7XG5cbiAgdmFyIGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuICBhcmdzID0gW2FyZ3NbMF0sIGMsICdjb2xvcjogaW5oZXJpdCddLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG5cbiAgLy8gdGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcbiAgLy8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuICAvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RDID0gMDtcbiAgYXJnc1swXS5yZXBsYWNlKC8lW2EteiVdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XG4gICAgaW5kZXgrKztcbiAgICBpZiAoJyVjJyA9PT0gbWF0Y2gpIHtcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuICAgICAgLy8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcbiAgICAgIGxhc3RDID0gaW5kZXg7XG4gICAgfVxuICB9KTtcblxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG4gIHJldHVybiBhcmdzO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5sb2dgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGxvZygpIHtcbiAgLy8gdGhpcyBoYWNrZXJ5IGlzIHJlcXVpcmVkIGZvciBJRTgvOSwgd2hlcmVcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcbiAgcmV0dXJuICdvYmplY3QnID09PSB0eXBlb2YgY29uc29sZVxuICAgICYmIGNvbnNvbGUubG9nXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcbiAgICAgIGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xuICAgIH1cbiAgfSBjYXRjaChlKSB7fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuICB0cnkge1xuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XG4gIH0gY2F0Y2goZSkge31cbiAgcmV0dXJuIHI7XG59XG5cbi8qKlxuICogRW5hYmxlIG5hbWVzcGFjZXMgbGlzdGVkIGluIGBsb2NhbFN0b3JhZ2UuZGVidWdgIGluaXRpYWxseS5cbiAqL1xuXG5leHBvcnRzLmVuYWJsZShsb2FkKCkpO1xuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpe1xuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cubG9jYWxTdG9yYWdlO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG59LHtcIi4vZGVidWdcIjo4NX1dLDg1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICpcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cbiAqL1xuXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBkZWJ1ZztcbmV4cG9ydHMuY29lcmNlID0gY29lcmNlO1xuZXhwb3J0cy5kaXNhYmxlID0gZGlzYWJsZTtcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xuZXhwb3J0cy5lbmFibGVkID0gZW5hYmxlZDtcbmV4cG9ydHMuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXG4vKipcbiAqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuICovXG5cbmV4cG9ydHMubmFtZXMgPSBbXTtcbmV4cG9ydHMuc2tpcHMgPSBbXTtcblxuLyoqXG4gKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gKlxuICogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXJjYXNlZCBsZXR0ZXIsIGkuZS4gXCJuXCIuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXR0ZXJzID0ge307XG5cbi8qKlxuICogUHJldmlvdXNseSBhc3NpZ25lZCBjb2xvci5cbiAqL1xuXG52YXIgcHJldkNvbG9yID0gMDtcblxuLyoqXG4gKiBQcmV2aW91cyBsb2cgdGltZXN0YW1wLlxuICovXG5cbnZhciBwcmV2VGltZTtcblxuLyoqXG4gKiBTZWxlY3QgYSBjb2xvci5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZWxlY3RDb2xvcigpIHtcbiAgcmV0dXJuIGV4cG9ydHMuY29sb3JzW3ByZXZDb2xvcisrICUgZXhwb3J0cy5jb2xvcnMubGVuZ3RoXTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZGVidWcobmFtZXNwYWNlKSB7XG5cbiAgLy8gZGVmaW5lIHRoZSBgZGlzYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZGlzYWJsZWQoKSB7XG4gIH1cbiAgZGlzYWJsZWQuZW5hYmxlZCA9IGZhbHNlO1xuXG4gIC8vIGRlZmluZSB0aGUgYGVuYWJsZWRgIHZlcnNpb25cbiAgZnVuY3Rpb24gZW5hYmxlZCgpIHtcblxuICAgIHZhciBzZWxmID0gZW5hYmxlZDtcblxuICAgIC8vIHNldCBgZGlmZmAgdGltZXN0YW1wXG4gICAgdmFyIGN1cnIgPSArbmV3IERhdGUoKTtcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuICAgIHNlbGYuZGlmZiA9IG1zO1xuICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgIHNlbGYuY3VyciA9IGN1cnI7XG4gICAgcHJldlRpbWUgPSBjdXJyO1xuXG4gICAgLy8gYWRkIHRoZSBgY29sb3JgIGlmIG5vdCBzZXRcbiAgICBpZiAobnVsbCA9PSBzZWxmLnVzZUNvbG9ycykgc2VsZi51c2VDb2xvcnMgPSBleHBvcnRzLnVzZUNvbG9ycygpO1xuICAgIGlmIChudWxsID09IHNlbGYuY29sb3IgJiYgc2VsZi51c2VDb2xvcnMpIHNlbGYuY29sb3IgPSBzZWxlY3RDb2xvcigpO1xuXG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuXG4gICAgYXJnc1swXSA9IGV4cG9ydHMuY29lcmNlKGFyZ3NbMF0pO1xuXG4gICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgYXJnc1swXSkge1xuICAgICAgLy8gYW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJW9cbiAgICAgIGFyZ3MgPSBbJyVvJ10uY29uY2F0KGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIGFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xuICAgICAgLy8gaWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgaWYgKG1hdGNoID09PSAnJSUnKSByZXR1cm4gbWF0Y2g7XG4gICAgICBpbmRleCsrO1xuICAgICAgdmFyIGZvcm1hdHRlciA9IGV4cG9ydHMuZm9ybWF0dGVyc1tmb3JtYXRdO1xuICAgICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBmb3JtYXR0ZXIpIHtcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICBtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuICAgICAgICBhcmdzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGluZGV4LS07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfSk7XG5cbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuZm9ybWF0QXJncykge1xuICAgICAgYXJncyA9IGV4cG9ydHMuZm9ybWF0QXJncy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICB9XG4gICAgdmFyIGxvZ0ZuID0gZW5hYmxlZC5sb2cgfHwgZXhwb3J0cy5sb2cgfHwgY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgfVxuICBlbmFibGVkLmVuYWJsZWQgPSB0cnVlO1xuXG4gIHZhciBmbiA9IGV4cG9ydHMuZW5hYmxlZChuYW1lc3BhY2UpID8gZW5hYmxlZCA6IGRpc2FibGVkO1xuXG4gIGZuLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblxuICByZXR1cm4gZm47XG59XG5cbi8qKlxuICogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XG5cbiAgdmFyIHNwbGl0ID0gKG5hbWVzcGFjZXMgfHwgJycpLnNwbGl0KC9bXFxzLF0rLyk7XG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGlmICghc3BsaXRbaV0pIGNvbnRpbnVlOyAvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcbiAgICAgIGV4cG9ydHMuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRpc2FibGUoKSB7XG4gIGV4cG9ydHMuZW5hYmxlKCcnKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuICB2YXIgaSwgbGVuO1xuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBDb2VyY2UgYHZhbGAuXG4gKlxuICogQHBhcmFtIHtNaXhlZH0gdmFsXG4gKiBAcmV0dXJuIHtNaXhlZH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcbiAgaWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuICByZXR1cm4gdmFsO1xufVxuXG59LHtcIm1zXCI6ODZ9XSw4NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKXtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgdmFsKSByZXR1cm4gcGFyc2UodmFsKTtcbiAgcmV0dXJuIG9wdGlvbnMubG9uZ1xuICAgID8gbG9uZyh2YWwpXG4gICAgOiBzaG9ydCh2YWwpO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9ICcnICsgc3RyO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMDAwKSByZXR1cm47XG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuO1xuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzaG9ydChtcykge1xuICBpZiAobXMgPj0gZCkgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgaWYgKG1zID49IGgpIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIGlmIChtcyA+PSBtKSByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICBpZiAobXMgPj0gcykgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvbmcobXMpIHtcbiAgcmV0dXJuIHBsdXJhbChtcywgZCwgJ2RheScpXG4gICAgfHwgcGx1cmFsKG1zLCBoLCAnaG91cicpXG4gICAgfHwgcGx1cmFsKG1zLCBtLCAnbWludXRlJylcbiAgICB8fCBwbHVyYWwobXMsIHMsICdzZWNvbmQnKVxuICAgIHx8IG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XG4gIGlmIChtcyA8IG4pIHJldHVybjtcbiAgaWYgKG1zIDwgbiAqIDEuNSkgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XG4gIHJldHVybiBNYXRoLmNlaWwobXMgLyBuKSArICcgJyArIG5hbWUgKyAncyc7XG59XG5cbn0se31dLDg3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbmlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuXG59LHt9XSw4ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKGdsb2JhbCl7XG4vKiEgSlNPTiB2My4zLjIgfCBodHRwOi8vYmVzdGllanMuZ2l0aHViLmlvL2pzb24zIHwgQ29weXJpZ2h0IDIwMTItMjAxNCwgS2l0IENhbWJyaWRnZSB8IGh0dHA6Ly9raXQubWl0LWxpY2Vuc2Uub3JnICovXG47KGZ1bmN0aW9uICgpIHtcbiAgLy8gRGV0ZWN0IHRoZSBgZGVmaW5lYCBmdW5jdGlvbiBleHBvc2VkIGJ5IGFzeW5jaHJvbm91cyBtb2R1bGUgbG9hZGVycy4gVGhlXG4gIC8vIHN0cmljdCBgZGVmaW5lYCBjaGVjayBpcyBuZWNlc3NhcnkgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBgci5qc2AuXG4gIHZhciBpc0xvYWRlciA9IHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kO1xuXG4gIC8vIEEgc2V0IG9mIHR5cGVzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggb2JqZWN0cyBmcm9tIHByaW1pdGl2ZXMuXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICBcImZ1bmN0aW9uXCI6IHRydWUsXG4gICAgXCJvYmplY3RcIjogdHJ1ZVxuICB9O1xuXG4gIC8vIERldGVjdCB0aGUgYGV4cG9ydHNgIG9iamVjdCBleHBvc2VkIGJ5IENvbW1vbkpTIGltcGxlbWVudGF0aW9ucy5cbiAgdmFyIGZyZWVFeHBvcnRzID0gb2JqZWN0VHlwZXNbdHlwZW9mIGV4cG9ydHNdICYmIGV4cG9ydHMgJiYgIWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblxuICAvLyBVc2UgdGhlIGBnbG9iYWxgIG9iamVjdCBleHBvc2VkIGJ5IE5vZGUgKGluY2x1ZGluZyBCcm93c2VyaWZ5IHZpYVxuICAvLyBgaW5zZXJ0LW1vZHVsZS1nbG9iYWxzYCksIE5hcndoYWwsIGFuZCBSaW5nbyBhcyB0aGUgZGVmYXVsdCBjb250ZXh0LFxuICAvLyBhbmQgdGhlIGB3aW5kb3dgIG9iamVjdCBpbiBicm93c2Vycy4gUmhpbm8gZXhwb3J0cyBhIGBnbG9iYWxgIGZ1bmN0aW9uXG4gIC8vIGluc3RlYWQuXG4gIHZhciByb290ID0gb2JqZWN0VHlwZXNbdHlwZW9mIHdpbmRvd10gJiYgd2luZG93IHx8IHRoaXMsXG4gICAgICBmcmVlR2xvYmFsID0gZnJlZUV4cG9ydHMgJiYgb2JqZWN0VHlwZXNbdHlwZW9mIG1vZHVsZV0gJiYgbW9kdWxlICYmICFtb2R1bGUubm9kZVR5cGUgJiYgdHlwZW9mIGdsb2JhbCA9PSBcIm9iamVjdFwiICYmIGdsb2JhbDtcblxuICBpZiAoZnJlZUdsb2JhbCAmJiAoZnJlZUdsb2JhbFtcImdsb2JhbFwiXSA9PT0gZnJlZUdsb2JhbCB8fCBmcmVlR2xvYmFsW1wid2luZG93XCJdID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWxbXCJzZWxmXCJdID09PSBmcmVlR2xvYmFsKSkge1xuICAgIHJvb3QgPSBmcmVlR2xvYmFsO1xuICB9XG5cbiAgLy8gUHVibGljOiBJbml0aWFsaXplcyBKU09OIDMgdXNpbmcgdGhlIGdpdmVuIGBjb250ZXh0YCBvYmplY3QsIGF0dGFjaGluZyB0aGVcbiAgLy8gYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgZnVuY3Rpb25zIHRvIHRoZSBzcGVjaWZpZWQgYGV4cG9ydHNgIG9iamVjdC5cbiAgZnVuY3Rpb24gcnVuSW5Db250ZXh0KGNvbnRleHQsIGV4cG9ydHMpIHtcbiAgICBjb250ZXh0IHx8IChjb250ZXh0ID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcbiAgICBleHBvcnRzIHx8IChleHBvcnRzID0gcm9vdFtcIk9iamVjdFwiXSgpKTtcblxuICAgIC8vIE5hdGl2ZSBjb25zdHJ1Y3RvciBhbGlhc2VzLlxuICAgIHZhciBOdW1iZXIgPSBjb250ZXh0W1wiTnVtYmVyXCJdIHx8IHJvb3RbXCJOdW1iZXJcIl0sXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHRbXCJTdHJpbmdcIl0gfHwgcm9vdFtcIlN0cmluZ1wiXSxcbiAgICAgICAgT2JqZWN0ID0gY29udGV4dFtcIk9iamVjdFwiXSB8fCByb290W1wiT2JqZWN0XCJdLFxuICAgICAgICBEYXRlID0gY29udGV4dFtcIkRhdGVcIl0gfHwgcm9vdFtcIkRhdGVcIl0sXG4gICAgICAgIFN5bnRheEVycm9yID0gY29udGV4dFtcIlN5bnRheEVycm9yXCJdIHx8IHJvb3RbXCJTeW50YXhFcnJvclwiXSxcbiAgICAgICAgVHlwZUVycm9yID0gY29udGV4dFtcIlR5cGVFcnJvclwiXSB8fCByb290W1wiVHlwZUVycm9yXCJdLFxuICAgICAgICBNYXRoID0gY29udGV4dFtcIk1hdGhcIl0gfHwgcm9vdFtcIk1hdGhcIl0sXG4gICAgICAgIG5hdGl2ZUpTT04gPSBjb250ZXh0W1wiSlNPTlwiXSB8fCByb290W1wiSlNPTlwiXTtcblxuICAgIC8vIERlbGVnYXRlIHRvIHRoZSBuYXRpdmUgYHN0cmluZ2lmeWAgYW5kIGBwYXJzZWAgaW1wbGVtZW50YXRpb25zLlxuICAgIGlmICh0eXBlb2YgbmF0aXZlSlNPTiA9PSBcIm9iamVjdFwiICYmIG5hdGl2ZUpTT04pIHtcbiAgICAgIGV4cG9ydHMuc3RyaW5naWZ5ID0gbmF0aXZlSlNPTi5zdHJpbmdpZnk7XG4gICAgICBleHBvcnRzLnBhcnNlID0gbmF0aXZlSlNPTi5wYXJzZTtcbiAgICB9XG5cbiAgICAvLyBDb252ZW5pZW5jZSBhbGlhc2VzLlxuICAgIHZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgICAgIGdldENsYXNzID0gb2JqZWN0UHJvdG8udG9TdHJpbmcsXG4gICAgICAgIGlzUHJvcGVydHksIGZvckVhY2gsIHVuZGVmO1xuXG4gICAgLy8gVGVzdCB0aGUgYERhdGUjZ2V0VVRDKmAgbWV0aG9kcy4gQmFzZWQgb24gd29yayBieSBAWWFmZmxlLlxuICAgIHZhciBpc0V4dGVuZGVkID0gbmV3IERhdGUoLTM1MDk4MjczMzQ1NzMyOTIpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUaGUgYGdldFVUQ0Z1bGxZZWFyYCwgYE1vbnRoYCwgYW5kIGBEYXRlYCBtZXRob2RzIHJldHVybiBub25zZW5zaWNhbFxuICAgICAgLy8gcmVzdWx0cyBmb3IgY2VydGFpbiBkYXRlcyBpbiBPcGVyYSA+PSAxMC41My5cbiAgICAgIGlzRXh0ZW5kZWQgPSBpc0V4dGVuZGVkLmdldFVUQ0Z1bGxZZWFyKCkgPT0gLTEwOTI1MiAmJiBpc0V4dGVuZGVkLmdldFVUQ01vbnRoKCkgPT09IDAgJiYgaXNFeHRlbmRlZC5nZXRVVENEYXRlKCkgPT09IDEgJiZcbiAgICAgICAgLy8gU2FmYXJpIDwgMi4wLjIgc3RvcmVzIHRoZSBpbnRlcm5hbCBtaWxsaXNlY29uZCB0aW1lIHZhbHVlIGNvcnJlY3RseSxcbiAgICAgICAgLy8gYnV0IGNsaXBzIHRoZSB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGRhdGUgbWV0aG9kcyB0byB0aGUgcmFuZ2Ugb2ZcbiAgICAgICAgLy8gc2lnbmVkIDMyLWJpdCBpbnRlZ2VycyAoWy0yICoqIDMxLCAyICoqIDMxIC0gMV0pLlxuICAgICAgICBpc0V4dGVuZGVkLmdldFVUQ0hvdXJzKCkgPT0gMTAgJiYgaXNFeHRlbmRlZC5nZXRVVENNaW51dGVzKCkgPT0gMzcgJiYgaXNFeHRlbmRlZC5nZXRVVENTZWNvbmRzKCkgPT0gNiAmJiBpc0V4dGVuZGVkLmdldFVUQ01pbGxpc2Vjb25kcygpID09IDcwODtcbiAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG5cbiAgICAvLyBJbnRlcm5hbDogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBuYXRpdmUgYEpTT04uc3RyaW5naWZ5YCBhbmQgYHBhcnNlYFxuICAgIC8vIGltcGxlbWVudGF0aW9ucyBhcmUgc3BlYy1jb21wbGlhbnQuIEJhc2VkIG9uIHdvcmsgYnkgS2VuIFNueWRlci5cbiAgICBmdW5jdGlvbiBoYXMobmFtZSkge1xuICAgICAgaWYgKGhhc1tuYW1lXSAhPT0gdW5kZWYpIHtcbiAgICAgICAgLy8gUmV0dXJuIGNhY2hlZCBmZWF0dXJlIHRlc3QgcmVzdWx0LlxuICAgICAgICByZXR1cm4gaGFzW25hbWVdO1xuICAgICAgfVxuICAgICAgdmFyIGlzU3VwcG9ydGVkO1xuICAgICAgaWYgKG5hbWUgPT0gXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIikge1xuICAgICAgICAvLyBJRSA8PSA3IGRvZXNuJ3Qgc3VwcG9ydCBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgdXNpbmcgc3F1YXJlXG4gICAgICAgIC8vIGJyYWNrZXQgbm90YXRpb24uIElFIDggb25seSBzdXBwb3J0cyB0aGlzIGZvciBwcmltaXRpdmVzLlxuICAgICAgICBpc1N1cHBvcnRlZCA9IFwiYVwiWzBdICE9IFwiYVwiO1xuICAgICAgfSBlbHNlIGlmIChuYW1lID09IFwianNvblwiKSB7XG4gICAgICAgIC8vIEluZGljYXRlcyB3aGV0aGVyIGJvdGggYEpTT04uc3RyaW5naWZ5YCBhbmQgYEpTT04ucGFyc2VgIGFyZVxuICAgICAgICAvLyBzdXBwb3J0ZWQuXG4gICAgICAgIGlzU3VwcG9ydGVkID0gaGFzKFwianNvbi1zdHJpbmdpZnlcIikgJiYgaGFzKFwianNvbi1wYXJzZVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB2YWx1ZSwgc2VyaWFsaXplZCA9ICd7XCJhXCI6WzEsdHJ1ZSxmYWxzZSxudWxsLFwiXFxcXHUwMDAwXFxcXGJcXFxcblxcXFxmXFxcXHJcXFxcdFwiXX0nO1xuICAgICAgICAvLyBUZXN0IGBKU09OLnN0cmluZ2lmeWAuXG4gICAgICAgIGlmIChuYW1lID09IFwianNvbi1zdHJpbmdpZnlcIikge1xuICAgICAgICAgIHZhciBzdHJpbmdpZnkgPSBleHBvcnRzLnN0cmluZ2lmeSwgc3RyaW5naWZ5U3VwcG9ydGVkID0gdHlwZW9mIHN0cmluZ2lmeSA9PSBcImZ1bmN0aW9uXCIgJiYgaXNFeHRlbmRlZDtcbiAgICAgICAgICBpZiAoc3RyaW5naWZ5U3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAvLyBBIHRlc3QgZnVuY3Rpb24gb2JqZWN0IHdpdGggYSBjdXN0b20gYHRvSlNPTmAgbWV0aG9kLlxuICAgICAgICAgICAgKHZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH0pLnRvSlNPTiA9IHZhbHVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID1cbiAgICAgICAgICAgICAgICAvLyBGaXJlZm94IDMuMWIxIGFuZCBiMiBzZXJpYWxpemUgc3RyaW5nLCBudW1iZXIsIGFuZCBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gcHJpbWl0aXZlcyBhcyBvYmplY3QgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KDApID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiwgYW5kIEpTT04gMiBzZXJpYWxpemUgd3JhcHBlZCBwcmltaXRpdmVzIGFzIG9iamVjdFxuICAgICAgICAgICAgICAgIC8vIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgTnVtYmVyKCkpID09PSBcIjBcIiAmJlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgU3RyaW5nKCkpID09ICdcIlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGAsIGB1bmRlZmluZWRgLCBvclxuICAgICAgICAgICAgICAgIC8vIGRvZXMgbm90IGRlZmluZSBhIGNhbm9uaWNhbCBKU09OIHJlcHJlc2VudGF0aW9uICh0aGlzIGFwcGxpZXMgdG9cbiAgICAgICAgICAgICAgICAvLyBvYmplY3RzIHdpdGggYHRvSlNPTmAgcHJvcGVydGllcyBhcyB3ZWxsLCAqdW5sZXNzKiB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyB3aXRoaW4gYW4gb2JqZWN0IG9yIGFycmF5KS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoZ2V0Q2xhc3MpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIElFIDggc2VyaWFsaXplcyBgdW5kZWZpbmVkYCBhcyBgXCJ1bmRlZmluZWRcImAuIFNhZmFyaSA8PSA1LjEuNyBhbmRcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMyBwYXNzIHRoaXMgdGVzdC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkodW5kZWYpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIFNhZmFyaSA8PSA1LjEuNyBhbmQgRkYgMy4xYjMgdGhyb3cgYEVycm9yYHMgYW5kIGBUeXBlRXJyb3JgcyxcbiAgICAgICAgICAgICAgICAvLyByZXNwZWN0aXZlbHksIGlmIHRoZSB2YWx1ZSBpcyBvbWl0dGVkIGVudGlyZWx5LlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSgpID09PSB1bmRlZiAmJlxuICAgICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCAyIHRocm93IGFuIGVycm9yIGlmIHRoZSBnaXZlbiB2YWx1ZSBpcyBub3QgYSBudW1iZXIsXG4gICAgICAgICAgICAgICAgLy8gc3RyaW5nLCBhcnJheSwgb2JqZWN0LCBCb29sZWFuLCBvciBgbnVsbGAgbGl0ZXJhbC4gVGhpcyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAgICAgLy8gb2JqZWN0cyB3aXRoIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzIGFzIHdlbGwsIHVubGVzcyB0aGV5IGFyZSBuZXN0ZWRcbiAgICAgICAgICAgICAgICAvLyBpbnNpZGUgb2JqZWN0IG9yIGFycmF5IGxpdGVyYWxzLiBZVUkgMy4wLjBiMSBpZ25vcmVzIGN1c3RvbSBgdG9KU09OYFxuICAgICAgICAgICAgICAgIC8vIG1ldGhvZHMgZW50aXJlbHkuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3ZhbHVlXSkgPT0gXCJbMV1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFByb3RvdHlwZSA8PSAxLjYuMSBzZXJpYWxpemVzIGBbdW5kZWZpbmVkXWAgYXMgYFwiW11cImAgaW5zdGVhZCBvZlxuICAgICAgICAgICAgICAgIC8vIGBcIltudWxsXVwiYC5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoW3VuZGVmXSkgPT0gXCJbbnVsbF1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIFlVSSAzLjAuMGIxIGZhaWxzIHRvIHNlcmlhbGl6ZSBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwpID09IFwibnVsbFwiICYmXG4gICAgICAgICAgICAgICAgLy8gRkYgMy4xYjEsIDIgaGFsdHMgc2VyaWFsaXphdGlvbiBpZiBhbiBhcnJheSBjb250YWlucyBhIGZ1bmN0aW9uOlxuICAgICAgICAgICAgICAgIC8vIGBbMSwgdHJ1ZSwgZ2V0Q2xhc3MsIDFdYCBzZXJpYWxpemVzIGFzIFwiWzEsdHJ1ZSxdLFwiLiBGRiAzLjFiM1xuICAgICAgICAgICAgICAgIC8vIGVsaWRlcyBub24tSlNPTiB2YWx1ZXMgZnJvbSBvYmplY3RzIGFuZCBhcnJheXMsIHVubGVzcyB0aGV5XG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGN1c3RvbSBgdG9KU09OYCBtZXRob2RzLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShbdW5kZWYsIGdldENsYXNzLCBudWxsXSkgPT0gXCJbbnVsbCxudWxsLG51bGxdXCIgJiZcbiAgICAgICAgICAgICAgICAvLyBTaW1wbGUgc2VyaWFsaXphdGlvbiB0ZXN0LiBGRiAzLjFiMSB1c2VzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlc1xuICAgICAgICAgICAgICAgIC8vIHdoZXJlIGNoYXJhY3RlciBlc2NhcGUgY29kZXMgYXJlIGV4cGVjdGVkIChlLmcuLCBgXFxiYCA9PiBgXFx1MDAwOGApLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeSh7IFwiYVwiOiBbdmFsdWUsIHRydWUsIGZhbHNlLCBudWxsLCBcIlxceDAwXFxiXFxuXFxmXFxyXFx0XCJdIH0pID09IHNlcmlhbGl6ZWQgJiZcbiAgICAgICAgICAgICAgICAvLyBGRiAzLjFiMSBhbmQgYjIgaWdub3JlIHRoZSBgZmlsdGVyYCBhbmQgYHdpZHRoYCBhcmd1bWVudHMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG51bGwsIHZhbHVlKSA9PT0gXCIxXCIgJiZcbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkoWzEsIDJdLCBudWxsLCAxKSA9PSBcIltcXG4gMSxcXG4gMlxcbl1cIiAmJlxuICAgICAgICAgICAgICAgIC8vIEpTT04gMiwgUHJvdG90eXBlIDw9IDEuNywgYW5kIG9sZGVyIFdlYktpdCBidWlsZHMgaW5jb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAvLyBzZXJpYWxpemUgZXh0ZW5kZWQgeWVhcnMuXG4gICAgICAgICAgICAgICAgc3RyaW5naWZ5KG5ldyBEYXRlKC04LjY0ZTE1KSkgPT0gJ1wiLTI3MTgyMS0wNC0yMFQwMDowMDowMC4wMDBaXCInICYmXG4gICAgICAgICAgICAgICAgLy8gVGhlIG1pbGxpc2Vjb25kcyBhcmUgb3B0aW9uYWwgaW4gRVMgNSwgYnV0IHJlcXVpcmVkIGluIDUuMS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoOC42NGUxNSkpID09ICdcIisyNzU3NjAtMDktMTNUMDA6MDA6MDAuMDAwWlwiJyAmJlxuICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggPD0gMTEuMCBpbmNvcnJlY3RseSBzZXJpYWxpemVzIHllYXJzIHByaW9yIHRvIDAgYXMgbmVnYXRpdmVcbiAgICAgICAgICAgICAgICAvLyBmb3VyLWRpZ2l0IHllYXJzIGluc3RlYWQgb2Ygc2l4LWRpZ2l0IHllYXJzLiBDcmVkaXRzOiBAWWFmZmxlLlxuICAgICAgICAgICAgICAgIHN0cmluZ2lmeShuZXcgRGF0ZSgtNjIxOTg3NTUyZTUpKSA9PSAnXCItMDAwMDAxLTAxLTAxVDAwOjAwOjAwLjAwMFpcIicgJiZcbiAgICAgICAgICAgICAgICAvLyBTYWZhcmkgPD0gNS4xLjUgYW5kIE9wZXJhID49IDEwLjUzIGluY29ycmVjdGx5IHNlcmlhbGl6ZSBtaWxsaXNlY29uZFxuICAgICAgICAgICAgICAgIC8vIHZhbHVlcyBsZXNzIHRoYW4gMTAwMC4gQ3JlZGl0czogQFlhZmZsZS5cbiAgICAgICAgICAgICAgICBzdHJpbmdpZnkobmV3IERhdGUoLTEpKSA9PSAnXCIxOTY5LTEyLTMxVDIzOjU5OjU5Ljk5OVpcIic7XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgc3RyaW5naWZ5U3VwcG9ydGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzU3VwcG9ydGVkID0gc3RyaW5naWZ5U3VwcG9ydGVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRlc3QgYEpTT04ucGFyc2VgLlxuICAgICAgICBpZiAobmFtZSA9PSBcImpzb24tcGFyc2VcIikge1xuICAgICAgICAgIHZhciBwYXJzZSA9IGV4cG9ydHMucGFyc2U7XG4gICAgICAgICAgaWYgKHR5cGVvZiBwYXJzZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIC8vIEZGIDMuMWIxLCBiMiB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhIGJhcmUgbGl0ZXJhbCBpcyBwcm92aWRlZC5cbiAgICAgICAgICAgICAgLy8gQ29uZm9ybWluZyBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGFsc28gY29lcmNlIHRoZSBpbml0aWFsIGFyZ3VtZW50IHRvXG4gICAgICAgICAgICAgIC8vIGEgc3RyaW5nIHByaW9yIHRvIHBhcnNpbmcuXG4gICAgICAgICAgICAgIGlmIChwYXJzZShcIjBcIikgPT09IDAgJiYgIXBhcnNlKGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIC8vIFNpbXBsZSBwYXJzaW5nIHRlc3QuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBwYXJzZShzZXJpYWxpemVkKTtcbiAgICAgICAgICAgICAgICB2YXIgcGFyc2VTdXBwb3J0ZWQgPSB2YWx1ZVtcImFcIl0ubGVuZ3RoID09IDUgJiYgdmFsdWVbXCJhXCJdWzBdID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDUuMS4yIGFuZCBGRiAzLjFiMSBhbGxvdyB1bmVzY2FwZWQgdGFicyBpbiBzdHJpbmdzLlxuICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9ICFwYXJzZSgnXCJcXHRcIicpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7fVxuICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gRkYgNC4wIGFuZCA0LjAuMSBhbGxvdyBsZWFkaW5nIGArYCBzaWducyBhbmQgbGVhZGluZ1xuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlY2ltYWwgcG9pbnRzLiBGRiA0LjAsIDQuMC4xLCBhbmQgSUUgOS0xMCBhbHNvIGFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgLy8gY2VydGFpbiBvY3RhbCBsaXRlcmFscy5cbiAgICAgICAgICAgICAgICAgICAgICBwYXJzZVN1cHBvcnRlZCA9IHBhcnNlKFwiMDFcIikgIT09IDE7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4Y2VwdGlvbikge31cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChwYXJzZVN1cHBvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEZGIDQuMCwgNC4wLjEsIGFuZCBSaGlubyAxLjdSMy1SNCBhbGxvdyB0cmFpbGluZyBkZWNpbWFsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gcG9pbnRzLiBUaGVzZSBlbnZpcm9ubWVudHMsIGFsb25nIHdpdGggRkYgMy4xYjEgYW5kIDIsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gYWxzbyBhbGxvdyB0cmFpbGluZyBjb21tYXMgaW4gSlNPTiBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBwYXJzZShcIjEuXCIpICE9PSAxO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgcGFyc2VTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNTdXBwb3J0ZWQgPSBwYXJzZVN1cHBvcnRlZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc1tuYW1lXSA9ICEhaXNTdXBwb3J0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKCFoYXMoXCJqc29uXCIpKSB7XG4gICAgICAvLyBDb21tb24gYFtbQ2xhc3NdXWAgbmFtZSBhbGlhc2VzLlxuICAgICAgdmFyIGZ1bmN0aW9uQ2xhc3MgPSBcIltvYmplY3QgRnVuY3Rpb25dXCIsXG4gICAgICAgICAgZGF0ZUNsYXNzID0gXCJbb2JqZWN0IERhdGVdXCIsXG4gICAgICAgICAgbnVtYmVyQ2xhc3MgPSBcIltvYmplY3QgTnVtYmVyXVwiLFxuICAgICAgICAgIHN0cmluZ0NsYXNzID0gXCJbb2JqZWN0IFN0cmluZ11cIixcbiAgICAgICAgICBhcnJheUNsYXNzID0gXCJbb2JqZWN0IEFycmF5XVwiLFxuICAgICAgICAgIGJvb2xlYW5DbGFzcyA9IFwiW29iamVjdCBCb29sZWFuXVwiO1xuXG4gICAgICAvLyBEZXRlY3QgaW5jb21wbGV0ZSBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXguXG4gICAgICB2YXIgY2hhckluZGV4QnVnZ3kgPSBoYXMoXCJidWctc3RyaW5nLWNoYXItaW5kZXhcIik7XG5cbiAgICAgIC8vIERlZmluZSBhZGRpdGlvbmFsIHV0aWxpdHkgbWV0aG9kcyBpZiB0aGUgYERhdGVgIG1ldGhvZHMgYXJlIGJ1Z2d5LlxuICAgICAgaWYgKCFpc0V4dGVuZGVkKSB7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgICAgIC8vIEEgbWFwcGluZyBiZXR3ZWVuIHRoZSBtb250aHMgb2YgdGhlIHllYXIgYW5kIHRoZSBudW1iZXIgb2YgZGF5cyBiZXR3ZWVuXG4gICAgICAgIC8vIEphbnVhcnkgMXN0IGFuZCB0aGUgZmlyc3Qgb2YgdGhlIHJlc3BlY3RpdmUgbW9udGguXG4gICAgICAgIHZhciBNb250aHMgPSBbMCwgMzEsIDU5LCA5MCwgMTIwLCAxNTEsIDE4MSwgMjEyLCAyNDMsIDI3MywgMzA0LCAzMzRdO1xuICAgICAgICAvLyBJbnRlcm5hbDogQ2FsY3VsYXRlcyB0aGUgbnVtYmVyIG9mIGRheXMgYmV0d2VlbiB0aGUgVW5peCBlcG9jaCBhbmQgdGhlXG4gICAgICAgIC8vIGZpcnN0IGRheSBvZiB0aGUgZ2l2ZW4gbW9udGguXG4gICAgICAgIHZhciBnZXREYXkgPSBmdW5jdGlvbiAoeWVhciwgbW9udGgpIHtcbiAgICAgICAgICByZXR1cm4gTW9udGhzW21vbnRoXSArIDM2NSAqICh5ZWFyIC0gMTk3MCkgKyBmbG9vcigoeWVhciAtIDE5NjkgKyAobW9udGggPSArKG1vbnRoID4gMSkpKSAvIDQpIC0gZmxvb3IoKHllYXIgLSAxOTAxICsgbW9udGgpIC8gMTAwKSArIGZsb29yKCh5ZWFyIC0gMTYwMSArIG1vbnRoKSAvIDQwMCk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBEZXRlcm1pbmVzIGlmIGEgcHJvcGVydHkgaXMgYSBkaXJlY3QgcHJvcGVydHkgb2YgdGhlIGdpdmVuXG4gICAgICAvLyBvYmplY3QuIERlbGVnYXRlcyB0byB0aGUgbmF0aXZlIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIG1ldGhvZC5cbiAgICAgIGlmICghKGlzUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eSkpIHtcbiAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgIHZhciBtZW1iZXJzID0ge30sIGNvbnN0cnVjdG9yO1xuICAgICAgICAgIGlmICgobWVtYmVycy5fX3Byb3RvX18gPSBudWxsLCBtZW1iZXJzLl9fcHJvdG9fXyA9IHtcbiAgICAgICAgICAgIC8vIFRoZSAqcHJvdG8qIHByb3BlcnR5IGNhbm5vdCBiZSBzZXQgbXVsdGlwbGUgdGltZXMgaW4gcmVjZW50XG4gICAgICAgICAgICAvLyB2ZXJzaW9ucyBvZiBGaXJlZm94IGFuZCBTZWFNb25rZXkuXG4gICAgICAgICAgICBcInRvU3RyaW5nXCI6IDFcbiAgICAgICAgICB9LCBtZW1iZXJzKS50b1N0cmluZyAhPSBnZXRDbGFzcykge1xuICAgICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC4zIGRvZXNuJ3QgaW1wbGVtZW50IGBPYmplY3QjaGFzT3duUHJvcGVydHlgLCBidXRcbiAgICAgICAgICAgIC8vIHN1cHBvcnRzIHRoZSBtdXRhYmxlICpwcm90byogcHJvcGVydHkuXG4gICAgICAgICAgICBpc1Byb3BlcnR5ID0gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgIC8vIENhcHR1cmUgYW5kIGJyZWFrIHRoZSBvYmplY3QncyBwcm90b3R5cGUgY2hhaW4gKHNlZSBzZWN0aW9uIDguNi4yXG4gICAgICAgICAgICAgIC8vIG9mIHRoZSBFUyA1LjEgc3BlYykuIFRoZSBwYXJlbnRoZXNpemVkIGV4cHJlc3Npb24gcHJldmVudHMgYW5cbiAgICAgICAgICAgICAgLy8gdW5zYWZlIHRyYW5zZm9ybWF0aW9uIGJ5IHRoZSBDbG9zdXJlIENvbXBpbGVyLlxuICAgICAgICAgICAgICB2YXIgb3JpZ2luYWwgPSB0aGlzLl9fcHJvdG9fXywgcmVzdWx0ID0gcHJvcGVydHkgaW4gKHRoaXMuX19wcm90b19fID0gbnVsbCwgdGhpcyk7XG4gICAgICAgICAgICAgIC8vIFJlc3RvcmUgdGhlIG9yaWdpbmFsIHByb3RvdHlwZSBjaGFpbi5cbiAgICAgICAgICAgICAgdGhpcy5fX3Byb3RvX18gPSBvcmlnaW5hbDtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIENhcHR1cmUgYSByZWZlcmVuY2UgdG8gdGhlIHRvcC1sZXZlbCBgT2JqZWN0YCBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICAgIGNvbnN0cnVjdG9yID0gbWVtYmVycy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSB0byBzaW11bGF0ZSBgT2JqZWN0I2hhc093blByb3BlcnR5YCBpblxuICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgaXNQcm9wZXJ0eSA9IGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gKHRoaXMuY29uc3RydWN0b3IgfHwgY29uc3RydWN0b3IpLnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5IGluIHRoaXMgJiYgIShwcm9wZXJ0eSBpbiBwYXJlbnQgJiYgdGhpc1twcm9wZXJ0eV0gPT09IHBhcmVudFtwcm9wZXJ0eV0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWVtYmVycyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIGlzUHJvcGVydHkuY2FsbCh0aGlzLCBwcm9wZXJ0eSk7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEludGVybmFsOiBOb3JtYWxpemVzIHRoZSBgZm9yLi4uaW5gIGl0ZXJhdGlvbiBhbGdvcml0aG0gYWNyb3NzXG4gICAgICAvLyBlbnZpcm9ubWVudHMuIEVhY2ggZW51bWVyYXRlZCBrZXkgaXMgeWllbGRlZCB0byBhIGBjYWxsYmFja2AgZnVuY3Rpb24uXG4gICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBQcm9wZXJ0aWVzLCBtZW1iZXJzLCBwcm9wZXJ0eTtcblxuICAgICAgICAvLyBUZXN0cyBmb3IgYnVncyBpbiB0aGUgY3VycmVudCBlbnZpcm9ubWVudCdzIGBmb3IuLi5pbmAgYWxnb3JpdGhtLiBUaGVcbiAgICAgICAgLy8gYHZhbHVlT2ZgIHByb3BlcnR5IGluaGVyaXRzIHRoZSBub24tZW51bWVyYWJsZSBmbGFnIGZyb21cbiAgICAgICAgLy8gYE9iamVjdC5wcm90b3R5cGVgIGluIG9sZGVyIHZlcnNpb25zIG9mIElFLCBOZXRzY2FwZSwgYW5kIE1vemlsbGEuXG4gICAgICAgIChQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRoaXMudmFsdWVPZiA9IDA7XG4gICAgICAgIH0pLnByb3RvdHlwZS52YWx1ZU9mID0gMDtcblxuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGBQcm9wZXJ0aWVzYCBjbGFzcy5cbiAgICAgICAgbWVtYmVycyA9IG5ldyBQcm9wZXJ0aWVzKCk7XG4gICAgICAgIGZvciAocHJvcGVydHkgaW4gbWVtYmVycykge1xuICAgICAgICAgIC8vIElnbm9yZSBhbGwgcHJvcGVydGllcyBpbmhlcml0ZWQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuXG4gICAgICAgICAgaWYgKGlzUHJvcGVydHkuY2FsbChtZW1iZXJzLCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHNpemUrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgUHJvcGVydGllcyA9IG1lbWJlcnMgPSBudWxsO1xuXG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgaXRlcmF0aW9uIGFsZ29yaXRobS5cbiAgICAgICAgaWYgKCFzaXplKSB7XG4gICAgICAgICAgLy8gQSBsaXN0IG9mIG5vbi1lbnVtZXJhYmxlIHByb3BlcnRpZXMgaW5oZXJpdGVkIGZyb20gYE9iamVjdC5wcm90b3R5cGVgLlxuICAgICAgICAgIG1lbWJlcnMgPSBbXCJ2YWx1ZU9mXCIsIFwidG9TdHJpbmdcIiwgXCJ0b0xvY2FsZVN0cmluZ1wiLCBcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsIFwiaXNQcm90b3R5cGVPZlwiLCBcImhhc093blByb3BlcnR5XCIsIFwiY29uc3RydWN0b3JcIl07XG4gICAgICAgICAgLy8gSUUgPD0gOCwgTW96aWxsYSAxLjAsIGFuZCBOZXRzY2FwZSA2LjIgaWdub3JlIHNoYWRvd2VkIG5vbi1lbnVtZXJhYmxlXG4gICAgICAgICAgLy8gcHJvcGVydGllcy5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBpc0Z1bmN0aW9uID0gZ2V0Q2xhc3MuY2FsbChvYmplY3QpID09IGZ1bmN0aW9uQ2xhc3MsIHByb3BlcnR5LCBsZW5ndGg7XG4gICAgICAgICAgICB2YXIgaGFzUHJvcGVydHkgPSAhaXNGdW5jdGlvbiAmJiB0eXBlb2Ygb2JqZWN0LmNvbnN0cnVjdG9yICE9IFwiZnVuY3Rpb25cIiAmJiBvYmplY3RUeXBlc1t0eXBlb2Ygb2JqZWN0Lmhhc093blByb3BlcnR5XSAmJiBvYmplY3QuaGFzT3duUHJvcGVydHkgfHwgaXNQcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIEdlY2tvIDw9IDEuMCBlbnVtZXJhdGVzIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgdW5kZXJcbiAgICAgICAgICAgICAgLy8gY2VydGFpbiBjb25kaXRpb25zOyBJRSBkb2VzIG5vdC5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiBoYXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciBlYWNoIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgZm9yIChsZW5ndGggPSBtZW1iZXJzLmxlbmd0aDsgcHJvcGVydHkgPSBtZW1iZXJzWy0tbGVuZ3RoXTsgaGFzUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSAmJiBjYWxsYmFjayhwcm9wZXJ0eSkpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoc2l6ZSA9PSAyKSB7XG4gICAgICAgICAgLy8gU2FmYXJpIDw9IDIuMC40IGVudW1lcmF0ZXMgc2hhZG93ZWQgcHJvcGVydGllcyB0d2ljZS5cbiAgICAgICAgICBmb3JFYWNoID0gZnVuY3Rpb24gKG9iamVjdCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNldCBvZiBpdGVyYXRlZCBwcm9wZXJ0aWVzLlxuICAgICAgICAgICAgdmFyIG1lbWJlcnMgPSB7fSwgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eTtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIC8vIFN0b3JlIGVhY2ggcHJvcGVydHkgbmFtZSB0byBwcmV2ZW50IGRvdWJsZSBlbnVtZXJhdGlvbi4gVGhlXG4gICAgICAgICAgICAgIC8vIGBwcm90b3R5cGVgIHByb3BlcnR5IG9mIGZ1bmN0aW9ucyBpcyBub3QgZW51bWVyYXRlZCBkdWUgdG8gY3Jvc3MtXG4gICAgICAgICAgICAgIC8vIGVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgICAgaWYgKCEoaXNGdW5jdGlvbiAmJiBwcm9wZXJ0eSA9PSBcInByb3RvdHlwZVwiKSAmJiAhaXNQcm9wZXJ0eS5jYWxsKG1lbWJlcnMsIHByb3BlcnR5KSAmJiAobWVtYmVyc1twcm9wZXJ0eV0gPSAxKSAmJiBpc1Byb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhwcm9wZXJ0eSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE5vIGJ1Z3MgZGV0ZWN0ZWQ7IHVzZSB0aGUgc3RhbmRhcmQgYGZvci4uLmluYCBhbGdvcml0aG0uXG4gICAgICAgICAgZm9yRWFjaCA9IGZ1bmN0aW9uIChvYmplY3QsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICB2YXIgaXNGdW5jdGlvbiA9IGdldENsYXNzLmNhbGwob2JqZWN0KSA9PSBmdW5jdGlvbkNsYXNzLCBwcm9wZXJ0eSwgaXNDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIGZvciAocHJvcGVydHkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgIGlmICghKGlzRnVuY3Rpb24gJiYgcHJvcGVydHkgPT0gXCJwcm90b3R5cGVcIikgJiYgaXNQcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpICYmICEoaXNDb25zdHJ1Y3RvciA9IHByb3BlcnR5ID09PSBcImNvbnN0cnVjdG9yXCIpKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2socHJvcGVydHkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYW51YWxseSBpbnZva2UgdGhlIGNhbGxiYWNrIGZvciB0aGUgYGNvbnN0cnVjdG9yYCBwcm9wZXJ0eSBkdWUgdG9cbiAgICAgICAgICAgIC8vIGNyb3NzLWVudmlyb25tZW50IGluY29uc2lzdGVuY2llcy5cbiAgICAgICAgICAgIGlmIChpc0NvbnN0cnVjdG9yIHx8IGlzUHJvcGVydHkuY2FsbChvYmplY3QsIChwcm9wZXJ0eSA9IFwiY29uc3RydWN0b3JcIikpKSB7XG4gICAgICAgICAgICAgIGNhbGxiYWNrKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb3JFYWNoKG9iamVjdCwgY2FsbGJhY2spO1xuICAgICAgfTtcblxuICAgICAgLy8gUHVibGljOiBTZXJpYWxpemVzIGEgSmF2YVNjcmlwdCBgdmFsdWVgIGFzIGEgSlNPTiBzdHJpbmcuIFRoZSBvcHRpb25hbFxuICAgICAgLy8gYGZpbHRlcmAgYXJndW1lbnQgbWF5IHNwZWNpZnkgZWl0aGVyIGEgZnVuY3Rpb24gdGhhdCBhbHRlcnMgaG93IG9iamVjdCBhbmRcbiAgICAgIC8vIGFycmF5IG1lbWJlcnMgYXJlIHNlcmlhbGl6ZWQsIG9yIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIG51bWJlcnMgdGhhdFxuICAgICAgLy8gaW5kaWNhdGVzIHdoaWNoIHByb3BlcnRpZXMgc2hvdWxkIGJlIHNlcmlhbGl6ZWQuIFRoZSBvcHRpb25hbCBgd2lkdGhgXG4gICAgICAvLyBhcmd1bWVudCBtYXkgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bWJlciB0aGF0IHNwZWNpZmllcyB0aGUgaW5kZW50YXRpb25cbiAgICAgIC8vIGxldmVsIG9mIHRoZSBvdXRwdXQuXG4gICAgICBpZiAoIWhhcyhcImpzb24tc3RyaW5naWZ5XCIpKSB7XG4gICAgICAgIC8vIEludGVybmFsOiBBIG1hcCBvZiBjb250cm9sIGNoYXJhY3RlcnMgYW5kIHRoZWlyIGVzY2FwZWQgZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBFc2NhcGVzID0ge1xuICAgICAgICAgIDkyOiBcIlxcXFxcXFxcXCIsXG4gICAgICAgICAgMzQ6ICdcXFxcXCInLFxuICAgICAgICAgIDg6IFwiXFxcXGJcIixcbiAgICAgICAgICAxMjogXCJcXFxcZlwiLFxuICAgICAgICAgIDEwOiBcIlxcXFxuXCIsXG4gICAgICAgICAgMTM6IFwiXFxcXHJcIixcbiAgICAgICAgICA5OiBcIlxcXFx0XCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogQ29udmVydHMgYHZhbHVlYCBpbnRvIGEgemVyby1wYWRkZWQgc3RyaW5nIHN1Y2ggdGhhdCBpdHNcbiAgICAgICAgLy8gbGVuZ3RoIGlzIGF0IGxlYXN0IGVxdWFsIHRvIGB3aWR0aGAuIFRoZSBgd2lkdGhgIG11c3QgYmUgPD0gNi5cbiAgICAgICAgdmFyIGxlYWRpbmdaZXJvZXMgPSBcIjAwMDAwMFwiO1xuICAgICAgICB2YXIgdG9QYWRkZWRTdHJpbmcgPSBmdW5jdGlvbiAod2lkdGgsIHZhbHVlKSB7XG4gICAgICAgICAgLy8gVGhlIGB8fCAwYCBleHByZXNzaW9uIGlzIG5lY2Vzc2FyeSB0byB3b3JrIGFyb3VuZCBhIGJ1ZyBpblxuICAgICAgICAgIC8vIE9wZXJhIDw9IDcuNTR1MiB3aGVyZSBgMCA9PSAtMGAsIGJ1dCBgU3RyaW5nKC0wKSAhPT0gXCIwXCJgLlxuICAgICAgICAgIHJldHVybiAobGVhZGluZ1plcm9lcyArICh2YWx1ZSB8fCAwKSkuc2xpY2UoLXdpZHRoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogRG91YmxlLXF1b3RlcyBhIHN0cmluZyBgdmFsdWVgLCByZXBsYWNpbmcgYWxsIEFTQ0lJIGNvbnRyb2xcbiAgICAgICAgLy8gY2hhcmFjdGVycyAoY2hhcmFjdGVycyB3aXRoIGNvZGUgdW5pdCB2YWx1ZXMgYmV0d2VlbiAwIGFuZCAzMSkgd2l0aFxuICAgICAgICAvLyB0aGVpciBlc2NhcGVkIGVxdWl2YWxlbnRzLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgUXVvdGUodmFsdWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICB2YXIgdW5pY29kZVByZWZpeCA9IFwiXFxcXHUwMFwiO1xuICAgICAgICB2YXIgcXVvdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gJ1wiJywgaW5kZXggPSAwLCBsZW5ndGggPSB2YWx1ZS5sZW5ndGgsIHVzZUNoYXJJbmRleCA9ICFjaGFySW5kZXhCdWdneSB8fCBsZW5ndGggPiAxMDtcbiAgICAgICAgICB2YXIgc3ltYm9scyA9IHVzZUNoYXJJbmRleCAmJiAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5zcGxpdChcIlwiKSA6IHZhbHVlKTtcbiAgICAgICAgICBmb3IgKDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjaGFyQ29kZSA9IHZhbHVlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGNoYXJhY3RlciBpcyBhIGNvbnRyb2wgY2hhcmFjdGVyLCBhcHBlbmQgaXRzIFVuaWNvZGUgb3JcbiAgICAgICAgICAgIC8vIHNob3J0aGFuZCBlc2NhcGUgc2VxdWVuY2U7IG90aGVyd2lzZSwgYXBwZW5kIHRoZSBjaGFyYWN0ZXIgYXMtaXMuXG4gICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgIGNhc2UgODogY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEyOiBjYXNlIDEzOiBjYXNlIDM0OiBjYXNlIDkyOlxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBFc2NhcGVzW2NoYXJDb2RlXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHVuaWNvZGVQcmVmaXggKyB0b1BhZGRlZFN0cmluZygyLCBjaGFyQ29kZS50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB1c2VDaGFySW5kZXggPyBzeW1ib2xzW2luZGV4XSA6IHZhbHVlLmNoYXJBdChpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQgKyAnXCInO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIGFuIG9iamVjdC4gSW1wbGVtZW50cyB0aGVcbiAgICAgICAgLy8gYFN0cihrZXksIGhvbGRlcilgLCBgSk8odmFsdWUpYCwgYW5kIGBKQSh2YWx1ZSlgIG9wZXJhdGlvbnMuXG4gICAgICAgIHZhciBzZXJpYWxpemUgPSBmdW5jdGlvbiAocHJvcGVydHksIG9iamVjdCwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIGluZGVudGF0aW9uLCBzdGFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSwgY2xhc3NOYW1lLCB5ZWFyLCBtb250aCwgZGF0ZSwgdGltZSwgaG91cnMsIG1pbnV0ZXMsIHNlY29uZHMsIG1pbGxpc2Vjb25kcywgcmVzdWx0cywgZWxlbWVudCwgaW5kZXgsIGxlbmd0aCwgcHJlZml4LCByZXN1bHQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5lY2Vzc2FyeSBmb3IgaG9zdCBvYmplY3Qgc3VwcG9ydC5cbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGNhdGNoIChleGNlcHRpb24pIHt9XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChjbGFzc05hbWUgPT0gZGF0ZUNsYXNzICYmICFpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSB7XG4gICAgICAgICAgICAgIGlmICh2YWx1ZSA+IC0xIC8gMCAmJiB2YWx1ZSA8IDEgLyAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRGF0ZXMgYXJlIHNlcmlhbGl6ZWQgYWNjb3JkaW5nIHRvIHRoZSBgRGF0ZSN0b0pTT05gIG1ldGhvZFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmllZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS45LjUuNDQuIFNlZSBzZWN0aW9uIDE1LjkuMS4xNVxuICAgICAgICAgICAgICAgIC8vIGZvciB0aGUgSVNPIDg2MDEgZGF0ZSB0aW1lIHN0cmluZyBmb3JtYXQuXG4gICAgICAgICAgICAgICAgaWYgKGdldERheSkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgY29tcHV0ZSB0aGUgeWVhciwgbW9udGgsIGRhdGUsIGhvdXJzLCBtaW51dGVzLFxuICAgICAgICAgICAgICAgICAgLy8gc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBpZiB0aGUgYGdldFVUQypgIG1ldGhvZHMgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBidWdneS4gQWRhcHRlZCBmcm9tIEBZYWZmbGUncyBgZGF0ZS1zaGltYCBwcm9qZWN0LlxuICAgICAgICAgICAgICAgICAgZGF0ZSA9IGZsb29yKHZhbHVlIC8gODY0ZTUpO1xuICAgICAgICAgICAgICAgICAgZm9yICh5ZWFyID0gZmxvb3IoZGF0ZSAvIDM2NS4yNDI1KSArIDE5NzAgLSAxOyBnZXREYXkoeWVhciArIDEsIDApIDw9IGRhdGU7IHllYXIrKyk7XG4gICAgICAgICAgICAgICAgICBmb3IgKG1vbnRoID0gZmxvb3IoKGRhdGUgLSBnZXREYXkoeWVhciwgMCkpIC8gMzAuNDIpOyBnZXREYXkoeWVhciwgbW9udGggKyAxKSA8PSBkYXRlOyBtb250aCsrKTtcbiAgICAgICAgICAgICAgICAgIGRhdGUgPSAxICsgZGF0ZSAtIGdldERheSh5ZWFyLCBtb250aCk7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgYHRpbWVgIHZhbHVlIHNwZWNpZmllcyB0aGUgdGltZSB3aXRoaW4gdGhlIGRheSAoc2VlIEVTXG4gICAgICAgICAgICAgICAgICAvLyA1LjEgc2VjdGlvbiAxNS45LjEuMikuIFRoZSBmb3JtdWxhIGAoQSAlIEIgKyBCKSAlIEJgIGlzIHVzZWRcbiAgICAgICAgICAgICAgICAgIC8vIHRvIGNvbXB1dGUgYEEgbW9kdWxvIEJgLCBhcyB0aGUgYCVgIG9wZXJhdG9yIGRvZXMgbm90XG4gICAgICAgICAgICAgICAgICAvLyBjb3JyZXNwb25kIHRvIHRoZSBgbW9kdWxvYCBvcGVyYXRpb24gZm9yIG5lZ2F0aXZlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgICB0aW1lID0gKHZhbHVlICUgODY0ZTUgKyA4NjRlNSkgJSA4NjRlNTtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBob3VycywgbWludXRlcywgc2Vjb25kcywgYW5kIG1pbGxpc2Vjb25kcyBhcmUgb2J0YWluZWQgYnlcbiAgICAgICAgICAgICAgICAgIC8vIGRlY29tcG9zaW5nIHRoZSB0aW1lIHdpdGhpbiB0aGUgZGF5LiBTZWUgc2VjdGlvbiAxNS45LjEuMTAuXG4gICAgICAgICAgICAgICAgICBob3VycyA9IGZsb29yKHRpbWUgLyAzNmU1KSAlIDI0O1xuICAgICAgICAgICAgICAgICAgbWludXRlcyA9IGZsb29yKHRpbWUgLyA2ZTQpICUgNjA7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gZmxvb3IodGltZSAvIDFlMykgJSA2MDtcbiAgICAgICAgICAgICAgICAgIG1pbGxpc2Vjb25kcyA9IHRpbWUgJSAxZTM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHllYXIgPSB2YWx1ZS5nZXRVVENGdWxsWWVhcigpO1xuICAgICAgICAgICAgICAgICAgbW9udGggPSB2YWx1ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgICAgICAgZGF0ZSA9IHZhbHVlLmdldFVUQ0RhdGUoKTtcbiAgICAgICAgICAgICAgICAgIGhvdXJzID0gdmFsdWUuZ2V0VVRDSG91cnMoKTtcbiAgICAgICAgICAgICAgICAgIG1pbnV0ZXMgPSB2YWx1ZS5nZXRVVENNaW51dGVzKCk7XG4gICAgICAgICAgICAgICAgICBzZWNvbmRzID0gdmFsdWUuZ2V0VVRDU2Vjb25kcygpO1xuICAgICAgICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gdmFsdWUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNlcmlhbGl6ZSBleHRlbmRlZCB5ZWFycyBjb3JyZWN0bHkuXG4gICAgICAgICAgICAgICAgdmFsdWUgPSAoeWVhciA8PSAwIHx8IHllYXIgPj0gMWU0ID8gKHllYXIgPCAwID8gXCItXCIgOiBcIitcIikgKyB0b1BhZGRlZFN0cmluZyg2LCB5ZWFyIDwgMCA/IC15ZWFyIDogeWVhcikgOiB0b1BhZGRlZFN0cmluZyg0LCB5ZWFyKSkgK1xuICAgICAgICAgICAgICAgICAgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBtb250aCArIDEpICsgXCItXCIgKyB0b1BhZGRlZFN0cmluZygyLCBkYXRlKSArXG4gICAgICAgICAgICAgICAgICAvLyBNb250aHMsIGRhdGVzLCBob3VycywgbWludXRlcywgYW5kIHNlY29uZHMgc2hvdWxkIGhhdmUgdHdvXG4gICAgICAgICAgICAgICAgICAvLyBkaWdpdHM7IG1pbGxpc2Vjb25kcyBzaG91bGQgaGF2ZSB0aHJlZS5cbiAgICAgICAgICAgICAgICAgIFwiVFwiICsgdG9QYWRkZWRTdHJpbmcoMiwgaG91cnMpICsgXCI6XCIgKyB0b1BhZGRlZFN0cmluZygyLCBtaW51dGVzKSArIFwiOlwiICsgdG9QYWRkZWRTdHJpbmcoMiwgc2Vjb25kcykgK1xuICAgICAgICAgICAgICAgICAgLy8gTWlsbGlzZWNvbmRzIGFyZSBvcHRpb25hbCBpbiBFUyA1LjAsIGJ1dCByZXF1aXJlZCBpbiA1LjEuXG4gICAgICAgICAgICAgICAgICBcIi5cIiArIHRvUGFkZGVkU3RyaW5nKDMsIG1pbGxpc2Vjb25kcykgKyBcIlpcIjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlLnRvSlNPTiA9PSBcImZ1bmN0aW9uXCIgJiYgKChjbGFzc05hbWUgIT0gbnVtYmVyQ2xhc3MgJiYgY2xhc3NOYW1lICE9IHN0cmluZ0NsYXNzICYmIGNsYXNzTmFtZSAhPSBhcnJheUNsYXNzKSB8fCBpc1Byb3BlcnR5LmNhbGwodmFsdWUsIFwidG9KU09OXCIpKSkge1xuICAgICAgICAgICAgICAvLyBQcm90b3R5cGUgPD0gMS42LjEgYWRkcyBub24tc3RhbmRhcmQgYHRvSlNPTmAgbWV0aG9kcyB0byB0aGVcbiAgICAgICAgICAgICAgLy8gYE51bWJlcmAsIGBTdHJpbmdgLCBgRGF0ZWAsIGFuZCBgQXJyYXlgIHByb3RvdHlwZXMuIEpTT04gM1xuICAgICAgICAgICAgICAvLyBpZ25vcmVzIGFsbCBgdG9KU09OYCBtZXRob2RzIG9uIHRoZXNlIG9iamVjdHMgdW5sZXNzIHRoZXkgYXJlXG4gICAgICAgICAgICAgIC8vIGRlZmluZWQgZGlyZWN0bHkgb24gYW4gaW5zdGFuY2UuXG4gICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKHByb3BlcnR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBJZiBhIHJlcGxhY2VtZW50IGZ1bmN0aW9uIHdhcyBwcm92aWRlZCwgY2FsbCBpdCB0byBvYnRhaW4gdGhlIHZhbHVlXG4gICAgICAgICAgICAvLyBmb3Igc2VyaWFsaXphdGlvbi5cbiAgICAgICAgICAgIHZhbHVlID0gY2FsbGJhY2suY2FsbChvYmplY3QsIHByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjbGFzc05hbWUgPSBnZXRDbGFzcy5jYWxsKHZhbHVlKTtcbiAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGJvb2xlYW5DbGFzcykge1xuICAgICAgICAgICAgLy8gQm9vbGVhbnMgYXJlIHJlcHJlc2VudGVkIGxpdGVyYWxseS5cbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgdmFsdWU7XG4gICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gbnVtYmVyQ2xhc3MpIHtcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gYEluZmluaXR5YCBhbmQgYE5hTmAgYXJlIHNlcmlhbGl6ZWQgYXNcbiAgICAgICAgICAgIC8vIGBcIm51bGxcImAuXG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPiAtMSAvIDAgJiYgdmFsdWUgPCAxIC8gMCA/IFwiXCIgKyB2YWx1ZSA6IFwibnVsbFwiO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzKSB7XG4gICAgICAgICAgICAvLyBTdHJpbmdzIGFyZSBkb3VibGUtcXVvdGVkIGFuZCBlc2NhcGVkLlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKFwiXCIgKyB2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IHNlcmlhbGl6ZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoaXMgaXMgYSBsaW5lYXIgc2VhcmNoOyBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgLy8gaXMgaW52ZXJzZWx5IHByb3BvcnRpb25hbCB0byB0aGUgbnVtYmVyIG9mIHVuaXF1ZSBuZXN0ZWQgb2JqZWN0cy5cbiAgICAgICAgICAgIGZvciAobGVuZ3RoID0gc3RhY2subGVuZ3RoOyBsZW5ndGgtLTspIHtcbiAgICAgICAgICAgICAgaWYgKHN0YWNrW2xlbmd0aF0gPT09IHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3ljbGljIHN0cnVjdHVyZXMgY2Fubm90IGJlIHNlcmlhbGl6ZWQgYnkgYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgICAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICByZXN1bHRzID0gW107XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBjdXJyZW50IGluZGVudGF0aW9uIGxldmVsIGFuZCBpbmRlbnQgb25lIGFkZGl0aW9uYWwgbGV2ZWwuXG4gICAgICAgICAgICBwcmVmaXggPSBpbmRlbnRhdGlvbjtcbiAgICAgICAgICAgIGluZGVudGF0aW9uICs9IHdoaXRlc3BhY2U7XG4gICAgICAgICAgICBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgc2VyaWFsaXplIGFycmF5IGVsZW1lbnRzLlxuICAgICAgICAgICAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQgPSBzZXJpYWxpemUoaW5kZXgsIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goZWxlbWVudCA9PT0gdW5kZWYgPyBcIm51bGxcIiA6IGVsZW1lbnQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIltcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwiXVwiIDogKFwiW1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwiXVwiKSkgOiBcIltdXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgb2JqZWN0IG1lbWJlcnMuIE1lbWJlcnMgYXJlIHNlbGVjdGVkIGZyb21cbiAgICAgICAgICAgICAgLy8gZWl0aGVyIGEgdXNlci1zcGVjaWZpZWQgbGlzdCBvZiBwcm9wZXJ0eSBuYW1lcywgb3IgdGhlIG9iamVjdFxuICAgICAgICAgICAgICAvLyBpdHNlbGYuXG4gICAgICAgICAgICAgIGZvckVhY2gocHJvcGVydGllcyB8fCB2YWx1ZSwgZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBzZXJpYWxpemUocHJvcGVydHksIHZhbHVlLCBjYWxsYmFjaywgcHJvcGVydGllcywgd2hpdGVzcGFjZSwgaW5kZW50YXRpb24sIHN0YWNrKTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCAhPT0gdW5kZWYpIHtcbiAgICAgICAgICAgICAgICAgIC8vIEFjY29yZGluZyB0byBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zOiBcIklmIGBnYXBgIHt3aGl0ZXNwYWNlfVxuICAgICAgICAgICAgICAgICAgLy8gaXMgbm90IHRoZSBlbXB0eSBzdHJpbmcsIGxldCBgbWVtYmVyYCB7cXVvdGUocHJvcGVydHkpICsgXCI6XCJ9XG4gICAgICAgICAgICAgICAgICAvLyBiZSB0aGUgY29uY2F0ZW5hdGlvbiBvZiBgbWVtYmVyYCBhbmQgdGhlIGBzcGFjZWAgY2hhcmFjdGVyLlwiXG4gICAgICAgICAgICAgICAgICAvLyBUaGUgXCJgc3BhY2VgIGNoYXJhY3RlclwiIHJlZmVycyB0byB0aGUgbGl0ZXJhbCBzcGFjZVxuICAgICAgICAgICAgICAgICAgLy8gY2hhcmFjdGVyLCBub3QgdGhlIGBzcGFjZWAge3dpZHRofSBhcmd1bWVudCBwcm92aWRlZCB0b1xuICAgICAgICAgICAgICAgICAgLy8gYEpTT04uc3RyaW5naWZ5YC5cbiAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChxdW90ZShwcm9wZXJ0eSkgKyBcIjpcIiArICh3aGl0ZXNwYWNlID8gXCIgXCIgOiBcIlwiKSArIGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdHMubGVuZ3RoID8gKHdoaXRlc3BhY2UgPyBcIntcXG5cIiArIGluZGVudGF0aW9uICsgcmVzdWx0cy5qb2luKFwiLFxcblwiICsgaW5kZW50YXRpb24pICsgXCJcXG5cIiArIHByZWZpeCArIFwifVwiIDogKFwie1wiICsgcmVzdWx0cy5qb2luKFwiLFwiKSArIFwifVwiKSkgOiBcInt9XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIG9iamVjdCBmcm9tIHRoZSB0cmF2ZXJzZWQgb2JqZWN0IHN0YWNrLlxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnN0cmluZ2lmeWAuIFNlZSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLlxuICAgICAgICBleHBvcnRzLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChzb3VyY2UsIGZpbHRlciwgd2lkdGgpIHtcbiAgICAgICAgICB2YXIgd2hpdGVzcGFjZSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIGNsYXNzTmFtZTtcbiAgICAgICAgICBpZiAob2JqZWN0VHlwZXNbdHlwZW9mIGZpbHRlcl0gJiYgZmlsdGVyKSB7XG4gICAgICAgICAgICBpZiAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwoZmlsdGVyKSkgPT0gZnVuY3Rpb25DbGFzcykge1xuICAgICAgICAgICAgICBjYWxsYmFjayA9IGZpbHRlcjtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgLy8gQ29udmVydCB0aGUgcHJvcGVydHkgbmFtZXMgYXJyYXkgaW50byBhIG1ha2VzaGlmdCBzZXQuXG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGggPSBmaWx0ZXIubGVuZ3RoLCB2YWx1ZTsgaW5kZXggPCBsZW5ndGg7IHZhbHVlID0gZmlsdGVyW2luZGV4KytdLCAoKGNsYXNzTmFtZSA9IGdldENsYXNzLmNhbGwodmFsdWUpKSwgY2xhc3NOYW1lID09IHN0cmluZ0NsYXNzIHx8IGNsYXNzTmFtZSA9PSBudW1iZXJDbGFzcykgJiYgKHByb3BlcnRpZXNbdmFsdWVdID0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAod2lkdGgpIHtcbiAgICAgICAgICAgIGlmICgoY2xhc3NOYW1lID0gZ2V0Q2xhc3MuY2FsbCh3aWR0aCkpID09IG51bWJlckNsYXNzKSB7XG4gICAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIGB3aWR0aGAgdG8gYW4gaW50ZWdlciBhbmQgY3JlYXRlIGEgc3RyaW5nIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgLy8gYHdpZHRoYCBudW1iZXIgb2Ygc3BhY2UgY2hhcmFjdGVycy5cbiAgICAgICAgICAgICAgaWYgKCh3aWR0aCAtPSB3aWR0aCAlIDEpID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAod2hpdGVzcGFjZSA9IFwiXCIsIHdpZHRoID4gMTAgJiYgKHdpZHRoID0gMTApOyB3aGl0ZXNwYWNlLmxlbmd0aCA8IHdpZHRoOyB3aGl0ZXNwYWNlICs9IFwiIFwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MpIHtcbiAgICAgICAgICAgICAgd2hpdGVzcGFjZSA9IHdpZHRoLmxlbmd0aCA8PSAxMCA/IHdpZHRoIDogd2lkdGguc2xpY2UoMCwgMTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBPcGVyYSA8PSA3LjU0dTIgZGlzY2FyZHMgdGhlIHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggZW1wdHkgc3RyaW5nIGtleXNcbiAgICAgICAgICAvLyAoYFwiXCJgKSBvbmx5IGlmIHRoZXkgYXJlIHVzZWQgZGlyZWN0bHkgd2l0aGluIGFuIG9iamVjdCBtZW1iZXIgbGlzdFxuICAgICAgICAgIC8vIChlLmcuLCBgIShcIlwiIGluIHsgXCJcIjogMX0pYCkuXG4gICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShcIlwiLCAodmFsdWUgPSB7fSwgdmFsdWVbXCJcIl0gPSBzb3VyY2UsIHZhbHVlKSwgY2FsbGJhY2ssIHByb3BlcnRpZXMsIHdoaXRlc3BhY2UsIFwiXCIsIFtdKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gUHVibGljOiBQYXJzZXMgYSBKU09OIHNvdXJjZSBzdHJpbmcuXG4gICAgICBpZiAoIWhhcyhcImpzb24tcGFyc2VcIikpIHtcbiAgICAgICAgdmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IEEgbWFwIG9mIGVzY2FwZWQgY29udHJvbCBjaGFyYWN0ZXJzIGFuZCB0aGVpciB1bmVzY2FwZWRcbiAgICAgICAgLy8gZXF1aXZhbGVudHMuXG4gICAgICAgIHZhciBVbmVzY2FwZXMgPSB7XG4gICAgICAgICAgOTI6IFwiXFxcXFwiLFxuICAgICAgICAgIDM0OiAnXCInLFxuICAgICAgICAgIDQ3OiBcIi9cIixcbiAgICAgICAgICA5ODogXCJcXGJcIixcbiAgICAgICAgICAxMTY6IFwiXFx0XCIsXG4gICAgICAgICAgMTEwOiBcIlxcblwiLFxuICAgICAgICAgIDEwMjogXCJcXGZcIixcbiAgICAgICAgICAxMTQ6IFwiXFxyXCJcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogU3RvcmVzIHRoZSBwYXJzZXIgc3RhdGUuXG4gICAgICAgIHZhciBJbmRleCwgU291cmNlO1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXNldHMgdGhlIHBhcnNlciBzdGF0ZSBhbmQgdGhyb3dzIGEgYFN5bnRheEVycm9yYC5cbiAgICAgICAgdmFyIGFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICB0aHJvdyBTeW50YXhFcnJvcigpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZXR1cm5zIHRoZSBuZXh0IHRva2VuLCBvciBgXCIkXCJgIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWRcbiAgICAgICAgLy8gdGhlIGVuZCBvZiB0aGUgc291cmNlIHN0cmluZy4gQSB0b2tlbiBtYXkgYmUgYSBzdHJpbmcsIG51bWJlciwgYG51bGxgXG4gICAgICAgIC8vIGxpdGVyYWwsIG9yIEJvb2xlYW4gbGl0ZXJhbC5cbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc291cmNlID0gU291cmNlLCBsZW5ndGggPSBzb3VyY2UubGVuZ3RoLCB2YWx1ZSwgYmVnaW4sIHBvc2l0aW9uLCBpc1NpZ25lZCwgY2hhckNvZGU7XG4gICAgICAgICAgd2hpbGUgKEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KTtcbiAgICAgICAgICAgIHN3aXRjaCAoY2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgY2FzZSA5OiBjYXNlIDEwOiBjYXNlIDEzOiBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIC8vIFNraXAgd2hpdGVzcGFjZSB0b2tlbnMsIGluY2x1ZGluZyB0YWJzLCBjYXJyaWFnZSByZXR1cm5zLCBsaW5lXG4gICAgICAgICAgICAgICAgLy8gZmVlZHMsIGFuZCBzcGFjZSBjaGFyYWN0ZXJzLlxuICAgICAgICAgICAgICAgIEluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgMTIzOiBjYXNlIDEyNTogY2FzZSA5MTogY2FzZSA5MzogY2FzZSA1ODogY2FzZSA0NDpcbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhIHB1bmN0dWF0b3IgdG9rZW4gKGB7YCwgYH1gLCBgW2AsIGBdYCwgYDpgLCBvciBgLGApIGF0XG4gICAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjaGFySW5kZXhCdWdneSA/IHNvdXJjZS5jaGFyQXQoSW5kZXgpIDogc291cmNlW0luZGV4XTtcbiAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgICAvLyBgXCJgIGRlbGltaXRzIGEgSlNPTiBzdHJpbmc7IGFkdmFuY2UgdG8gdGhlIG5leHQgY2hhcmFjdGVyIGFuZFxuICAgICAgICAgICAgICAgIC8vIGJlZ2luIHBhcnNpbmcgdGhlIHN0cmluZy4gU3RyaW5nIHRva2VucyBhcmUgcHJlZml4ZWQgd2l0aCB0aGVcbiAgICAgICAgICAgICAgICAvLyBzZW50aW5lbCBgQGAgY2hhcmFjdGVyIHRvIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSBwdW5jdHVhdG9ycyBhbmRcbiAgICAgICAgICAgICAgICAvLyBlbmQtb2Ytc3RyaW5nIHRva2Vucy5cbiAgICAgICAgICAgICAgICBmb3IgKHZhbHVlID0gXCJAXCIsIEluZGV4Kys7IEluZGV4IDwgbGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPCAzMikge1xuICAgICAgICAgICAgICAgICAgICAvLyBVbmVzY2FwZWQgQVNDSUkgY29udHJvbCBjaGFyYWN0ZXJzICh0aG9zZSB3aXRoIGEgY29kZSB1bml0XG4gICAgICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhhbiB0aGUgc3BhY2UgY2hhcmFjdGVyKSBhcmUgbm90IHBlcm1pdHRlZC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT0gOTIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSByZXZlcnNlIHNvbGlkdXMgKGBcXGApIG1hcmtzIHRoZSBiZWdpbm5pbmcgb2YgYW4gZXNjYXBlZFxuICAgICAgICAgICAgICAgICAgICAvLyBjb250cm9sIGNoYXJhY3RlciAoaW5jbHVkaW5nIGBcImAsIGBcXGAsIGFuZCBgL2ApIG9yIFVuaWNvZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5MjogY2FzZSAzNDogY2FzZSA0NzogY2FzZSA5ODogY2FzZSAxMTY6IGNhc2UgMTEwOiBjYXNlIDEwMjogY2FzZSAxMTQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgZXNjYXBlZCBjb250cm9sIGNoYXJhY3RlcnMuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBVbmVzY2FwZXNbY2hhckNvZGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYFxcdWAgbWFya3MgdGhlIGJlZ2lubmluZyBvZiBhIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgZmlyc3QgY2hhcmFjdGVyIGFuZCB2YWxpZGF0ZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZvdXItZGlnaXQgY29kZSBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2luID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleCArIDQ7IEluZGV4IDwgcG9zaXRpb247IEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEEgdmFsaWQgc2VxdWVuY2UgY29tcHJpc2VzIGZvdXIgaGV4ZGlnaXRzIChjYXNlLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbnNlbnNpdGl2ZSkgdGhhdCBmb3JtIGEgc2luZ2xlIGhleGFkZWNpbWFsIHZhbHVlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1NyB8fCBjaGFyQ29kZSA+PSA5NyAmJiBjaGFyQ29kZSA8PSAxMDIgfHwgY2hhckNvZGUgPj0gNjUgJiYgY2hhckNvZGUgPD0gNzApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52YWxpZCBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXZpdmUgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKFwiMHhcIiArIHNvdXJjZS5zbGljZShiZWdpbiwgSW5kZXgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbnZhbGlkIGVzY2FwZSBzZXF1ZW5jZS5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIEFuIHVuZXNjYXBlZCBkb3VibGUtcXVvdGUgY2hhcmFjdGVyIG1hcmtzIHRoZSBlbmQgb2YgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3RyaW5nLlxuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBiZWdpbiA9IEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6ZSBmb3IgdGhlIGNvbW1vbiBjYXNlIHdoZXJlIGEgc3RyaW5nIGlzIHZhbGlkLlxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY2hhckNvZGUgPj0gMzIgJiYgY2hhckNvZGUgIT0gOTIgJiYgY2hhckNvZGUgIT0gMzQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFwcGVuZCB0aGUgc3RyaW5nIGFzLWlzLlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSArPSBzb3VyY2Uuc2xpY2UoYmVnaW4sIEluZGV4KTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSA9PSAzNCkge1xuICAgICAgICAgICAgICAgICAgLy8gQWR2YW5jZSB0byB0aGUgbmV4dCBjaGFyYWN0ZXIgYW5kIHJldHVybiB0aGUgcmV2aXZlZCBzdHJpbmcuXG4gICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnRlcm1pbmF0ZWQgc3RyaW5nLlxuICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbnVtYmVycyBhbmQgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgYmVnaW4gPSBJbmRleDtcbiAgICAgICAgICAgICAgICAvLyBBZHZhbmNlIHBhc3QgdGhlIG5lZ2F0aXZlIHNpZ24sIGlmIG9uZSBpcyBzcGVjaWZpZWQuXG4gICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ1KSB7XG4gICAgICAgICAgICAgICAgICBpc1NpZ25lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KCsrSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbiBpbnRlZ2VyIG9yIGZsb2F0aW5nLXBvaW50IHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmIChjaGFyQ29kZSA+PSA0OCAmJiBjaGFyQ29kZSA8PSA1Nykge1xuICAgICAgICAgICAgICAgICAgLy8gTGVhZGluZyB6ZXJvZXMgYXJlIGludGVycHJldGVkIGFzIG9jdGFsIGxpdGVyYWxzLlxuICAgICAgICAgICAgICAgICAgaWYgKGNoYXJDb2RlID09IDQ4ICYmICgoY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCArIDEpKSwgY2hhckNvZGUgPj0gNDggJiYgY2hhckNvZGUgPD0gNTcpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgb2N0YWwgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSB0aGUgaW50ZWdlciBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICBmb3IgKDsgSW5kZXggPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KEluZGV4KSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgSW5kZXgrKyk7XG4gICAgICAgICAgICAgICAgICAvLyBGbG9hdHMgY2Fubm90IGNvbnRhaW4gYSBsZWFkaW5nIGRlY2ltYWwgcG9pbnQ7IGhvd2V2ZXIsIHRoaXNcbiAgICAgICAgICAgICAgICAgIC8vIGNhc2UgaXMgYWxyZWFkeSBhY2NvdW50ZWQgZm9yIGJ5IHRoZSBwYXJzZXIuXG4gICAgICAgICAgICAgICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoSW5kZXgpID09IDQ2KSB7XG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uID0gKytJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFyc2UgdGhlIGRlY2ltYWwgY29tcG9uZW50LlxuICAgICAgICAgICAgICAgICAgICBmb3IgKDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgdHJhaWxpbmcgZGVjaW1hbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIEluZGV4ID0gcG9zaXRpb247XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQYXJzZSBleHBvbmVudHMuIFRoZSBgZWAgZGVub3RpbmcgdGhlIGV4cG9uZW50IGlzXG4gICAgICAgICAgICAgICAgICAvLyBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICAgICAgICAgICAgICAgY2hhckNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChJbmRleCk7XG4gICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gMTAxIHx8IGNoYXJDb2RlID09IDY5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb2RlID0gc291cmNlLmNoYXJDb2RlQXQoKytJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNraXAgcGFzdCB0aGUgc2lnbiBmb2xsb3dpbmcgdGhlIGV4cG9uZW50LCBpZiBvbmUgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gc3BlY2lmaWVkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckNvZGUgPT0gNDMgfHwgY2hhckNvZGUgPT0gNDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICBJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFBhcnNlIHRoZSBleHBvbmVudGlhbCBjb21wb25lbnQuXG4gICAgICAgICAgICAgICAgICAgIGZvciAocG9zaXRpb24gPSBJbmRleDsgcG9zaXRpb24gPCBsZW5ndGggJiYgKChjaGFyQ29kZSA9IHNvdXJjZS5jaGFyQ29kZUF0KHBvc2l0aW9uKSksIGNoYXJDb2RlID49IDQ4ICYmIGNoYXJDb2RlIDw9IDU3KTsgcG9zaXRpb24rKyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PSBJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIElsbGVnYWwgZW1wdHkgZXhwb25lbnQuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gQ29lcmNlIHRoZSBwYXJzZWQgdmFsdWUgdG8gYSBKYXZhU2NyaXB0IG51bWJlci5cbiAgICAgICAgICAgICAgICAgIHJldHVybiArc291cmNlLnNsaWNlKGJlZ2luLCBJbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEEgbmVnYXRpdmUgc2lnbiBtYXkgb25seSBwcmVjZWRlIG51bWJlcnMuXG4gICAgICAgICAgICAgICAgaWYgKGlzU2lnbmVkKSB7XG4gICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBgdHJ1ZWAsIGBmYWxzZWAsIGFuZCBgbnVsbGAgbGl0ZXJhbHMuXG4gICAgICAgICAgICAgICAgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcInRydWVcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc291cmNlLnNsaWNlKEluZGV4LCBJbmRleCArIDUpID09IFwiZmFsc2VcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHNvdXJjZS5zbGljZShJbmRleCwgSW5kZXggKyA0KSA9PSBcIm51bGxcIikge1xuICAgICAgICAgICAgICAgICAgSW5kZXggKz0gNDtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVbnJlY29nbml6ZWQgdG9rZW4uXG4gICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUmV0dXJuIHRoZSBzZW50aW5lbCBgJGAgY2hhcmFjdGVyIGlmIHRoZSBwYXJzZXIgaGFzIHJlYWNoZWQgdGhlIGVuZFxuICAgICAgICAgIC8vIG9mIHRoZSBzb3VyY2Ugc3RyaW5nLlxuICAgICAgICAgIHJldHVybiBcIiRcIjtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBJbnRlcm5hbDogUGFyc2VzIGEgSlNPTiBgdmFsdWVgIHRva2VuLlxuICAgICAgICB2YXIgZ2V0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdHMsIGhhc01lbWJlcnM7XG4gICAgICAgICAgaWYgKHZhbHVlID09IFwiJFwiKSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dC5cbiAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgaWYgKChjaGFySW5kZXhCdWdneSA/IHZhbHVlLmNoYXJBdCgwKSA6IHZhbHVlWzBdKSA9PSBcIkBcIikge1xuICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIHNlbnRpbmVsIGBAYCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBhcnNlIG9iamVjdCBhbmQgYXJyYXkgbGl0ZXJhbHMuXG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gXCJbXCIpIHtcbiAgICAgICAgICAgICAgLy8gUGFyc2VzIGEgSlNPTiBhcnJheSwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgICAgICAgIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgICAgZm9yICg7OyBoYXNNZW1iZXJzIHx8IChoYXNNZW1iZXJzID0gdHJ1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGxleCgpO1xuICAgICAgICAgICAgICAgIC8vIEEgY2xvc2luZyBzcXVhcmUgYnJhY2tldCBtYXJrcyB0aGUgZW5kIG9mIHRoZSBhcnJheSBsaXRlcmFsLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIl1cIikge1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhcnJheSBsaXRlcmFsIGNvbnRhaW5zIGVsZW1lbnRzLCB0aGUgY3VycmVudCB0b2tlblxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhIGNvbW1hIHNlcGFyYXRpbmcgdGhlIHByZXZpb3VzIGVsZW1lbnQgZnJvbSB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0LlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwiXVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gYXJyYXkgbGl0ZXJhbC5cbiAgICAgICAgICAgICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBBIGAsYCBtdXN0IHNlcGFyYXRlIGVhY2ggYXJyYXkgZWxlbWVudC5cbiAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gRWxpc2lvbnMgYW5kIGxlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIikge1xuICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGdldCh2YWx1ZSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBcIntcIikge1xuICAgICAgICAgICAgICAvLyBQYXJzZXMgYSBKU09OIG9iamVjdCwgcmV0dXJuaW5nIGEgbmV3IEphdmFTY3JpcHQgb2JqZWN0LlxuICAgICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgICAgICAgIGZvciAoOzsgaGFzTWVtYmVycyB8fCAoaGFzTWVtYmVycyA9IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAvLyBBIGNsb3NpbmcgY3VybHkgYnJhY2UgbWFya3MgdGhlIGVuZCBvZiB0aGUgb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCBsaXRlcmFsIGNvbnRhaW5zIG1lbWJlcnMsIHRoZSBjdXJyZW50IHRva2VuXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIGJlIGEgY29tbWEgc2VwYXJhdG9yLlxuICAgICAgICAgICAgICAgIGlmIChoYXNNZW1iZXJzKSB7XG4gICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT0gXCIsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBsZXgoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IFwifVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVW5leHBlY3RlZCB0cmFpbGluZyBgLGAgaW4gb2JqZWN0IGxpdGVyYWwuXG4gICAgICAgICAgICAgICAgICAgICAgYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBgLGAgbXVzdCBzZXBhcmF0ZSBlYWNoIG9iamVjdCBtZW1iZXIuXG4gICAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIExlYWRpbmcgY29tbWFzIGFyZSBub3QgcGVybWl0dGVkLCBvYmplY3QgcHJvcGVydHkgbmFtZXMgbXVzdCBiZVxuICAgICAgICAgICAgICAgIC8vIGRvdWJsZS1xdW90ZWQgc3RyaW5ncywgYW5kIGEgYDpgIG11c3Qgc2VwYXJhdGUgZWFjaCBwcm9wZXJ0eVxuICAgICAgICAgICAgICAgIC8vIG5hbWUgYW5kIHZhbHVlLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBcIixcIiB8fCB0eXBlb2YgdmFsdWUgIT0gXCJzdHJpbmdcIiB8fCAoY2hhckluZGV4QnVnZ3kgPyB2YWx1ZS5jaGFyQXQoMCkgOiB2YWx1ZVswXSkgIT0gXCJAXCIgfHwgbGV4KCkgIT0gXCI6XCIpIHtcbiAgICAgICAgICAgICAgICAgIGFib3J0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbdmFsdWUuc2xpY2UoMSldID0gZ2V0KGxleCgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFVuZXhwZWN0ZWQgdG9rZW4gZW5jb3VudGVyZWQuXG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW50ZXJuYWw6IFVwZGF0ZXMgYSB0cmF2ZXJzZWQgb2JqZWN0IG1lbWJlci5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciBlbGVtZW50ID0gd2Fsayhzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjayk7XG4gICAgICAgICAgaWYgKGVsZW1lbnQgPT09IHVuZGVmKSB7XG4gICAgICAgICAgICBkZWxldGUgc291cmNlW3Byb3BlcnR5XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc291cmNlW3Byb3BlcnR5XSA9IGVsZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEludGVybmFsOiBSZWN1cnNpdmVseSB0cmF2ZXJzZXMgYSBwYXJzZWQgSlNPTiBvYmplY3QsIGludm9raW5nIHRoZVxuICAgICAgICAvLyBgY2FsbGJhY2tgIGZ1bmN0aW9uIGZvciBlYWNoIHZhbHVlLiBUaGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIG9mIHRoZVxuICAgICAgICAvLyBgV2Fsayhob2xkZXIsIG5hbWUpYCBvcGVyYXRpb24gZGVmaW5lZCBpbiBFUyA1LjEgc2VjdGlvbiAxNS4xMi4yLlxuICAgICAgICB2YXIgd2FsayA9IGZ1bmN0aW9uIChzb3VyY2UsIHByb3BlcnR5LCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wZXJ0eV0sIGxlbmd0aDtcbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIGBmb3JFYWNoYCBjYW4ndCBiZSB1c2VkIHRvIHRyYXZlcnNlIGFuIGFycmF5IGluIE9wZXJhIDw9IDguNTRcbiAgICAgICAgICAgIC8vIGJlY2F1c2UgaXRzIGBPYmplY3QjaGFzT3duUHJvcGVydHlgIGltcGxlbWVudGF0aW9uIHJldHVybnMgYGZhbHNlYFxuICAgICAgICAgICAgLy8gZm9yIGFycmF5IGluZGljZXMgKGUuZy4sIGAhWzEsIDIsIDNdLmhhc093blByb3BlcnR5KFwiMFwiKWApLlxuICAgICAgICAgICAgaWYgKGdldENsYXNzLmNhbGwodmFsdWUpID09IGFycmF5Q2xhc3MpIHtcbiAgICAgICAgICAgICAgZm9yIChsZW5ndGggPSB2YWx1ZS5sZW5ndGg7IGxlbmd0aC0tOykge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgbGVuZ3RoLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZvckVhY2godmFsdWUsIGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZSh2YWx1ZSwgcHJvcGVydHksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHNvdXJjZSwgcHJvcGVydHksIHZhbHVlKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBQdWJsaWM6IGBKU09OLnBhcnNlYC4gU2VlIEVTIDUuMSBzZWN0aW9uIDE1LjEyLjIuXG4gICAgICAgIGV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc291cmNlLCBjYWxsYmFjaykge1xuICAgICAgICAgIHZhciByZXN1bHQsIHZhbHVlO1xuICAgICAgICAgIEluZGV4ID0gMDtcbiAgICAgICAgICBTb3VyY2UgPSBcIlwiICsgc291cmNlO1xuICAgICAgICAgIHJlc3VsdCA9IGdldChsZXgoKSk7XG4gICAgICAgICAgLy8gSWYgYSBKU09OIHN0cmluZyBjb250YWlucyBtdWx0aXBsZSB0b2tlbnMsIGl0IGlzIGludmFsaWQuXG4gICAgICAgICAgaWYgKGxleCgpICE9IFwiJFwiKSB7XG4gICAgICAgICAgICBhYm9ydCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBSZXNldCB0aGUgcGFyc2VyIHN0YXRlLlxuICAgICAgICAgIEluZGV4ID0gU291cmNlID0gbnVsbDtcbiAgICAgICAgICByZXR1cm4gY2FsbGJhY2sgJiYgZ2V0Q2xhc3MuY2FsbChjYWxsYmFjaykgPT0gZnVuY3Rpb25DbGFzcyA/IHdhbGsoKHZhbHVlID0ge30sIHZhbHVlW1wiXCJdID0gcmVzdWx0LCB2YWx1ZSksIFwiXCIsIGNhbGxiYWNrKSA6IHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBleHBvcnRzW1wicnVuSW5Db250ZXh0XCJdID0gcnVuSW5Db250ZXh0O1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9XG5cbiAgaWYgKGZyZWVFeHBvcnRzICYmICFpc0xvYWRlcikge1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgZW52aXJvbm1lbnRzLlxuICAgIHJ1bkluQ29udGV4dChyb290LCBmcmVlRXhwb3J0cyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gRXhwb3J0IGZvciB3ZWIgYnJvd3NlcnMgYW5kIEphdmFTY3JpcHQgZW5naW5lcy5cbiAgICB2YXIgbmF0aXZlSlNPTiA9IHJvb3QuSlNPTixcbiAgICAgICAgcHJldmlvdXNKU09OID0gcm9vdFtcIkpTT04zXCJdLFxuICAgICAgICBpc1Jlc3RvcmVkID0gZmFsc2U7XG5cbiAgICB2YXIgSlNPTjMgPSBydW5JbkNvbnRleHQocm9vdCwgKHJvb3RbXCJKU09OM1wiXSA9IHtcbiAgICAgIC8vIFB1YmxpYzogUmVzdG9yZXMgdGhlIG9yaWdpbmFsIHZhbHVlIG9mIHRoZSBnbG9iYWwgYEpTT05gIG9iamVjdCBhbmRcbiAgICAgIC8vIHJldHVybnMgYSByZWZlcmVuY2UgdG8gdGhlIGBKU09OM2Agb2JqZWN0LlxuICAgICAgXCJub0NvbmZsaWN0XCI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCFpc1Jlc3RvcmVkKSB7XG4gICAgICAgICAgaXNSZXN0b3JlZCA9IHRydWU7XG4gICAgICAgICAgcm9vdC5KU09OID0gbmF0aXZlSlNPTjtcbiAgICAgICAgICByb290W1wiSlNPTjNcIl0gPSBwcmV2aW91c0pTT047XG4gICAgICAgICAgbmF0aXZlSlNPTiA9IHByZXZpb3VzSlNPTiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEpTT04zO1xuICAgICAgfVxuICAgIH0pKTtcblxuICAgIHJvb3QuSlNPTiA9IHtcbiAgICAgIFwicGFyc2VcIjogSlNPTjMucGFyc2UsXG4gICAgICBcInN0cmluZ2lmeVwiOiBKU09OMy5zdHJpbmdpZnlcbiAgICB9O1xuICB9XG5cbiAgLy8gRXhwb3J0IGZvciBhc3luY2hyb25vdXMgbW9kdWxlIGxvYWRlcnMuXG4gIGlmIChpc0xvYWRlcikge1xuICAgIGRlZmluZShmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gSlNPTjM7XG4gICAgfSk7XG4gIH1cbn0pLmNhbGwodGhpcyk7XG5cbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdyA6IHt9KVxufSx7fV0sODk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVxdWlyZWQgPSByZXF1aXJlKCdyZXF1aXJlcy1wb3J0JylcbiAgLCBsb2xjYXRpb24gPSByZXF1aXJlKCcuL2xvbGNhdGlvbicpXG4gICwgcXMgPSByZXF1aXJlKCdxdWVyeXN0cmluZ2lmeScpXG4gICwgcmVsYXRpdmVyZSA9IC9eXFwvKD8hXFwvKS87XG5cbi8qKlxuICogVGhlc2UgYXJlIHRoZSBwYXJzZSBpbnN0cnVjdGlvbnMgZm9yIHRoZSBVUkwgcGFyc2VycywgaXQgaW5mb3JtcyB0aGUgcGFyc2VyXG4gKiBhYm91dDpcbiAqXG4gKiAwLiBUaGUgY2hhciBpdCBOZWVkcyB0byBwYXJzZSwgaWYgaXQncyBhIHN0cmluZyBpdCBzaG91bGQgYmUgZG9uZSB1c2luZ1xuICogICAgaW5kZXhPZiwgUmVnRXhwIHVzaW5nIGV4ZWMgYW5kIE5hTiBtZWFucyBzZXQgYXMgY3VycmVudCB2YWx1ZS5cbiAqIDEuIFRoZSBwcm9wZXJ0eSB3ZSBzaG91bGQgc2V0IHdoZW4gcGFyc2luZyB0aGlzIHZhbHVlLlxuICogMi4gSW5kaWNhdGlvbiBpZiBpdCdzIGJhY2t3YXJkcyBvciBmb3J3YXJkIHBhcnNpbmcsIHdoZW4gc2V0IGFzIG51bWJlciBpdCdzXG4gKiAgICB0aGUgdmFsdWUgb2YgZXh0cmEgY2hhcnMgdGhhdCBzaG91bGQgYmUgc3BsaXQgb2ZmLlxuICogMy4gSW5oZXJpdCBmcm9tIGxvY2F0aW9uIGlmIG5vbiBleGlzdGluZyBpbiB0aGUgcGFyc2VyLlxuICogNC4gYHRvTG93ZXJDYXNlYCB0aGUgcmVzdWx0aW5nIHZhbHVlLlxuICovXG52YXIgaW5zdHJ1Y3Rpb25zID0gW1xuICBbJyMnLCAnaGFzaCddLCAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWyc/JywgJ3F1ZXJ5J10sICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnLy8nLCAncHJvdG9jb2wnLCAyLCAxLCAxXSwgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgWycvJywgJ3BhdGhuYW1lJ10sICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnQCcsICdhdXRoJywgMV0sICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBmcm9udC5cbiAgW05hTiwgJ2hvc3QnLCB1bmRlZmluZWQsIDEsIDFdLCAgICAgICAvLyBTZXQgbGVmdCBvdmVyIHZhbHVlLlxuICBbL1xcOihcXGQrKSQvLCAncG9ydCddLCAgICAgICAgICAgICAgICAgLy8gUmVnRXhwIHRoZSBiYWNrLlxuICBbTmFOLCAnaG9zdG5hbWUnLCB1bmRlZmluZWQsIDEsIDFdICAgIC8vIFNldCBsZWZ0IG92ZXIuXG5dO1xuXG4vKipcbiAqIFRoZSBhY3R1YWwgVVJMIGluc3RhbmNlLiBJbnN0ZWFkIG9mIHJldHVybmluZyBhbiBvYmplY3Qgd2UndmUgb3B0ZWQtaW4gdG9cbiAqIGNyZWF0ZSBhbiBhY3R1YWwgY29uc3RydWN0b3IgYXMgaXQncyBtdWNoIG1vcmUgbWVtb3J5IGVmZmljaWVudCBhbmRcbiAqIGZhc3RlciBhbmQgaXQgcGxlYXNlcyBteSBDRE8uXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxmdW5jdGlvbn0gcGFyc2VyIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsb2NhdGlvbiBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBVUkwoYWRkcmVzcywgbG9jYXRpb24sIHBhcnNlcikge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVVJMKSkge1xuICAgIHJldHVybiBuZXcgVVJMKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlID0gcmVsYXRpdmVyZS50ZXN0KGFkZHJlc3MpXG4gICAgLCBwYXJzZSwgaW5zdHJ1Y3Rpb24sIGluZGV4LCBrZXlcbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jYXRpb25cbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIGkgPSAwO1xuXG4gIC8vXG4gIC8vIFRoZSBmb2xsb3dpbmcgaWYgc3RhdGVtZW50cyBhbGxvd3MgdGhpcyBtb2R1bGUgdHdvIGhhdmUgY29tcGF0aWJpbGl0eSB3aXRoXG4gIC8vIDIgZGlmZmVyZW50IEFQSTpcbiAgLy9cbiAgLy8gMS4gTm9kZS5qcydzIGB1cmwucGFyc2VgIGFwaSB3aGljaCBhY2NlcHRzIGEgVVJMLCBib29sZWFuIGFzIGFyZ3VtZW50c1xuICAvLyAgICB3aGVyZSB0aGUgYm9vbGVhbiBpbmRpY2F0ZXMgdGhhdCB0aGUgcXVlcnkgc3RyaW5nIHNob3VsZCBhbHNvIGJlIHBhcnNlZC5cbiAgLy9cbiAgLy8gMi4gVGhlIGBVUkxgIGludGVyZmFjZSBvZiB0aGUgYnJvd3NlciB3aGljaCBhY2NlcHRzIGEgVVJMLCBvYmplY3QgYXNcbiAgLy8gICAgYXJndW1lbnRzLiBUaGUgc3VwcGxpZWQgb2JqZWN0IHdpbGwgYmUgdXNlZCBhcyBkZWZhdWx0IHZhbHVlcyAvIGZhbGwtYmFja1xuICAvLyAgICBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gIC8vXG4gIGlmICgnb2JqZWN0JyAhPT0gdHlwZSAmJiAnc3RyaW5nJyAhPT0gdHlwZSkge1xuICAgIHBhcnNlciA9IGxvY2F0aW9uO1xuICAgIGxvY2F0aW9uID0gbnVsbDtcbiAgfVxuXG4gIGlmIChwYXJzZXIgJiYgJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIHBhcnNlcikge1xuICAgIHBhcnNlciA9IHFzLnBhcnNlO1xuICB9XG5cbiAgbG9jYXRpb24gPSBsb2xjYXRpb24obG9jYXRpb24pO1xuXG4gIGZvciAoOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSBpbnN0cnVjdGlvbnNbaV07XG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbmRleCA9IHBhcnNlLmV4ZWMoYWRkcmVzcykpIHtcbiAgICAgIHVybFtrZXldID0gaW5kZXhbMV07XG4gICAgICBhZGRyZXNzID0gYWRkcmVzcy5zbGljZSgwLCBhZGRyZXNzLmxlbmd0aCAtIGluZGV4WzBdLmxlbmd0aCk7XG4gICAgfVxuXG4gICAgdXJsW2tleV0gPSB1cmxba2V5XSB8fCAoaW5zdHJ1Y3Rpb25bM10gfHwgKCdwb3J0JyA9PT0ga2V5ICYmIHJlbGF0aXZlKSA/IGxvY2F0aW9uW2tleV0gfHwgJycgOiAnJyk7XG5cbiAgICAvL1xuICAgIC8vIEhvc3RuYW1lLCBob3N0IGFuZCBwcm90b2NvbCBzaG91bGQgYmUgbG93ZXJjYXNlZCBzbyB0aGV5IGNhbiBiZSB1c2VkIHRvXG4gICAgLy8gY3JlYXRlIGEgcHJvcGVyIGBvcmlnaW5gLlxuICAgIC8vXG4gICAgaWYgKGluc3RydWN0aW9uWzRdKSB7XG4gICAgICB1cmxba2V5XSA9IHVybFtrZXldLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuICB9XG5cbiAgLy9cbiAgLy8gQWxzbyBwYXJzZSB0aGUgc3VwcGxpZWQgcXVlcnkgc3RyaW5nIGluIHRvIGFuIG9iamVjdC4gSWYgd2UncmUgc3VwcGxpZWRcbiAgLy8gd2l0aCBhIGN1c3RvbSBwYXJzZXIgYXMgZnVuY3Rpb24gdXNlIHRoYXQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBidWlsZC1pblxuICAvLyBwYXJzZXIuXG4gIC8vXG4gIGlmIChwYXJzZXIpIHVybC5xdWVyeSA9IHBhcnNlcih1cmwucXVlcnkpO1xuXG4gIC8vXG4gIC8vIFdlIHNob3VsZCBub3QgYWRkIHBvcnQgbnVtYmVycyBpZiB0aGV5IGFyZSBhbHJlYWR5IHRoZSBkZWZhdWx0IHBvcnQgbnVtYmVyXG4gIC8vIGZvciBhIGdpdmVuIHByb3RvY29sLiBBcyB0aGUgaG9zdCBhbHNvIGNvbnRhaW5zIHRoZSBwb3J0IG51bWJlciB3ZSdyZSBnb2luZ1xuICAvLyBvdmVycmlkZSBpdCB3aXRoIHRoZSBob3N0bmFtZSB3aGljaCBjb250YWlucyBubyBwb3J0IG51bWJlci5cbiAgLy9cbiAgaWYgKCFyZXF1aXJlZCh1cmwucG9ydCwgdXJsLnByb3RvY29sKSkge1xuICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lO1xuICAgIHVybC5wb3J0ID0gJyc7XG4gIH1cblxuICAvL1xuICAvLyBQYXJzZSBkb3duIHRoZSBgYXV0aGAgZm9yIHRoZSB1c2VybmFtZSBhbmQgcGFzc3dvcmQuXG4gIC8vXG4gIHVybC51c2VybmFtZSA9IHVybC5wYXNzd29yZCA9ICcnO1xuICBpZiAodXJsLmF1dGgpIHtcbiAgICBpbnN0cnVjdGlvbiA9IHVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgdXJsLnVzZXJuYW1lID0gaW5zdHJ1Y3Rpb25bMF0gfHwgJyc7XG4gICAgdXJsLnBhc3N3b3JkID0gaW5zdHJ1Y3Rpb25bMV0gfHwgJyc7XG4gIH1cblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcCBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEByZXR1cm5zIHtVUkx9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5VUkwucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldChwYXJ0LCB2YWx1ZSwgZm4pIHtcbiAgdmFyIHVybCA9IHRoaXM7XG5cbiAgaWYgKCdxdWVyeScgPT09IHBhcnQpIHtcbiAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gKGZuIHx8IHFzLnBhcnNlKSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH0gZWxzZSBpZiAoJ3BvcnQnID09PSBwYXJ0KSB7XG4gICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICBpZiAoIXJlcXVpcmVkKHZhbHVlLCB1cmwucHJvdG9jb2wpKSB7XG4gICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgIHVybC5ob3N0ID0gdXJsLmhvc3RuYW1lICsnOicrIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnaG9zdG5hbWUnID09PSBwYXJ0KSB7XG4gICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICBpZiAodXJsLnBvcnQpIHZhbHVlICs9ICc6JysgdXJsLnBvcnQ7XG4gICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgfSBlbHNlIGlmICgnaG9zdCcgPT09IHBhcnQpIHtcbiAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgIGlmICgvXFw6XFxkKy8udGVzdCh2YWx1ZSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgIHVybC5ob3N0bmFtZSA9IHZhbHVlWzBdO1xuICAgICAgdXJsLnBvcnQgPSB2YWx1ZVsxXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuICByZXR1cm4gdXJsO1xufTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgYmFjayBpbiB0byBhIHZhbGlkIGFuZCBmdWxsIFVSTCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc3RyaW5naWZ5IE9wdGlvbmFsIHF1ZXJ5IHN0cmluZ2lmeSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5VUkwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoc3RyaW5naWZ5KSB7XG4gIGlmICghc3RyaW5naWZ5IHx8ICdmdW5jdGlvbicgIT09IHR5cGVvZiBzdHJpbmdpZnkpIHN0cmluZ2lmeSA9IHFzLnN0cmluZ2lmeTtcblxuICB2YXIgcXVlcnlcbiAgICAsIHVybCA9IHRoaXNcbiAgICAsIHJlc3VsdCA9IHVybC5wcm90b2NvbCArJy8vJztcblxuICBpZiAodXJsLnVzZXJuYW1lKSB7XG4gICAgcmVzdWx0ICs9IHVybC51c2VybmFtZTtcbiAgICBpZiAodXJsLnBhc3N3b3JkKSByZXN1bHQgKz0gJzonKyB1cmwucGFzc3dvcmQ7XG4gICAgcmVzdWx0ICs9ICdAJztcbiAgfVxuXG4gIHJlc3VsdCArPSB1cmwuaG9zdG5hbWU7XG4gIGlmICh1cmwucG9ydCkgcmVzdWx0ICs9ICc6JysgdXJsLnBvcnQ7XG5cbiAgcmVzdWx0ICs9IHVybC5wYXRobmFtZTtcblxuICBxdWVyeSA9ICdvYmplY3QnID09PSB0eXBlb2YgdXJsLnF1ZXJ5ID8gc3RyaW5naWZ5KHVybC5xdWVyeSkgOiB1cmwucXVlcnk7XG4gIGlmIChxdWVyeSkgcmVzdWx0ICs9ICc/JyAhPT0gcXVlcnkuY2hhckF0KDApID8gJz8nKyBxdWVyeSA6IHF1ZXJ5O1xuXG4gIGlmICh1cmwuaGFzaCkgcmVzdWx0ICs9IHVybC5oYXNoO1xuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycy5cbi8vXG5VUkwucXMgPSBxcztcblVSTC5sb2NhdGlvbiA9IGxvbGNhdGlvbjtcbm1vZHVsZS5leHBvcnRzID0gVVJMO1xuXG59LHtcIi4vbG9sY2F0aW9uXCI6OTAsXCJxdWVyeXN0cmluZ2lmeVwiOjkxLFwicmVxdWlyZXMtcG9ydFwiOjkyfV0sOTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuKGZ1bmN0aW9uIChnbG9iYWwpe1xuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkIG5vdCBiZSBjb3BpZWQgb3IgaW5oZXJpdGVkIGZyb20uIFRoaXMgaXMgb25seSBuZWVkZWRcbiAqIGZvciBhbGwgbm9uIGJsb2IgVVJMJ3MgYXMgdGhlIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH1cbiAgLCBVUkw7XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbG9jIE9wdGlvbmFsIGRlZmF1bHQgbG9jYXRpb24gb2JqZWN0LlxuICogQHJldHVybnMge09iamVjdH0gbG9sY2F0aW9uIG9iamVjdC5cbiAqIEBhcGkgcHVibGljXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbG9sY2F0aW9uKGxvYykge1xuICBsb2MgPSBsb2MgfHwgZ2xvYmFsLmxvY2F0aW9uIHx8IHt9O1xuICBVUkwgPSBVUkwgfHwgcmVxdWlyZSgnLi8nKTtcblxuICB2YXIgZmluYWxkZXN0aW5hdGlvbiA9IHt9XG4gICAgLCB0eXBlID0gdHlwZW9mIGxvY1xuICAgICwga2V5O1xuXG4gIGlmICgnYmxvYjonID09PSBsb2MucHJvdG9jb2wpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTCh1bmVzY2FwZShsb2MucGF0aG5hbWUpLCB7fSk7XG4gIH0gZWxzZSBpZiAoJ3N0cmluZycgPT09IHR5cGUpIHtcbiAgICBmaW5hbGRlc3RpbmF0aW9uID0gbmV3IFVSTChsb2MsIHt9KTtcbiAgICBmb3IgKGtleSBpbiBpZ25vcmUpIGRlbGV0ZSBmaW5hbGRlc3RpbmF0aW9uW2tleV07XG4gIH0gZWxzZSBpZiAoJ29iamVjdCcgPT09IHR5cGUpIGZvciAoa2V5IGluIGxvYykge1xuICAgIGlmIChrZXkgaW4gaWdub3JlKSBjb250aW51ZTtcbiAgICBmaW5hbGRlc3RpbmF0aW9uW2tleV0gPSBsb2Nba2V5XTtcbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufTtcblxufSkuY2FsbCh0aGlzLHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDoge30pXG59LHtcIi4vXCI6ODl9XSw5MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8mXSspPShbXiZdKikvZ1xuICAgICwgcmVzdWx0ID0ge31cbiAgICAsIHBhcnQ7XG5cbiAgLy9cbiAgLy8gTGl0dGxlIG5pZnR5IHBhcnNpbmcgaGFjaywgbGV2ZXJhZ2UgdGhlIGZhY3QgdGhhdCBSZWdFeHAuZXhlYyBpbmNyZW1lbnRzXG4gIC8vIHRoZSBsYXN0SW5kZXggcHJvcGVydHkgc28gd2UgY2FuIGNvbnRpbnVlIGV4ZWN1dGluZyB0aGlzIGxvb3AgdW50aWwgd2UndmVcbiAgLy8gcGFyc2VkIGFsbCByZXN1bHRzLlxuICAvL1xuICBmb3IgKDtcbiAgICBwYXJ0ID0gcGFyc2VyLmV4ZWMocXVlcnkpO1xuICAgIHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQocGFydFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KHBhcnRbMl0pXG4gICk7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdO1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoaGFzLmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICBwYWlycy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsnPScrIGVuY29kZVVSSUNvbXBvbmVudChvYmpba2V5XSkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG5cbn0se31dLDkyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMjtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuXG59LHt9XSw5MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCcuL2luZGV4LWNsaWVudCcpO1xucmVxdWlyZSgnLi9saWIvY2xpZW50L3RyYW5zcG9ydC9Tb2NranMnKTtcbn0se1wiLi9pbmRleC1jbGllbnRcIjoxNyxcIi4vbGliL2NsaWVudC90cmFuc3BvcnQvU29ja2pzXCI6Mjd9XSw5NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5yZXF1aXJlKCdqaWkvZGVwcycpO1xucmVxdWlyZSgnamlpLWNvbWV0L3NvY2tqcycpO1xucmVxdWlyZSgnamlpLWNvbWV0L25lYXQnKTtcbnJlcXVpcmUoJ2ppaS1hci1zcWwnKTtcblxudmFyIGFwcCA9IEppaS5uYW1lc3BhY2UoJ2FwcCcpO1xuXG5yZXF1aXJlKCcuLi9tb2RlbHMvRGVtb1JvdycpO1xuXG4kKGZ1bmN0aW9uICgpIHtcblxuICAgIEppaS5jcmVhdGVXZWJBcHBsaWNhdGlvbihKaWkubWVyZ2VDb25maWdzKHtcbiAgICAgICAgYXBwbGljYXRpb246IHtcbiAgICAgICAgICAgIGJhc2VQYXRoOiAnLycsXG4gICAgICAgICAgICBjb21wb25lbnRzOiB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQG5hbWUgSmlpLmFwcC5jb21ldFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtKaWkuY29tZXQuY2xpZW50LkNsaWVudH1cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb21ldDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdKaWkuY29tZXQuY2xpZW50LkNsaWVudCcsXG4gICAgICAgICAgICAgICAgICAgIHNlcnZlclVybDogJ2h0dHA6Ly8xMjcuMC4wLjE6MzEwMC9zdGF0L25vZGUtY29tZXQvMC8nXG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEBuYW1lIEppaS5hcHAubmVhdFxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnR9XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbmVhdDoge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdKaWkuY29tZXQuY2xpZW50Lk5lYXRDbGllbnQnLFxuICAgICAgICAgICAgICAgICAgICBlbmdpbmU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ05lYXRDb21ldC5OZWF0Q29tZXRDbGllbnQnXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQG5hbWUgSmlpLmFwcC5kYlxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHtKaWkuc3FsLnJlbW90ZS5Db25uZWN0aW9ufVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGRiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0ppaS5zcWwucmVtb3RlLkNvbm5lY3Rpb24nLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ0ppaS5zcWwucmVtb3RlLlNjaGVtYSdcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHdpbmRvdy5KSUlfQ09ORklHKSkuc3RhcnQoKTtcblxuICAgIHZhciBwcm9maWxlID0gSmlpLmFwcC5uZWF0Lm9wZW5Qcm9maWxlKCd0ZXN0Jywge1xuICAgICAgICBjYXRlZ29yeTogJ24nLFxuICAgICAgICBmaWx0ZXI6ICdubidcbiAgICB9KTtcblxuICAgIHByb2ZpbGUuZ2V0Q29sbGVjdGlvbignYWxsJykub24oSmlpLmJhc2UuQ29sbGVjdGlvbi5FVkVOVF9DSEFOR0UsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBKaWkuXy5lYWNoKGV2ZW50LmFkZGVkLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICQoJycgK1xuICAgICAgICAgICAgICAgICc8dHIgZGF0YS1pZD1cIicgKyBtb2RlbC5nZXQoJ2lkJykgKyAnXCI+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgbW9kZWwuZ2V0KCdpZCcpICsgJzwvdGQ+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD48aW5wdXQgY2xhc3M9XCJmb3JtLWNvbnRyb2xcIiB2YWx1ZT1cIicgKyBtb2RlbC5nZXQoJ3N1YmplY3QnKSArICdcIiAvPjwvdGQ+JyArXG4gICAgICAgICAgICAgICAgJzx0ZD4nICsgbW9kZWwuZ2V0KCdraW5kJykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPicgKyBtb2RlbC5nZXQoJ2NhdGVnb3J5JykgKyAnPC90ZD4nICtcbiAgICAgICAgICAgICAgICAnPHRkPjxhIGhyZWY9XCIjXCIgY2xhc3M9XCJidG4tcmVtb3ZlXCI+eDwvYT48L3RkPicgK1xuICAgICAgICAgICAgICAgICc8L3RyPidcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAuYXBwZW5kVG8oJCgnI2RlbW8tcm93cyB0Ym9keScpKVxuICAgICAgICAgICAgICAgIC5vbignY2hhbmdlJywgJ2lucHV0JywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoJ3N1YmplY3QnLCAkKHRoaXMpLnZhbCgpKTtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2F2ZSgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLm9uKCdjbGljaycsICdhLmJ0bi1yZW1vdmUnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgSmlpLl8uZWFjaChldmVudC5yZW1vdmVkLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICQoJyNkZW1vLXJvd3MgdGJvZHknKS5maW5kKCdbZGF0YS1pZD0nICsgbW9kZWwuZ2V0KCdpZCcpICsgJ10nKS5yZW1vdmUoKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICB2YXIgZm9ybSA9ICQoJyNkZW1vLWZvcm0nKTtcblxuICAgIHZhciByYW5kVmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3JtLmZpbmQoJ1tuYW1lPXN1YmplY3RdJykudmFsKEppaS5fLnJhbmRvbSgxLCAxMDApKTtcbiAgICAgICAgZm9ybS5maW5kKCdbbmFtZT1jYXRlZ29yeV0nKS52YWwoSmlpLl8ucmFuZG9tKDEsIDkpKTtcbiAgICAgICAgZm9ybS5maW5kKCdbbmFtZT1raW5kXScpLnZhbChKaWkuXy5yYW5kb20oMSwgOSkpO1xuICAgIH1cbiAgICByYW5kVmFsdWVzKCk7XG5cbiAgICBmb3JtLm9uKCdzdWJtaXQnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgbmV3IGFwcC5tb2RlbHMuRGVtb1Jvdyh7XG4gICAgICAgICAgICBzdWJqZWN0OiBmb3JtLmZpbmQoJ1tuYW1lPXN1YmplY3RdJykudmFsKCksXG4gICAgICAgICAgICBjYXRlZ29yeTogZm9ybS5maW5kKCdbbmFtZT1jYXRlZ29yeV0nKS52YWwoKSxcbiAgICAgICAgICAgIGtpbmQ6IGZvcm0uZmluZCgnW25hbWU9a2luZF0nKS52YWwoKVxuICAgICAgICB9KS5zYXZlKCk7XG5cbiAgICAgICAgcmFuZFZhbHVlcygpO1xuICAgIH0pO1xuXG59KTtcbn0se1wiLi4vbW9kZWxzL0RlbW9Sb3dcIjo5NSxcImppaS1hci1zcWxcIjo5LFwiamlpLWNvbWV0L25lYXRcIjoyOSxcImppaS1jb21ldC9zb2NranNcIjo5MyxcImppaS9kZXBzXCI6MTIzfV0sOTU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXHJcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuLyoqXHJcbiAqIEBuYW1lc3BhY2UgSmlpXHJcbiAqIEBpZ25vcmVcclxuICovXHJcbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgYXBwLm1vZGVscy5EZW1vUm93XHJcbiAqIEBleHRlbmRzIEppaS5zcWwuQWN0aXZlUmVjb3JkXHJcbiAqL1xyXG5KaWkuZGVmaW5lQ2xhc3MoJ2FwcC5tb2RlbHMuRGVtb1JvdycsIC8qKiBAbGVuZHMgYXBwLm1vZGVscy5EZW1vUm93LnByb3RvdHlwZSAqL3tcclxuXHJcblx0X19leHRlbmRzOiBKaWkuc3FsLkFjdGl2ZVJlY29yZCxcclxuXHJcblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmNvbWV0LnNlcnZlci5IdWJTZXJ2ZXIgKi97XHJcblxyXG4gICAgICAgIHRhYmxlTmFtZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gJ2VwX2NvbWV0X3NhbXBsZV9kZW1vX3Jvd3MnO1xyXG4gICAgICAgIH1cclxuXHJcblx0fSxcclxuXHJcbiAgICBydWxlczogZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgW1snc3ViamVjdCddLCAnc3RyaW5nJywge21heDogMjU1fV0sXHJcbiAgICAgICAgICAgIFtbJ2NhdGVnb3J5JywgJ2tpbmQnXSwgJ3N0cmluZycsIHttYXg6IDF9XVxyXG4gICAgICAgIF07XHJcbiAgICB9XHJcblxyXG59KTtcclxuXG59LHtcImppaVwiOjEyNH1dLDk2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxuJ3VzZSBzdHJpY3QnO1xuXG5yZXF1aXJlKCdqaWknKTtcblxuLy8gTG9hZCBmcmFtZXdvcmsgZmlsZXNcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQWN0aXZlUmVjb3JkJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0NvbGxlY3Rpb24nKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvRGF0YVByb3ZpZGVyJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsQXR0cmlidXRlU2NoZW1hJyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZGVsU2NoZW1hJyk7XG5yZXF1aXJlKCcuL2xpYi9tb2RlbC9BcnJheURhdGFQcm92aWRlcicpO1xucmVxdWlyZSgnLi9saWIvbW9kZWwvQ2hhbmdlQXR0cmlidXRlRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL21vZGVsL0NoYW5nZUV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9tb2RlbC9Db2xsZWN0aW9uRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL21vZGVsL0xpbmtNb2RlbEV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL0Jvb2xlYW5WYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvQ29tcGFyZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9EYXRlVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL0RlZmF1bHRWYWx1ZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9FbWFpbFZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9GaWx0ZXJWYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvSW5saW5lVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL051bWJlclZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SYW5nZVZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SZWd1bGFyRXhwcmVzc2lvblZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9SZXF1aXJlZFZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9TYWZlVmFsaWRhdG9yJyk7XG5yZXF1aXJlKCcuL2xpYi92YWxpZGF0b3JzL1N0cmluZ1ZhbGlkYXRvcicpO1xucmVxdWlyZSgnLi9saWIvdmFsaWRhdG9ycy9VcmxWYWxpZGF0b3InKTtcbnJlcXVpcmUoJy4vbGliL3ZhbGlkYXRvcnMvVmFsaWRhdG9yJyk7XG59LHtcIi4vbGliL2Jhc2UvQWN0aXZlUmVjb3JkXCI6OTcsXCIuL2xpYi9iYXNlL0NvbGxlY3Rpb25cIjo5OCxcIi4vbGliL2Jhc2UvRGF0YVByb3ZpZGVyXCI6OTksXCIuL2xpYi9iYXNlL01vZGVsXCI6MTAwLFwiLi9saWIvYmFzZS9Nb2RlbEF0dHJpYnV0ZVNjaGVtYVwiOjEwMSxcIi4vbGliL2Jhc2UvTW9kZWxTY2hlbWFcIjoxMDIsXCIuL2xpYi9tb2RlbC9BcnJheURhdGFQcm92aWRlclwiOjEwMyxcIi4vbGliL21vZGVsL0NoYW5nZUF0dHJpYnV0ZUV2ZW50XCI6MTA0LFwiLi9saWIvbW9kZWwvQ2hhbmdlRXZlbnRcIjoxMDUsXCIuL2xpYi9tb2RlbC9Db2xsZWN0aW9uRXZlbnRcIjoxMDYsXCIuL2xpYi9tb2RlbC9MaW5rTW9kZWxFdmVudFwiOjEwNyxcIi4vbGliL3ZhbGlkYXRvcnMvQm9vbGVhblZhbGlkYXRvclwiOjEwOCxcIi4vbGliL3ZhbGlkYXRvcnMvQ29tcGFyZVZhbGlkYXRvclwiOjEwOSxcIi4vbGliL3ZhbGlkYXRvcnMvRGF0ZVZhbGlkYXRvclwiOjExMCxcIi4vbGliL3ZhbGlkYXRvcnMvRGVmYXVsdFZhbHVlVmFsaWRhdG9yXCI6MTExLFwiLi9saWIvdmFsaWRhdG9ycy9FbWFpbFZhbGlkYXRvclwiOjExMixcIi4vbGliL3ZhbGlkYXRvcnMvRmlsdGVyVmFsaWRhdG9yXCI6MTEzLFwiLi9saWIvdmFsaWRhdG9ycy9JbmxpbmVWYWxpZGF0b3JcIjoxMTQsXCIuL2xpYi92YWxpZGF0b3JzL051bWJlclZhbGlkYXRvclwiOjExNSxcIi4vbGliL3ZhbGlkYXRvcnMvUmFuZ2VWYWxpZGF0b3JcIjoxMTYsXCIuL2xpYi92YWxpZGF0b3JzL1JlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdG9yXCI6MTE3LFwiLi9saWIvdmFsaWRhdG9ycy9SZXF1aXJlZFZhbGlkYXRvclwiOjExOCxcIi4vbGliL3ZhbGlkYXRvcnMvU2FmZVZhbGlkYXRvclwiOjExOSxcIi4vbGliL3ZhbGlkYXRvcnMvU3RyaW5nVmFsaWRhdG9yXCI6MTIwLFwiLi9saWIvdmFsaWRhdG9ycy9VcmxWYWxpZGF0b3JcIjoxMjEsXCIuL2xpYi92YWxpZGF0b3JzL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDk3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vTW9kZWwnKTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIEBjbGFzcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmRcbiAqIEBleHRlbmRzIEppaS5iYXNlLk1vZGVsXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuQWN0aXZlUmVjb3JkJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuTW9kZWwsXG5cdFxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5BY3RpdmVSZWNvcmQgKi97XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjaW5pdFxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLkV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSByZWNvcmQgaXMgaW5pdGlhbGl6ZWQgdmlhIFtbaW5pdCgpXV0uXG4gICAgICAgICAqL1xuXHRcdEVWRU5UX0lOSVQ6ICdpbml0JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNhZnRlckZpbmRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdGhlIHJlY29yZCBpcyBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQgd2l0aCBxdWVyeSByZXN1bHQuXG4gICAgICAgICAqL1xuXHRcdEVWRU5UX0FGVEVSX0ZJTkQ6ICdhZnRlckZpbmQnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBZb3UgbWF5IHNldCBbW0ppaS5iYXNlLk1vZGVsRXZlbnQuaXNWYWxpZF1dIHRvIGJlIGZhbHNlIHRvIHN0b3AgdGhlIGluc2VydGlvbi5cbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNiZWZvcmVJbnNlcnRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5Nb2RlbEV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBiZWZvcmUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuICAgICAgICAgKi9cblx0XHRFVkVOVF9CRUZPUkVfSU5TRVJUOiAnYmVmb3JlSW5zZXJ0JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogRXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSByZWNvcmQgaXMgaW5zZXJ0ZWQuXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjYWZ0ZXJJbnNlcnRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9BRlRFUl9JTlNFUlQ6ICdhZnRlckluc2VydCcsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFlvdSBtYXkgc2V0IFtbTW9kZWxFdmVudC5pc1ZhbGlkXV0gdG8gYmUgZmFsc2UgdG8gc3RvcCB0aGUgdXBkYXRlLlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2JlZm9yZVVwZGF0ZVxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLk1vZGVsRXZlbnR9IGV2ZW50IGFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJlZm9yZSB1cGRhdGluZyBhIHJlY29yZC5cbiAgICAgICAgICovXG5cdFx0RVZFTlRfQkVGT1JFX1VQREFURTogJ2JlZm9yZVVwZGF0ZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjYWZ0ZXJVcGRhdGVcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuc3FsLkFmdGVyU2F2ZUV2ZW50fSBldmVudCBhbiBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCBhZnRlciBhIHJlY29yZCBpcyB1cGRhdGVkLlxuICAgICAgICAgKi9cblx0XHRFVkVOVF9BRlRFUl9VUERBVEU6ICdhZnRlclVwZGF0ZScsXG5cblx0XHQvKipcbiAgICAgICAgICogWW91IG1heSBzZXQgW1tNb2RlbEV2ZW50LmlzVmFsaWRdXSB0byBiZSBmYWxzZSB0byBzdG9wIHRoZSBkZWxldGlvbi5cbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkFjdGl2ZVJlY29yZCNiZWZvcmVEZWxldGVcblx0XHQgKiBAcHJvcGVydHkge0ppaS5iYXNlLk1vZGVsRXZlbnR9IGV2ZW50IGFuIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIGJlZm9yZSBkZWxldGluZyBhIHJlY29yZC5cblx0XHQgKi9cblx0XHRFVkVOVF9CRUZPUkVfREVMRVRFOiAnYmVmb3JlRGVsZXRlJyxcblxuXHRcdC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2FmdGVyRGVsZXRlXG5cdFx0ICogQHByb3BlcnR5IHtKaWkuYmFzZS5FdmVudH0gZXZlbnQgYW4gZXZlbnQgdGhhdCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgYSByZWNvcmQgaXMgZGVsZXRlZC5cblx0XHQgKi9cblx0XHRFVkVOVF9BRlRFUl9ERUxFVEU6ICdhZnRlckRlbGV0ZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjbGlua1xuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5tb2RlbC5MaW5rTW9kZWxFdmVudH0gZXZlbnRcbiAgICAgICAgICovXG5cdFx0RVZFTlRfTElOSzogJ2xpbmsnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI2xpbms6XG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9MSU5LX05BTUU6ICdsaW5rOicsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5BY3RpdmVSZWNvcmQjdW5saW5rXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50fSBldmVudFxuICAgICAgICAgKi9cblx0XHRFVkVOVF9VTkxJTks6ICd1bmxpbmsnLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQWN0aXZlUmVjb3JkI3VubGluazpcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuTGlua01vZGVsRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuXHRcdEVWRU5UX1VOTElOS19OQU1FOiAndW5saW5rOicsXG5cbiAgICAgICAgX21vZGVsU2NoZW1hOiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7e319XG4gICAgICAgICAqL1xuICAgICAgICBtb2RlbFNjaGVtYTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtKaWkuc3FsLlRhYmxlU2NoZW1hfVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0VGFibGVTY2hlbWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX21vZGVsU2NoZW1hID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9kZWxTY2hlbWEgPSB0aGlzLm1vZGVsU2NoZW1hKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoISh0aGlzLl9tb2RlbFNjaGVtYSBpbnN0YW5jZW9mIEppaS5iYXNlLk1vZGVsU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tb2RlbFNjaGVtYSA9IEppaS5iYXNlLk1vZGVsU2NoZW1hLmNyZWF0ZUZyb21PYmplY3QodGhpcy5fbW9kZWxTY2hlbWEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb2RlbFNjaGVtYTtcbiAgICAgICAgfSxcblxuICAgICAgICB0YWJsZU5hbWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0sXG5cblx0XHQvKipcblx0XHQgKiBAaW5oZXJpdGRvY1xuXHRcdCAqIEByZXR1cm5zIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IEFjdGl2ZVJlY29yZCBpbnN0YW5jZSBtYXRjaGluZyB0aGUgY29uZGl0aW9uLCBvciBgbnVsbGAgaWYgbm90aGluZyBtYXRjaGVzLlxuXHRcdCAqL1xuXHRcdGZpbmRPbmU6IGZ1bmN0aW9uIChjb25kaXRpb24pIHtcblx0XHRcdHJldHVybiB0aGlzLl9maW5kQnlDb25kaXRpb24oY29uZGl0aW9uLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQGluaGVyaXRkb2Ncblx0XHQgKiBAcmV0dXJucyB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkW119IGFuIGFycmF5IG9mIEFjdGl2ZVJlY29yZCBpbnN0YW5jZXMsIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vdGhpbmcgbWF0Y2hlcy5cblx0XHQgKi9cblx0XHRmaW5kQWxsOiBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fZmluZEJ5Q29uZGl0aW9uKGNvbmRpdGlvbiwgZmFsc2UpO1xuXHRcdH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICAgICAqL1xuICAgICAgICBmaW5kOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBAdG9kb1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBwcmltYXJ5IGtleSBuYW1lKHMpIGZvciB0aGlzIEFSIGNsYXNzLlxuICAgICAgICAgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHJldHVybiB0aGUgcHJpbWFyeSBrZXkocykgYXMgZGVjbGFyZWRcbiAgICAgICAgICogaW4gdGhlIERCIHRhYmxlIHRoYXQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG4gICAgICAgICAqXG4gICAgICAgICAqIElmIHRoZSBEQiB0YWJsZSBkb2VzIG5vdCBkZWNsYXJlIGFueSBwcmltYXJ5IGtleSwgeW91IHNob3VsZCBvdmVycmlkZVxuICAgICAgICAgKiB0aGlzIG1ldGhvZCB0byByZXR1cm4gdGhlIGF0dHJpYnV0ZXMgdGhhdCB5b3Ugd2FudCB0byB1c2UgYXMgcHJpbWFyeSBrZXlzXG4gICAgICAgICAqIGZvciB0aGlzIEFSIGNsYXNzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYW4gYXJyYXkgc2hvdWxkIGJlIHJldHVybmVkIGV2ZW4gZm9yIGEgdGFibGUgd2l0aCBzaW5nbGUgcHJpbWFyeSBrZXkuXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX0gdGhlIHByaW1hcnkga2V5cyBvZiB0aGUgYXNzb2NpYXRlZCBkYXRhYmFzZSB0YWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHByaW1hcnlLZXk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFRhYmxlU2NoZW1hKCkucHJpbWFyeUtleTtcbiAgICAgICAgfSxcblxuXHRcdC8qKlxuXHRcdCAqIEZpbmRzIEFjdGl2ZVJlY29yZCBpbnN0YW5jZShzKSBieSB0aGUgZ2l2ZW4gY29uZGl0aW9uLlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGludGVybmFsbHkgY2FsbGVkIGJ5IFtbZmluZE9uZSgpXV0gYW5kIFtbZmluZEFsbCgpXV0uXG5cdFx0ICogQHBhcmFtIHsqfSBjb25kaXRpb24gcGxlYXNlIHJlZmVyIHRvIFtbZmluZE9uZSgpXV0gZm9yIHRoZSBleHBsYW5hdGlvbiBvZiB0aGlzIHBhcmFtZXRlclxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gb25lIHdoZXRoZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkIGJ5IFtbZmluZE9uZSgpXV0gb3IgW1tmaW5kQWxsKCldXVxuXHRcdCAqIEByZXR1cm5zIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR8SmlpLmJhc2UuQWN0aXZlUmVjb3JkW119XG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbn0gaWYgdGhlcmUgaXMgbm8gcHJpbWFyeSBrZXkgZGVmaW5lZFxuXHRcdCAqIEBpbnRlcm5hbFxuXHRcdCAqL1xuXHRcdF9maW5kQnlDb25kaXRpb246IGZ1bmN0aW9uIChjb25kaXRpb24sIG9uZSkge1xuXHRcdFx0dmFyIHF1ZXJ5ID0gdGhpcy5maW5kKCk7XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShjb25kaXRpb24pIHx8IEppaS5fLmlzT2JqZWN0KGNvbmRpdGlvbikpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNvbmRpdGlvbik7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJpbWFyeUtleSA9IHRoaXMucHJpbWFyeUtleSgpO1xuXG5cdFx0XHRcdC8vIHF1ZXJ5IGJ5IHByaW1hcnkga2V5XG5cdFx0XHRcdGlmIChwcmltYXJ5S2V5Lmxlbmd0aCA+IDApIHtcblx0XHRcdFx0XHR2YXIgcGsgPSBwcmltYXJ5S2V5WzBdO1xuXHRcdFx0XHRcdGlmICghSmlpLl8uaXNFbXB0eShxdWVyeS5nZXRKb2luKCkpIHx8ICFKaWkuXy5pc0VtcHR5KHF1ZXJ5LmdldEpvaW5XaXRoKCkpKSB7XG5cdFx0XHRcdFx0XHRwayA9IHRoaXMudGFibGVOYW1lKCkgKyAnLicgKyBwaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR2YXIgY29uZGl0aW9uT2JqZWN0ID0ge307XG5cdFx0XHRcdFx0Y29uZGl0aW9uT2JqZWN0W3BrXSA9IGNvbmRpdGlvbjtcblx0XHRcdFx0XHRyZXR1cm4gY29uZGl0aW9uT2JqZWN0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24odGhpcy5jbGFzc05hbWUoKSArICcgbXVzdCBoYXZlIGEgcHJpbWFyeSBrZXkuJyk7XG5cdFx0XHR9LmJpbmQodGhpcykpLnRoZW4oZnVuY3Rpb24oY29uZGl0aW9uKSB7XG5cdFx0XHRcdHF1ZXJ5LmFuZFdoZXJlKGNvbmRpdGlvbik7XG5cblx0XHRcdFx0cmV0dXJuIG9uZSA/IHF1ZXJ5Lm9uZSgpIDogcXVlcnkuYWxsKCk7XG5cdFx0XHR9LmJpbmQodGhpcykpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSB3aG9sZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgYXR0cmlidXRlIHZhbHVlcyBhbmQgY29uZGl0aW9ucy5cblx0XHQgKiBGb3IgZXhhbXBsZSwgdG8gY2hhbmdlIHRoZSBzdGF0dXMgdG8gYmUgMSBmb3IgYWxsIGN1c3RvbWVycyB3aG9zZSBzdGF0dXMgaXMgMjpcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIEN1c3RvbWVyLnVwZGF0ZUFsbCh7c3RhdHVzOiAxfSwgJ3N0YXR1cyA9IDInKTtcblx0XHQgKiB+fn5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHNhdmVkIGludG8gdGhlIHRhYmxlXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZFxuXHRcdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbn0gaWYgbm90IG92ZXJyaWRlZFxuXHRcdCAqL1xuXHRcdHVwZGF0ZUFsbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGNvbmRpdGlvbikge1xuXHRcdFx0Y29uZGl0aW9uID0gY29uZGl0aW9uIHx8ICcnO1xuXG5cdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uKCd1cGRhdGVBbGwoKSBpcyBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBVcGRhdGVzIHRoZSB3aG9sZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgY291bnRlciBjaGFuZ2VzIGFuZCBjb25kaXRpb25zLlxuXHRcdCAqIEZvciBleGFtcGxlLCB0byBpbmNyZW1lbnQgYWxsIGN1c3RvbWVycycgYWdlIGJ5IDEsXG5cdFx0ICpcblx0XHQgKiB+fn5cblx0XHQgKiBDdXN0b21lci51cGRhdGVBbGxDb3VudGVycyh7YWdlOiAxfSk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge1tdfSBjb3VudGVycyB0aGUgY291bnRlcnMgdG8gYmUgdXBkYXRlZCAoYXR0cmlidXRlIG5hbWUgPT4gaW5jcmVtZW50IHZhbHVlKS5cblx0XHQgKiBVc2UgbmVnYXRpdmUgdmFsdWVzIGlmIHlvdSB3YW50IHRvIGRlY3JlbWVudCB0aGUgY291bnRlcnMuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8W119IFtjb25kaXRpb25dIHRoZSBjb25kaXRpb25zIHRoYXQgd2lsbCBiZSBwdXQgaW4gdGhlIFdIRVJFIHBhcnQgb2YgdGhlIFVQREFURSBTUUwuXG5cdFx0ICogUGxlYXNlIHJlZmVyIHRvIFtbUXVlcnkud2hlcmUoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IHRoaXMgcGFyYW1ldGVyLlxuXHRcdCAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdFx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9ufSBpZiBub3Qgb3ZlcnJpZGVkXG5cdFx0ICovXG5cdFx0dXBkYXRlQWxsQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycywgY29uZGl0aW9uKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24oJ3VwZGF0ZUFsbENvdW50ZXJzKCkgaXMgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogRGVsZXRlcyByb3dzIGluIHRoZSB0YWJsZSB1c2luZyB0aGUgcHJvdmlkZWQgY29uZGl0aW9ucy5cblx0XHQgKiBXQVJOSU5HOiBJZiB5b3UgZG8gbm90IHNwZWNpZnkgYW55IGNvbmRpdGlvbiwgdGhpcyBtZXRob2Qgd2lsbCBkZWxldGUgQUxMIHJvd3MgaW4gdGhlIHRhYmxlLlxuXHRcdCAqXG5cdFx0ICogRm9yIGV4YW1wbGUsIHRvIGRlbGV0ZSBhbGwgY3VzdG9tZXJzIHdob3NlIHN0YXR1cyBpcyAzOlxuXHRcdCAqXG5cdFx0ICogfn5+XG5cdFx0ICogQ3VzdG9tZXIuZGVsZXRlQWxsKCdzdGF0dXMgPSAzJyk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xbXX0gW2NvbmRpdGlvbl0gdGhlIGNvbmRpdGlvbnMgdGhhdCB3aWxsIGJlIHB1dCBpbiB0aGUgV0hFUkUgcGFydCBvZiB0aGUgREVMRVRFIFNRTC5cblx0XHQgKiBQbGVhc2UgcmVmZXIgdG8gW1tRdWVyeS53aGVyZSgpXV0gb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdFx0ICogQHBhcmFtIHtbXX0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgKG5hbWUgPT4gdmFsdWUpIHRvIGJlIGJvdW5kIHRvIHRoZSBxdWVyeS5cblx0XHQgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgbnVtYmVyIG9mIHJvd3MgZGVsZXRlZFxuXHRcdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbn0gaWYgbm90IG92ZXJyaWRlZFxuXHRcdCAqL1xuXHRcdGRlbGV0ZUFsbDogZnVuY3Rpb24gKGNvbmRpdGlvbiwgcGFyYW1zKSB7XG5cdFx0XHRjb25kaXRpb24gPSBjb25kaXRpb24gfHwgJyc7XG5cdFx0XHRwYXJhbXMgPSBwYXJhbXMgfHwgW107XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24oJ2RlbGV0ZUFsbCgpIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFBvcHVsYXRlcyBhbiBhY3RpdmUgcmVjb3JkIG9iamVjdCB1c2luZyBhIHJvdyBvZiBkYXRhIGZyb20gdGhlIGRhdGFiYXNlL3N0b3JhZ2UuXG5cdFx0ICpcblx0XHQgKiBUaGlzIGlzIGFuIGludGVybmFsIG1ldGhvZCBtZWFudCB0byBiZSBjYWxsZWQgdG8gY3JlYXRlIGFjdGl2ZSByZWNvcmQgb2JqZWN0cyBhZnRlclxuXHRcdCAqIGZldGNoaW5nIGRhdGEgZnJvbSB0aGUgZGF0YWJhc2UuIEl0IGlzIG1haW5seSB1c2VkIGJ5IFtbQWN0aXZlUXVlcnldXSB0byBwb3B1bGF0ZVxuXHRcdCAqIHRoZSBxdWVyeSByZXN1bHRzIGludG8gYWN0aXZlIHJlY29yZHMuXG5cdFx0ICpcblx0XHQgKiBXaGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgbWFudWFsbHkgeW91IHNob3VsZCBjYWxsIFtbYWZ0ZXJGaW5kKCldXSBvbiB0aGUgY3JlYXRlZFxuXHRcdCAqIHJlY29yZCB0byB0cmlnZ2VyIHRoZSBbW0VWRU5UX0FGVEVSX0ZJTkR8YWZ0ZXJGaW5kIEV2ZW50XV0uXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gcmVjb3JkIHRoZSByZWNvcmQgdG8gYmUgcG9wdWxhdGVkLiBJbiBtb3N0IGNhc2VzIHRoaXMgd2lsbCBiZSBhbiBpbnN0YW5jZVxuXHRcdCAqIGNyZWF0ZWQgYnkgW1tpbnN0YW50aWF0ZSgpXV0gYmVmb3JlaGFuZC5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gcm93IGF0dHJpYnV0ZSB2YWx1ZXMgKG5hbWUgPT4gdmFsdWUpXG5cdFx0ICovXG5cdFx0cG9wdWxhdGVSZWNvcmQ6IGZ1bmN0aW9uIChyZWNvcmQsIHJvdykge1xuXHRcdFx0dmFyIGNvbHVtbnMgPSByZWNvcmQuYXR0cmlidXRlcygpO1xuXG5cdFx0XHRKaWkuXy5lYWNoKHJvdywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRpZiAoSmlpLl8uaW5kZXhPZihjb2x1bW5zLCBuYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZWNvcmQuX2F0dHJpYnV0ZXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChyZWNvcmQuY2FuU2V0UHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRyZWNvcmQuc2V0KG5hbWUsIHZhbHVlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0cmVjb3JkLnNldE9sZEF0dHJpYnV0ZXMoSmlpLl8uY2xvbmUocmVjb3JkLl9hdHRyaWJ1dGVzKSk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIENyZWF0ZXMgYW4gYWN0aXZlIHJlY29yZCBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCB0b2dldGhlciB3aXRoIFtbcG9wdWxhdGVSZWNvcmQoKV1dIGJ5IFtbQWN0aXZlUXVlcnldXS5cblx0XHQgKiBJdCBpcyBub3QgbWVhbnQgdG8gYmUgdXNlZCBmb3IgY3JlYXRpbmcgbmV3IHJlY29yZHMoKSBkaXJlY3RseS5cblx0XHQgKlxuXHRcdCAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgaWYgdGhlIGluc3RhbmNlIGJlaW5nIGNyZWF0ZWRcblx0XHQgKiBkZXBlbmRzIG9uIHRoZSByb3cgZGF0YSB0byBiZSBwb3B1bGF0ZWQgaW50byB0aGUgcmVjb3JkLlxuXHRcdCAqIEZvciBleGFtcGxlLCBieSBjcmVhdGluZyBhIHJlY29yZCBiYXNlZCBvbiB0aGUgdmFsdWUgb2YgYSBjb2x1bW4sXG5cdFx0ICogeW91IG1heSBpbXBsZW1lbnQgdGhlIHNvLWNhbGxlZCBzaW5nbGUtdGFibGUgaW5oZXJpdGFuY2UgbWFwcGluZy5cblx0XHQgKiBAcGFyYW0ge29iamVjdH0gcm93IHJvdyBkYXRhIHRvIGJlIHBvcHVsYXRlZCBpbnRvIHRoZSByZWNvcmQuXG5cdFx0ICogQHJldHVybnMge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gdGhlIG5ld2x5IGNyZWF0ZWQgYWN0aXZlIHJlY29yZFxuXHRcdCAqL1xuXHRcdGluc3RhbnRpYXRlOiBmdW5jdGlvbiAocm93KSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMoKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgZ2l2ZW4gc2V0IG9mIGF0dHJpYnV0ZXMgcmVwcmVzZW50cyB0aGUgcHJpbWFyeSBrZXkgZm9yIHRoaXMgbW9kZWxcblx0XHQgKiBAcGFyYW0ge1tdfSBrZXlzIHRoZSBzZXQgb2YgYXR0cmlidXRlcyB0byBjaGVja1xuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBnaXZlbiBzZXQgb2YgYXR0cmlidXRlcyByZXByZXNlbnRzIHRoZSBwcmltYXJ5IGtleSBmb3IgdGhpcyBtb2RlbFxuXHRcdCAqL1xuXHRcdGlzUHJpbWFyeUtleTogZnVuY3Rpb24gKGtleXMpIHtcblx0XHRcdHZhciBwa3MgPSB0aGlzLnByaW1hcnlLZXkoKTtcblxuXHRcdFx0aWYgKGtleXMubGVuZ3RoICE9PSBKaWkuXy5zaXplKHBrcykpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuICAgICAgICAgICAgcmV0dXJuICghSmlpLl8uaXNBcnJheShwa3MpID8gSmlpLl8ua2V5cyhwa3MpIDogcGtzKS5zb3J0KCkudG9TdHJpbmcoKSA9PT0ga2V5cy5zb3J0KCkudG9TdHJpbmcoKTtcblx0XHR9XG5cblx0fSxcblxuXHQvKipcblx0ICogQHR5cGUge29iamVjdH0gcmVsYXRlZCBtb2RlbHMgaW5kZXhlZCBieSB0aGUgcmVsYXRpb24gbmFtZXNcblx0ICovXG5cdF9yZWxhdGVkOiB7fSxcblxuXHQvKipcblx0ICogQHR5cGUge29iamVjdH1cblx0ICovXG5cdF9yZWxhdGVkTGF6eUV2ZW50czoge30sXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtvYmplY3R8bnVsbH0gb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgaW5kZXhlZCBieSBhdHRyaWJ1dGUgbmFtZXMuXG5cdCAqIFRoaXMgaXMgYG51bGxgIGlmIHRoZSByZWNvcmQgW1tpc05ld1JlY29yZHxpcyBuZXddXS5cblx0ICovXG5cdF9vbGRBdHRyaWJ1dGVzOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBJbml0aWFsaXplcyB0aGUgb2JqZWN0LlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiB0aGUgY29uc3RydWN0b3IuXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgdHJpZ2dlciBhbiBbW0VWRU5UX0lOSVRdXSBldmVudC5cblx0ICogSWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLCBtYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBhdCB0aGUgZW5kXG5cdCAqIHRvIGVuc3VyZSB0cmlnZ2VyaW5nIG9mIHRoZSBldmVudC5cblx0ICovXG5cdGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9JTklUKTtcblxuXHRcdHRoaXMuX19zdXBlcigpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBhIGBoYXMtb25lYCByZWxhdGlvbi5cblx0ICogVGhlIGRlY2xhcmF0aW9uIGlzIHJldHVybmVkIGluIHRlcm1zIG9mIGEgcmVsYXRpb25hbCBbW0FjdGl2ZVF1ZXJ5XV0gaW5zdGFuY2Vcblx0ICogdGhyb3VnaCB3aGljaCB0aGUgcmVsYXRlZCByZWNvcmQgY2FuIGJlIHF1ZXJpZWQgYW5kIHJldHJpZXZlZCBiYWNrLlxuXHQgKlxuXHQgKiBBIGBoYXMtb25lYCByZWxhdGlvbiBtZWFucyB0aGF0IHRoZXJlIGlzIGF0IG1vc3Qgb25lIHJlbGF0ZWQgcmVjb3JkIG1hdGNoaW5nXG5cdCAqIHRoZSBjcml0ZXJpYSBzZXQgYnkgdGhpcyByZWxhdGlvbiwgZS5nLiwgYSBjdXN0b21lciBoYXMgb25lIGNvdW50cnkuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byBkZWNsYXJlIHRoZSBgY291bnRyeWAgcmVsYXRpb24gZm9yIGBDdXN0b21lcmAgY2xhc3MsIHdlIGNhbiB3cml0ZVxuXHQgKiB0aGUgZm9sbG93aW5nIGNvZGUgaW4gdGhlIGBDdXN0b21lcmAgY2xhc3M6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gZ2V0Q291bnRyeSgpXG5cdCAqIHtcbiAgICAgKiAgICAgcmV0dXJuIHRoaXMuaGFzT25lKENvdW50cnkuY2xhc3NOYW1lKCksIHtpZDogJ2NvdW50cnlfaWQnfSk7XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogTm90ZSB0aGF0IGluIHRoZSBhYm92ZSwgdGhlICdpZCcga2V5IGluIHRoZSBgbGlua2AgcGFyYW1ldGVyIHJlZmVycyB0byBhbiBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBpbiB0aGUgcmVsYXRlZCBjbGFzcyBgQ291bnRyeWAsIHdoaWxlIHRoZSAnY291bnRyeV9pZCcgdmFsdWUgcmVmZXJzIHRvIGFuIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIGluIHRoZSBjdXJyZW50IEFSIGNsYXNzLlxuXHQgKlxuXHQgKiBDYWxsIG1ldGhvZHMgZGVjbGFyZWQgaW4gW1tBY3RpdmVRdWVyeV1dIHRvIGZ1cnRoZXIgY3VzdG9taXplIHRoZSByZWxhdGlvbi5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgcmVsYXRlZCByZWNvcmRcblx0ICogQHBhcmFtIHtvYmplY3R9IGxpbmsgdGhlIHByaW1hcnktZm9yZWlnbiBrZXkgY29uc3RyYWludC4gVGhlIGtleXMgb2YgdGhlIGFycmF5IHJlZmVyIHRvXG5cdCAqIHRoZSBhdHRyaWJ1dGVzIG9mIHRoZSByZWNvcmQgYXNzb2NpYXRlZCB3aXRoIHRoZSBgY2xhc3NgIG1vZGVsLCB3aGlsZSB0aGUgdmFsdWVzIG9mIHRoZVxuXHQgKiBhcnJheSByZWZlciB0byB0aGUgY29ycmVzcG9uZGluZyBhdHRyaWJ1dGVzIGluICoqdGhpcyoqIEFSIGNsYXNzLlxuXHQgKiBAcmV0dXJucyB7SmlpLnNxbC5BY3RpdmVRdWVyeX0gdGhlIHJlbGF0aW9uYWwgcXVlcnkgb2JqZWN0LlxuXHQgKi9cblx0aGFzT25lOiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBsaW5rKSB7XG5cdFx0LyoqIEB0eXBlZGVmIHtKaWkuc3FsLkFjdGl2ZVJlY29yZH0gY2xhc3NPYmplY3QgKi9cblx0XHR2YXIgY2xhc3NPYmplY3QgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cblx0XHQvKiogQHR5cGVkZWYge0ppaS5kYXRhLkFjdGl2ZVF1ZXJ5fSBxdWVyeSAqL1xuXHRcdHZhciBxdWVyeSA9IGNsYXNzT2JqZWN0LmZpbmQoKTtcblx0XHRxdWVyeS5wcmltYXJ5TW9kZWwgPSB0aGlzO1xuXHRcdHF1ZXJ5LmxpbmsgPSBsaW5rO1xuXHRcdHF1ZXJ5Lm11bHRpcGxlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHF1ZXJ5O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBhIGBoYXMtbWFueWAgcmVsYXRpb24uXG5cdCAqIFRoZSBkZWNsYXJhdGlvbiBpcyByZXR1cm5lZCBpbiB0ZXJtcyBvZiBhIHJlbGF0aW9uYWwgW1tBY3RpdmVRdWVyeV1dIGluc3RhbmNlXG5cdCAqIHRocm91Z2ggd2hpY2ggdGhlIHJlbGF0ZWQgcmVjb3JkIGNhbiBiZSBxdWVyaWVkIGFuZCByZXRyaWV2ZWQgYmFjay5cblx0ICpcblx0ICogQSBgaGFzLW1hbnlgIHJlbGF0aW9uIG1lYW5zIHRoYXQgdGhlcmUgYXJlIG11bHRpcGxlIHJlbGF0ZWQgcmVjb3JkcyBtYXRjaGluZ1xuXHQgKiB0aGUgY3JpdGVyaWEgc2V0IGJ5IHRoaXMgcmVsYXRpb24sIGUuZy4sIGEgY3VzdG9tZXIgaGFzIG1hbnkgb3JkZXJzLlxuXHQgKlxuXHQgKiBGb3IgZXhhbXBsZSwgdG8gZGVjbGFyZSB0aGUgYG9yZGVyc2AgcmVsYXRpb24gZm9yIGBDdXN0b21lcmAgY2xhc3MsIHdlIGNhbiB3cml0ZVxuXHQgKiB0aGUgZm9sbG93aW5nIGNvZGUgaW4gdGhlIGBDdXN0b21lcmAgY2xhc3M6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gZ2V0T3JkZXJzKClcblx0ICoge1xuXHRcdCAqICAgICByZXR1cm4gdGhpcy5oYXNNYW55KE9yZGVyLmNsYXNzTmFtZSgpLCB7Y3VzdG9tZXJfaWQ6ICdpZCd9KTtcblx0XHQgKiB9XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaW4gdGhlIGFib3ZlLCB0aGUgJ2N1c3RvbWVyX2lkJyBrZXkgaW4gdGhlIGBsaW5rYCBwYXJhbWV0ZXIgcmVmZXJzIHRvXG5cdCAqIGFuIGF0dHJpYnV0ZSBuYW1lIGluIHRoZSByZWxhdGVkIGNsYXNzIGBPcmRlcmAsIHdoaWxlIHRoZSAnaWQnIHZhbHVlIHJlZmVycyB0b1xuXHQgKiBhbiBhdHRyaWJ1dGUgbmFtZSBpbiB0aGUgY3VycmVudCBBUiBjbGFzcy5cblx0ICpcblx0ICogQ2FsbCBtZXRob2RzIGRlY2xhcmVkIGluIFtbQWN0aXZlUXVlcnldXSB0byBmdXJ0aGVyIGN1c3RvbWl6ZSB0aGUgcmVsYXRpb24uXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIGNsYXNzIG5hbWUgb2YgdGhlIHJlbGF0ZWQgcmVjb3JkXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsaW5rIHRoZSBwcmltYXJ5LWZvcmVpZ24ga2V5IGNvbnN0cmFpbnQuIFRoZSBrZXlzIG9mIHRoZSBhcnJheSByZWZlciB0b1xuXHQgKiB0aGUgYXR0cmlidXRlcyBvZiB0aGUgcmVjb3JkIGFzc29jaWF0ZWQgd2l0aCB0aGUgYGNsYXNzYCBtb2RlbCwgd2hpbGUgdGhlIHZhbHVlcyBvZiB0aGVcblx0ICogYXJyYXkgcmVmZXIgdG8gdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlcyBpbiAqKnRoaXMqKiBBUiBjbGFzcy5cblx0ICogQHJldHVybnMge0ppaS5zcWwuQWN0aXZlUXVlcnl9IHRoZSByZWxhdGlvbmFsIHF1ZXJ5IG9iamVjdC5cblx0ICovXG5cdGhhc01hbnk6IGZ1bmN0aW9uIChjbGFzc05hbWUsIGxpbmspIHtcblx0XHQvKiogQHR5cGUge2NsYXNzfSBBY3RpdmVSZWNvcmRJbnRlcmZhY2UgKi9cblx0XHR2YXIgY2xhc3NPYmplY3QgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cblx0XHQvKiogQHR5cGUge0ppaS5zcWwuQWN0aXZlUXVlcnl9ICovXG5cdFx0dmFyIHF1ZXJ5ID0gY2xhc3NPYmplY3QuZmluZCgpO1xuXHRcdHF1ZXJ5LnByaW1hcnlNb2RlbCA9IHRoaXM7XG5cdFx0cXVlcnkubGluayA9IGxpbms7XG5cdFx0cXVlcnkubXVsdGlwbGUgPSB0cnVlO1xuXHRcdHJldHVybiBxdWVyeTtcblx0fSxcblxuXHRsb2FkOiBmdW5jdGlvbihuYW1lKSB7XG5cdFx0aWYgKHRoaXMuX3JlbGF0ZWRbbmFtZV0pIHtcblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fcmVsYXRlZFtuYW1lXSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblx0XHRpZiAocmVsYXRpb24gaW5zdGFuY2VvZiBKaWkuc3FsLkFjdGl2ZVF1ZXJ5KSB7XG5cdFx0XHRyZXR1cm4gcmVsYXRpb24uZmluZEZvcihuYW1lLCB0aGlzKS50aGVuKGZ1bmN0aW9uKG1vZGVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgcmVsYXRpb24ubXVsdGlwbGUgPyBuZXcgSmlpLmJhc2UuQ29sbGVjdGlvbihtb2RlbHMsIHttb2RlbENsYXNzOiByZWxhdGlvbi5tb2RlbENsYXNzfSkgOiBtb2RlbHMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fcmVsYXRlZFtuYW1lXTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlbGF0aW9uO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBQb3B1bGF0ZXMgdGhlIG5hbWVkIHJlbGF0aW9uIHdpdGggdGhlIHJlbGF0ZWQgcmVjb3Jkcy5cblx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRvZXMgbm90IGNoZWNrIGlmIHRoZSByZWxhdGlvbiBleGlzdHMgb3Igbm90LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcmVsYXRpb24gbmFtZSAoY2FzZS1zZW5zaXRpdmUpXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfEppaS5iYXNlLkFjdGl2ZVJlY29yZFtdfG51bGx9IHJlY29yZHMgdGhlIHJlbGF0ZWQgcmVjb3JkcyB0byBiZSBwb3B1bGF0ZWQgaW50byB0aGUgcmVsYXRpb24uXG5cdCAqL1xuXHRwb3B1bGF0ZVJlbGF0aW9uOiBmdW5jdGlvbiAobmFtZSwgcmVjb3Jkcykge1xuICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIEppaS5fLmlzQXJyYXkocmVjb3JkcykgPyBuZXcgSmlpLmJhc2UuQ29sbGVjdGlvbihyZWNvcmRzKSA6IHJlY29yZHMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayB3aGV0aGVyIHRoZSBuYW1lZCByZWxhdGlvbiBoYXMgYmVlbiBwb3B1bGF0ZWQgd2l0aCByZWNvcmRzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgcmVsYXRpb24gbmFtZSAoY2FzZS1zZW5zaXRpdmUpXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHJlbGF0aW9uIGhhcyBiZWVuIHBvcHVsYXRlZCB3aXRoIHJlY29yZHMuXG5cdCAqL1xuXHRpc1JlbGF0aW9uUG9wdWxhdGVkOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHJldHVybiBKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYWxsIHBvcHVsYXRlZCByZWxhdGVkIHJlY29yZHMuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IGFuIGFycmF5IG9mIHJlbGF0ZWQgcmVjb3JkcyBpbmRleGVkIGJ5IHJlbGF0aW9uIG5hbWVzLlxuXHQgKi9cblx0Z2V0UmVsYXRlZFJlY29yZHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVsYXRlZDtcblx0fSxcblxuICAgIC8qKlxuICAgICAqIEdldCBhdHRyaWJ1dGUgdmFsdWVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldDogZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGlvbiA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3JlbGF0ZWRbbmFtZV0gJiYgcmVsYXRpb24ubXVsdGlwbGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIG5ldyBKaWkuYmFzZS5Db2xsZWN0aW9uKFtdLCB7bW9kZWxDbGFzczogcmVsYXRpb24ubW9kZWxDbGFzc30pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZWxhdGVkW25hbWVdIHx8IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgYXR0cmlidXRlIHZhbHVlXG4gICAgICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWxhdGVkW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZFtuYW1lXS5zZXQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVsYXRpb24gPSB0aGlzLmdldFJlbGF0aW9uKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW9kZWxzID0gIUppaS5fLmlzQXJyYXkodmFsdWUpID8gW3ZhbHVlXSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRSZWxhdGVkKG5hbWUsIG5ldyBKaWkuYmFzZS5Db2xsZWN0aW9uKG1vZGVscywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxDbGFzczogcmVsYXRpb24ubW9kZWxDbGFzc1xuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9jbGFzcyA9IHJlbGF0aW9uLm1vZGVsQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgLyoqIEB0eXBlZGVmIHtKaWkuc3FsLkFjdGl2ZVJlY29yZH0gbW9kZWwgKi9cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1vZGVsID0gX2NsYXNzLmluc3RhbnRpYXRlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgX2NsYXNzLnBvcHVsYXRlUmVjb3JkKG1vZGVsLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgbW9kZWwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7Kn0gW2RhdGFdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNBcHBlbmRdXG4gICAgICovXG4gICAgb246IGZ1bmN0aW9uKG5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKSB7XG4gICAgICAgIC8vIE11bHRpcGxlIG5hbWVzIHN1cHBvcnRcbiAgICAgICAgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50TmFtZXMobmFtZSk7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2gobmFtZSwgZnVuY3Rpb24obikge1xuICAgICAgICAgICAgICAgIHRoaXMub24obiwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpXG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdWIgbW9kZWxzIHN1cHBvcnQ6IGZvb1swXVxuICAgICAgICB2YXIgY29sbGVjdGlvbkZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdENvbGxlY3Rpb24obmFtZSwgdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRSk7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uRm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgY29sbEV2ZW50TmFtZSA9IGNvbGxlY3Rpb25Gb3JtYXQuc3ViTmFtZSB8fCB0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRTtcbiAgICAgICAgICAgIGNvbGxlY3Rpb25Gb3JtYXQubW9kZWwub24oY29sbEV2ZW50TmFtZSwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb28uYmFyXG4gICAgICAgIHZhciBtb2RlbEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdE1vZGVsKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAobW9kZWxGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbEZvcm1hdC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIG1vZGVsRm9ybWF0Lm1vZGVsLm9uKG1vZGVsRm9ybWF0LnN1Yk5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTGF6eSBzdWJzY3JpYmVcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGVkTGF6eUV2ZW50c1ttb2RlbEZvcm1hdC5uYW1lXSA9IHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW21vZGVsRm9ybWF0Lm5hbWVdIHx8IFtdO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW21vZGVsRm9ybWF0Lm5hbWVdLnB1c2goW21vZGVsRm9ybWF0LnN1Yk5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZWxhdGlvbiBzdXBwb3J0XG4gICAgICAgIHZhciByZWxhdGlvbkZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdFJlbGF0aW9uKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAocmVsYXRpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciByZWxhdGlvbkV2ZW50ID0gcmVsYXRpb25Gb3JtYXQubXVsdGlwbGUgPyBKaWkuYmFzZS5Db2xsZWN0aW9uLkVWRU5UX0NIQU5HRSA6IHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFO1xuICAgICAgICAgICAgaWYgKHJlbGF0aW9uRm9ybWF0Lm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmVsYXRpb25Gb3JtYXQubW9kZWwub24ocmVsYXRpb25FdmVudCwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IHN1YnNjcmliZVxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdID0gdGhpcy5fcmVsYXRlZExhenlFdmVudHNbcmVsYXRpb25Gb3JtYXQubmFtZV0gfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZExhenlFdmVudHNbcmVsYXRpb25Gb3JtYXQubmFtZV0ucHVzaChbcmVsYXRpb25FdmVudCwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihuYW1lLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdXG4gICAgICogQHJldHVybiBib29sZWFuXG4gICAgICovXG4gICAgb2ZmOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgIC8vIE11bHRpcGxlIG5hbWVzIHN1cHBvcnRcbiAgICAgICAgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50TmFtZXMobmFtZSk7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbihuLCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBib29sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1YiBtb2RlbHMgc3VwcG9ydDogZm9vWzBdXG4gICAgICAgIHZhciBjb2xsZWN0aW9uRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0Q29sbGVjdGlvbihuYW1lLCB0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRV9OQU1FKTtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb25Gb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBjb2xsRXZlbnROYW1lID0gY29sbGVjdGlvbkZvcm1hdC5zdWJOYW1lIHx8IHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFO1xuICAgICAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25Gb3JtYXQubW9kZWwub2ZmKGNvbGxFdmVudE5hbWUsIGhhbmRsZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb28uYmFyXG4gICAgICAgIHZhciBtb2RlbEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdE1vZGVsKG5hbWUsIHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpO1xuICAgICAgICBpZiAobW9kZWxGb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChtb2RlbEZvcm1hdC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbEZvcm1hdC5tb2RlbC5vZmYobW9kZWxGb3JtYXQuc3ViTmFtZSwgaGFuZGxlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIExhenkgdW5zdWJzY3JpYmVcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0gPSBKaWkuXy5maWx0ZXIodGhpcy5fcmVsYXRlZExhenlFdmVudHNbbW9kZWxGb3JtYXQubmFtZV0sIGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFyclswXSAhPT0gbW9kZWxGb3JtYXQuc3ViTmFtZSB8fCBhcnJbMV0gIT09IGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbGF0aW9uIHN1cHBvcnRcbiAgICAgICAgdmFyIHJlbGF0aW9uRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0UmVsYXRpb24obmFtZSwgdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0VfTkFNRSk7XG4gICAgICAgIGlmIChyZWxhdGlvbkZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIHJlbGF0aW9uRXZlbnQgPSByZWxhdGlvbkZvcm1hdC5tdWx0aXBsZSA/IEppaS5iYXNlLkNvbGxlY3Rpb24uRVZFTlRfQ0hBTkdFIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0U7XG4gICAgICAgICAgICBpZiAocmVsYXRpb25Gb3JtYXQubW9kZWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVsYXRpb25Gb3JtYXQubW9kZWwub2ZmKHJlbGF0aW9uRXZlbnQsIGhhbmRsZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBMYXp5IHVuc3Vic2NyaWJlXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdID0gSmlpLl8uZmlsdGVyKHRoaXMuX3JlbGF0ZWRMYXp5RXZlbnRzW3JlbGF0aW9uRm9ybWF0Lm5hbWVdLCBmdW5jdGlvbihhcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF0gIT09IHJlbGF0aW9uRXZlbnQgfHwgYXJyWzFdICE9PSBoYW5kbGVyO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUsIGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdXG4gICAgICogQHJldHVybnMge3ttb2RlbDogSmlpLmJhc2UuQWN0aXZlUmVjb3JkfG51bGwsIG5hbWU6IHN0cmluZ318bnVsbH1cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX2RldGVjdEtleUZvcm1hdFJlbGF0aW9uOiBmdW5jdGlvbihuYW1lLCBwcmVmaXgpIHtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gICAgICAgIGlmIChwcmVmaXggJiYgbmFtZS5pbmRleE9mKHByZWZpeCkgIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cihwcmVmaXgubGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuaGFzUmVsYXRpb24obmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG11bHRpcGxlID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3JlbGF0ZWRbbmFtZV0pIHtcbiAgICAgICAgICAgIG11bHRpcGxlID0gdGhpcy5fcmVsYXRlZFtuYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLkNvbGxlY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG11bHRpcGxlID09PSBudWxsKSB7XG4gICAgICAgICAgICBtdWx0aXBsZSA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSkubXVsdGlwbGU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kZWw6IHRoaXMuZ2V0KG5hbWUpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgIG11bHRpcGxlOiBtdWx0aXBsZVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9zZXRSZWxhdGVkOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLl9yZWxhdGVkW25hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgLy8gQXR0YWNoIGxhenkgZXZlbnRzXG4gICAgICAgIEppaS5fLmVhY2godGhpcy5fcmVsYXRlZExhenlFdmVudHNbbmFtZV0gfHwge30sIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbGF0ZWRbbmFtZV0ub24uYXBwbHkodGhpcy5fcmVsYXRlZFtuYW1lXSwgYXJncyk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0xJTkssIG5ldyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnQoe1xuICAgICAgICAgICAgcmVsYXRpb25OYW1lOiBuYW1lXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfTElOS19OQU1FICsgbmFtZSwgbmV3IEppaS5tb2RlbC5MaW5rTW9kZWxFdmVudCh7XG4gICAgICAgICAgICByZWxhdGlvbk5hbWU6IG5hbWVcbiAgICAgICAgfSkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVSZWxhdGVkOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9yZWxhdGVkW25hbWVdO1xuXG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX1VOTElOSywgbmV3IEppaS5tb2RlbC5MaW5rTW9kZWxFdmVudCh7XG4gICAgICAgICAgICByZWxhdGlvbk5hbWU6IG5hbWVcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9VTkxJTktfTkFNRSArIG5hbWUsIG5ldyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnQoe1xuICAgICAgICAgICAgcmVsYXRpb25OYW1lOiBuYW1lXG4gICAgICAgIH0pKTtcbiAgICB9LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdGhhc0F0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIG5hbWUpIHx8IEppaS5fLmluZGV4T2YodGhpcy5hdHRyaWJ1dGVzKCksIG5hbWUpICE9PSAtMTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBvbGQgYXR0cmlidXRlIHZhbHVlcyAobmFtZS12YWx1ZSBwYWlycylcblx0ICovXG5cdGdldE9sZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2xkQXR0cmlidXRlcyB8fCB7fTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMuXG5cdCAqIEFsbCBleGlzdGluZyBvbGQgYXR0cmlidXRlIHZhbHVlcyB3aWxsIGJlIGRpc2NhcmRlZC5cblx0ICogQHBhcmFtIHt7fXxudWxsfSB2YWx1ZXMgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgdG8gYmUgc2V0LlxuXHQgKiBJZiBzZXQgdG8gYG51bGxgIHRoaXMgcmVjb3JkIGlzIGNvbnNpZGVyZWQgdG8gYmUgW1tpc05ld1JlY29yZHxuZXddXS5cblx0ICovXG5cdHNldE9sZEF0dHJpYnV0ZXM6IGZ1bmN0aW9uICh2YWx1ZXMpIHtcblx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvbGQgdmFsdWUgb2YgdGhlIG5hbWVkIGF0dHJpYnV0ZS5cblx0ICogSWYgdGhpcyByZWNvcmQgaXMgdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5IGFuZCB0aGUgYXR0cmlidXRlIGlzIG5vdCBsb2FkZWQsXG5cdCAqIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEByZXR1cm5zIHsqfSB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZS4gTnVsbCBpZiB0aGUgYXR0cmlidXRlIGlzIG5vdCBsb2FkZWQgYmVmb3JlXG5cdCAqIG9yIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAc2VlIGhhc0F0dHJpYnV0ZSgpXG5cdCAqL1xuXHRnZXRPbGRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9vbGRBdHRyaWJ1dGVzLCBuYW1lKSA/IHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBvbGQgdmFsdWUgb2YgdGhlIG5hbWVkIGF0dHJpYnV0ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGF0dHJpYnV0ZSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gdmFsdWUgdGhlIG9sZCBhdHRyaWJ1dGUgdmFsdWUuXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbn0gaWYgdGhlIG5hbWVkIGF0dHJpYnV0ZSBkb2VzIG5vdCBleGlzdC5cblx0ICogQHNlZSBoYXNBdHRyaWJ1dGUoKVxuXHQgKi9cblx0c2V0T2xkQXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpIHx8IHRoaXMuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG5cdFx0XHRpZiAodGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0ge307XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cdFx0fVxuXG5cdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbih0aGlzLmNsYXNzTmFtZSgpICsgJyBoYXMgbm8gYXR0cmlidXRlIG5hbWVkIFwiJyArIG5hbWUgKyAnXCIuJyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1hcmtzIGFuIGF0dHJpYnV0ZSBkaXJ0eS5cblx0ICogVGhpcyBtZXRob2QgbWF5IGJlIGNhbGxlZCB0byBmb3JjZSB1cGRhdGluZyBhIHJlY29yZCB3aGVuIGNhbGxpbmcgW1t1cGRhdGUoKV1dLFxuXHQgKiBldmVuIGlmIHRoZXJlIGlzIG5vIGNoYW5nZSBiZWluZyBtYWRlIHRvIHRoZSByZWNvcmQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKi9cblx0bWFya0F0dHJpYnV0ZURpcnR5OiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdGRlbGV0ZSB0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBuYW1lZCBhdHRyaWJ1dGUgaGFzIGJlZW4gY2hhbmdlZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGF0dHJpYnV0ZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0cmlidXRlIGhhcyBiZWVuIGNoYW5nZWRcblx0ICovXG5cdGlzQXR0cmlidXRlQ2hhbmdlZDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIG5hbWUpICYmIHRoaXMuX29sZEF0dHJpYnV0ZXMgJiYgSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpKSB7XG5cdFx0XHRyZXR1cm4gIUppaS5fLmlzRXF1YWwodGhpcy5fYXR0cmlidXRlc1tuYW1lXSwgdGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9hdHRyaWJ1dGVzLCBuYW1lKSB8fCAodGhpcy5fb2xkQXR0cmlidXRlcyAmJiBKaWkuXy5oYXModGhpcy5fb2xkQXR0cmlidXRlcywgbmFtZSkpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBhdHRyaWJ1dGUgdmFsdWVzIHRoYXQgaGF2ZSBiZWVuIG1vZGlmaWVkIHNpbmNlIHRoZXkgYXJlIGxvYWRlZCBvciBzYXZlZCBtb3N0IHJlY2VudGx5LlxuXHQgKiBAcGFyYW0ge3N0cmluZ1tdfG51bGx9IG5hbWVzIHRoZSBuYW1lcyBvZiB0aGUgYXR0cmlidXRlcyB3aG9zZSB2YWx1ZXMgbWF5IGJlIHJldHVybmVkIGlmIHRoZXkgYXJlXG5cdCAqIGNoYW5nZWQgcmVjZW50bHkuIElmIG51bGwsIFtbYXR0cmlidXRlcygpXV0gd2lsbCBiZSB1c2VkLlxuXHQgKiBAcmV0dXJucyB7b2JqZWN0fSB0aGUgY2hhbmdlZCBhdHRyaWJ1dGUgdmFsdWVzIChuYW1lLXZhbHVlIHBhaXJzKVxuXHQgKi9cblx0Z2V0RGlydHlBdHRyaWJ1dGVzOiBmdW5jdGlvbiAobmFtZXMpIHtcblx0XHRuYW1lcyA9IG5hbWVzIHx8IG51bGw7XG5cblx0XHRpZiAobmFtZXMgPT09IG51bGwpIHtcblx0XHRcdG5hbWVzID0gdGhpcy5hdHRyaWJ1dGVzKCk7XG5cdFx0fVxuXG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB7fTtcblx0XHRKaWkuXy5lYWNoKHRoaXMuX2F0dHJpYnV0ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdGlmIChKaWkuXy5pbmRleE9mKG5hbWVzLCBuYW1lKSA9PT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbCB8fCAhSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpIHx8ICFKaWkuXy5pc0VxdWFsKHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0sIHZhbHVlKSkge1xuXHRcdFx0XHRhdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdH0sXG5cblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbGlzdCBvZiBhbGwgYXR0cmlidXRlIG5hbWVzIG9mIHRoZSBtb2RlbC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gd2lsbCByZXR1cm4gYWxsIGNvbHVtbiBuYW1lcyBvZiB0aGUgdGFibGUgYXNzb2NpYXRlZCB3aXRoIHRoaXMgQVIgY2xhc3MuXG5cdCAqIEByZXR1cm4ge3N0cmluZ1tdfSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcy5cblx0ICovXG5cdGF0dHJpYnV0ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBKaWkuXy5rZXlzKHRoaXMuX19zdGF0aWMuZ2V0VGFibGVTY2hlbWEoKS5jb2x1bW5zKTtcblx0fSxcblxuXHQvKipcblx0ICogU2F2ZXMgdGhlIGN1cnJlbnQgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCB3aWxsIGNhbGwgW1tpbnNlcnQoKV1dIHdoZW4gW1tpc05ld1JlY29yZF1dIGlzIHRydWUsIG9yIFtbdXBkYXRlKCldXVxuXHQgKiB3aGVuIFtbaXNOZXdSZWNvcmRdXSBpcyBmYWxzZS5cblx0ICpcblx0ICogRm9yIGV4YW1wbGUsIHRvIHNhdmUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IG5ldyBDdXN0b21lcigpOyAgLy8gb3IgY3VzdG9tZXIgPSBDdXN0b21lci5maW5kT25lKGlkKTtcblx0ICogY3VzdG9tZXIubmFtZSA9IG5hbWU7XG5cdCAqIGN1c3RvbWVyLmVtYWlsID0gZW1haWw7XG5cdCAqIGN1c3RvbWVyLnNhdmUoKTtcblx0ICogfn5+XG5cdCAqXG5cdCAqXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3J1blZhbGlkYXRpb25dIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgc2F2ZWQgdG8gZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nW119IFthdHRyaWJ1dGVOYW1lc10gbGlzdCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBuZWVkIHRvIGJlIHNhdmVkLiBEZWZhdWx0cyB0byBudWxsLFxuXHQgKiBtZWFuaW5nIGFsbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIGxvYWRlZCBmcm9tIERCIHdpbGwgYmUgc2F2ZWQuXG5cdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBzYXZpbmcgc3VjY2VlZHNcblx0ICovXG5cdHNhdmU6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVOYW1lcykge1xuXHRcdHJ1blZhbGlkYXRpb24gPSBydW5WYWxpZGF0aW9uICE9PSBmYWxzZTtcblx0XHRhdHRyaWJ1dGVOYW1lcyA9IGF0dHJpYnV0ZU5hbWVzIHx8IG51bGw7XG5cblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnQocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy51cGRhdGUocnVuVmFsaWRhdGlvbiwgYXR0cmlidXRlTmFtZXMpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQgIT09IGZhbHNlO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBJbnNlcnRzIHRoZSByZWNvcmQgaW50byB0aGUgZGF0YWJhc2UgdXNpbmcgdGhlIGF0dHJpYnV0ZSB2YWx1ZXMgb2YgdGhpcyByZWNvcmQuXG5cdCAqXG5cdCAqIFVzYWdlIGV4YW1wbGU6XG5cdCAqXG5cdCAqIGBgYHBocFxuXHQgKiAkY3VzdG9tZXIgPSBuZXcgQ3VzdG9tZXI7XG5cdCAqICRjdXN0b21lci0+bmFtZSA9ICRuYW1lO1xuXHQgKiAkY3VzdG9tZXItPmVtYWlsID0gJGVtYWlsO1xuXHQgKiAkY3VzdG9tZXItPmluc2VydCgpO1xuXHQgKiBgYGBcblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBydW5WYWxpZGF0aW9uIHdoZXRoZXIgdG8gcGVyZm9ybSB2YWxpZGF0aW9uIGJlZm9yZSBzYXZpbmcgdGhlIHJlY29yZC5cblx0ICogSWYgdGhlIHZhbGlkYXRpb24gZmFpbHMsIHRoZSByZWNvcmQgd2lsbCBub3QgYmUgaW5zZXJ0ZWQgaW50byB0aGUgZGF0YWJhc2UuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBhdHRyaWJ1dGVOYW1lcyBsaXN0IG9mIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHRvIGJlIHNhdmVkLiBEZWZhdWx0cyB0byBudWxsLFxuXHQgKiBtZWFuaW5nIGFsbCBhdHRyaWJ1dGVzIHRoYXQgYXJlIGxvYWRlZCBmcm9tIERCIHdpbGwgYmUgc2F2ZWQuXG5cdCAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZSBhdHRyaWJ1dGVzIGFyZSB2YWxpZCBhbmQgdGhlIHJlY29yZCBpcyBpbnNlcnRlZCBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRpbnNlcnQ6IGZ1bmN0aW9uIChydW5WYWxpZGF0aW9uLCBhdHRyaWJ1dGVOYW1lcykge1xuXG5cdH0sXG5cblx0LyoqXG5cdCAqIFNhdmVzIHRoZSBjaGFuZ2VzIHRvIHRoaXMgYWN0aXZlIHJlY29yZCBpbnRvIHRoZSBhc3NvY2lhdGVkIGRhdGFiYXNlIHRhYmxlLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlVmFsaWRhdGUoKV1dIHdoZW4gYHJ1blZhbGlkYXRpb25gIGlzIHRydWUuIElmIHZhbGlkYXRpb25cblx0ICogICAgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDIuIGNhbGwgW1thZnRlclZhbGlkYXRlKCldXSB3aGVuIGBydW5WYWxpZGF0aW9uYCBpcyB0cnVlLlxuXHQgKiAzLiBjYWxsIFtbYmVmb3JlU2F2ZSgpXV0uIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBza2lwIHRoZVxuXHQgKiAgICByZXN0IG9mIHRoZSBzdGVwcztcblx0ICogNC4gc2F2ZSB0aGUgcmVjb3JkIGludG8gZGF0YWJhc2UuIElmIHRoaXMgZmFpbHMsIGl0IHdpbGwgc2tpcCB0aGUgcmVzdCBvZiB0aGUgc3RlcHM7XG5cdCAqIDUuIGNhbGwgW1thZnRlclNhdmUoKV1dO1xuXHQgKlxuXHQgKiBJbiB0aGUgYWJvdmUgc3RlcCAxLCAyLCAzIGFuZCA1LCBldmVudHMgW1tFVkVOVF9CRUZPUkVfVkFMSURBVEVdXSxcblx0ICogW1tFVkVOVF9CRUZPUkVfVVBEQVRFXV0sIFtbRVZFTlRfQUZURVJfVVBEQVRFXV0gYW5kIFtbRVZFTlRfQUZURVJfVkFMSURBVEVdXVxuXHQgKiB3aWxsIGJlIHJhaXNlZCBieSB0aGUgY29ycmVzcG9uZGluZyBtZXRob2RzLlxuXHQgKlxuXHQgKiBPbmx5IHRoZSBbW2RpcnR5QXR0cmlidXRlc3xjaGFuZ2VkIGF0dHJpYnV0ZSB2YWx1ZXNdXSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2UuXG5cdCAqXG5cdCAqIEZvciBleGFtcGxlLCB0byB1cGRhdGUgYSBjdXN0b21lciByZWNvcmQ6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBjdXN0b21lciA9IEN1c3RvbWVyLmZpbmRPbmUoaWQpO1xuXHQgKiBjdXN0b21lci5uYW1lID0gbmFtZTtcblx0ICogY3VzdG9tZXIuZW1haWwgPSBlbWFpbDtcblx0ICogY3VzdG9tZXIudXBkYXRlKCk7XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIHVwZGF0ZSBkb2VzIG5vdCBhZmZlY3QgYW55IHJvdyBpbiB0aGUgdGFibGUuXG5cdCAqIEluIHRoaXMgY2FzZSwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gMC4gRm9yIHRoaXMgcmVhc29uLCB5b3Ugc2hvdWxkIHVzZSB0aGUgZm9sbG93aW5nXG5cdCAqIGNvZGUgdG8gY2hlY2sgaWYgdXBkYXRlKCkgaXMgc3VjY2Vzc2Z1bCBvciBub3Q6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBpZiAodGhpcy51cGRhdGUoKSAhPT0gZmFsc2UpIHtcbiAgICAgKiAgICAgLy8gdXBkYXRlIHN1Y2Nlc3NmdWxcbiAgICAgKiB9IGVsc2Uge1xuICAgICAqICAgICAvLyB1cGRhdGUgZmFpbGVkXG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBbcnVuVmFsaWRhdGlvbl0gd2hldGhlciB0byBwZXJmb3JtIHZhbGlkYXRpb24gYmVmb3JlIHNhdmluZyB0aGUgcmVjb3JkLlxuXHQgKiBJZiB0aGUgdmFsaWRhdGlvbiBmYWlscywgdGhlIHJlY29yZCB3aWxsIG5vdCBiZSBpbnNlcnRlZCBpbnRvIHRoZSBkYXRhYmFzZS5cblx0ICogQHBhcmFtIHtzdHJpbmdbXX0gW2F0dHJpYnV0ZU5hbWVzXSBsaXN0IG9mIGF0dHJpYnV0ZSBuYW1lcyB0aGF0IG5lZWQgdG8gYmUgc2F2ZWQuIERlZmF1bHRzIHRvIG51bGwsXG5cdCAqIG1lYW5pbmcgYWxsIGF0dHJpYnV0ZXMgdGhhdCBhcmUgbG9hZGVkIGZyb20gREIgd2lsbCBiZSBzYXZlZC5cblx0ICogQHJldHVybnMge1Byb21pc2UuPG51bWJlcnxib29sZWFuPn0gdGhlIG51bWJlciBvZiByb3dzIGFmZmVjdGVkLCBvciBmYWxzZSBpZiB2YWxpZGF0aW9uIGZhaWxzXG5cdCAqIG9yIFtbYmVmb3JlU2F2ZSgpXV0gc3RvcHMgdGhlIHVwZGF0aW5nIHByb2Nlc3MuXG5cdCAqIEB0aHJvd3MgU3RhbGVPYmplY3RFeGNlcHRpb24gaWYgW1tvcHRpbWlzdGljTG9ja3xvcHRpbWlzdGljIGxvY2tpbmddXSBpcyBlbmFibGVkIGFuZCB0aGUgZGF0YVxuXHQgKiBiZWluZyB1cGRhdGVkIGlzIG91dGRhdGVkLlxuXHQgKiBAdGhyb3dzIFxcRXhjZXB0aW9uIGluIGNhc2UgdXBkYXRlIGZhaWxlZC5cblx0ICovXG5cdHVwZGF0ZTogZnVuY3Rpb24gKHJ1blZhbGlkYXRpb24sIGF0dHJpYnV0ZU5hbWVzKSB7XG5cdFx0cnVuVmFsaWRhdGlvbiA9IHJ1blZhbGlkYXRpb24gIT09IGZhbHNlO1xuXHRcdGF0dHJpYnV0ZU5hbWVzID0gYXR0cmlidXRlTmFtZXMgfHwgbnVsbDtcblxuXHRcdHZhciB2YWxpZGF0ZVByb21pc2UgPSBydW5WYWxpZGF0aW9uID8gdGhpcy52YWxpZGF0ZShhdHRyaWJ1dGVOYW1lcykgOiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdFx0cmV0dXJuIHZhbGlkYXRlUHJvbWlzZS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oaXNWYWxpZCkge1xuXHRcdFx0aWYgKCFpc1ZhbGlkKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHRoaXMuX3VwZGF0ZUludGVybmFsKGF0dHJpYnV0ZU5hbWVzKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFVwZGF0ZXMgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGVzLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBhIHNob3J0Y3V0IHRvIFtbdXBkYXRlKCldXSB3aGVuIGRhdGEgdmFsaWRhdGlvbiBpcyBub3QgbmVlZGVkXG5cdCAqIGFuZCBvbmx5IGEgc21hbGwgc2V0IGF0dHJpYnV0ZXMgbmVlZCB0byBiZSB1cGRhdGVkLlxuXHQgKlxuXHQgKiBZb3UgbWF5IHNwZWNpZnkgdGhlIGF0dHJpYnV0ZXMgdG8gYmUgdXBkYXRlZCBhcyBuYW1lIGxpc3Qgb3IgbmFtZS12YWx1ZSBwYWlycy5cblx0ICogSWYgdGhlIGxhdHRlciwgdGhlIGNvcnJlc3BvbmRpbmcgYXR0cmlidXRlIHZhbHVlcyB3aWxsIGJlIG1vZGlmaWVkIGFjY29yZGluZ2x5LlxuXHQgKiBUaGUgbWV0aG9kIHdpbGwgdGhlbiBzYXZlIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlcyBpbnRvIGRhdGFiYXNlLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2Qgd2lsbCAqKm5vdCoqIHBlcmZvcm0gZGF0YSB2YWxpZGF0aW9uIGFuZCB3aWxsICoqbm90KiogdHJpZ2dlciBldmVudHMuXG5cdCAqXG5cdCAqIEBwYXJhbSB7W119IGF0dHJpYnV0ZXMgdGhlIGF0dHJpYnV0ZXMgKG5hbWVzIG9yIG5hbWUtdmFsdWUgcGFpcnMpIHRvIGJlIHVwZGF0ZWRcblx0ICogQHJldHVybnMge1Byb21pc2UuPG51bWJlcj59IHRoZSBudW1iZXIgb2Ygcm93cyBhZmZlY3RlZC5cblx0ICovXG5cdHVwZGF0ZUF0dHJpYnV0ZXM6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzKSB7XG5cdFx0dmFyIGF0dHJzID0gW107XG5cdFx0SmlpLl8uZWFjaChhdHRyaWJ1dGVzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRpZiAoSmlpLl8uaXNOdW1iZXIobmFtZSkpIHtcblx0XHRcdFx0YXR0cnMucHVzaCh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldChuYW1lLCB2YWx1ZSk7XG5cdFx0XHRcdGF0dHJzLnB1c2gobmFtZSk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0RGlydHlBdHRyaWJ1dGVzKGF0dHJzKTtcblx0XHRpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG5cdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKDApO1xuXHRcdH1cblxuXHRcdHZhciBvbGRQcmltYXJ5S2V5ID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMudXBkYXRlQWxsKHZhbHVlcywgb2xkUHJpbWFyeUtleSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocm93cykge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZhbHVlcywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXNbbmFtZV0gPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuXHRcdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdFx0cmV0dXJuIHJvd3M7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBzZWUgdXBkYXRlKClcblx0ICogQHBhcmFtIHtbXX0gW2F0dHJpYnV0ZXNdIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxudW1iZXI+fSBudW1iZXIgb2Ygcm93cyB1cGRhdGVkXG5cdCAqIEB0aHJvd3MgU3RhbGVPYmplY3RFeGNlcHRpb25cblx0ICovXG5cdF91cGRhdGVJbnRlcm5hbDogZnVuY3Rpb24gKGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXMgfHwgbnVsbDtcblxuXHRcdHZhciB2YWx1ZXMgPSBudWxsO1xuXG5cdFx0cmV0dXJuIHRoaXMuYmVmb3JlU2F2ZShmYWxzZSkudGhlbihmdW5jdGlvbihib29sKSB7XG4gICAgICAgICAgICBpZiAoIWJvb2wpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsdWVzID0gdGhpcy5nZXREaXJ0eUF0dHJpYnV0ZXMoYXR0cmlidXRlcyk7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaXNFbXB0eSh2YWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWZ0ZXJTYXZlKGZhbHNlLCB2YWx1ZXMpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRpYy5nZXREYigpLmNyZWF0ZUNvbW1hbmQoKS51cGRhdGVNb2RlbCh0aGlzLCB2YWx1ZXMpO1xuICAgICAgICB9LmJpbmQodGhpcykpLnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbihyb3dzKSB7XG5cblx0XHRcdHZhciBjaGFuZ2VkQXR0cmlidXRlcyA9IHt9O1xuXHRcdFx0SmlpLl8uZWFjaCh2YWx1ZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdFx0Y2hhbmdlZEF0dHJpYnV0ZXNbbmFtZV0gPSBKaWkuXy5oYXModGhpcy5fb2xkQXR0cmlidXRlcywgbmFtZSkgPyB0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHRcdFx0dGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0fSwgdGhpcykpO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hZnRlclNhdmUoZmFsc2UsIGNoYW5nZWRBdHRyaWJ1dGVzKS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gcm93cztcblx0XHRcdH0pO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlcyBvbmUgb3Igc2V2ZXJhbCBjb3VudGVyIGNvbHVtbnMgZm9yIHRoZSBjdXJyZW50IEFSIG9iamVjdC5cblx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBbW3VwZGF0ZUFsbENvdW50ZXJzKCldXSBpbiB0aGF0IGl0IG9ubHlcblx0ICogc2F2ZXMgY291bnRlcnMgZm9yIHRoZSBjdXJyZW50IEFSIG9iamVjdC5cblx0ICpcblx0ICogQW4gZXhhbXBsZSB1c2FnZSBpcyBhcyBmb2xsb3dzOlxuXHQgKlxuXHQgKiB+fn5cblx0ICogcG9zdCA9IFBvc3QuZmluZE9uZShpZCk7XG5cdCAqIHBvc3QudXBkYXRlQ291bnRlcnMoe3ZpZXdfY291bnQ6IDF9KTtcblx0ICogfn5+XG5cdCAqXG5cdCAqIEBwYXJhbSB7W119IGNvdW50ZXJzIHRoZSBjb3VudGVycyB0byBiZSB1cGRhdGVkIChhdHRyaWJ1dGUgbmFtZSA9PiBpbmNyZW1lbnQgdmFsdWUpXG5cdCAqIFVzZSBuZWdhdGl2ZSB2YWx1ZXMgaWYgeW91IHdhbnQgdG8gZGVjcmVtZW50IHRoZSBjb3VudGVycy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHNhdmluZyBpcyBzdWNjZXNzZnVsXG5cdCAqIEBzZWUgdXBkYXRlQWxsQ291bnRlcnMoKVxuXHQgKi9cblx0dXBkYXRlQ291bnRlcnM6IGZ1bmN0aW9uIChjb3VudGVycykge1xuXHRcdHZhciBvbGRQcmltYXJ5S2V5ID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXHRcdHJldHVybiB0aGlzLl9fc3RhdGljLnVwZGF0ZUFsbENvdW50ZXJzKEppaS5fLmNsb25lKGNvdW50ZXJzKSwgb2xkUHJpbWFyeUtleSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oYWZmZWN0ZWRSb3dzKSB7XG5cdFx0XHRcdGlmIChhZmZlY3RlZFJvd3MgPT09IDApIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdEppaS5fLmVhY2goY291bnRlcnMsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHRcdFx0dGhpcy5fYXR0cmlidXRlc1tuYW1lXSArPSB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzW25hbWVdID0gdGhpcy5fYXR0cmlidXRlc1tuYW1lXTtcblx0XHRcdFx0fS5iaW5kKHRoaXMpKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0XHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogRGVsZXRlcyB0aGUgdGFibGUgcm93IGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBhY3RpdmUgcmVjb3JkLlxuXHQgKlxuXHQgKiBUaGlzIG1ldGhvZCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIHN0ZXBzIGluIG9yZGVyOlxuXHQgKlxuXHQgKiAxLiBjYWxsIFtbYmVmb3JlRGVsZXRlKCldXS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIGZhbHNlLCBpdCB3aWxsIHNraXAgdGhlXG5cdCAqICAgIHJlc3Qgb2YgdGhlIHN0ZXBzO1xuXHQgKiAyLiBkZWxldGUgdGhlIHJlY29yZCBmcm9tIHRoZSBkYXRhYmFzZTtcblx0ICogMy4gY2FsbCBbW2FmdGVyRGVsZXRlKCldXS5cblx0ICpcblx0ICogSW4gdGhlIGFib3ZlIHN0ZXAgMSBhbmQgMywgZXZlbnRzIG5hbWVkIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGFuZCBbW0VWRU5UX0FGVEVSX0RFTEVURV1dXG5cdCAqIHdpbGwgYmUgcmFpc2VkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtudW1iZXJ8Ym9vbGVhbn0gdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQsIG9yIGZhbHNlIGlmIHRoZSBkZWxldGlvbiBpcyB1bnN1Y2Nlc3NmdWwgZm9yIHNvbWUgcmVhc29uLlxuXHQgKiBOb3RlIHRoYXQgaXQgaXMgcG9zc2libGUgdGhlIG51bWJlciBvZiByb3dzIGRlbGV0ZWQgaXMgMCwgZXZlbiB0aG91Z2ggdGhlIGRlbGV0aW9uIGV4ZWN1dGlvbiBpcyBzdWNjZXNzZnVsLlxuXHQgKiBAdGhyb3dzIFN0YWxlT2JqZWN0RXhjZXB0aW9uIGlmIFtbb3B0aW1pc3RpY0xvY2t8b3B0aW1pc3RpYyBsb2NraW5nXV0gaXMgZW5hYmxlZCBhbmQgdGhlIGRhdGFcblx0ICogYmVpbmcgZGVsZXRlZCBpcyBvdXRkYXRlZC5cblx0ICogQHRocm93cyBcXEV4Y2VwdGlvbiBpbiBjYXNlIGRlbGV0ZSBmYWlsZWQuXG5cdCAqL1xuXHRkZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5iZWZvcmVEZWxldGUoKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oYm9vbCkge1xuXHRcdFx0aWYgKCFib29sKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgY29uZGl0aW9uID0gdGhpcy5nZXRPbGRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0XHQvLyB3ZSBkbyBub3QgY2hlY2sgdGhlIHJldHVybiB2YWx1ZSBvZiBkZWxldGVBbGwoKSBiZWNhdXNlIGl0J3MgcG9zc2libGVcblx0XHRcdC8vIHRoZSByZWNvcmQgaXMgYWxyZWFkeSBkZWxldGVkIGluIHRoZSBkYXRhYmFzZSBhbmQgdGh1cyB0aGUgbWV0aG9kIHdpbGwgcmV0dXJuIDBcblx0XHRcdHJldHVybiB0aGlzLl9fc3RhdGljLmRlbGV0ZUFsbChjb25kaXRpb24pO1xuXHRcdH0sIHRoaXMpKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocmVzdWx0KSB7XG5cblx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXMgPSBudWxsO1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5hZnRlckRlbGV0ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHR9KTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGN1cnJlbnQgcmVjb3JkIGlzIG5ldy5cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBpcyBuZXcgYW5kKCkgc2hvdWxkIGJlIGluc2VydGVkIHdoZW4gY2FsbGluZyBbW3NhdmUoKV1dLlxuXHQgKi9cblx0aXNOZXdSZWNvcmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5fb2xkQXR0cmlidXRlcyA9PT0gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSByZWNvcmQgaXMgbmV3LlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlIHdoZXRoZXIgdGhlIHJlY29yZCBpcyBuZXcgYW5kKCkgc2hvdWxkIGJlIGluc2VydGVkIHdoZW4gY2FsbGluZyBbW3NhdmUoKV1dLlxuXHQgKiBAc2VlIGlzTmV3UmVjb3JkKClcblx0ICovXG5cdHNldElzTmV3UmVjb3JkOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9vbGRBdHRyaWJ1dGVzID0gdmFsdWUgPyBudWxsIDogdGhpcy5fYXR0cmlidXRlcztcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHdoZW4gdGhlIEFSIG9iamVjdCBpcyBjcmVhdGVkIGFuZCBwb3B1bGF0ZWQgd2l0aCB0aGUgcXVlcnkgcmVzdWx0LlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHRyaWdnZXIgYW4gW1tFVkVOVF9BRlRFUl9GSU5EXV0gZXZlbnQuXG5cdCAqIFdoZW4gb3ZlcnJpZGluZyB0aGlzIG1ldGhvZCwgbWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gdG8gZW5zdXJlIHRoZVxuXHQgKiBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdCAqL1xuXHRhZnRlckZpbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9GSU5EKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgaW5zZXJ0aW5nIG9yIHVwZGF0aW5nIGEgcmVjb3JkLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHRyaWdnZXIgYW4gW1tFVkVOVF9CRUZPUkVfSU5TRVJUXV0gZXZlbnQgd2hlbiBgaW5zZXJ0YCBpcyB0cnVlLFxuXHQgKiBvciBhbiBbW0VWRU5UX0JFRk9SRV9VUERBVEVdXSBldmVudCBpZiBgaW5zZXJ0YCBpcyBmYWxzZS5cblx0ICogV2hlbiBvdmVycmlkaW5nIHRoaXMgbWV0aG9kLCBtYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdCAqXG5cdCAqIH5+flxuXHQgKiBwdWJsaWMgZnVuY3Rpb24gYmVmb3JlU2F2ZShpbnNlcnQpXG5cdCAqIHtcbiAgICAgKiAgICAgaWYgKHBhcmVudC5iZWZvcmVTYXZlKGluc2VydCkpIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLmN1c3RvbSBjb2RlIGhlcmUuLi5cbiAgICAgKiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtib29sZWFufSBpbnNlcnQgd2hldGhlciB0aGlzIG1ldGhvZCBjYWxsZWQgd2hpbGUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuXHQgKiBJZiBmYWxzZSwgaXQgbWVhbnMgdGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxib29sZWFuPn0gd2hldGhlciB0aGUgaW5zZXJ0aW9uIG9yIHVwZGF0aW5nIHNob3VsZCBjb250aW51ZS5cblx0ICogSWYgZmFsc2UsIHRoZSBpbnNlcnRpb24gb3IgdXBkYXRpbmcgd2lsbCBiZSBjYW5jZWxsZWQuXG5cdCAqL1xuXHRiZWZvcmVTYXZlOiBmdW5jdGlvbiAoaW5zZXJ0KSB7XG5cdFx0dmFyIGV2ZW50ID0gbmV3IEppaS5iYXNlLk1vZGVsRXZlbnQoKTtcblx0XHR0aGlzLnRyaWdnZXIoaW5zZXJ0ID8gdGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfSU5TRVJUIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9CRUZPUkVfVVBEQVRFLCBldmVudCk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGV2ZW50LmlzVmFsaWQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiBpbnNlcnRpbmcgb3IgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHdpbGwgdHJpZ2dlciBhbiBbW0VWRU5UX0FGVEVSX0lOU0VSVF1dIGV2ZW50IHdoZW4gYGluc2VydGAgaXMgdHJ1ZSxcblx0ICogb3IgYW4gW1tFVkVOVF9BRlRFUl9VUERBVEVdXSBldmVudCBpZiBgaW5zZXJ0YCBpcyBmYWxzZS4gVGhlIGV2ZW50IGNsYXNzIHVzZWQgaXMgW1tBZnRlclNhdmVFdmVudF1dLlxuXHQgKiBXaGVuIG92ZXJyaWRpbmcgdGhpcyBtZXRob2QsIG1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIHNvIHRoYXRcblx0ICogdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtib29sZWFufSBpbnNlcnQgd2hldGhlciB0aGlzIG1ldGhvZCBjYWxsZWQgd2hpbGUgaW5zZXJ0aW5nIGEgcmVjb3JkLlxuXHQgKiBJZiBmYWxzZSwgaXQgbWVhbnMgdGhlIG1ldGhvZCBpcyBjYWxsZWQgd2hpbGUgdXBkYXRpbmcgYSByZWNvcmQuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBjaGFuZ2VkQXR0cmlidXRlcyBUaGUgb2xkIHZhbHVlcyBvZiBhdHRyaWJ1dGVzIHRoYXQgaGFkIGNoYW5nZWQgYW5kIHdlcmUgc2F2ZWQuXG5cdCAqIFlvdSBjYW4gdXNlIHRoaXMgcGFyYW1ldGVyIHRvIHRha2UgYWN0aW9uIGJhc2VkIG9uIHRoZSBjaGFuZ2VzIG1hZGUgZm9yIGV4YW1wbGUgc2VuZCBhbiBlbWFpbFxuXHQgKiB3aGVuIHRoZSBwYXNzd29yZCBoYWQgY2hhbmdlZCBvciBpbXBsZW1lbnQgYXVkaXQgdHJhaWwgdGhhdCB0cmFja3MgYWxsIHRoZSBjaGFuZ2VzLlxuXHQgKiBgY2hhbmdlZEF0dHJpYnV0ZXNgIGdpdmVzIHlvdSB0aGUgb2xkIGF0dHJpYnV0ZSB2YWx1ZXMgd2hpbGUgdGhlIGFjdGl2ZSByZWNvcmQgKGB0aGlzYCkgaGFzXG5cdCAqIGFscmVhZHkgdGhlIG5ldywgdXBkYXRlZCB2YWx1ZXMuXG5cdCAqL1xuXHRhZnRlclNhdmU6IGZ1bmN0aW9uIChpbnNlcnQsIGNoYW5nZWRBdHRyaWJ1dGVzKSB7XG5cdFx0dmFyIGV2ZW50TmFtZSA9IGluc2VydCA/IHRoaXMuX19zdGF0aWMuRVZFTlRfQUZURVJfSU5TRVJUIDogdGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9VUERBVEU7XG5cblx0XHR0aGlzLnRyaWdnZXIoZXZlbnROYW1lLCBuZXcgSmlpLnNxbC5BZnRlclNhdmVFdmVudCh7XG5cdFx0XHRjaGFuZ2VkQXR0cmlidXRlczogY2hhbmdlZEF0dHJpYnV0ZXNcblx0XHR9KSk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGRlbGV0aW5nIGEgcmVjb3JkLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByYWlzZXMgdGhlIFtbRVZFTlRfQkVGT1JFX0RFTEVURV1dIGV2ZW50LlxuXHQgKiBXaGVuIG92ZXJyaWRpbmcgdGhpcyBtZXRob2QsIG1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIGxpa2UgdGhlIGZvbGxvd2luZzpcblx0ICpcblx0ICogfn5+XG5cdCAqIHB1YmxpYyBmdW5jdGlvbiBiZWZvcmVEZWxldGUoKVxuXHQgKiB7XG4gICAgICogICAgIGlmIChwYXJlbnQuYmVmb3JlRGVsZXRlKCkpIHtcbiAgICAgKiAgICAgICAgIC8vIC4uLmN1c3RvbSBjb2RlIGhlcmUuLi5cbiAgICAgKiAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAqICAgICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlY29yZCBzaG91bGQgYmUgZGVsZXRlZC4gRGVmYXVsdHMgdG8gdHJ1ZS5cblx0ICovXG5cdGJlZm9yZURlbGV0ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBldmVudCA9IG5ldyBKaWkuYmFzZS5Nb2RlbEV2ZW50KCk7XG5cdFx0dGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQkVGT1JFX0RFTEVURSwgZXZlbnQpO1xuXG5cdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShldmVudC5pc1ZhbGlkKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCBhZnRlciBkZWxldGluZyBhIHJlY29yZC5cblx0ICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gcmFpc2VzIHRoZSBbW0VWRU5UX0FGVEVSX0RFTEVURV1dIGV2ZW50LlxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHBvc3Rwcm9jZXNzaW5nIGFmdGVyIHRoZSByZWNvcmQgaXMgZGVsZXRlZC5cblx0ICogTWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgZXZlbnQgaXMgcmFpc2VkIHByb3Blcmx5LlxuXHQgKi9cblx0YWZ0ZXJEZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9ERUxFVEUpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmVwb3B1bGF0ZXMgdGhpcyBhY3RpdmUgcmVjb3JkIHdpdGggdGhlIGxhdGVzdCBkYXRhLlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgcm93IHN0aWxsIGV4aXN0cyBpbiB0aGUgZGF0YWJhc2UuIElmIHRydWUsIHRoZSBsYXRlc3QgZGF0YVxuXHQgKiB3aWxsIGJlIHBvcHVsYXRlZCB0byB0aGlzIGFjdGl2ZSByZWNvcmQuIE90aGVyd2lzZSwgdGhpcyByZWNvcmQgd2lsbCByZW1haW4gdW5jaGFuZ2VkLlxuXHQgKi9cblx0cmVmcmVzaDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwcmltYXJ5S2V5ID0gdGhpcy5nZXRQcmltYXJ5S2V5KHRydWUpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX19zdGF0aWMuZmluZE9uZShwcmltYXJ5S2V5KS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24ocmVjb3JkKSB7XG5cdFx0XHRpZiAocmVjb3JkID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0XHRKaWkuXy5lYWNoKHRoaXMuYXR0cmlidXRlcygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0dGhpcy5fYXR0cmlidXRlc1tuYW1lXSA9IEppaS5fLmhhcyhyZWNvcmQuX2F0dHJpYnV0ZXMsIG5hbWUpID8gcmVjb3JkLl9hdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdHRoaXMuX29sZEF0dHJpYnV0ZXMgPSBKaWkuXy5jbG9uZSh0aGlzLl9hdHRyaWJ1dGVzKTtcblxuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9yZWxhdGVkLCBmdW5jdGlvbihyZWxhdGlvbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlbGF0ZWQobmFtZSk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpXG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBnaXZlbiBhY3RpdmUgcmVjb3JkIGlzIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50IG9uZS5cblx0ICogVGhlIGNvbXBhcmlzb24gaXMgbWFkZSBieSBjb21wYXJpbmcgdGhlIHRhYmxlIG5hbWVzIGFuZCB0aGUgcHJpbWFyeSBrZXkgdmFsdWVzIG9mIHRoZSB0d28gYWN0aXZlIHJlY29yZHMuXG5cdCAqIElmIG9uZSBvZiB0aGUgcmVjb3JkcyBbW2lzTmV3UmVjb3JkfGlzIG5ld11dIHRoZXkgYXJlIGFsc28gY29uc2lkZXJlZCBub3QgZXF1YWwuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSByZWNvcmQgcmVjb3JkIHRvIGNvbXBhcmUgdG9cblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHR3byBhY3RpdmUgcmVjb3JkcyByZWZlciB0byB0aGUgc2FtZSByb3cgaW4gdGhlIHNhbWUgZGF0YWJhc2UgdGFibGUuXG5cdCAqL1xuXHRlcXVhbHM6IGZ1bmN0aW9uIChyZWNvcmQpIHtcblx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IHJlY29yZC5pc05ld1JlY29yZCgpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuY2xhc3NOYW1lKCkgIT09IHJlY29yZC5jbGFzc05hbWUoKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdldFByaW1hcnlLZXkoKS50b1N0cmluZygpID09PSByZWNvcmQuZ2V0UHJpbWFyeUtleSgpLnRvU3RyaW5nKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHByaW1hcnkga2V5IHZhbHVlKHMpLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFthc0FycmF5XSB3aGV0aGVyIHRvIHJldHVybiB0aGUgcHJpbWFyeSBrZXkgdmFsdWUgYXMgYW4gYXJyYXkuIElmIHRydWUsXG5cdCAqIHRoZSByZXR1cm4gdmFsdWUgd2lsbCBiZSBhbiBhcnJheSB3aXRoIGNvbHVtbiBuYW1lcyBhcyBrZXlzIGFuZCBjb2x1bW4gdmFsdWVzIGFzIHZhbHVlcy5cblx0ICogTm90ZSB0aGF0IGZvciBjb21wb3NpdGUgcHJpbWFyeSBrZXlzLCBhbiBhcnJheSB3aWxsIGFsd2F5cyBiZSByZXR1cm5lZCByZWdhcmRsZXNzIG9mIHRoaXMgcGFyYW1ldGVyIHZhbHVlLlxuXHQgKiBAcHJvcGVydHkgbWl4ZWQgVGhlIHByaW1hcnkga2V5IHZhbHVlLiBBbiBhcnJheSAoY29sdW1uIG5hbWUgPT4gY29sdW1uIHZhbHVlKSBpcyByZXR1cm5lZCBpZlxuXHQgKiB0aGUgcHJpbWFyeSBrZXkgaXMgY29tcG9zaXRlLiBBIHN0cmluZyBpcyByZXR1cm5lZCBvdGhlcndpc2UgKG51bGwgd2lsbCBiZSByZXR1cm5lZCBpZlxuXHQgKiB0aGUga2V5IHZhbHVlIGlzIG51bGwpLlxuXHQgKiBAcmV0dXJucyB7Kn0gdGhlIHByaW1hcnkga2V5IHZhbHVlLiBBbiBhcnJheSAoY29sdW1uIG5hbWUgPT4gY29sdW1uIHZhbHVlKSBpcyByZXR1cm5lZCBpZiB0aGUgcHJpbWFyeSBrZXlcblx0ICogaXMgY29tcG9zaXRlIG9yIGBhc0FycmF5YCBpcyB0cnVlLiBBIHN0cmluZyBpcyByZXR1cm5lZCBvdGhlcndpc2UgKG51bGwgd2lsbCBiZSByZXR1cm5lZCBpZlxuXHQgKiB0aGUga2V5IHZhbHVlIGlzIG51bGwpLlxuXHQgKi9cblx0Z2V0UHJpbWFyeUtleTogZnVuY3Rpb24gKGFzQXJyYXkpIHtcblx0XHRhc0FycmF5ID0gYXNBcnJheSB8fCBmYWxzZTtcblxuXHRcdHZhciBrZXlzID0gdGhpcy5fX3N0YXRpYy5wcmltYXJ5S2V5KCk7XG5cdFx0aWYgKGtleXMubGVuZ3RoID09PSAxICYmICFhc0FycmF5KSB7XG5cdFx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIGtleXNbMF0pID8gdGhpcy5fYXR0cmlidXRlc1trZXlzWzBdXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIHZhbHVlcyA9IHt9O1xuXHRcdEppaS5fLmVhY2goa2V5cywgSmlpLl8uYmluZChmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR2YWx1ZXNbbmFtZV0gPSBKaWkuXy5oYXModGhpcy5fYXR0cmlidXRlcywgbmFtZSkgPyB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdIDogbnVsbDtcblx0XHR9LCB0aGlzKSk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBvbGQgcHJpbWFyeSBrZXkgdmFsdWUocykuXG5cdCAqIFRoaXMgcmVmZXJzIHRvIHRoZSBwcmltYXJ5IGtleSB2YWx1ZSB0aGF0IGlzIHBvcHVsYXRlZCBpbnRvIHRoZSByZWNvcmRcblx0ICogYWZ0ZXIgZXhlY3V0aW5nIGEgZmluZCBtZXRob2QgKGUuZy4gZmluZCgpLCBmaW5kT25lKCkpLlxuXHQgKiBUaGUgdmFsdWUgcmVtYWlucyB1bmNoYW5nZWQgZXZlbiBpZiB0aGUgcHJpbWFyeSBrZXkgYXR0cmlidXRlIGlzIG1hbnVhbGx5IGFzc2lnbmVkIHdpdGggYSBkaWZmZXJlbnQgdmFsdWUuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2FzQXJyYXldIHdoZXRoZXIgdG8gcmV0dXJuIHRoZSBwcmltYXJ5IGtleSB2YWx1ZSBhcyBhbiBhcnJheS4gSWYgdHJ1ZSxcblx0ICogdGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIGFuIGFycmF5IHdpdGggY29sdW1uIG5hbWUgYXMga2V5IGFuZCBjb2x1bW4gdmFsdWUgYXMgdmFsdWUuXG5cdCAqIElmIHRoaXMgaXMgZmFsc2UgKGRlZmF1bHQpLCBhIHNjYWxhciB2YWx1ZSB3aWxsIGJlIHJldHVybmVkIGZvciBub24tY29tcG9zaXRlIHByaW1hcnkga2V5LlxuXHQgKiBAcHJvcGVydHkgbWl4ZWQgVGhlIG9sZCBwcmltYXJ5IGtleSB2YWx1ZS4gQW4gYXJyYXkgKGNvbHVtbiBuYW1lID0+IGNvbHVtbiB2YWx1ZSkgaXNcblx0ICogcmV0dXJuZWQgaWYgdGhlIHByaW1hcnkga2V5IGlzIGNvbXBvc2l0ZS4gQSBzdHJpbmcgaXMgcmV0dXJuZWQgb3RoZXJ3aXNlIChudWxsIHdpbGwgYmVcblx0ICogcmV0dXJuZWQgaWYgdGhlIGtleSB2YWx1ZSBpcyBudWxsKS5cblx0ICogQHJldHVybnMgeyp9IHRoZSBvbGQgcHJpbWFyeSBrZXkgdmFsdWUuIEFuIGFycmF5IChjb2x1bW4gbmFtZSA9PiBjb2x1bW4gdmFsdWUpIGlzIHJldHVybmVkIGlmIHRoZSBwcmltYXJ5IGtleVxuXHQgKiBpcyBjb21wb3NpdGUgb3IgYGFzQXJyYXlgIGlzIHRydWUuIEEgc3RyaW5nIGlzIHJldHVybmVkIG90aGVyd2lzZSAobnVsbCB3aWxsIGJlIHJldHVybmVkIGlmXG5cdCAqIHRoZSBrZXkgdmFsdWUgaXMgbnVsbCkuXG5cdCAqL1xuXHRnZXRPbGRQcmltYXJ5S2V5OiBmdW5jdGlvbiAoYXNBcnJheSkge1xuXHRcdGFzQXJyYXkgPSBhc0FycmF5IHx8IGZhbHNlO1xuXG5cdFx0dmFyIGtleXMgPSB0aGlzLl9fc3RhdGljLnByaW1hcnlLZXkoKTtcblxuXHRcdGlmIChrZXlzLmxlbmd0aCA9PT0gMSAmJiAhYXNBcnJheSkge1xuXHRcdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9vbGRBdHRyaWJ1dGVzLCBrZXlzWzBdKSA/IHRoaXMuX29sZEF0dHJpYnV0ZXNba2V5c1swXV0gOiBudWxsO1xuXHRcdH1cblxuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblx0XHRKaWkuXy5lYWNoKGtleXMsIEppaS5fLmJpbmQoZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dmFsdWVzW25hbWVdID0gSmlpLl8uaGFzKHRoaXMuX29sZEF0dHJpYnV0ZXMsIG5hbWUpID8gdGhpcy5fb2xkQXR0cmlidXRlc1tuYW1lXSA6IG51bGw7XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcmVsYXRpb24gb2JqZWN0IHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuXHQgKiBBIHJlbGF0aW9uIGlzIGRlZmluZWQgYnkgYSBnZXR0ZXIgbWV0aG9kIHdoaWNoIHJldHVybnMgYW4gW1tBY3RpdmVRdWVyeUludGVyZmFjZV1dIG9iamVjdC5cblx0ICogSXQgY2FuIGJlIGRlY2xhcmVkIGluIGVpdGhlciB0aGUgQWN0aXZlIFJlY29yZCBjbGFzcyBpdHNlbGYgb3Igb25lIG9mIGl0cyBiZWhhdmlvcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSByZWxhdGlvbiBuYW1lXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rocm93RXhjZXB0aW9uXSB3aGV0aGVyIHRvIHRocm93IGV4Y2VwdGlvbiBpZiB0aGUgcmVsYXRpb24gZG9lcyBub3QgZXhpc3QuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlLjxKaWkuc3FsLkFjdGl2ZVF1ZXJ5Pn0gdGhlIHJlbGF0aW9uYWwgcXVlcnkgb2JqZWN0LiBJZiB0aGUgcmVsYXRpb24gZG9lcyBub3QgZXhpc3Rcblx0ICogYW5kIGB0aHJvd0V4Y2VwdGlvbmAgaXMgZmFsc2UsIG51bGwgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9ufSBpZiB0aGUgbmFtZWQgcmVsYXRpb24gZG9lcyBub3QgZXhpc3QuXG5cdCAqL1xuXHRnZXRSZWxhdGlvbjogZnVuY3Rpb24gKG5hbWUsIHRocm93RXhjZXB0aW9uKSB7XG5cdFx0dGhyb3dFeGNlcHRpb24gPSAhSmlpLl8uaXNVbmRlZmluZWQodGhyb3dFeGNlcHRpb24pID8gdGhyb3dFeGNlcHRpb24gOiB0cnVlO1xuXG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgSmlpLl9zLmNhcGl0YWxpemUobmFtZSk7XG5cdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1tnZXR0ZXJdKSkge1xuXHRcdFx0cmV0dXJuIHRoaXNbZ2V0dGVyXSgpO1xuXHRcdH0gZWxzZSBpZiAodGhyb3dFeGNlcHRpb24pIHtcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24odGhpcy5jbGFzc05hbWUoKSArICcgaGFzIG5vIHJlbGF0aW9uIG5hbWVkIGAnICsgbmFtZSArICdgLicpO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc1JlbGF0aW9uOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSAnZ2V0JyArIEppaS5fcy5jYXBpdGFsaXplKG5hbWUpO1xuICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbih0aGlzW2dldHRlcl0pO1xuICAgIH0sXG5cblx0LyoqXG5cdCAqIEVzdGFibGlzaGVzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gbW9kZWxzLlxuXHQgKlxuXHQgKiBUaGUgcmVsYXRpb25zaGlwIGlzIGVzdGFibGlzaGVkIGJ5IHNldHRpbmcgdGhlIGZvcmVpZ24ga2V5IHZhbHVlKHMpIGluIG9uZSBtb2RlbFxuXHQgKiB0byBiZSB0aGUgY29ycmVzcG9uZGluZyBwcmltYXJ5IGtleSB2YWx1ZShzKSBpbiB0aGUgb3RoZXIgbW9kZWwuXG5cdCAqIFRoZSBtb2RlbCB3aXRoIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIHNhdmVkIGludG8gZGF0YWJhc2Ugd2l0aG91dCBwZXJmb3JtaW5nIHZhbGlkYXRpb24uXG5cdCAqXG5cdCAqIElmIHRoZSByZWxhdGlvbnNoaXAgaW52b2x2ZXMgYSBwaXZvdCB0YWJsZSwgYSBuZXcgcm93KCkgd2lsbCBiZSBpbnNlcnRlZCBpbnRvIHRoZVxuXHQgKiBwaXZvdCB0YWJsZSB3aGljaCBjb250YWlucyB0aGUgcHJpbWFyeSBrZXkgdmFsdWVzIGZyb20gYm90aCBtb2RlbHMuXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0aGlzIG1ldGhvZCByZXF1aXJlcyB0aGF0IHRoZSBwcmltYXJ5IGtleSB2YWx1ZSBpcyBub3QgbnVsbC5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGNhc2Ugc2Vuc2l0aXZlIG5hbWUgb2YgdGhlIHJlbGF0aW9uc2hpcFxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWwgdGhlIG1vZGVsIHRvIGJlIGxpbmtlZCB3aXRoIHRoZSBjdXJyZW50IG9uZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtleHRyYUNvbHVtbnNdIGFkZGl0aW9uYWwgY29sdW1uIHZhbHVlcyB0byBiZSBzYXZlZCBpbnRvIHRoZSBwaXZvdCB0YWJsZS5cblx0ICogVGhpcyBwYXJhbWV0ZXIgaXMgb25seSBtZWFuaW5nZnVsIGZvciBhIHJlbGF0aW9uc2hpcCBpbnZvbHZpbmcgYSBwaXZvdCB0YWJsZVxuXHQgKiAoaS5lLiwgYSByZWxhdGlvbiBzZXQgd2l0aCBbW0FjdGl2ZVJlbGF0aW9uVHJhaXQudmlhKCldXSBvciBgW1tBY3RpdmVRdWVyeS52aWFUYWJsZSgpXV1gLilcblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9ufSBpZiB0aGUgbWV0aG9kIGlzIHVuYWJsZSB0byBsaW5rIHR3byBtb2RlbHMuXG5cdCAqL1xuXHRsaW5rOiBmdW5jdGlvbiAobmFtZSwgbW9kZWwsIGV4dHJhQ29sdW1ucykge1xuXHRcdGV4dHJhQ29sdW1ucyA9IGV4dHJhQ29sdW1ucyB8fCB7fTtcblxuXHRcdHZhciByZWxhdGlvbiA9IHRoaXMuZ2V0UmVsYXRpb24obmFtZSk7XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdGlmIChyZWxhdGlvbi5nZXRWaWEoKSAhPT0gbnVsbCkge1xuXHRcdFx0XHRpZiAodGhpcy5pc05ld1JlY29yZCgpIHx8IG1vZGVsLmlzTmV3UmVjb3JkKCkpIHtcblx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENhbGxFeGNlcHRpb24oJ1VuYWJsZSB0byBsaW5rIG1vZGVsczogYm90aCBtb2RlbHMgbXVzdCBOT1QgYmUgbmV3bHkgY3JlYXRlZC4nKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciB2aWFOYW1lID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVJlbGF0aW9uID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYUNsYXNzID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVRhYmxlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFOYW1lID0gcmVsYXRpb24uZ2V0VmlhKClbMF07XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKVsxXTtcblxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSAqL1xuXHRcdFx0XHRcdHZpYUNsYXNzID0gdmlhUmVsYXRpb24ubW9kZWxDbGFzcztcblxuXHRcdFx0XHRcdC8vIHVuc2V0IHZpYU5hbWUgc28gdGhhdCBpdCBjYW4gYmUgcmVsb2FkZWQgdG8gcmVmbGVjdCB0aGUgY2hhbmdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlbW92ZVJlbGF0ZWQodmlhTmFtZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKTtcblx0XHRcdFx0XHR2aWFUYWJsZSA9IEppaS5fLmZpcnN0KHJlbGF0aW9uLmdldFZpYSgpLmdldEZyb20oKSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgY29sdW1ucyA9IHt9O1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZpYVJlbGF0aW9uLmxpbmssIGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRjb2x1bW5zW2FdID0gdGhpcy5nZXQoYik7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdEppaS5fLmVhY2gocmVsYXRpb24ubGluaywgZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYl0gPSBtb2RlbC5nZXQoYSk7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHRcdEppaS5fLmVhY2goZXh0cmFDb2x1bW5zLCBmdW5jdGlvbih2LCBrKSB7XG5cdFx0XHRcdFx0Y29sdW1uc1trXSA9IHY7XG5cdFx0XHRcdH0uYmluZCh0aGlzKSk7XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzQXJyYXkocmVsYXRpb24uZ2V0VmlhKCkpKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9ICovXG5cdFx0XHRcdFx0dmFyIHJlY29yZCA9IG5ldyB2aWFDbGFzcygpO1xuXHRcdFx0XHRcdEppaS5fLmVhY2goY29sdW1ucywgSmlpLl8uYmluZChmdW5jdGlvbih2YWx1ZSwgY29sdW1uKSB7XG5cdFx0XHRcdFx0XHRyZWNvcmQuc2V0KGNvbHVtbiwgdmFsdWUpO1xuXHRcdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVjb3JkLmluc2VydChmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBAdHlwZSB7dmlhVGFibGV9IHN0cmluZyAqL1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fX3N0YXRpYy5nZXREYigpLmNyZWF0ZUNvbW1hbmQoKS5pbnNlcnQodmlhVGFibGUsIGNvbHVtbnMpO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgcDEgPSBtb2RlbC5fX3N0YXRpYy5pc1ByaW1hcnlLZXkoSmlpLl8ua2V5cyhyZWxhdGlvbi5saW5rKSk7XG5cdFx0XHR2YXIgcDIgPSB0aGlzLl9fc3RhdGljLmlzUHJpbWFyeUtleShKaWkuXy52YWx1ZXMocmVsYXRpb24ubGluaykpO1xuXHRcdFx0aWYgKHAxICYmIHAyKSB7XG5cdFx0XHRcdGlmICh0aGlzLmlzTmV3UmVjb3JkKCkgJiYgbW9kZWwuaXNOZXdSZWNvcmQoKSkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIGxpbmsgbW9kZWxzOiBib3RoIG1vZGVscyBhcmUgbmV3bHkgY3JlYXRlZC4nKTtcblx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLmlzTmV3UmVjb3JkKCkpIHtcblx0XHRcdFx0XHR2YXIgbGluayA9IHt9O1xuXHRcdFx0XHRcdGZvciAodmFyIGZrIGluIHJlbGF0aW9uLmxpbmspIHtcblx0XHRcdFx0XHRcdGlmIChyZWxhdGlvbi5saW5rLmhhc093blByb3BlcnR5KGZrKSkge1xuXHRcdFx0XHRcdFx0XHRsaW5rW3JlbGF0aW9uLmxpbmtbZmtdXSA9IGZrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5fYmluZE1vZGVscyhsaW5rLCB0aGlzLCBtb2RlbCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMuX2JpbmRNb2RlbHMocmVsYXRpb24ubGluaywgbW9kZWwsIHRoaXMpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHAxKSB7XG5cdFx0XHRcdHZhciBsaW5rMiA9IHt9O1xuXHRcdFx0XHRmb3IgKHZhciBmazIgaW4gcmVsYXRpb24ubGluaykge1xuXHRcdFx0XHRcdGlmIChyZWxhdGlvbi5saW5rLmhhc093blByb3BlcnR5KGZrMikpIHtcblx0XHRcdFx0XHRcdGxpbmsyW3JlbGF0aW9uLmxpbmtbZmsyXV0gPSBmazI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzLl9iaW5kTW9kZWxzKGxpbmsyLCB0aGlzLCBtb2RlbCk7XG5cdFx0XHR9IGVsc2UgaWYgKHAyKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9iaW5kTW9kZWxzKHJlbGF0aW9uLmxpbmssIG1vZGVsLCB0aGlzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIGxpbmsgbW9kZWxzOiB0aGUgbGluayBkb2VzIG5vdCBpbnZvbHZlIGFueSBwcmltYXJ5IGtleS4nKTtcblx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpLnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbigpIHtcblx0XHRcdC8vIHVwZGF0ZSBsYXppbHkgbG9hZGVkIHJlbGF0ZWQgb2JqZWN0c1xuXHRcdFx0aWYgKCFyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFJlbGF0ZWQobmFtZSwgbW9kZWwpO1xuXHRcdFx0fSBlbHNlIGlmIChKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWxhdGVkW25hbWVdLmFkZChtb2RlbCk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlc3Ryb3lzIHRoZSByZWxhdGlvbnNoaXAgYmV0d2VlbiB0d28gbW9kZWxzLlxuXHQgKlxuXHQgKiBUaGUgbW9kZWwgd2l0aCB0aGUgZm9yZWlnbiBrZXkgb2YgdGhlIHJlbGF0aW9uc2hpcCB3aWxsIGJlIGRlbGV0ZWQgaWYgYGRlbGV0ZWAgaXMgdHJ1ZS5cblx0ICogT3RoZXJ3aXNlLCB0aGUgZm9yZWlnbiBrZXkgd2lsbCBiZSBzZXQgbnVsbCBhbmQgdGhlIG1vZGVsIHdpbGwgYmUgc2F2ZWQgd2l0aG91dCB2YWxpZGF0aW9uLlxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgY2FzZSBzZW5zaXRpdmUgbmFtZSBvZiB0aGUgcmVsYXRpb25zaGlwLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gbW9kZWwgdGhlIG1vZGVsIHRvIGJlIHVubGlua2VkIGZyb20gdGhlIGN1cnJlbnQgb25lLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlbGV0ZV0gd2hldGhlciB0byBkZWxldGUgdGhlIG1vZGVsIHRoYXQgY29udGFpbnMgdGhlIGZvcmVpZ24ga2V5LlxuXHQgKiBJZiBmYWxzZSwgdGhlIG1vZGVsJ3MgZm9yZWlnbiBrZXkgd2lsbCBiZSBzZXQgbnVsbCBhbmQgc2F2ZWQuXG5cdCAqIElmIHRydWUsIHRoZSBtb2RlbCBjb250YWluaW5nIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIGRlbGV0ZWQuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKiBAdGhyb3dzIEludmFsaWRDYWxsRXhjZXB0aW9uIGlmIHRoZSBtb2RlbHMgY2Fubm90IGJlIHVubGlua2VkXG5cdCAqL1xuXHR1bmxpbms6IGZ1bmN0aW9uIChuYW1lLCBtb2RlbCwgaXNEZWxldGUpIHtcblx0XHRpc0RlbGV0ZSA9IGlzRGVsZXRlIHx8IGZhbHNlO1xuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRpZiAocmVsYXRpb24uZ2V0VmlhKCkgIT09IG51bGwpIHtcblxuXHRcdFx0XHR2YXIgdmlhTmFtZSA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFSZWxhdGlvbiA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFDbGFzcyA9IG51bGw7XG5cdFx0XHRcdHZhciB2aWFUYWJsZSA9IG51bGw7XG5cblx0XHRcdFx0aWYgKEppaS5fLmlzQXJyYXkocmVsYXRpb24uZ2V0VmlhKCkpKSB7XG5cdFx0XHRcdFx0LyoqIEB0eXBlIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9ICovXG5cdFx0XHRcdFx0dmlhTmFtZSA9IHJlbGF0aW9uLmdldFZpYSgpWzBdO1xuXHRcdFx0XHRcdHZpYVJlbGF0aW9uID0gcmVsYXRpb24uZ2V0VmlhKClbMV07XG5cblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFDbGFzcyA9IHZpYVJlbGF0aW9uLm1vZGVsQ2xhc3M7XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVsYXRlZCh2aWFOYW1lKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2aWFSZWxhdGlvbiA9IHJlbGF0aW9uLmdldFZpYSgpO1xuXHRcdFx0XHRcdHZpYVRhYmxlID0gSmlpLl8uZmlyc3QocmVsYXRpb24uZ2V0VmlhKCkuZ2V0RnJvbSgpKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHZhciBjb2x1bW5zID0ge307XG5cdFx0XHRcdHZhciBudWxscyA9IHt9O1xuXHRcdFx0XHRKaWkuXy5lYWNoKHZpYVJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYV0gPSB0aGlzLmdldChiKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdGNvbHVtbnNbYl0gPSBtb2RlbC5nZXQoYSk7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0SmlpLl8uZWFjaChKaWkuXy5rZXlzKGNvbHVtbnMpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGspIHtcblx0XHRcdFx0XHRudWxsc1trXSA9IG51bGw7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2aWFDbGFzcy5kZWxldGVBbGwoY29sdW1ucyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHZpYUNsYXNzLnVwZGF0ZUFsbChudWxscywgY29sdW1ucyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBAdHlwZSBKaWkuc3FsLkNvbW1hbmQgKi9cblx0XHRcdFx0dmFyIGNvbW1hbmQgPSB0aGlzLl9fc3RhdGljLmdldERiKCkuY3JlYXRlQ29tbWFuZCgpO1xuXHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tbWFuZC5kZWxldGUodmlhVGFibGUsIGNvbHVtbnMpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGNvbW1hbmQudXBkYXRlKHZpYVRhYmxlLCBudWxscywgY29sdW1ucyk7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBwMSA9IG1vZGVsLl9fc3RhdGljLmlzUHJpbWFyeUtleShKaWkuXy5rZXlzKHJlbGF0aW9uLmxpbmspKTtcblx0XHRcdHZhciBwMiA9IHRoaXMuX19zdGF0aWMuaXNQcmltYXJ5S2V5KEppaS5fLnZhbHVlcyhyZWxhdGlvbi5saW5rKSk7XG5cblx0XHRcdGlmIChwMSAmJiBwMiB8fCBwMikge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdG1vZGVsLnNldChhLCBudWxsKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXG5cdFx0XHRcdHJldHVybiBpc0RlbGV0ZSA/IG1vZGVsLmRlbGV0ZSgpIDogbW9kZWwuc2F2ZShmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChwMSkge1xuXHRcdFx0XHRKaWkuXy5lYWNoKHJlbGF0aW9uLmxpbmssIEppaS5fLmJpbmQoZnVuY3Rpb24oYiwgYSkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldChiKTtcblxuXHRcdFx0XHRcdGlmIChKaWkuXy5pc0FycmF5KHZhbHVlcykpIHsgLy8gcmVsYXRpb24gdmlhIGFycmF5IHZhbHVlZCBhdHRyaWJ1dGVcblx0XHRcdFx0XHRcdHZhciBpbmRleCA9IEppaS5fLmluZGV4T2YodmFsdWVzLCBtb2RlbC5nZXQoYSkpO1xuXHRcdFx0XHRcdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRcdFx0XHR2YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5zZXQoYiwgbnVsbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdFx0cmV0dXJuIGlzRGVsZXRlID8gdGhpcy5kZWxldGUoKSA6IHRoaXMuc2F2ZShmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbignVW5hYmxlIHRvIHVubGluayBtb2RlbHM6IHRoZSBsaW5rIGRvZXMgbm90IGludm9sdmUgYW55IHByaW1hcnkga2V5LicpO1xuXHRcdH0uYmluZCh0aGlzKSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCFyZWxhdGlvbi5tdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWxhdGVkKG5hbWUpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChKaWkuXy5oYXModGhpcy5fcmVsYXRlZCwgbmFtZSkpIHtcblx0XHRcdFx0XHR0aGlzLl9yZWxhdGVkW25hbWVdLnJlbW92ZShtb2RlbCk7XG5cdFx0XHRcdH1cblx0XHR9LmJpbmQodGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXN0cm95cyB0aGUgcmVsYXRpb25zaGlwIGluIGN1cnJlbnQgbW9kZWwuXG5cdCAqXG5cdCAqIFRoZSBtb2RlbCB3aXRoIHRoZSBmb3JlaWduIGtleSBvZiB0aGUgcmVsYXRpb25zaGlwIHdpbGwgYmUgZGVsZXRlZCBpZiBgZGVsZXRlYCBpcyB0cnVlLlxuXHQgKiBPdGhlcndpc2UsIHRoZSBmb3JlaWduIGtleSB3aWxsIGJlIHNldCBudWxsIGFuZCB0aGUgbW9kZWwgd2lsbCBiZSBzYXZlZCB3aXRob3V0IHZhbGlkYXRpb24uXG5cdCAqXG5cdCAqIE5vdGUgdGhhdCB0byBkZXN0cm95IHRoZSByZWxhdGlvbnNoaXAgd2l0aG91dCByZW1vdmluZyByZWNvcmRzIG1ha2Ugc3VyZSB5b3VyIGtleXMgY2FuIGJlIHNldCB0byBudWxsXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBjYXNlIHNlbnNpdGl2ZSBuYW1lIG9mIHRoZSByZWxhdGlvbnNoaXAuXG5cdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVsZXRlXSB3aGV0aGVyIHRvIGRlbGV0ZSB0aGUgbW9kZWwgdGhhdCBjb250YWlucyB0aGUgZm9yZWlnbiBrZXkuXG5cdCAqIEByZXR1cm5zIHtQcm9taXNlfVxuXHQgKi9cblx0dW5saW5rQWxsOiBmdW5jdGlvbiAobmFtZSwgaXNEZWxldGUpIHtcblx0XHRpc0RlbGV0ZSA9IGlzRGVsZXRlIHx8IGZhbHNlO1xuXG5cdFx0dmFyIHJlbGF0aW9uID0gdGhpcy5nZXRSZWxhdGlvbihuYW1lKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24oKSB7XG5cblx0XHRcdGlmIChyZWxhdGlvbi5nZXRWaWEoKSAhPT0gbnVsbCkge1xuXG5cdFx0XHRcdHZhciB2aWFOYW1lID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVJlbGF0aW9uID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYUNsYXNzID0gbnVsbDtcblx0XHRcdFx0dmFyIHZpYVRhYmxlID0gbnVsbDtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHQvKiogQHR5cGUge0ppaS5iYXNlLkFjdGl2ZVJlY29yZH0gKi9cblx0XHRcdFx0XHR2aWFOYW1lID0gcmVsYXRpb24uZ2V0VmlhKClbMF07XG5cdFx0XHRcdFx0dmlhUmVsYXRpb24gPSByZWxhdGlvbi5nZXRWaWEoKVsxXTtcblxuXHRcdFx0XHRcdC8qKiBAdHlwZSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSAqL1xuXHRcdFx0XHRcdHZpYUNsYXNzID0gdmlhUmVsYXRpb24ubW9kZWxDbGFzcztcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVSZWxhdGVkKHZpYU5hbWUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZpYVJlbGF0aW9uID0gcmVsYXRpb24uZ2V0VmlhKCk7XG5cdFx0XHRcdFx0dmlhVGFibGUgPSBKaWkuXy5maXJzdChyZWxhdGlvbi5nZXRWaWEoKS5nZXRGcm9tKCkpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dmFyIGNvbmRpdGlvbiA9IHt9O1xuXHRcdFx0XHR2YXIgbnVsbHMgPSB7fTtcblx0XHRcdFx0SmlpLl8uZWFjaCh2aWFSZWxhdGlvbi5saW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRudWxsc1thXSA9IG51bGw7XG5cdFx0XHRcdFx0Y29uZGl0aW9uW2FdID0gdGhpcy5nZXQoYik7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheShyZWxhdGlvbi5nZXRWaWEoKSkpIHtcblx0XHRcdFx0XHRpZiAoaXNEZWxldGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB2aWFDbGFzcy5kZWxldGVBbGwoY29uZGl0aW9uKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHZpYUNsYXNzLnVwZGF0ZUFsbChudWxscywgY29uZGl0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8qKiBAdHlwZSB7SmlpLnNxbC5Db21tYW5kfSAqL1xuXHRcdFx0XHR2YXIgY29tbWFuZCA9IHRoaXMuX19zdGF0aWMuZ2V0RGIoKS5jcmVhdGVDb21tYW5kKCk7XG5cdFx0XHRcdGlmIChpc0RlbGV0ZSkge1xuXHRcdFx0XHRcdHJldHVybiBjb21tYW5kLmRlbGV0ZSh2aWFUYWJsZSwgY29uZGl0aW9uKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBjb21tYW5kLnVwZGF0ZSh2aWFUYWJsZSwgbnVsbHMsIGNvbmRpdGlvbik7XG5cdFx0XHR9XG5cblx0XHRcdC8qKiBAdHlwZWRlZiB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSByZWxhdGVkTW9kZWwgKi9cblx0XHRcdHZhciByZWxhdGVkTW9kZWwgPSByZWxhdGlvbi5tb2RlbENsYXNzO1xuXHRcdFx0dmFyIGtleSA9IHJlbGF0aW9uLmxpbmtbMF07XG5cdFx0XHRpZiAoIWlzRGVsZXRlICYmIHJlbGF0aW9uLmxpbmsubGVuZ3RoID09IDEgJiYgSmlpLl8uaXNBcnJheSh0aGlzLmdldChrZXkpKSkge1xuXHRcdFx0XHQvLyByZWxhdGlvbiB2aWEgYXJyYXkgdmFsdWVkIGF0dHJpYnV0ZVxuXHRcdFx0XHR0aGlzLnNldChrZXksIFtdKTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuc2F2ZShmYWxzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgbnVsbHMyID0ge307XG5cdFx0XHRcdHZhciBjb25kaXRpb24yID0ge307XG5cblx0XHRcdFx0SmlpLl8uZWFjaChyZWxhdGlvbi5saW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGIsIGEpIHtcblx0XHRcdFx0XHRudWxsczJbYV0gPSBudWxsO1xuXHRcdFx0XHRcdGNvbmRpdGlvbjJbYV0gPSB0aGlzLmdldChiKTtcblx0XHRcdFx0fSwgdGhpcykpO1xuXHRcdFx0XHRpZiAocmVsYXRpb24uZ2V0V2hlcmUoKSkge1xuXHRcdFx0XHRcdGNvbmRpdGlvbjIgPSBbJ2FuZCcsIGNvbmRpdGlvbjIsIHJlbGF0aW9uLmdldFdoZXJlKCldO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGlzRGVsZXRlKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlbGF0ZWRNb2RlbC5kZWxldGVBbGwoY29uZGl0aW9uMik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHJlbGF0ZWRNb2RlbC51cGRhdGVBbGwobnVsbHMyLCBjb25kaXRpb24yKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSkudGhlbihKaWkuXy5iaW5kKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlUmVsYXRlZChuYW1lKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBsaW5rXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aXZlUmVjb3JkfSBmb3JlaWduTW9kZWxcblx0ICogQHBhcmFtIHtKaWkuYmFzZS5BY3RpdmVSZWNvcmR9IHByaW1hcnlNb2RlbFxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ2FsbEV4Y2VwdGlvbn1cblx0ICogQHJldHVybnMge1Byb21pc2V9XG5cdCAqL1xuXHRfYmluZE1vZGVsczogZnVuY3Rpb24gKGxpbmssIGZvcmVpZ25Nb2RlbCwgcHJpbWFyeU1vZGVsKSB7XG5cdFx0SmlpLl8uZWFjaChsaW5rLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHBrLCBmaykge1xuXHRcdFx0dmFyIHZhbHVlID0gcHJpbWFyeU1vZGVsLmdldChwayk7XG5cdFx0XHRpZiAodmFsdWUgPT09IG51bGwpIHtcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9uKCdVbmFibGUgdG8gbGluayBtb2RlbHM6IHRoZSBwcmltYXJ5IGtleSBvZiBgJyArIHByaW1hcnlNb2RlbC5jbGFzc05hbWUoKSArICdgIGlzIG51bGwuJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKaWkuXy5pc0FycmF5KGZvcmVpZ25Nb2RlbC5nZXQoZmspKSkgeyAvLyByZWxhdGlvbiB2aWEgYXJyYXkgdmFsdWVkIGF0dHJpYnV0ZVxuXHRcdFx0XHRmb3JlaWduTW9kZWwuZ2V0KGZrKS5jb25jYXQodmFsdWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zm9yZWlnbk1vZGVsLnNldChmaywgdmFsdWUpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblxuXHRcdHJldHVybiBmb3JlaWduTW9kZWwuc2F2ZShmYWxzZSk7XG5cdH0sXG5cblxuXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHRleHQgbGFiZWwgZm9yIHRoZSBzcGVjaWZpZWQgYXR0cmlidXRlLlxuXHQgKiBJZiB0aGUgYXR0cmlidXRlIGxvb2tzIGxpa2UgYHJlbGF0ZWRNb2RlbC5hdHRyaWJ1dGVgLCB0aGVuIHRoZSBhdHRyaWJ1dGUgd2lsbCBiZSByZWNlaXZlZCBmcm9tIHRoZSByZWxhdGVkIG1vZGVsLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlIHRoZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgYXR0cmlidXRlIGxhYmVsXG5cdCAqIEBzZWUgZ2VuZXJhdGVBdHRyaWJ1dGVMYWJlbCgpXG5cdCAqIEBzZWUgYXR0cmlidXRlTGFiZWxzKClcblx0ICovXG5cdGdldEF0dHJpYnV0ZUxhYmVsOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0dmFyIGxhYmVscyA9IHRoaXMuYXR0cmlidXRlTGFiZWxzKCk7XG5cblx0XHRpZiAoSmlpLl8uaGFzKGxhYmVsc1thdHRyaWJ1dGVdKSkge1xuXHRcdFx0cmV0dXJuIGxhYmVsc1thdHRyaWJ1dGVdO1xuXHRcdH1cblxuXHRcdGlmIChhdHRyaWJ1dGUuaW5kZXhPZignLicpICE9PSAtMSkge1xuXHRcdFx0dmFyIGF0dHJpYnV0ZVBhcnRzID0gYXR0cmlidXRlLnNwbGl0KCcuJyk7XG5cdFx0XHR2YXIgbmVlZGVkQXR0cmlidXRlID0gYXR0cmlidXRlUGFydHMucG9wKCk7XG5cblx0XHRcdHZhciByZWxhdGVkTW9kZWwgPSB0aGlzO1xuXHRcdFx0SmlpLl8uZWFjaChhdHRyaWJ1dGVQYXJ0cywgSmlpLl8uYmluZChmdW5jdGlvbihyZWxhdGlvbk5hbWUpIHtcblx0XHRcdFx0aWYgKEppaS5fLmhhcyh0aGlzLl9yZWxhdGVkLCByZWxhdGlvbk5hbWUpICYmIHRoaXMuX3JlbGF0ZWRbcmVsYXRpb25OYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkge1xuXHRcdFx0XHRcdHJlbGF0ZWRNb2RlbCA9IHRoaXMuX3JlbGF0ZWRbcmVsYXRpb25OYW1lXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyBAdG9kb1xuXHRcdFx0XHRcdC8qdHJ5IHtcblx0XHRcdFx0XHRcdHJlbGF0aW9uID0gcmVsYXRlZE1vZGVsLmdldFJlbGF0aW9uKHJlbGF0aW9uTmFtZSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoSW52YWxpZFBhcmFtRXhjZXB0aW9uIGUpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQXR0cmlidXRlTGFiZWwoYXR0cmlidXRlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmVsYXRlZE1vZGVsID0gbmV3IHJlbGF0aW9uLm1vZGVsQ2xhc3MoKTsqL1xuXHRcdFx0XHR9XG5cdFx0XHR9LCB0aGlzKSk7XG5cblx0XHRcdGxhYmVscyA9IHJlbGF0ZWRNb2RlbC5hdHRyaWJ1dGVMYWJlbHMoKTtcblxuXHRcdFx0aWYgKEppaS5fLmhhcyhsYWJlbHNbYXR0cmlidXRlXSkpIHtcblx0XHRcdFx0cmV0dXJuIGxhYmVsc1thdHRyaWJ1dGVdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLmdlbmVyYXRlQXR0cmlidXRlTGFiZWwoYXR0cmlidXRlKTtcblx0fVxuXG59KTtcblxufSx7XCIuL01vZGVsXCI6MTAwLFwiamlpXCI6MTI0fV0sOTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBCYXNlQ29sbGVjdGlvbiBwcm92aWRlcyBhIGJhc2UgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHRoZSBbW0NvbGxlY3Rpb25JbnRlcmZhY2VdXS5cbiAqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQ29sbGVjdGlvblxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50XG4gKiBAZXh0ZW5kcyBBcnJheVxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkNvbGxlY3Rpb24nLCAvKiogQGxlbmRzIEppaS5iYXNlLkNvbGxlY3Rpb24ucHJvdG90eXBlICove1xuXG4gICAgX19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5Db2xsZWN0aW9uICove1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuQ29sbGVjdGlvbiNhZGRcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuQ29sbGVjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQUREOiAnYWRkJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkNvbGxlY3Rpb24jY2hhbmdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX0NIQU5HRTogJ2NoYW5nZScsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Db2xsZWN0aW9uI2NoYW5nZTpcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuQ29sbGVjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQ0hBTkdFX05BTUU6ICdjaGFuZ2U6JyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLkNvbGxlY3Rpb24jcmVtb3ZlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX1JFTU9WRTogJ3JlbW92ZSdcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIGxlbmd0aDogMCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8SmlpLmJhc2UuTW9kZWx9XG4gICAgICovXG4gICAgbW9kZWxDbGFzczogbnVsbCxcblxuICAgIF9ieUlkOiB7fSxcblxuICAgIF9ldmVudHNDaGFuZ2VOYW1lOiBbXSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7W118b2JqZWN0fSBbbW9kZWxzXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29uZmlnXVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAobW9kZWxzLCBjb25maWcpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkobW9kZWxzKSkge1xuICAgICAgICAgICAgdGhpcy5hZGQobW9kZWxzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7W118b2JqZWN0fVxuICAgICAqL1xuICAgIGdldE1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbDtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W118SmlpLmJhc2UuTW9kZWx8SmlpLmJhc2UuTW9kZWxbXX0gbW9kZWxzXG4gICAgICovXG4gICAgc2V0TW9kZWxzOiBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NoYW5nZSh0aGlzLmxlbmd0aCwgbW9kZWxzLCBbXSwgdHJ1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R8b2JqZWN0W118SmlpLmJhc2UuTW9kZWx8SmlpLmJhc2UuTW9kZWxbXX0gbW9kZWxzXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleF1cbiAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuTW9kZWxbXX1cbiAgICAgKi9cbiAgICBhZGQ6IGZ1bmN0aW9uKG1vZGVscywgaW5kZXgpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaW5kZXggJiYgaW5kZXggIT09IDApIHtcbiAgICAgICAgICAgIGluZGV4ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NoYW5nZShpbmRleCwgbW9kZWxzLCBbXSkuYWRkZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfCpbXX0gbW9kZWxzXG4gICAgICogQHJldHVybnMge0ppaS5iYXNlLk1vZGVsW119XG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihtb2RlbHMpIHtcbiAgICAgICAgaWYgKCFKaWkuXy5pc0FycmF5KG1vZGVscykpIHtcbiAgICAgICAgICAgIG1vZGVscyA9IFttb2RlbHNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9jaGFuZ2UoMCwgW10sIG1vZGVscykucmVtb3ZlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R8b2JqZWN0W119IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZV1cbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBzZXQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIC8vIEZvcm1hdCBbMF0ubmFtZVxuICAgICAgICB2YXIgaW5kZXhGb3JtYXQgPSB0aGlzLl9kZXRlY3RLZXlGb3JtYXRJbmRleChuYW1lKTtcbiAgICAgICAgaWYgKGluZGV4Rm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmF0KGluZGV4Rm9ybWF0LmluZGV4KTtcbiAgICAgICAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtb2RlbC5zZXQoaW5kZXhGb3JtYXQuc3ViTmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdOb3QgZm91bmQgbW9kZWwgd2l0aCBpbmRleCBgJyArIGluZGV4Rm9ybWF0LmluZGV4ICsgJ2AgZm9yIHNldCBhdHRyaWJ1dGUgYCcgKyBpbmRleEZvcm1hdC5zdWJOYW1lICsgJ2AuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPYmplY3QgZm9ybWF0XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChuYW1lKSAmJiAhSmlpLl8uaGFzKG5hbWUsICdtb2RlbENsYXNzJykpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNldE1vZGVscyhuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFycmF5IGZvcm1hdFxuICAgICAgICBpZiAoSmlpLl8uaXNBcnJheShuYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0TW9kZWxzKG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdXBlcihuYW1lLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgLy8gRm9ybWF0IFswXS5uYW1lXG4gICAgICAgIHZhciBpbmRleEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdEluZGV4KG5hbWUpO1xuICAgICAgICBpZiAoaW5kZXhGb3JtYXQpIHtcbiAgICAgICAgICAgIHZhciBtb2RlbCA9IHRoaXMuYXQoaW5kZXhGb3JtYXQuaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGluZGV4Rm9ybWF0LnN1Yk5hbWUgPyBtb2RlbC5nZXQoaW5kZXhGb3JtYXQuc3ViTmFtZSkgOiBtb2RlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gR2V0IGJ5IHBrXG4gICAgICAgIHZhciBwcmltYXJ5S2V5ID0gdGhpcy5fZ2V0UHJpbWFyeUtleShuYW1lKTtcbiAgICAgICAgaWYgKEppaS5fLmhhcyh0aGlzLl9ieUlkLCBwcmltYXJ5S2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbcHJpbWFyeUtleV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICogQHJldHVybnMge3tpbmRleDogbnVtYmVyLCBzdWJOYW1lOiBzdHJpbmd8bnVsbH19XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZGV0ZWN0S2V5Rm9ybWF0SW5kZXg6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAvXlxcWyhbMC05XSspXFxdXFwuPyguKikvLmV4ZWMobmFtZSk7XG4gICAgICAgIGlmIChtYXRjaGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbmRleDogcGFyc2VJbnQobWF0Y2hlc1sxXSksXG4gICAgICAgICAgICBzdWJOYW1lOiBtYXRjaGVzWzJdIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ3xvYmplY3R9IHByaW1hcnlLZXlcbiAgICAgKiBAcmV0dXJucyB7KnxudWxsfVxuICAgICAqL1xuICAgIGdldEJ5SWQ6IGZ1bmN0aW9uKHByaW1hcnlLZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2J5SWRbdGhpcy5fZ2V0UHJpbWFyeUtleShwcmltYXJ5S2V5KV0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICB0b0pTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kZWwudG9KU09OKG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBhdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgaW5kZXggPSBNYXRoLm1heCgwLCB0aGlzLmxlbmd0aCArIGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1tpbmRleF0gfHwgbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IFttb2RlbHNdXG4gICAgICovXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKG1vZGVscykge1xuICAgICAgICBtb2RlbHMgPSBtb2RlbHMgfHwgW107XG4gICAgICAgIGlmICghSmlpLl8uaXNBcnJheShtb2RlbHMpKSB7XG4gICAgICAgICAgICBtb2RlbHMgPSBbbW9kZWxzXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b0FkZCA9IFtdO1xuICAgICAgICBKaWkuXy5lYWNoKG1vZGVscywgZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgdmFyIGZpbmVkTW9kZWxzID0gdGhpcy5fZmluZE1vZGVscyhkYXRhKTtcbiAgICAgICAgICAgIGlmIChmaW5lZE1vZGVscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IGRhdGEgdG8gbW9kZWxcbiAgICAgICAgICAgICAgICBKaWkuXy5lYWNoKHRoaXMuX2ZpbmRNb2RlbHMoZGF0YSksIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChKaWkuXy5pbmRleE9mKHRvQWRkLCBtb2RlbCkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKG1vZGVsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b0FkZC5wdXNoKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHZhciB0b1JlbW92ZSA9IFtdO1xuICAgICAgICBKaWkuXy5lYWNoKHRoaXMuZ2V0TW9kZWxzKCksIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaW5kZXhPZih0b0FkZCwgbW9kZWwpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRvUmVtb3ZlLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9jaGFuZ2UoMCwgdG9BZGQsIHRvUmVtb3ZlLCB0cnVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7SmlpLmJhc2UuT2JqZWN0Ll9fc3VwZXJ9XG4gICAgICovXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbmV3IHRoaXMuX19zdXBlcih0aGlzLmdldE1vZGVscygpLCB7XG4gICAgICAgICAgICBtb2RlbENsYXNzOiB0aGlzLm1vZGVsQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2J5SWQgID0ge307XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zcGxpY2UuY2FsbCh0aGlzLCAwLCB0aGlzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIF9jaGFuZ2U6IGZ1bmN0aW9uKHN0YXJ0SW5kZXgsIHRvQWRkLCB0b1JlbW92ZSwgdW5pcXVlKSB7XG4gICAgICAgIHVuaXF1ZSA9IHVuaXF1ZSB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgYWRkZWQgPSBbXTtcbiAgICAgICAgdmFyIHJlbW92ZWQgPSBbXTtcbiAgICAgICAgdmFyIGlzU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgLy8gUmVtb3ZlXG4gICAgICAgIEppaS5fLmVhY2godG9SZW1vdmUsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZmluZE1vZGVscyhkYXRhKSwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4T2YobW9kZWwpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA8IHN0YXJ0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRJbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJlbW92ZWQucHVzaChtb2RlbCk7XG5cbiAgICAgICAgICAgICAgICAvLyBBcnJheSBhY2Nlc3NcbiAgICAgICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc3BsaWNlLmNhbGwodGhpcywgaW5kZXgsIDEpO1xuXG4gICAgICAgICAgICAgICAgLy8gQnkgaWRcbiAgICAgICAgICAgICAgICBpZiAobW9kZWwgaW5zdGFuY2VvZiBKaWkuYmFzZS5BY3RpdmVSZWNvcmQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2J5SWRbdGhpcy5fZ2V0UHJpbWFyeUtleShtb2RlbCldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gQWRkXG4gICAgICAgIEppaS5fLmVhY2godG9BZGQsIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIHZhciBleGlzdHNNb2RlbHMgPSB1bmlxdWUgPyB0aGlzLl9maW5kTW9kZWxzKGRhdGEpIDogW107XG4gICAgICAgICAgICB2YXIgbW9kZWxzID0gZXhpc3RzTW9kZWxzLmxlbmd0aCA+IDAgPyBleGlzdHNNb2RlbHMgOiBbdGhpcy5jcmVhdGVNb2RlbChkYXRhKV07XG5cbiAgICAgICAgICAgIEppaS5fLmVhY2gobW9kZWxzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIG1vdmluZ1xuICAgICAgICAgICAgICAgIGlmIChleGlzdHNNb2RlbHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBpc1NvcnRlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIG1vZGVsIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vZGVsIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwgJiYgSmlpLl8uaXNPYmplY3QoZGF0YSkgJiYgIShkYXRhIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbC5zZXQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhZGRlZC5wdXNoKG1vZGVsKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBBcnJheSBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNwbGljZS5jYWxsKHRoaXMsIHN0YXJ0SW5kZXgrKywgMCwgbW9kZWwpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGlkXG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RlbCBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fYnlJZFt0aGlzLl9nZXRQcmltYXJ5S2V5KG1vZGVsKV0gPSBtb2RlbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gTGF6eSBzdWJzY3JpYmUgb24gYWRkZWRcbiAgICAgICAgSmlpLl8uZWFjaChhZGRlZCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZXZlbnRzQ2hhbmdlTmFtZSwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwub24uYXBwbHkobW9kZWwsIGFycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBVbnN1YnNjcmliZSBvbiByZW1vdmVkXG4gICAgICAgIEppaS5fLmVhY2gocmVtb3ZlZCwgZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZXZlbnRzQ2hhbmdlTmFtZSwgZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwub2ZmLmFwcGx5KG1vZGVsLCBhcnIuc2xpY2UoMCwgMikpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG5cbiAgICAgICAgLy8gVHJpZ2dlciBldmVudHNcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEppaS5tb2RlbC5Db2xsZWN0aW9uRXZlbnQoe1xuICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgICB9KVxuICAgICAgICBpZiAoYWRkZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQURELCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfUkVNT1ZFLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0UsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5fb25Tb3J0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWRkZWQ6IGFkZGVkLFxuICAgICAgICAgICAgcmVtb3ZlZDogcmVtb3ZlZFxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfG9iamVjdH0gZGF0YVxuICAgICAqIEByZXR1cm5zIHsqfCpbXX1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9maW5kTW9kZWxzOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBwcmltYXJ5S2V5ID0gdGhpcy5fZ2V0UHJpbWFyeUtleShkYXRhKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJpbWFyeUtleSA9PSB0aGlzLl9nZXRQcmltYXJ5S2V5KG1vZGVsKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcnxzdHJpbmd8b2JqZWN0fSBkYXRhXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBfZ2V0UHJpbWFyeUtleTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBpZiAoSmlpLl8uaXNPYmplY3QoZGF0YSkgJiYgdGhpcy5tb2RlbENsYXNzICYmICEoZGF0YSBpbnN0YW5jZW9mIEppaS5iYXNlLkFjdGl2ZVJlY29yZCkpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLmNyZWF0ZU1vZGVsKGRhdGEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBKaWkuYmFzZS5BY3RpdmVSZWNvcmQpIHtcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmdldFByaW1hcnlLZXkoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGFueSBkYXRhIHRvIG1vZGVsXG4gICAgICogQHBhcmFtIHtvYmplY3R8Kn0gZGF0YVxuICAgICAqIEByZXR1cm5zIHtKaWkuYmFzZS5Nb2RlbH1cbiAgICAgKi9cbiAgICBjcmVhdGVNb2RlbDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAvLyBBbHJlYWR5IG1vZGVsXG4gICAgICAgIGlmIChkYXRhIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGlzYWJsZWQgbW9kZWwgYXV0byBjcmVhdGVcbiAgICAgICAgaWYgKHRoaXMubW9kZWxDbGFzcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVxdWlyZWRcbiAgICAgICAgaWYgKHRoaXMubW9kZWxDbGFzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbignUHJvcGVydHkgYG1vZGVsQ2xhc3NgIGluIGNvbGxlY3Rpb24gaXMgcmVxdWlyZWQgKG9yIHNldCBmYWxzZSB0byBmb3JjZSBkaXNhYmxlKS4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgdmFyIG1vZGVsQ2xhc3MgPSB0aGlzLm1vZGVsQ2xhc3M7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaXNTdHJpbmcobW9kZWxDbGFzcykpIHtcbiAgICAgICAgICAgICAgICBtb2RlbENsYXNzID0gSmlpLm5hbWVzcGFjZShtb2RlbENsYXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghSmlpLl8uaXNGdW5jdGlvbihtb2RlbENsYXNzKSkge1xuICAgICAgICAgICAgICAgIEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ05vdCBmb3VuZCBtb2RlbCBjbGFzcyBmb3IgY3JlYXRlIGluc3RhbmNlIGluIGNvbGxlY3Rpb24sIG1vZGVsQ2xhc3M6ICcgKyB0aGlzLm1vZGVsQ2xhc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IG1vZGVsQ2xhc3MoZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdDYW5ub3QgY3JlYXRlIG1vZGVsIGluc3RhbmNlIGZyb20gZGF0YTogJyArIEpTT04uc3RyaW5naWZ5KGRhdGEpKTtcbiAgICB9LFxuXG4gICAgX29uU29ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIEB0b2RvIFRyaWdnZXIgc29ydCBldmVudFxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXJcbiAgICAgKiBAcGFyYW0geyp9IFtkYXRhXVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzQXBwZW5kXVxuICAgICAqL1xuICAgIG9uOiBmdW5jdGlvbihuYW1lLCBoYW5kbGVyLCBkYXRhLCBpc0FwcGVuZCkge1xuICAgICAgICAvLyBNdWx0aXBsZSBuYW1lcyBzdXBwb3J0XG4gICAgICAgIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVFdmVudE5hbWVzKG5hbWUpO1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKG4sIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQXR0cmlidXRlcyBpbiBtb2RlbHNcbiAgICAgICAgdmFyIGNoYW5nZU5hbWVGb3JtYXQgPSB0aGlzLl9kZXRlY3RLZXlGb3JtYXRDaGFuZ2VOYW1lKG5hbWUpO1xuICAgICAgICBpZiAoY2hhbmdlTmFtZUZvcm1hdCkge1xuICAgICAgICAgICAgdmFyIGNoYW5nZU5hbWVFdmVudCA9IEppaS5iYXNlLk1vZGVsLkVWRU5UX0NIQU5HRV9OQU1FICsgY2hhbmdlTmFtZUZvcm1hdC5zdWJOYW1lO1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRzQ2hhbmdlTmFtZS5wdXNoKFtjaGFuZ2VOYW1lRXZlbnQsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kXSk7XG4gICAgICAgICAgICB0aGlzLmVhY2goZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5vbihjaGFuZ2VOYW1lRXZlbnQsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9fc3VwZXIobmFtZSwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gbmFtZVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtoYW5kbGVyXVxuICAgICAqIEByZXR1cm4gYm9vbGVhblxuICAgICAqL1xuICAgIG9mZjogZnVuY3Rpb24obmFtZSwgaGFuZGxlcikge1xuICAgICAgICAvLyBNdWx0aXBsZSBuYW1lcyBzdXBwb3J0XG4gICAgICAgIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVFdmVudE5hbWVzKG5hbWUpO1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgYm9vbCA9IGZhbHNlO1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbihuKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub24obiwgaGFuZGxlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgYm9vbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybiBib29sO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmFtZSA9IG5hbWVbMF07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBdHRyaWJ1dGVzIGluIG1vZGVsc1xuICAgICAgICB2YXIgY2hhbmdlTmFtZUZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdENoYW5nZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChjaGFuZ2VOYW1lRm9ybWF0KSB7XG4gICAgICAgICAgICB2YXIgY2hhbmdlTmFtZUV2ZW50ID0gSmlpLmJhc2UuTW9kZWwuRVZFTlRfQ0hBTkdFX05BTUUgKyBjaGFuZ2VOYW1lRm9ybWF0LnN1Yk5hbWU7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHNDaGFuZ2VOYW1lID0gSmlpLl8uZmlsdGVyKHRoaXMuX2V2ZW50c0NoYW5nZU5hbWUsIGZ1bmN0aW9uKGFycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJbMF0gIT09IGNoYW5nZU5hbWVFdmVudCB8fCBhcnJbMV0gIT09IGhhbmRsZXI7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGJvb2wgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZWFjaChmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgICAgIGlmIChtb2RlbC5vZmYoY2hhbmdlTmFtZUV2ZW50LCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBib29sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fX3N1cGVyKG5hbWUsIGhhbmRsZXIpO1xuICAgIH0sXG5cbiAgICBfZGV0ZWN0S2V5Rm9ybWF0Q2hhbmdlTmFtZTogZnVuY3Rpb24obmFtZSkge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKHRoaXMuX19zdGF0aWMuRVZFTlRfQ0hBTkdFX05BTUUpICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWJOYW1lOiBuYW1lLnN1YnN0cih0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRV9OQU1FLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gQXJyYXkgcHJvdG90eXBlXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gdmFsdWUxXG4gICAgICogQHJldHVybnMge3NlbGZ9XG4gICAgICovXG4gICAgY29uY2F0OiBmdW5jdGlvbih2YWx1ZTEpIHtcbiAgICAgICAgdGhpcy5hZGQoSmlpLl8udG9BcnJheShhcmd1bWVudHMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgcmV2ZXJzZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5yZXZlcnNlLmNhbGwodGhpcyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgc29ydDogZnVuY3Rpb24oKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zb3J0LmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuX29uU29ydCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIGpvaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kb1xuICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kb1xuICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICovXG4gICAgdG9Mb2NhbGVTdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBAdG9kb1xuICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuTm90U3VwcG9ydGVkRXhjZXB0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVsZXRlQ291bnRcbiAgICAgKiBAcGFyYW0gey4uLm9iamVjdH0gW21vZGVsMV1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgc3BsaWNlOiBmdW5jdGlvbihzdGFydCwgZGVsZXRlQ291bnQsIG1vZGVsMSkge1xuICAgICAgICB2YXIgdG9SZW1vdmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLCBzdGFydCwgc3RhcnQgKyBkZWxldGVDb3VudCk7XG4gICAgICAgIHRoaXMucmVtb3ZlKHRvUmVtb3ZlKTtcbiAgICAgICAgdGhpcy5hZGQoSmlpLl8udG9BcnJheShhcmd1bWVudHMpLnNsaWNlKDIpLCBzdGFydCk7XG4gICAgICAgIHJldHVybiB0b1JlbW92ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYmVnaW5cbiAgICAgKiBAcGFyYW0gZW5kXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2xpY2U6IGZ1bmN0aW9uKGJlZ2luLCBlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLl9fc3RhdGljKEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMsIGJlZ2luLCBlbmQpLCB7XG4gICAgICAgICAgICBtb2RlbENsYXNzOiB0aGlzLm1vZGVsQ2xhc3NcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R9IG1vZGVsMVxuICAgICAqL1xuICAgIHB1c2g6IGZ1bmN0aW9uKG1vZGVsMSkge1xuICAgICAgICB0aGlzLmFkZChKaWkuXy50b0FycmF5KGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgcG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdGhpcy5yZW1vdmUobW9kZWwpO1xuICAgICAgICByZXR1cm4gbW9kZWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R9IG1vZGVsMVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgdW5zaGlmdDogZnVuY3Rpb24obW9kZWwxKSB7XG4gICAgICAgIHRoaXMuYWRkKEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKSwgMCk7XG4gICAgICAgIHJldHVybiB0aGlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIHNoaWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb2RlbCA9IHRoaXNbMF07XG4gICAgICAgIHRoaXMucmVtb3ZlKG1vZGVsKTtcbiAgICAgICAgcmV0dXJuIG1vZGVsO1xuICAgIH0sXG5cbiAgICAvLyBAdG9kbyBFUzYgbWV0aG9kc1xuICAgIC8vZXM2IGNvcHlXaXRoaW46IGZ1bmN0aW9uKCkge30sXG4gICAgLy9lczYgZW50cmllczogZnVuY3Rpb24oKSB7fSxcbiAgICAvL2VzNiBmaWxsOiBmdW5jdGlvbigpIHt9LFxuICAgIC8vZXM2IGtleXM6IGZ1bmN0aW9uKCkge30sXG4gICAgLy9lczYgdmFsdWVzOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLy8gVW5kZXJzY29yZSBtZXRob2RzXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGl0ZXJhdGVlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqL1xuICAgIGVhY2g6IGZ1bmN0aW9uKGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5lYWNoKHRoaXMsIGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBmb3JFYWNoOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIG1hcDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLm1hcCh0aGlzLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlcmF0ZWVcbiAgICAgKiBAcGFyYW0geyp9IFttZW1vXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgcmVkdWNlOiBmdW5jdGlvbihpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8ucmVkdWNlKHRoaXMsIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZVxuICAgICAqIEBwYXJhbSB7Kn0gW21lbW9dXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICByZWR1Y2VSaWdodDogZnVuY3Rpb24oaXRlcmF0ZWUsIG1lbW8sIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLnJlZHVjZVJpZ2h0KHRoaXMsIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBmaW5kOiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmZpbmQodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIGZpbHRlcjogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5maWx0ZXIodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcGVydGllc1xuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgd2hlcmU6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLndoZXJlKHRoaXMsIHByb3BlcnRpZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBmaW5kV2hlcmU6IGZ1bmN0aW9uKHByb3BlcnRpZXMpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmZpbmRXaGVyZSh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBwcmVkaWNhdGVcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG4gICAgICogQHJldHVybnMge1tdfVxuICAgICAqL1xuICAgIHJlamVjdDogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5yZWplY3QodGhpcywgcHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcHJlZGljYXRlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKi9cbiAgICBldmVyeTogZnVuY3Rpb24ocHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5ldmVyeSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVkaWNhdGVdXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqL1xuICAgIHNvbWU6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uc29tZSh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4XVxuICAgICAqL1xuICAgIGNvbnRhaW5zOiBmdW5jdGlvbih2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5jb250YWlucyh0aGlzLCB2YWx1ZSwgZnJvbUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleF1cbiAgICAgKi9cbiAgICBpbmNsdWRlczogZnVuY3Rpb24odmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWlucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kTmFtZV1cbiAgICAgKiBAcGFyYW0gey4uLip9IFttZXRob2RQYXJhbV1cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgaW52b2tlOiBmdW5jdGlvbihtZXRob2ROYW1lLCBtZXRob2RQYXJhbSkge1xuICAgICAgICB2YXIgYXJncyA9IEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICByZXR1cm4gSmlpLl8uaW52b2tlLmFwcGx5KEppaS5fLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHBsdWNrOiBmdW5jdGlvbihwcm9wZXJ0eU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLm1hcCh0aGlzLCBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIEppaS5fLmlzRnVuY3Rpb24obW9kZWwuZ2V0KSA/IG1vZGVsLmdldChwcm9wZXJ0eU5hbWUpIDogbW9kZWxbcHJvcGVydHlOYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2l0ZXJhdGVlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIG1heDogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLm1heCh0aGlzLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2l0ZXJhdGVlXVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIG1pbjogZnVuY3Rpb24oaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLm1pbih0aGlzLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHZhbHVlXG4gICAgICogQHBhcmFtIFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBzb3J0Qnk6IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IEppaS5fLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUgOiBmdW5jdGlvbihtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIEppaS5fLmlzRnVuY3Rpb24obW9kZWwuZ2V0KSA/IG1vZGVsLmdldCh2YWx1ZSkgOiBtb2RlbFt2YWx1ZV07XG4gICAgICAgIH07XG4gICAgICAgIEppaS5fLmVhY2goSmlpLl8uc29ydEJ5KHRoaXMsIGl0ZXJhdG9yLCBjb250ZXh0KSwgZnVuY3Rpb24obW9kZWwsIGkpIHtcbiAgICAgICAgICAgIHRoaXNbaV0gPSBtb2RlbDtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy5fb25Tb3J0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHZhbHVlXG4gICAgICogQHBhcmFtIFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBncm91cEJ5OiBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBKaWkuXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKG1vZGVsLmdldCkgPyBtb2RlbC5nZXQodmFsdWUpIDogbW9kZWxbdmFsdWVdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSmlpLl8uZ3JvdXBCeSh0aGlzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHZhbHVlXG4gICAgICogQHBhcmFtIFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBpbmRleEJ5OiBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBKaWkuXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKG1vZGVsLmdldCkgPyBtb2RlbC5nZXQodmFsdWUpIDogbW9kZWxbdmFsdWVdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSmlpLl8uaW5kZXhCeSh0aGlzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd8ZnVuY3Rpb259IHZhbHVlXG4gICAgICogQHBhcmFtIFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICBjb3VudEJ5OiBmdW5jdGlvbih2YWx1ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBKaWkuXy5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlIDogZnVuY3Rpb24obW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBKaWkuXy5pc0Z1bmN0aW9uKG1vZGVsLmdldCkgPyBtb2RlbC5nZXQodmFsdWUpIDogbW9kZWxbdmFsdWVdO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gSmlpLl8uY291bnRCeSh0aGlzLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBbbnVtXVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmlyc3Q6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgICByZXR1cm4gSmlpLl8uZmlyc3QodGhpcywgbnVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW251bV1cbiAgICAgKiBAcmV0dXJucyB7W119XG4gICAgICovXG4gICAgaW5pdGlhbDogZnVuY3Rpb24obnVtKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5pbml0aWFsKHRoaXMsIG51bSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIFtudW1dXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBsYXN0OiBmdW5jdGlvbihudW0pIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmxhc3QodGhpcywgbnVtKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gW2luZGV4XVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgcmVzdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLnJlc3QodGhpcywgaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlXVxuICAgICAqIEByZXR1cm5zIHtbXX1cbiAgICAgKi9cbiAgICB3aXRob3V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgYXJncyA9IEppaS5fLnRvQXJyYXkoYXJndW1lbnRzKTtcbiAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMpO1xuICAgICAgICByZXR1cm4gSmlpLl8ud2l0aG91dC5hcHBseShKaWkuXywgYXJncyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNTb3J0ZWRdXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBpbmRleE9mOiBmdW5jdGlvbih2YWx1ZSwgaXNTb3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmluZGV4T2YodGhpcywgdmFsdWUsIGlzU29ydGVkKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXhdXG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBsYXN0SW5kZXhPZjogZnVuY3Rpb24odmFsdWUsIGZyb21JbmRleCkge1xuICAgICAgICByZXR1cm4gSmlpLl8ubGFzdEluZGV4T2YodGhpcywgdmFsdWUsIGZyb21JbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IG1vZGVsXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHNvcnRlZEluZGV4OiBmdW5jdGlvbihtb2RlbCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gSmlpLl8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZSA6IGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gSmlpLl8uaXNGdW5jdGlvbihtb2RlbC5nZXQpID8gbW9kZWwuZ2V0KHZhbHVlKSA6IG1vZGVsW3ZhbHVlXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIEppaS5fLnNvcnRlZEluZGV4KHRoaXMsIG1vZGVsLCBpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmdW5jdGlvbn0gcHJlZGljYXRlXG4gICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0XVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICovXG4gICAgZmluZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIEppaS5fLmZpbmRJbmRleCh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF1cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGZpbmRMYXN0SW5kZXg6IGZ1bmN0aW9uKHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gSmlpLl8uZmluZExhc3RJbmRleCh0aGlzLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqL1xuICAgIHNodWZmbGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBKaWkuXy5zaHVmZmxlKHRoaXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDA7XG4gICAgfVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSw5OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL0NvbGxlY3Rpb24nKTtcblxuLyoqXG4gKiBCYXNlRGF0YVByb3ZpZGVyIHByb3ZpZGVzIGEgYmFzZSBjbGFzcyB0aGF0IGltcGxlbWVudHMgdGhlIFtbRGF0YVByb3ZpZGVySW50ZXJmYWNlXV0uXG4gKlxuICogQGNsYXNzIEppaS5iYXNlLkRhdGFQcm92aWRlclxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29sbGVjdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkRhdGFQcm92aWRlcicsIC8qKiBAbGVuZHMgSmlpLmJhc2UuRGF0YVByb3ZpZGVyLnByb3RvdHlwZSAqL3tcblxuICAgIF9fZXh0ZW5kczogSmlpLmJhc2UuQ29sbGVjdGlvbixcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd9IGFuIElEIHRoYXQgdW5pcXVlbHkgaWRlbnRpZmllcyB0aGUgZGF0YSBwcm92aWRlciBhbW9uZyBhbGwgZGF0YSBwcm92aWRlcnMuXG4gICAgICogWW91IHNob3VsZCBzZXQgdGhpcyBwcm9wZXJ0eSBpZiB0aGUgc2FtZSBwYWdlIGNvbnRhaW5zIHR3byBvciBtb3JlIGRpZmZlcmVudCBkYXRhIHByb3ZpZGVycy5cbiAgICAgKiBPdGhlcndpc2UsIHRoZSBbW3BhZ2luYXRpb25dXSBhbmQgW1tzb3J0XV0gbWF5IG5vdCB3b3JrIHByb3Blcmx5LlxuICAgICAqL1xuICAgIGlkOiBudWxsLFxuXG4gICAgX3NvcnQ6IG51bGwsXG4gICAgX3BhZ2luYXRpb246IG51bGwsXG4gICAgX2tleXM6IG51bGwsXG4gICAgX2lzTW9kZWxzUHJlcGFyZTogZmFsc2UsXG4gICAgX3RvdGFsQ291bnQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgZGF0YSBtb2RlbHMgdGhhdCB3aWxsIGJlIG1hZGUgYXZhaWxhYmxlIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICogQHJldHVybnMge1tdfSB0aGUgYXZhaWxhYmxlIGRhdGEgbW9kZWxzXG4gICAgICovXG4gICAgcHJlcGFyZU1vZGVsczogZnVuY3Rpb24gKCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIHRoZSBrZXlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudGx5IGF2YWlsYWJsZSBkYXRhIG1vZGVscy5cbiAgICAgKiBAcGFyYW0ge1tdfSBtb2RlbHMgdGhlIGF2YWlsYWJsZSBkYXRhIG1vZGVsc1xuICAgICAqIEByZXR1cm5zIHtbXX0gdGhlIGtleXNcbiAgICAgKi9cbiAgICBwcmVwYXJlS2V5czogZnVuY3Rpb24gKG1vZGVscykge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHRoZSB0b3RhbCBudW1iZXIgb2YgZGF0YSBtb2RlbHMgaW4gdGhpcyBkYXRhIHByb3ZpZGVyLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IHRvdGFsIG51bWJlciBvZiBkYXRhIG1vZGVscyBpbiB0aGlzIGRhdGEgcHJvdmlkZXIuXG4gICAgICovXG4gICAgcHJlcGFyZVRvdGFsQ291bnQ6IGZ1bmN0aW9uICgpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyB0aGUgZGF0YSBtb2RlbHMgYW5kIGtleXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIHByZXBhcmUgdGhlIGRhdGEgbW9kZWxzIGFuZCBrZXlzIHRoYXQgY2FuIGJlIHJldHJpZXZlZCB2aWFcbiAgICAgKiBbW2dldE1vZGVscygpXV0gYW5kIFtbZ2V0S2V5cygpXV0uXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCB3aWxsIGJlIGltcGxpY2l0bHkgY2FsbGVkIGJ5IFtbZ2V0TW9kZWxzKCldXSBhbmQgW1tnZXRLZXlzKCldXSBpZiBpdCBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlUHJlcGFyZV0gd2hldGhlciB0byBmb3JjZSBkYXRhIHByZXBhcmF0aW9uIGV2ZW4gaWYgaXQgaGFzIGJlZW4gZG9uZSBiZWZvcmUuXG4gICAgICovXG4gICAgcHJlcGFyZTogZnVuY3Rpb24gKGZvcmNlUHJlcGFyZSkge1xuICAgICAgICBmb3JjZVByZXBhcmUgPSBmb3JjZVByZXBhcmUgfHwgZmFsc2U7XG5cbiAgICAgICAgaWYgKGZvcmNlUHJlcGFyZSB8fCAhdGhpcy5faXNNb2RlbHNQcmVwYXJlKSB7XG4gICAgICAgICAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKHRoaXMucHJlcGFyZU1vZGVscygpLCBmdW5jdGlvbiAobW9kZWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2gobW9kZWwpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VQcmVwYXJlIHx8IHRoaXMuX2tleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2tleXMgPSB0aGlzLnByZXBhcmVLZXlzKHRoaXMuX21vZGVscyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgZGF0YSBtb2RlbHMgaW4gdGhlIGN1cnJlbnQgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7W119IHRoZSBsaXN0IG9mIGRhdGEgbW9kZWxzIGluIHRoZSBjdXJyZW50IHBhZ2UuXG4gICAgICovXG4gICAgZ2V0TW9kZWxzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc3VwZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUga2V5IHZhbHVlcyBhc3NvY2lhdGVkIHdpdGggdGhlIGRhdGEgbW9kZWxzLlxuICAgICAqIEByZXR1cm5zIHtbXX0gdGhlIGxpc3Qgb2Yga2V5IHZhbHVlcyBjb3JyZXNwb25kaW5nIHRvIFtbbW9kZWxzXV0uIEVhY2ggZGF0YSBtb2RlbCBpbiBbW21vZGVsc11dXG4gICAgICogaXMgdW5pcXVlbHkgaWRlbnRpZmllZCBieSB0aGUgY29ycmVzcG9uZGluZyBrZXkgdmFsdWUgaW4gdGhpcyBhcnJheS5cbiAgICAgKi9cbiAgICBnZXRLZXlzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZSgpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9rZXlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBrZXkgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZGF0YSBtb2RlbHMuXG4gICAgICogQHBhcmFtIHtbXX0ga2V5cyB0aGUgbGlzdCBvZiBrZXkgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gW1ttb2RlbHNdXS5cbiAgICAgKi9cbiAgICBzZXRLZXlzOiBmdW5jdGlvbiAoa2V5cykge1xuICAgICAgICB0aGlzLl9rZXlzID0ga2V5cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgbW9kZWxzLlxuICAgICAqIFdoZW4gW1twYWdpbmF0aW9uXV0gaXMgZmFsc2UsIHRoaXMgcmV0dXJucyB0aGUgc2FtZSB2YWx1ZSBhcyBbW2NvdW50XV0uXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGNhbGwgW1twcmVwYXJlVG90YWxDb3VudCgpXV0gdG8gZ2V0IHRoZSBjb3VudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0b3RhbCBudW1iZXIgb2YgcG9zc2libGUgZGF0YSBtb2RlbHMuXG4gICAgICovXG4gICAgZ2V0VG90YWxDb3VudDogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5nZXRQYWdpbmF0aW9uKCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb3VudCgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3RvdGFsQ291bnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX3RvdGFsQ291bnQgPSB0aGlzLnByZXBhcmVUb3RhbENvdW50KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5fdG90YWxDb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgbW9kZWxzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSB0aGUgdG90YWwgbnVtYmVyIG9mIGRhdGEgbW9kZWxzLlxuICAgICAqL1xuICAgIHNldFRvdGFsQ291bnQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICB0aGlzLl90b3RhbENvdW50ID0gdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIHBhZ2luYXRpb24gb2JqZWN0IHVzZWQgYnkgdGhpcyBkYXRhIHByb3ZpZGVyLlxuICAgICAqIE5vdGUgdGhhdCB5b3Ugc2hvdWxkIGNhbGwgW1twcmVwYXJlKCldXSBvciBbW2dldE1vZGVscygpXV0gZmlyc3QgdG8gZ2V0IGNvcnJlY3QgdmFsdWVzXG4gICAgICogb2YgW1tQYWdpbmF0aW9uLnRvdGFsQ291bnRdXSBhbmQgW1tQYWdpbmF0aW9uLnBhZ2VDb3VudF1dLlxuICAgICAqIEByZXR1cm5zIHtqaWkuZGF0YS5QYWdpbmF0aW9ufGJvb2xlYW59IHRoZSBwYWdpbmF0aW9uIG9iamVjdC4gSWYgdGhpcyBpcyBmYWxzZSwgaXQgbWVhbnMgdGhlIHBhZ2luYXRpb24gaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgZ2V0UGFnaW5hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKmlmICh0aGlzLl9wYWdpbmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICB0aGlzLnNldFBhZ2luYXRpb24oe30pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gdGhpcy5fcGFnaW5hdGlvbjsqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBwYWdpbmF0aW9uIGZvciB0aGlzIGRhdGEgcHJvdmlkZXIuXG4gICAgICogQHBhcmFtIHtbXXxqaWkuZGF0YS5QYWdpbmF0aW9ufGJvb2xlYW59IHZhbHVlIHRoZSBwYWdpbmF0aW9uIHRvIGJlIHVzZWQgYnkgdGhpcyBkYXRhIHByb3ZpZGVyLlxuICAgICAqIFRoaXMgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgICAqXG4gICAgICogLSBhIGNvbmZpZ3VyYXRpb24gYXJyYXkgZm9yIGNyZWF0aW5nIHRoZSBwYWdpbmF0aW9uIG9iamVjdC4gVGhlIFwiY2xhc3NcIiBlbGVtZW50IGRlZmF1bHRzXG4gICAgICogICB0byAnamlpXFxkYXRhXFxQYWdpbmF0aW9uJ1xuICAgICAqIC0gYW4gaW5zdGFuY2Ugb2YgW1tQYWdpbmF0aW9uXV0gb3IgaXRzIHN1YmNsYXNzXG4gICAgICogLSBmYWxzZSwgaWYgcGFnaW5hdGlvbiBuZWVkcyB0byBiZSBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgSW52YWxpZFBhcmFtRXhjZXB0aW9uXG4gICAgICovXG4gICAgc2V0UGFnaW5hdGlvbjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIEB0b2RvIFBhZ2luYXRpb24gJiBTb3J0XG4gICAgICAgIC8qaWYgKEppaS5fLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgY29uZmlnID0ge2NsYXNzOiBQYWdpbmF0aW9uLmNsYXNzTmFtZSgpfTtcbiAgICAgICAgIGlmICh0aGlzLmlkICE9PSBudWxsKSB7XG4gICAgICAgICBjb25maWdbJ3BhZ2VQYXJhbSddID0gdGhpcy5pZCAuICctcGFnZSc7XG4gICAgICAgICBjb25maWdbJ3BhZ2VTaXplUGFyYW0nXSA9IHRoaXMuaWQgLiAnLXBlci1wYWdlJztcbiAgICAgICAgIH1cbiAgICAgICAgIHRoaXMuX3BhZ2luYXRpb24gPSBKaWkuY3JlYXRlT2JqZWN0KGFycmF5X21lcmdlKGNvbmZpZywgdmFsdWUpKTtcbiAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgaW5zdGFuY2VvZiBQYWdpbmF0aW9uIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgdGhpcy5fcGFnaW5hdGlvbiA9IHZhbHVlO1xuICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1FeGNlcHRpb24oJ09ubHkgUGFnaW5hdGlvbiBpbnN0YW5jZSwgY29uZmlndXJhdGlvbiBhcnJheSBvciBmYWxzZSBpcyBhbGxvd2VkLicpO1xuICAgICAgICAgfSovXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtqaWkuZGF0YS5Tb3J0fGJvb2xlYW59IHRoZSBzb3J0aW5nIG9iamVjdC4gSWYgdGhpcyBpcyBmYWxzZSwgaXQgbWVhbnMgdGhlIHNvcnRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICovXG4gICAgZ2V0U29ydDogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKmlmICh0aGlzLl9zb3J0ID09PSBudWxsKSB7XG4gICAgICAgICB0aGlzLnNldFNvcnQoe30pO1xuICAgICAgICAgfVxuXG4gICAgICAgICByZXR1cm4gdGhpcy5fc29ydDsqL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzb3J0IGRlZmluaXRpb24gZm9yIHRoaXMgZGF0YSBwcm92aWRlci5cbiAgICAgKiBAcGFyYW0ge1tdfGppaS5kYXRhLlNvcnR8Ym9vbGVhbn0gdmFsdWUgdGhlIHNvcnQgZGVmaW5pdGlvbiB0byBiZSB1c2VkIGJ5IHRoaXMgZGF0YSBwcm92aWRlci5cbiAgICAgKiBUaGlzIGNhbiBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICAgKlxuICAgICAqIC0gYSBjb25maWd1cmF0aW9uIGFycmF5IGZvciBjcmVhdGluZyB0aGUgc29ydCBkZWZpbml0aW9uIG9iamVjdC4gVGhlIFwiY2xhc3NcIiBlbGVtZW50IGRlZmF1bHRzXG4gICAgICogICB0byAnamlpXFxkYXRhXFxTb3J0J1xuICAgICAqIC0gYW4gaW5zdGFuY2Ugb2YgW1tTb3J0XV0gb3IgaXRzIHN1YmNsYXNzXG4gICAgICogLSBmYWxzZSwgaWYgc29ydGluZyBuZWVkcyB0byBiZSBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgSW52YWxpZFBhcmFtRXhjZXB0aW9uXG4gICAgICovXG4gICAgc2V0U29ydDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIC8vIEB0b2RvIFBhZ2luYXRpb24gJiBTb3J0XG4gICAgICAgIC8qaWYgKEppaS5fLmlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgY29uZmlnID0ge2NsYXNzOiBTb3J0LmNsYXNzTmFtZSgpfTtcbiAgICAgICAgIGlmICh0aGlzLmlkICE9PSBudWxsKSB7XG4gICAgICAgICBjb25maWdbJ3NvcnRQYXJhbSddID0gdGhpcy5pZCAuICctc29ydCc7XG4gICAgICAgICB9XG4gICAgICAgICB0aGlzLl9zb3J0ID0gSmlpLmNyZWF0ZU9iamVjdChhcnJheV9tZXJnZShjb25maWcsIHZhbHVlKSk7XG4gICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU29ydCB8fCB2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgIHRoaXMuX3NvcnQgPSB2YWx1ZTtcbiAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdPbmx5IFNvcnQgaW5zdGFuY2UsIGNvbmZpZ3VyYXRpb24gYXJyYXkgb3IgZmFsc2UgaXMgYWxsb3dlZC4nKTtcbiAgICAgICAgIH0qL1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIGRhdGEgcHJvdmlkZXIuXG4gICAgICogQWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCwgaWYgW1tnZXRNb2RlbHMoKV1dLCBbW2dldEtleXMoKV1dIG9yIFtbZ2V0VG90YWxDb3VudCgpXV0gaXMgY2FsbGVkIGFnYWluLFxuICAgICAqIHRoZXkgd2lsbCByZS1leGVjdXRlIHRoZSBxdWVyeSBhbmQgcmV0dXJuIHRoZSBsYXRlc3QgZGF0YSBhdmFpbGFibGUuXG4gICAgICovXG4gICAgcmVmcmVzaDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnNwbGljZSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX3RvdGFsQ291bnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9rZXlzID0gbnVsbDtcbiAgICB9XG5cblxufSk7XG5cbn0se1wiLi9Db2xsZWN0aW9uXCI6OTgsXCJqaWlcIjoxMjR9XSwxMDA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuTW9kZWxcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk1vZGVsJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2RlbC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cblx0X2F0dHJpYnV0ZXM6IHt9LFxuXHRfZXJyb3JzOiB7fSxcblx0X3ZhbGlkYXRvcnM6IG51bGwsXG5cdF9zY2VuYXJpbzogJ2RlZmF1bHQnLFxuXG4gICAgX2VkaXRlZExldmVsOiAwLFxuICAgIF9lZGl0ZWRTdWJNb2RlbHM6IFtdLFxuICAgIF9lZGl0ZWRDaGFuZ2VzOiB7fSxcblxuICAgIF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5iYXNlLk1vZGVsICove1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuTW9kZWwjY2hhbmdlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLm1vZGVsLkNoYW5nZUV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQ0hBTkdFOiAnY2hhbmdlJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLk1vZGVsI2NoYW5nZTpcbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkubW9kZWwuQ2hhbmdlQXR0cmlidXRlRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9DSEFOR0VfTkFNRTogJ2NoYW5nZTonXG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICovXG4gICAgY29uc3RydWN0b3I6IGZ1bmN0aW9uIChhdHRyaWJ1dGVzLCBjb25maWcpIHtcbiAgICAgICAgaWYgKEppaS5fLmlzT2JqZWN0KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICB0aGlzLnNldChhdHRyaWJ1dGVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihjb25maWcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBWYWxpZGF0aW9uIHJ1bGVzXG4gICAgICogQHJldHVybnMge0FycmF5fVxuICAgICAqL1xuICAgIHJ1bGVzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQmVnaW4gY2hhbmdlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGJlZ2luRWRpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2VkaXRlZExldmVsKys7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENhbmNlbCBhbGwgY2hhbmdlcyBhZnRlciBiZWdpbkVkaXQoKSBjYWxsXG4gICAgICovXG4gICAgY2FuY2VsRWRpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9lZGl0ZWRMZXZlbCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2VkaXRlZExldmVsLS07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDYW5jZWwgaW4gc3ViLW1vZGVsc1xuICAgICAgICBpZiAodGhpcy5fZWRpdGVkTGV2ZWwgPT09IDApIHtcbiAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZWRpdGVkU3ViTW9kZWxzLCBmdW5jdGlvbiAoc3ViTW9kZWwpIHtcbiAgICAgICAgICAgICAgICBzdWJNb2RlbC5jYW5jZWxFZGl0KCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gUmV2ZXJ0IGF0dHJpYnV0ZSBjaGFuZ2VzXG4gICAgICAgICAgICBKaWkuXy5lYWNoKHRoaXMuX2VkaXRlZENoYW5nZXMsIGZ1bmN0aW9uICh2YWx1ZXMsIG5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWVzWzBdO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBFbmQgY2hhbmdlIG9wZXJhdGlvbiAtIHRyaWdnZXIgY2hhbmdlIGV2ZW50c1xuICAgICAqL1xuICAgIGVuZEVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZWRpdGVkTGV2ZWwgPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0ZWRMZXZlbC0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX2VkaXRlZExldmVsID09PSAwKSB7XG4gICAgICAgICAgICAvLyBFbmQgaW4gc3ViLW1vZGVsc1xuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9lZGl0ZWRTdWJNb2RlbHMsIGZ1bmN0aW9uKHN1Yk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgc3ViTW9kZWwuZW5kRWRpdCgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgY2hhbmdlIGF0dHJpYnV0ZSBldmVudHNcbiAgICAgICAgICAgIGlmICghSmlpLl8uaXNFbXB0eSh0aGlzLl9lZGl0ZWRDaGFuZ2VzKSkge1xuICAgICAgICAgICAgICAgIEppaS5fLmVhY2godGhpcy5fZWRpdGVkQ2hhbmdlcywgZnVuY3Rpb24odmFsdWVzLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0NIQU5HRV9OQU1FICsgbmFtZSwgbmV3IEppaS5tb2RlbC5DaGFuZ2VBdHRyaWJ1dGVFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBvbGRWYWx1ZTogdmFsdWVzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3VmFsdWU6IHZhbHVlc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiB0aGlzLl9lZGl0ZWRDaGFuZ2VzXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBjaGFuZ2UgZXZlbnRcbiAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9DSEFOR0UsIG5ldyBKaWkubW9kZWwuQ2hhbmdlRXZlbnQoe1xuICAgICAgICAgICAgICAgICAgICBzZW5kZXI6IHRoaXMsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5nZWRBdHRyaWJ1dGVzOiB0aGlzLl9lZGl0ZWRDaGFuZ2VzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5fZWRpdGVkU3ViTW9kZWxzID0gW107XG4gICAgICAgICAgICB0aGlzLl9lZGl0ZWRDaGFuZ2VzID0ge307XG4gICAgICAgIH1cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYXR0cmlidXRlIHZhbHVlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Z2V0OiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN1YiBtb2RlbHMgc3VwcG9ydDogZm9vWzBdXG4gICAgICAgIHZhciBjb2xsZWN0aW9uRm9ybWF0ID0gdGhpcy5fZGV0ZWN0S2V5Rm9ybWF0Q29sbGVjdGlvbihuYW1lLCAnJywgdHJ1ZSk7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uRm9ybWF0KSB7XG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbkZvcm1hdC5zdWJOYW1lID9cbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uRm9ybWF0Lm1vZGVsLmdldChjb2xsZWN0aW9uRm9ybWF0LnN1Yk5hbWUpIDpcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uRm9ybWF0Lm1vZGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3ViIG1vZGVscyBzdXBwb3J0OiBmb28uYmFyXG4gICAgICAgIHZhciBtb2RlbEZvcm1hdCA9IHRoaXMuX2RldGVjdEtleUZvcm1hdE1vZGVsKG5hbWUpO1xuICAgICAgICBpZiAobW9kZWxGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RlbEZvcm1hdC5tb2RlbCA/XG4gICAgICAgICAgICAgICAgbW9kZWxGb3JtYXQubW9kZWwuZ2V0KG1vZGVsRm9ybWF0LnN1Yk5hbWUpIDpcbiAgICAgICAgICAgICAgICBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fc3VwZXIobmFtZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmICghKGUgaW5zdGFuY2VvZiBKaWkuZXhjZXB0aW9ucy5Vbmtub3duUHJvcGVydHlFeGNlcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldCBhdHRyaWJ1dGUgdmFsdWVcblx0ICogQHBhcmFtIHtvYmplY3R8c3RyaW5nfSBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gW3ZhbHVlXVxuXHQgKi9cblx0c2V0OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgLy8gT2JqZWN0IGZvcm1hdCBzdXBwb3J0XG4gICAgICAgIGlmIChKaWkuXy5pc09iamVjdChuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5iZWdpbkVkaXQoKTtcblxuICAgICAgICAgICAgdmFyIGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgSmlpLl8uZWFjaChuYW1lLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnNldChuYW1lLCB2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICB0aGlzLmVuZEVkaXQoKTtcbiAgICAgICAgICAgIHJldHVybiBpc0NoYW5nZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdWIgbW9kZWxzIHN1cHBvcnQ6IGZvb1swXS5iYXIuemVuXG4gICAgICAgIHZhciBzdWJNYXRjaGVzID0gL14oLispXFwuKFteXFxbXFxdLl0rKSQvLmV4ZWMobmFtZSk7XG4gICAgICAgIGlmIChzdWJNYXRjaGVzICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgc3ViTW9kZWwgPSB0aGlzLmdldChzdWJNYXRjaGVzWzFdKTtcblxuICAgICAgICAgICAgLy8gQ2hlY2sgc3ViLW1vZGVsIGlzIEppaS5iYXNlLk1vZGVsXG4gICAgICAgICAgICBpZiAoc3ViTW9kZWwgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRQYXJhbUV4Y2VwdGlvbignVHJ5IHNldCBwcm9wZXJ0eSBvZiBhcnJheSBtb2RlbHM6IGAnICsgbmFtZSArICdgJyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCEoc3ViTW9kZWwgaW5zdGFuY2VvZiBKaWkuYmFzZS5Nb2RlbCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uKCdTZXR0aW5nIHByb3BlcnR5IG9mIG51bGwgc3ViLW1vZGVsIGAnICsgbmFtZSArICdgJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN1Yk1vZGVsLmJlZ2luRWRpdCgpO1xuICAgICAgICAgICAgdGhpcy5fZWRpdGVkU3ViTW9kZWxzLnB1c2goc3ViTW9kZWwpO1xuXG4gICAgICAgICAgICB2YXIgaXNTdWJDaGFuZ2VkID0gc3ViTW9kZWwuc2V0KHN1Yk1hdGNoZXNbMl0sIHZhbHVlKTtcblxuICAgICAgICAgICAgdGhpcy5lbmRFZGl0KCk7XG4gICAgICAgICAgICByZXR1cm4gaXNTdWJDaGFuZ2VkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzLmJlZ2luRWRpdCgpO1xuXG4gICAgICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdO1xuICAgICAgICAgICAgdmFyIGlzQXR0cmlidXRlQ2hhbmdlZCA9ICFKaWkuXy5pc0VxdWFsKG9sZFZhbHVlLCB2YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG5cbiAgICAgICAgICAgIGlmIChpc0F0dHJpYnV0ZUNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9lZGl0ZWRDaGFuZ2VzW25hbWVdID0gW29sZFZhbHVlLCB2YWx1ZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZW5kRWRpdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGlzQXR0cmlidXRlQ2hhbmdlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX19zdXBlcihuYW1lLCB2YWx1ZSk7XG5cdH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbc2tpcFRocm93XVxuICAgICAqIEByZXR1cm5zIHt7bW9kZWw6IEppaS5iYXNlLkFjdGl2ZVJlY29yZCwgbmFtZTogc3RyaW5nLCBzdWJOYW1lOiBzdHJpbmd9fG51bGx9XG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9kZXRlY3RLZXlGb3JtYXRDb2xsZWN0aW9uOiBmdW5jdGlvbihuYW1lLCBwcmVmaXgsIHNraXBUaHJvdykge1xuICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG4gICAgICAgIHNraXBUaHJvdyA9IHNraXBUaHJvdyB8fCBmYWxzZTtcblxuICAgICAgICAvLyBTdWIgbW9kZWxzIHN1cHBvcnQ6IGNoYW5nZTpmb29bMF1cbiAgICAgICAgdmFyIGFyclJlZ0V4cCA9IG5ldyBSZWdFeHAoJ14nICsgcHJlZml4ICsgJyhbXlxcXFxbXFxcXF0uXSspXFxcXFsoWy0wLTldKylcXFxcXShcXFxcLiguKykpPyQnKTtcbiAgICAgICAgdmFyIGFyck1hdGNoZXMgPSBhcnJSZWdFeHAuZXhlYyhuYW1lKTtcbiAgICAgICAgaWYgKGFyck1hdGNoZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbGxlY3Rpb24gPSB0aGlzLmdldChhcnJNYXRjaGVzWzFdKTtcbiAgICAgICAgaWYgKGNvbGxlY3Rpb24gaW5zdGFuY2VvZiBKaWkuYmFzZS5Db2xsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludChhcnJNYXRjaGVzWzJdKTtcbiAgICAgICAgICAgIHZhciBhcnJTdWJNb2RlbCA9IGNvbGxlY3Rpb24uYXQoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKGFyclN1Yk1vZGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IGFyclN1Yk1vZGVsLFxuICAgICAgICAgICAgICAgICAgICBzdWJOYW1lOiBhcnJNYXRjaGVzWzRdID8gcHJlZml4ICsgYXJyTWF0Y2hlc1s0XSA6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFza2lwVGhyb3cpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdNb2RlbCB3aXRoIGluZGV4IGAnICsgaW5kZXggKyAnYCBpbiBjb2xsZWN0aW9uIGAnICsgYXJyTWF0Y2hlc1sxXSArICdgIGlzIG5vdCBmb3VuZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc2tpcFRocm93KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdSZWxhdGlvbiBgJyArIGFyck1hdGNoZXNbMV0gKyAnYCBpcyBub3QgY29sbGVjdGlvbi4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXhdXG4gICAgICogQHJldHVybnMge3ttb2RlbDogSmlpLmJhc2UuQWN0aXZlUmVjb3JkfG51bGwsIG5hbWU6IHN0cmluZywgc3ViTmFtZTogc3RyaW5nfXxudWxsfVxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfZGV0ZWN0S2V5Rm9ybWF0TW9kZWw6IGZ1bmN0aW9uKG5hbWUsIHByZWZpeCkge1xuICAgICAgICBwcmVmaXggPSBwcmVmaXggfHwgJyc7XG5cbiAgICAgICAgaWYgKHByZWZpeCAmJiBuYW1lLmluZGV4T2YocHJlZml4KSAhPT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKHByZWZpeC5sZW5ndGgpO1xuXG4gICAgICAgIHZhciBkb3RJbmRleCA9IG5hbWUuaW5kZXhPZignLicpO1xuICAgICAgICBpZiAoZG90SW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWxhdGlvbk5hbWUgPSBuYW1lLnN1YnN0cigwLCBkb3RJbmRleCk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1vZGVsOiB0aGlzLmdldChyZWxhdGlvbk5hbWUpLFxuICAgICAgICAgICAgbmFtZTogcmVsYXRpb25OYW1lLFxuICAgICAgICAgICAgc3ViTmFtZTogcHJlZml4ICsgbmFtZS5zdWJzdHIoZG90SW5kZXggKyAxKVxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lZCBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogSWYgdGhpcyByZWNvcmQgaXMgdGhlIHJlc3VsdCBvZiBhIHF1ZXJ5IGFuZCB0aGUgYXR0cmlidXRlIGlzIG5vdCBsb2FkZWQsXG4gICAgICogbnVsbCB3aWxsIGJlIHJldHVybmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBhdHRyaWJ1dGUgbmFtZVxuICAgICAqIEByZXR1cm5zIHsqfSB0aGUgYXR0cmlidXRlIHZhbHVlLiBOdWxsIGlmIHRoZSBhdHRyaWJ1dGUgaXMgbm90IHNldCBvciBkb2VzIG5vdCBleGlzdC5cbiAgICAgKiBAc2VlIGhhc0F0dHJpYnV0ZSgpXG4gICAgICovXG4gICAgZ2V0QXR0cmlidXRlOiBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2F0dHJpYnV0ZXMsIG5hbWUpID8gdGhpcy5fYXR0cmlidXRlc1tuYW1lXSA6IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIG5hbWVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIHRoZSBhdHRyaWJ1dGUgdmFsdWUuXG4gICAgICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9ufSBpZiB0aGUgbmFtZWQgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LlxuICAgICAqIEBzZWUgaGFzQXR0cmlidXRlKClcbiAgICAgKi9cbiAgICBzZXRBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24odGhpcy5jbGFzc05hbWUoKSArICcgaGFzIG5vIGF0dHJpYnV0ZSBuYW1lZCBcIicgKyBuYW1lICsgJ1wiLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuXHQvKipcblx0ICogVXBkYXRlIG1vZGVsIGF0dHJpYnV0ZXMuIFRoaXMgbWV0aG9kIHJ1biBjaGFuZ2Vcblx0ICogYW5kIGNoYW5nZToqIGV2ZW50cywgaWYgYXR0cmlidXRlcyB3aWxsIGJlIGNoYW5nZXNcblx0ICogQHBhcmFtIGF0dHJpYnV0ZXNcblx0ICogQHBhcmFtIHtCb29sZWFufSBbc2FmZU9ubHldXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0c2V0QXR0cmlidXRlczogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIHNhZmVPbmx5KSB7XG5cdFx0aWYgKEppaS5fLmlzVW5kZWZpbmVkKHNhZmVPbmx5KSkge1xuXHRcdFx0c2FmZU9ubHkgPSB0cnVlO1xuXHRcdH1cblxuICAgICAgICB2YXIgZmlsdGVyZWRBdHRyaWJ1dGVzID0ge307XG5cdFx0dmFyIGF0dHJpYnV0ZU5hbWVzID0gc2FmZU9ubHkgPyB0aGlzLnNhZmVBdHRyaWJ1dGVzKCkgOiB0aGlzLmF0dHJpYnV0ZXMoKTtcblxuXHRcdEppaS5fLmVhY2goYXR0cmlidXRlcywgSmlpLl8uYmluZChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuXHRcdFx0aWYgKEppaS5fLmluZGV4T2YoYXR0cmlidXRlTmFtZXMsIGtleSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRBdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdH0gZWxzZSBpZiAoc2FmZU9ubHkpIHtcblx0XHRcdFx0dGhpcy5vblVuc2FmZUF0dHJpYnV0ZShrZXksIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSk7XG5cblx0XHRyZXR1cm4gdGhpcy5zZXQoZmlsdGVyZWRBdHRyaWJ1dGVzKTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCB3aGVuIGFuIHVuc2FmZSBhdHRyaWJ1dGUgaXMgYmVpbmcgbWFzc2l2ZWx5IGFzc2lnbmVkLlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGxvZyBhIHdhcm5pbmcgbWVzc2FnZSBpZiBZSUlfREVCVUcgaXMgb24uXG5cdCAqIEl0IGRvZXMgbm90aGluZyBvdGhlcndpc2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSB1bnNhZmUgYXR0cmlidXRlIG5hbWVcblx0ICogQHBhcmFtIHsqfSB2YWx1ZSB0aGUgYXR0cmlidXRlIHZhbHVlXG5cdCAqL1xuXHRvblVuc2FmZUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdFx0aWYgKEppaS5kZWJ1Zykge1xuXHRcdFx0SmlpLnRyYWNlKCdGYWlsZWQgdG8gc2V0IHVuc2FmZSBhdHRyaWJ1dGUgYCcgKyBuYW1lICsgJ2AgaW4gJyArIHRoaXMuY2xhc3NOYW1lKCkgKyAnYCcpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhdHRyaWJ1dGUgdmFsdWVzLlxuXHQgKiBAcGFyYW0ge0FycmF5fSBbbmFtZXNdXG5cdCAqIEBwYXJhbSB7QXJyYXl9IFtleGNlcHRdXG5cdCAqIEByZXR1cm5zIHt7fX0gQXR0cmlidXRlIHZhbHVlcyAobmFtZSA9PiB2YWx1ZSkuXG5cdCAqL1xuXHRnZXRBdHRyaWJ1dGVzOiBmdW5jdGlvbiAobmFtZXMsIGV4Y2VwdCkge1xuXHRcdHZhciB2YWx1ZXMgPSB7fTtcblxuXHRcdGlmICghSmlpLl8uaXNBcnJheShuYW1lcykpIHtcblx0XHRcdG5hbWVzID0gdGhpcy5hdHRyaWJ1dGVzKCk7XG5cdFx0fVxuXG5cdFx0SmlpLl8uZWFjaChuYW1lcywgSmlpLl8uYmluZChmdW5jdGlvbiAobmFtZSkge1xuXHRcdFx0aWYgKCFKaWkuXy5pc0FycmF5KGV4Y2VwdCkgfHwgSmlpLl8uaW5kZXhPZihuYW1lLCBleGNlcHQpID09PSAtMSkge1xuXHRcdFx0XHR2YWx1ZXNbbmFtZV0gPSB0aGlzLmdldChuYW1lKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKSk7XG5cblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZXQgYXR0cmlidXRlcyBsaXN0IGZvciB0aGlzIG1vZGVsXG5cdCAqIEByZXR1cm4ge0FycmF5fVxuXHQgKi9cblx0YXR0cmlidXRlczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBKaWkuXy5rZXlzKHRoaXMuX2F0dHJpYnV0ZXMpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVjayBhdHRyaWJ1dGUgZXhpc3RzIGluIHRoaXMgbW9kZWxcblx0ICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNBdHRyaWJ1dGU6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0Ly9yZXR1cm4gdHJ1ZTtcblx0XHRyZXR1cm4gSmlpLl8uaW5kZXhPZih0aGlzLmF0dHJpYnV0ZXMoKSwgbmFtZSkgIT09IC0xO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBGb3JtYXQ6IGF0dHJpYnV0ZSA9PiBsYWJlbFxuXHQgKiBAcmV0dXJuIHtvYmplY3R9XG5cdCAqL1xuXHRhdHRyaWJ1dGVMYWJlbHM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIEdldCBsYWJlbCBieSBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0Z2V0QXR0cmlidXRlTGFiZWw6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZUxhYmVscygpO1xuXHRcdHJldHVybiBKaWkuXy5oYXMoYXR0cmlidXRlcywgbmFtZSkgPyBhdHRyaWJ1dGVzW25hbWVdIDogbmFtZTtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHNjZW5hcmlvXG5cdCAqL1xuXHRzZXRTY2VuYXJpbzogZnVuY3Rpb24gKHNjZW5hcmlvKSB7XG5cdFx0dGhpcy5fc2NlbmFyaW8gPSBzY2VuYXJpbztcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldFNjZW5hcmlvOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NjZW5hcmlvO1xuXHR9LFxuXG5cdHNhZmVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjZW5hcmlvID0gdGhpcy5nZXRTY2VuYXJpbygpO1xuXHRcdHZhciBzY2VuYXJpb3MgPSB0aGlzLnNjZW5hcmlvcygpO1xuXG5cdFx0aWYgKCFKaWkuXy5oYXMoc2NlbmFyaW9zLCBzY2VuYXJpbykpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IFtdO1xuXHRcdEppaS5fLmVhY2goc2NlbmFyaW9zW3NjZW5hcmlvXSwgZnVuY3Rpb24gKGF0dHJpYnV0ZSwgaSkge1xuXHRcdFx0aWYgKGF0dHJpYnV0ZS5zdWJzdHIoMCwgMSkgIT09ICchJykge1xuXHRcdFx0XHRhdHRyaWJ1dGVzLnB1c2goYXR0cmlidXRlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gYXR0cmlidXRlcztcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRhY3RpdmVBdHRyaWJ1dGVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNjZW5hcmlvID0gdGhpcy5nZXRTY2VuYXJpbygpO1xuXHRcdHZhciBzY2VuYXJpb3MgPSB0aGlzLnNjZW5hcmlvcygpO1xuXG5cdFx0aWYgKCFKaWkuXy5oYXMoc2NlbmFyaW9zLCBzY2VuYXJpbykpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0XHR2YXIgYXR0cmlidXRlcyA9IHNjZW5hcmlvc1tzY2VuYXJpb107XG5cdFx0SmlpLl8uZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cmlidXRlLCBpKSB7XG5cdFx0XHRpZiAoYXR0cmlidXRlLnN1YnN0cigwLCAxKSA9PT0gJyEnKSB7XG5cdFx0XHRcdGF0dHJpYnV0ZXNbaV0gPSBhdHRyaWJ1dGUuc3Vic3RyKDEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cmV0dXJuIGF0dHJpYnV0ZXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRzY2VuYXJpb3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2NlbmFyaW9zID0ge307XG5cdFx0c2NlbmFyaW9zWydkZWZhdWx0J10gPSBbXTtcblxuXHRcdEppaS5fLmVhY2godGhpcy5nZXRWYWxpZGF0b3JzKCksIGZ1bmN0aW9uICh2YWxpZGF0b3IpIHtcblx0XHRcdEppaS5fLmVhY2godmFsaWRhdG9yLm9uLCBmdW5jdGlvbihzY2VuYXJpbykge1xuXHRcdFx0XHRzY2VuYXJpb3Nbc2NlbmFyaW9dID0gW107XG5cdFx0XHR9KTtcblx0XHRcdEppaS5fLmVhY2godmFsaWRhdG9yLmV4Y2VwdCwgZnVuY3Rpb24oc2NlbmFyaW8pIHtcblx0XHRcdFx0c2NlbmFyaW9zW3NjZW5hcmlvXSA9IFtdO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0dmFyIG5hbWVzID0gSmlpLl8ua2V5cyhzY2VuYXJpb3MpO1xuXG5cdFx0SmlpLl8uZWFjaCh0aGlzLmdldFZhbGlkYXRvcnMoKSwgZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuXHRcdFx0dmFyIHZhbGlkYXRvclNjZW5hcmlvcyA9IHZhbGlkYXRvci5vbiAmJiB2YWxpZGF0b3Iub24ubGVuZ3RoID4gMCA/IHZhbGlkYXRvci5vbiA6IG5hbWVzO1xuXHRcdFx0SmlpLl8uZWFjaCh2YWxpZGF0b3JTY2VuYXJpb3MsIGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0XHRcdGlmICghc2NlbmFyaW9zW25hbWVdKSB7XG5cdFx0XHRcdFx0c2NlbmFyaW9zW25hbWVdID0gW107XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoSmlpLl8uaW5kZXhPZih2YWxpZGF0b3IuZXhjZXB0LCBuYW1lKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRKaWkuXy5lYWNoKHZhbGlkYXRvci5hdHRyaWJ1dGVzLCBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cblx0XHRcdFx0XHRpZiAoSmlpLl8uaW5kZXhPZihzY2VuYXJpb3NbbmFtZV0sIGF0dHJpYnV0ZSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0c2NlbmFyaW9zW25hbWVdLnB1c2goYXR0cmlidXRlKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblxuXHRcdHJldHVybiBzY2VuYXJpb3M7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtBcnJheX1cblx0ICovXG5cdGNyZWF0ZVZhbGlkYXRvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdmFsaWRhdG9ycyA9IFtdO1xuXHRcdEppaS5fLmVhY2godGhpcy5ydWxlcygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uIChydWxlKSB7XG5cdFx0XHRpZiAocnVsZSBpbnN0YW5jZW9mIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcikge1xuXHRcdFx0XHR2YWxpZGF0b3JzLnB1c2gocnVsZSk7XG5cdFx0XHR9IGVsc2UgaWYgKEppaS5fLmlzQXJyYXkocnVsZSkgJiYgcnVsZS5sZW5ndGggPj0gMikge1xuXHRcdFx0XHR2YXIgYXR0cmlidXRlcyA9IEppaS5fLmlzU3RyaW5nKHJ1bGVbMF0pID8gW3J1bGVbMF1dIDogcnVsZVswXTtcblx0XHRcdFx0dmFyIHBhcmFtcyA9IHJ1bGVbMl0gfHwge307XG5cdFx0XHRcdHBhcmFtcy5vbiA9IEppaS5fLmlzU3RyaW5nKHBhcmFtcy5vbikgPyBbcGFyYW1zLm9uXSA6IHBhcmFtcy5vbjtcblxuXHRcdFx0XHR2YXIgdmFsaWRhdG9yID0gSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLmNyZWF0ZShydWxlWzFdLCB0aGlzLCBhdHRyaWJ1dGVzLCBwYXJhbXMpO1xuXHRcdFx0XHR2YWxpZGF0b3JzLnB1c2godmFsaWRhdG9yKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignSW52YWxpZCB2YWxpZGF0aW9uIHJ1bGU6IGEgcnVsZSBtdXN0IHNwZWNpZnkgYm90aCBhdHRyaWJ1dGUgbmFtZXMgYW5kIHZhbGlkYXRvciB0eXBlLicpO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblx0XHRyZXR1cm4gdmFsaWRhdG9ycztcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMgeyp9XG5cdCAqL1xuXHRnZXRWYWxpZGF0b3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3ZhbGlkYXRvcnMgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3ZhbGlkYXRvcnMgPSB0aGlzLmNyZWF0ZVZhbGlkYXRvcnMoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3ZhbGlkYXRvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBbYXR0cmlidXRlXVxuXHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdCAqL1xuXHRnZXRBY3RpdmVWYWxpZGF0b3JzOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0dmFyIHZhbGlkYXRvcnMgPSBbXTtcblx0XHR2YXIgc2NlbmFyaW8gPSB0aGlzLmdldFNjZW5hcmlvKCk7XG5cblx0XHRKaWkuXy5lYWNoKHRoaXMuZ2V0VmFsaWRhdG9ycygpLCBmdW5jdGlvbiAodmFsaWRhdG9yKSB7XG5cdFx0XHRpZiAoIXZhbGlkYXRvci5pc0FjdGl2ZShzY2VuYXJpbykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoYXR0cmlidXRlICYmIEppaS5fLmluZGV4T2YodmFsaWRhdG9yLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZSkgPT09IC0xKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFsaWRhdG9ycy5wdXNoKHZhbGlkYXRvcik7XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdmFsaWRhdG9ycztcblx0fSxcblxuXHQvKipcblx0ICogVmFsaWRhdGUgbW9kZWwgYnkgcnVsZXMsIHNlZSBydWxlcygpIG1ldGhvZC5cblx0ICogQHBhcmFtIHtBcnJheX0gW2F0dHJpYnV0ZXNdXG5cdCAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzQ2xlYXJFcnJvcnNdXG5cdCAqL1xuXHR2YWxpZGF0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZXMsIGlzQ2xlYXJFcnJvcnMpIHtcblx0XHRpZiAoSmlpLl8uaXNVbmRlZmluZWQoaXNDbGVhckVycm9ycykpIHtcblx0XHRcdGlzQ2xlYXJFcnJvcnMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoIWF0dHJpYnV0ZXMpIHtcblx0XHRcdGF0dHJpYnV0ZXMgPSB0aGlzLmFjdGl2ZUF0dHJpYnV0ZXMoKTtcblx0XHR9XG5cblx0XHR2YXIgc2NlbmFyaW9zID0gdGhpcy5zY2VuYXJpb3MoKTtcblx0XHR2YXIgc2NlbmFyaW8gPSB0aGlzLmdldFNjZW5hcmlvKCk7XG5cdFx0aWYgKCFKaWkuXy5oYXMoc2NlbmFyaW9zLCBzY2VuYXJpbykpIHtcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignVW5rbm93biBzY2VuYXJpbyBgJyArIHNjZW5hcmlvICsgJ2AuJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzQ2xlYXJFcnJvcnMpIHtcblx0XHRcdHRoaXMuY2xlYXJFcnJvcnMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYmVmb3JlVmFsaWRhdGUoKSlcblx0XHRcdC50aGVuKEppaS5fLmJpbmQoZnVuY3Rpb24gKGJvb2wpIHtcblx0XHRcdFx0aWYgKCFib29sKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgcHJvbWlzZXMgPSBKaWkuXy5tYXAodGhpcy5nZXRBY3RpdmVWYWxpZGF0b3JzKCksIEppaS5fLmJpbmQoZnVuY3Rpb24gKHZhbGlkYXRvcikge1xuXHRcdFx0XHRcdHJldHVybiB2YWxpZGF0b3IudmFsaWRhdGUodGhpcywgYXR0cmlidXRlcyk7XG5cdFx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcblx0XHRcdH0sIHRoaXMpKVxuXHRcdFx0LnRoZW4odGhpcy5hZnRlclZhbGlkYXRlKVxuXHRcdFx0LnRoZW4oSmlpLl8uYmluZChmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdGlmICh0aGlzLmhhc0Vycm9ycygpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXR1cm4gcmVzdWx0XG5cdFx0XHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdFx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0YWRkRXJyb3I6IGZ1bmN0aW9uIChhdHRyaWJ1dGUsIGVycm9yKSB7XG5cdFx0aWYgKCF0aGlzLl9lcnJvcnNbYXR0cmlidXRlXSkge1xuXHRcdFx0dGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV0gPSBbXTtcblx0XHR9XG5cblx0XHR0aGlzLl9lcnJvcnNbYXR0cmlidXRlXS5wdXNoKGVycm9yKTtcblx0fSxcblxuXHRzZXRFcnJvcnM6IGZ1bmN0aW9uIChlcnJvcnMpIHtcblx0XHR0aGlzLl9lcnJvcnMgPSBlcnJvcnM7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBbYXR0cmlidXRlXVxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGdldEVycm9yczogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHJldHVybiAhYXR0cmlidXRlID8gdGhpcy5fZXJyb3JzIDogdGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV0gfHwge307XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqIEBwYXJhbSBbYXR0cmlidXRlXVxuXHQgKiBAcmV0dXJucyB7Kn1cblx0ICovXG5cdGhhc0Vycm9yczogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHJldHVybiBhdHRyaWJ1dGUgPyBKaWkuXy5oYXModGhpcy5fZXJyb3JzLCBhdHRyaWJ1dGUpIDogIUppaS5fLmlzRW1wdHkodGhpcy5fZXJyb3JzKTtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIFthdHRyaWJ1dGVdXG5cdCAqIEByZXR1cm5zIHsqfVxuXHQgKi9cblx0Y2xlYXJFcnJvcnM6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblx0XHRpZiAoIWF0dHJpYnV0ZSkge1xuXHRcdFx0dGhpcy5fZXJyb3JzID0ge307XG5cdFx0fSBlbHNlIGlmICh0aGlzLl9lcnJvcnMpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9lcnJvcnNbYXR0cmlidXRlXTtcblx0XHR9XG5cdH0sXG5cblx0YmVmb3JlVmFsaWRhdGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRhZnRlclZhbGlkYXRlOiBmdW5jdGlvbiAoKSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyByZXF1aXJlZC5cblx0ICogVGhpcyBpcyBkZXRlcm1pbmVkIGJ5IGNoZWNraW5nIGlmIHRoZSBhdHRyaWJ1dGUgaXMgYXNzb2NpYXRlZCB3aXRoIGFcblx0ICogW1tcXGppaVxcdmFsaWRhdG9yc1xcUmVxdWlyZWRWYWxpZGF0b3J8cmVxdWlyZWRdXSB2YWxpZGF0aW9uIHJ1bGUgaW4gdGhlXG5cdCAqIGN1cnJlbnQgW1tzY2VuYXJpb11dLlxuXHQgKlxuXHQgKiBOb3RlIHRoYXQgd2hlbiB0aGUgdmFsaWRhdG9yIGhhcyBhIGNvbmRpdGlvbmFsIHZhbGlkYXRpb24gYXBwbGllZCB1c2luZ1xuXHQgKiBbW1xcamlpXFx2YWxpZGF0b3JzXFxSZXF1aXJlZFZhbGlkYXRvci53aGVufHdoZW5dXSB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQgKiBgZmFsc2VgIHJlZ2FyZGxlc3Mgb2YgdGhlIGB3aGVuYCBjb25kaXRpb24gYmVjYXVzZSBpdCBtYXkgYmUgY2FsbGVkIGJlXG5cdCAqIGJlZm9yZSB0aGUgbW9kZWwgaXMgbG9hZGVkIHdpdGggZGF0YS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0cmlidXRlIGlzIHJlcXVpcmVkXG5cdCAqL1xuXHRpc0F0dHJpYnV0ZVJlcXVpcmVkOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0dmFyIGJvb2wgPSBmYWxzZTtcblx0XHRKaWkuXy5lYWNoKHRoaXMuZ2V0QWN0aXZlVmFsaWRhdG9ycyhhdHRyaWJ1dGUpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHZhbGlkYXRvcikge1xuXHRcdFx0aWYgKHZhbGlkYXRvciBpbnN0YW5jZW9mIEppaS52YWxpZGF0b3JzLlJlcXVpcmVkVmFsaWRhdG9yICYmIHZhbGlkYXRvci53aGVuID09PSBudWxsKSB7XG5cdFx0XHRcdGJvb2wgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMpKTtcblx0XHRyZXR1cm4gYm9vbDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgYXR0cmlidXRlIGlzIHNhZmUgZm9yIG1hc3NpdmUgYXNzaWdubWVudHMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgYXR0cmlidXRlIG5hbWVcblx0ICogQHJldHVybnMge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGF0dHJpYnV0ZSBpcyBzYWZlIGZvciBtYXNzaXZlIGFzc2lnbm1lbnRzXG5cdCAqIEBzZWUgc2FmZUF0dHJpYnV0ZXMoKVxuXHQgKi9cblx0aXNBdHRyaWJ1dGVTYWZlOiBmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG5cdFx0cmV0dXJuIEppaS5fLmluZGV4T2YodGhpcy5zYWZlQXR0cmlidXRlcygpLCBhdHRyaWJ1dGUpICE9PSAtMTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgYXR0cmlidXRlIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzY2VuYXJpby5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZSBhdHRyaWJ1dGUgbmFtZVxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn0gd2hldGhlciB0aGUgYXR0cmlidXRlIGlzIGFjdGl2ZSBpbiB0aGUgY3VycmVudCBzY2VuYXJpb1xuXHQgKiBAc2VlIGFjdGl2ZUF0dHJpYnV0ZXMoKVxuXHQgKi9cblx0aXNBdHRyaWJ1dGVBY3RpdmU6IGZ1bmN0aW9uIChhdHRyaWJ1dGUpIHtcblx0XHRyZXR1cm4gSmlpLl8uaW5kZXhPZih0aGlzLmFjdGl2ZUF0dHJpYnV0ZXMoKSwgYXR0cmlidXRlKSAhPT0gLTE7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGZpcnN0IGVycm9yIG9mIGV2ZXJ5IGF0dHJpYnV0ZSBpbiB0aGUgbW9kZWwuXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9IHRoZSBmaXJzdCBlcnJvcnMuIFRoZSBhcnJheSBrZXlzIGFyZSB0aGUgYXR0cmlidXRlIG5hbWVzLCBhbmQgdGhlIGFycmF5XG5cdCAqIHZhbHVlcyBhcmUgdGhlIGNvcnJlc3BvbmRpbmcgZXJyb3IgbWVzc2FnZXMuIEFuIGVtcHR5IGFycmF5IHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhlcmUgaXMgbm8gZXJyb3IuXG5cdCAqIEBzZWUgZ2V0RXJyb3JzKClcblx0ICogQHNlZSBnZXRGaXJzdEVycm9yKClcblx0ICovXG5cdGdldEZpcnN0RXJyb3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKEppaS5fLmlzRW1wdHkodGhpcy5fZXJyb3JzKSkge1xuXHRcdFx0cmV0dXJuIHt9O1xuXHRcdH1cblxuXHRcdHZhciBlcnJvcnMgPSB7fTtcblx0XHRKaWkuXy5lYWNoKHRoaXMuX2Vycm9ycywgSmlpLl8uYmluZChmdW5jdGlvbihlcywgbmFtZSkge1xuXHRcdFx0aWYgKGVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0ZXJyb3JzW25hbWVdID0gZXNbMF07XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXG5cdFx0cmV0dXJuIGVycm9ycztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZmlyc3QgZXJyb3Igb2YgdGhlIHNwZWNpZmllZCBhdHRyaWJ1dGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGUgYXR0cmlidXRlIG5hbWUuXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBlcnJvciBtZXNzYWdlLiBOdWxsIGlzIHJldHVybmVkIGlmIG5vIGVycm9yLlxuXHQgKiBAc2VlIGdldEVycm9ycygpXG5cdCAqIEBzZWUgZ2V0Rmlyc3RFcnJvcnMoKVxuXHQgKi9cblx0Z2V0Rmlyc3RFcnJvcjogZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuXHRcdHJldHVybiBKaWkuXy5oYXModGhpcy5fZXJyb3JzLCBhdHRyaWJ1dGUpID8gdGhpcy5fZXJyb3JzW2F0dHJpYnV0ZV1bMF0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZXMgYSB1c2VyIGZyaWVuZGx5IGF0dHJpYnV0ZSBsYWJlbCBiYXNlZCBvbiB0aGUgZ2l2ZSBhdHRyaWJ1dGUgbmFtZS5cblx0ICogVGhpcyBpcyBkb25lIGJ5IHJlcGxhY2luZyB1bmRlcnNjb3JlcywgZGFzaGVzIGFuZCBkb3RzIHdpdGggYmxhbmtzIGFuZFxuXHQgKiBjaGFuZ2luZyB0aGUgZmlyc3QgbGV0dGVyIG9mIGVhY2ggd29yZCB0byB1cHBlciBjYXNlLlxuXHQgKiBGb3IgZXhhbXBsZSwgJ2RlcGFydG1lbnRfbmFtZScgb3IgJ0RlcGFydG1lbnROYW1lJyB3aWxsIGdlbmVyYXRlICdEZXBhcnRtZW50IE5hbWUnLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgY29sdW1uIG5hbWVcblx0ICogQHJldHVybnMge3N0cmluZ30gdGhlIGF0dHJpYnV0ZSBsYWJlbFxuXHQgKi9cblx0Z2VuZXJhdGVBdHRyaWJ1dGVMYWJlbDogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gSmlpLl9zLmh1bWFuaXplKG5hbWUpO1xuXHR9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEwMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Nb2RlbEF0dHJpYnV0ZVNjaGVtYVxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWEnLCAvKiogQGxlbmRzIEppaS5iYXNlLk1vZGVsQXR0cmlidXRlU2NoZW1hLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nfSBuYW1lIG9mIHRoaXMgY29sdW1uICh3aXRob3V0IHF1b3RlcykuXG5cdCAqL1xuXHRuYW1lOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtzdHJpbmd9IGFic3RyYWN0IHR5cGUgb2YgdGhpcyBjb2x1bW4uIFBvc3NpYmxlIGFic3RyYWN0IHR5cGVzIGluY2x1ZGU6XG5cdCAqIHN0cmluZywgdGV4dCwgYm9vbGVhbiwgc21hbGxpbnQsIGludGVnZXIsIGJpZ2ludCwgZmxvYXQsIGRlY2ltYWwsIGRhdGV0aW1lLFxuXHQgKiB0aW1lc3RhbXAsIHRpbWUsIGRhdGUsIGJpbmFyeSwgYW5kIG1vbmV5LlxuXHQgKi9cblx0dHlwZTogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nfSB0aGUgSlMgdHlwZSBvZiB0aGlzIGNvbHVtbi4gUG9zc2libGUgSlMgdHlwZXMgaW5jbHVkZTpcblx0ICogc3RyaW5nLCBib29sZWFuLCBudW1iZXIsIGRvdWJsZS5cblx0ICovXG5cdGpzVHlwZTogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7Kn0gZGVmYXVsdCB2YWx1ZSBvZiB0aGlzIGNvbHVtblxuXHQgKi9cblx0ZGVmYXVsdFZhbHVlOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtib29sZWFufSB3aGV0aGVyIHRoaXMgY29sdW1uIGlzIGEgcHJpbWFyeSBrZXlcblx0ICovXG5cdGlzUHJpbWFyeUtleTogZmFsc2UsXG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIHRoZSBpbnB1dCB2YWx1ZSBhY2NvcmRpbmcgdG8gW1tqc1R5cGVdXS5cblx0ICogSWYgdGhlIHZhbHVlIGlzIG51bGwgb3IgYW4gW1tFeHByZXNzaW9uXV0sIGl0IHdpbGwgbm90IGJlIGNvbnZlcnRlZC5cblx0ICogQHBhcmFtIHsqfSB2YWx1ZSBpbnB1dCB2YWx1ZVxuXHQgKiBAcmV0dXJuIHsqfSBjb252ZXJ0ZWQgdmFsdWVcblx0ICovXG5cdHR5cGVjYXN0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdGlmICh2YWx1ZSA9PT0gJycgJiYgdGhpcy50eXBlICE9PSBKaWkuc3FsLkJhc2VTY2hlbWEuVFlQRV9URVhUICYmXG5cdFx0XHR0aGlzLnR5cGUgIT09IEppaS5zcWwuQmFzZVNjaGVtYS5UWVBFX1NUUklORyAmJlxuXHRcdFx0dGhpcy50eXBlICE9PSBKaWkuc3FsLkJhc2VTY2hlbWEuVFlQRV9CSU5BUlkpIHtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblxuXHRcdC8vIEB0b2RvIHBocC0+anMgdHlwZXNcblx0XHRpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mKHZhbHVlKSA9PT0gdGhpcy5qc1R5cGUgfHwgdmFsdWUgaW5zdGFuY2VvZiBKaWkuc3FsLkV4cHJlc3Npb24pIHtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKHRoaXMuanNUeXBlKSB7XG5cdFx0XHRjYXNlICdzdHJpbmcnOlxuXHRcdFx0XHRyZXR1cm4gU3RyaW5nKHZhbHVlKTtcblxuXHRcdFx0Y2FzZSAnbnVtYmVyJzpcblx0XHRcdFx0cmV0dXJuIEppaS5fLmlzQm9vbGVhbih2YWx1ZSkgP1xuXHRcdFx0XHRcdCh2YWx1ZSA/IDEgOiAwKSA6XG5cdFx0XHRcdFx0cGFyc2VGbG9hdCh2YWx1ZSk7XG5cblx0XHRcdGNhc2UgJ2Jvb2xlYW4nOlxuXHRcdFx0XHRyZXR1cm4gISF2YWx1ZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsdWU7XG5cdH0sXG5cbiAgICB0b0pTT046IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2JqID0ge307XG5cbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdFZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvYmouZGVmYXVsdFZhbHVlID0gdGhpcy5kZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5S2V5KSB7XG4gICAgICAgICAgICBvYmouaXNQcmltYXJ5S2V5ID0gdGhpcy5pc1ByaW1hcnlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuanNUeXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBvYmouanNUeXBlID0gdGhpcy5qc1R5cGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqLm5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoSmlpLl8uaXNFbXB0eShvYmopKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMudHlwZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgb2JqLnR5cGUgPSB0aGlzLnR5cGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEwMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5Nb2RlbFNjaGVtYVxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuTW9kZWxTY2hlbWEnLCAvKiogQGxlbmRzIEppaS5iYXNlLk1vZGVsU2NoZW1hLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuICAgIF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5iYXNlLk1vZGVsU2NoZW1hICove1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqXG4gICAgICAgICAqIEByZXR1cm5zIHtKaWkuYmFzZS5Nb2RlbFNjaGVtYX1cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZUZyb21PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgSmlpLl8uZWFjaChvYmouY29sdW1ucywgZnVuY3Rpb24oY29sdW1uLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEoY29sdW1uIGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChKaWkuXy5pc1N0cmluZyhjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoSmlpLl8uaXNOdW1iZXIobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBjb2x1bW4uc3BsaXQoJzonKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IHBhcnRzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogY29sdW1uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFKaWkuXy5pc09iamVjdChjb2x1bW4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbignSW52YWxpZCBjb2x1bW4gZm9ybWF0OiAnICsgY29sdW1uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoIUppaS5fLmlzU3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4ubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb2JqLmNvbHVtbnNbbmFtZV0gPSBuZXcgSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWEoY29sdW1uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgICAgICByZXR1cm4gbmV3IEppaS5iYXNlLk1vZGVsU2NoZW1hKG9iaik7XG4gICAgICAgIH1cblxuICAgIH0sXG5cblx0LyoqXG5cdCAqIEB2YXIge3N0cmluZ30gdGhlIG5hbWUgb2YgdGhlIHNjaGVtYSB0aGF0IHRoaXMgdGFibGUgYmVsb25ncyB0by5cblx0ICovXG5cdHNjaGVtYU5hbWU6ICcnLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtzdHJpbmdbXX0gcHJpbWFyeSBrZXlzIG9mIHRoaXMgdGFibGUuXG5cdCAqL1xuXHRwcmltYXJ5S2V5OiBbXSxcblxuXHQvKipcblx0ICogQHZhciB7e3N0cmluZzogSmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWF9fSBjb2x1bW4gbWV0YWRhdGEgb2YgdGhpcyB0YWJsZS4gRWFjaCBhcnJheSBlbGVtZW50IGlzIGEgW1tKaWkuYmFzZS5Nb2RlbEF0dHJpYnV0ZVNjaGVtYV1dIG9iamVjdCwgaW5kZXhlZCBieSBjb2x1bW4gbmFtZXMuXG5cdCAqL1xuXHRjb2x1bW5zOiB7fSxcblxuXHQvKipcblx0ICogR2V0cyB0aGUgbmFtZWQgY29sdW1uIG1ldGFkYXRhLlxuXHQgKiBUaGlzIGlzIGEgY29udmVuaWVudCBtZXRob2QgZm9yIHJldHJpZXZpbmcgYSBuYW1lZCBjb2x1bW4gZXZlbiBpZiBpdCBkb2VzIG5vdCBleGlzdC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgY29sdW1uIG5hbWVcblx0ICogQHJldHVybiB7SmlpLmJhc2UuTW9kZWxBdHRyaWJ1dGVTY2hlbWF9IG1ldGFkYXRhIG9mIHRoZSBuYW1lZCBjb2x1bW4uIE51bGwgaWYgdGhlIG5hbWVkIGNvbHVtbiBkb2VzIG5vdCBleGlzdC5cblx0ICovXG5cdGdldENvbHVtbjogZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuY29sdW1ucywgbmFtZSkgPyB0aGlzLmNvbHVtbnNbbmFtZV0gOiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBhbGwgY29sdW1ucyBpbiB0aGlzIHRhYmxlLlxuXHQgKiBAcmV0dXJuIHtbXX0gbGlzdCBvZiBjb2x1bW4gbmFtZXNcblx0ICovXG5cdGdldENvbHVtbk5hbWVzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEppaS5fLmtleXModGhpcy5jb2x1bW5zKTtcblx0fSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBvYmogPSB7fTtcblxuICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkodGhpcy5wcmltYXJ5S2V5KSkge1xuICAgICAgICAgICAgb2JqLnByaW1hcnlLZXkgPSB0aGlzLnByaW1hcnlLZXk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFKaWkuXy5pc0VtcHR5KHRoaXMuc2NoZW1hTmFtZSkpIHtcbiAgICAgICAgICAgIG9iai5zY2hlbWFOYW1lID0gdGhpcy5zY2hlbWFOYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghSmlpLl8uaXNFbXB0eSh0aGlzLmNvbHVtbnMpKSB7XG4gICAgICAgICAgICBvYmouY29sdW1ucyA9IHt9O1xuICAgICAgICAgICAgSmlpLl8uZWFjaCh0aGlzLmNvbHVtbnMsIGZ1bmN0aW9uKGNvbHVtbiwgbmFtZSkge1xuICAgICAgICAgICAgICAgIG9iai5jb2x1bW5zW25hbWVdID0gY29sdW1uLnRvSlNPTigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTAzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQXJyYXlEYXRhUHJvdmlkZXIgaW1wbGVtZW50cyBhIGRhdGEgcHJvdmlkZXIgYmFzZWQgb24gYSBkYXRhIGFycmF5LlxuICpcbiAqIFRoZSBbW2FsbE1vZGVsc11dIHByb3BlcnR5IGNvbnRhaW5zIGFsbCBkYXRhIG1vZGVscyB0aGF0IG1heSBiZSBzb3J0ZWQgYW5kL29yIHBhZ2luYXRlZC5cbiAqIEFycmF5RGF0YVByb3ZpZGVyIHdpbGwgcHJvdmlkZSB0aGUgZGF0YSBhZnRlciBzb3J0aW5nIGFuZC9vciBwYWdpbmF0aW9uLlxuICogWW91IG1heSBjb25maWd1cmUgdGhlIFtbc29ydF1dIGFuZCBbW3BhZ2luYXRpb25dXSBwcm9wZXJ0aWVzIHRvXG4gKiBjdXN0b21pemUgdGhlIHNvcnRpbmcgYW5kIHBhZ2luYXRpb24gYmVoYXZpb3JzLlxuICpcbiAqIEVsZW1lbnRzIGluIHRoZSBbW2FsbE1vZGVsc11dIGFycmF5IG1heSBiZSBlaXRoZXIgb2JqZWN0cyAoZS5nLiBtb2RlbCBvYmplY3RzKVxuICogb3IgYXNzb2NpYXRpdmUgYXJyYXlzIChlLmcuIHF1ZXJ5IHJlc3VsdHMgb2YgREFPKS5cbiAqIE1ha2Ugc3VyZSB0byBzZXQgdGhlIFtba2V5XV0gcHJvcGVydHkgdG8gdGhlIG5hbWUgb2YgdGhlIGZpZWxkIHRoYXQgdW5pcXVlbHlcbiAqIGlkZW50aWZpZXMgYSBkYXRhIHJlY29yZCBvciBmYWxzZSBpZiB5b3UgZG8gbm90IGhhdmUgc3VjaCBhIGZpZWxkLlxuICpcbiAqIENvbXBhcmVkIHRvIFtbQWN0aXZlRGF0YVByb3ZpZGVyXV0sIEFycmF5RGF0YVByb3ZpZGVyIGNvdWxkIGJlIGxlc3MgZWZmaWNpZW50XG4gKiBiZWNhdXNlIGl0IG5lZWRzIHRvIGhhdmUgW1thbGxNb2RlbHNdXSByZWFkeS5cbiAqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQXJyYXlEYXRhUHJvdmlkZXJcbiAqIEBleHRlbmRzIEppaS5iYXNlLkRhdGFQcm92aWRlclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkFycmF5RGF0YVByb3ZpZGVyJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5BcnJheURhdGFQcm92aWRlci5wcm90b3R5cGUgKi97XG5cbiAgICBfX2V4dGVuZHM6IEppaS5iYXNlLkRhdGFQcm92aWRlcixcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtzdHJpbmd8ZnVuY3Rpb259IHRoZSBjb2x1bW4gdGhhdCBpcyB1c2VkIGFzIHRoZSBrZXkgb2YgdGhlIGRhdGEgbW9kZWxzLlxuICAgICAqIFRoaXMgY2FuIGJlIGVpdGhlciBhIGNvbHVtbiBuYW1lLCBvciBhIGNhbGxhYmxlIHRoYXQgcmV0dXJucyB0aGUga2V5IHZhbHVlIG9mIGEgZ2l2ZW4gZGF0YSBtb2RlbC5cbiAgICAgKiBJZiB0aGlzIGlzIG5vdCBzZXQsIHRoZSBpbmRleCBvZiB0aGUgW1ttb2RlbHNdXSBhcnJheSB3aWxsIGJlIHVzZWQuXG4gICAgICogQHNlZSBnZXRLZXlzKClcbiAgICAgKi9cbiAgICBrZXk6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7W119IHRoZSBkYXRhIHRoYXQgaXMgbm90IHBhZ2luYXRlZCBvciBzb3J0ZWQuIFdoZW4gcGFnaW5hdGlvbiBpcyBlbmFibGVkLFxuICAgICAqIHRoaXMgcHJvcGVydHkgdXN1YWxseSBjb250YWlucyBtb3JlIGVsZW1lbnRzIHRoYW4gW1ttb2RlbHNdXS5cbiAgICAgKiBUaGUgYXJyYXkgZWxlbWVudHMgbXVzdCB1c2UgemVyby1iYXNlZCBpbnRlZ2VyIGtleXMuXG4gICAgICovXG4gICAgYWxsTW9kZWxzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBfcHJlcGFyZU1vZGVsczogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbW9kZWxzID0gdGhpcy5hbGxNb2RlbHM7XG4gICAgICAgIGlmIChtb2RlbHMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEB0b2RvIFBhZ2luYXRpb24gJiBTb3J0XG4gICAgICAgIC8qdmFyIHNvcnQgPSB0aGlzLmdldFNvcnQoKTtcbiAgICAgICAgaWYgKHNvcnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBtb2RlbHMgPSB0aGlzLl9zb3J0TW9kZWxzKEppaS5fLmNsb25lKG1vZGVscyksIHNvcnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhZ2luYXRpb24gPSB0aGlzLmdldFBhZ2luYXRpb24oKTtcbiAgICAgICAgaWYgKHBhZ2luYXRpb24gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICBwYWdpbmF0aW9uLnRvdGFsQ291bnQgPSB0aGlzLmdldFRvdGFsQ291bnQoKTtcblxuICAgICAgICAgICAgaWYgKHBhZ2luYXRpb24uZ2V0UGFnZVNpemUoKSA+IDApIHtcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSBhcnJheV9zbGljZShtb2RlbHMsIHBhZ2luYXRpb24uZ2V0T2Zmc2V0KCksIHBhZ2luYXRpb24uZ2V0TGltaXQoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0qL1xuXG4gICAgICAgIHJldHVybiBtb2RlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBpbmhlcml0ZG9jXG4gICAgICovXG4gICAgX3ByZXBhcmVLZXlzOiBmdW5jdGlvbiAobW9kZWxzKSB7XG4gICAgICAgIGlmICh0aGlzLmtleSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIEppaS5fLm1hcChtb2RlbHMsIGZ1bmN0aW9uKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEppaS5fLmlzU3RyaW5nKHRoaXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbW9kZWxbdGhpcy5rZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5rZXkuY2FsbChudWxsLCBtb2RlbCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIEppaS5fLmtleXMobW9kZWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGluaGVyaXRkb2NcbiAgICAgKi9cbiAgICBfcHJlcGFyZVRvdGFsQ291bnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsTW9kZWxzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU29ydHMgdGhlIGRhdGEgbW9kZWxzIGFjY29yZGluZyB0byB0aGUgZ2l2ZW4gc29ydCBkZWZpbml0aW9uXG4gICAgICogQHBhcmFtIHtbXX0gbW9kZWxzIHRoZSBtb2RlbHMgdG8gYmUgc29ydGVkXG4gICAgICogQHBhcmFtIHtqaWkuZGF0YS5Tb3J0fSBzb3J0IHRoZSBzb3J0IGRlZmluaXRpb25cbiAgICAgKiBAcmV0dXJucyB7W119IHRoZSBzb3J0ZWQgZGF0YSBtb2RlbHNcbiAgICAgKi9cbiAgICBfc29ydE1vZGVsczogZnVuY3Rpb24gKG1vZGVscywgc29ydCkge1xuICAgICAgICAvLyBAdG9kbyBQYWdpbmF0aW9uICYgU29ydFxuICAgICAgICAvKnZhciBvcmRlcnMgPSBzb3J0LmdldE9yZGVycygpO1xuICAgICAgICBpZiAoIUppaS5fLmlzRW1wdHkob3JkZXJzKSkge1xuICAgICAgICAgICAgQXJyYXlIZWxwZXIubXVsdGlzb3J0KG1vZGVscywgYXJyYXlfa2V5cyhvcmRlcnMpLCBhcnJheV92YWx1ZXMob3JkZXJzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbW9kZWxzOyovXG4gICAgfVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMDQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL0NoYW5nZUV2ZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5tb2RlbC5DaGFuZ2VBdHRyaWJ1dGVFdmVudFxuICogQGV4dGVuZHMgSmlpLm1vZGVsLkNoYW5nZUV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLm1vZGVsLkNoYW5nZUF0dHJpYnV0ZUV2ZW50JywgLyoqIEBsZW5kcyBKaWkubW9kZWwuQ2hhbmdlQXR0cmlidXRlRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLm1vZGVsLkNoYW5nZUV2ZW50LFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBhdHRyaWJ1dGU6ICcnLFxuXG4gICAgLyoqXG4gICAgICogQHR5cGUgeyp9XG4gICAgICovXG4gICAgb2xkVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Kn1cbiAgICAgKi9cbiAgICBuZXdWYWx1ZTogbnVsbFxuXG59KTtcblxufSx7XCIuL0NoYW5nZUV2ZW50XCI6MTA1LFwiamlpXCI6MTI0fV0sMTA1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLm1vZGVsLkNoYW5nZUV2ZW50XG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5FdmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5tb2RlbC5DaGFuZ2VFdmVudCcsIC8qKiBAbGVuZHMgSmlpLm1vZGVsLkNoYW5nZUV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG4gICAgY2hhbmdlZEF0dHJpYnV0ZXM6IHt9XG5cbn0pO1xuXG59LHtcImppaVwiOjEyNH1dLDEwNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5tb2RlbC5Db2xsZWN0aW9uRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudCcsIC8qKiBAbGVuZHMgSmlpLm1vZGVsLkNvbGxlY3Rpb25FdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5FdmVudCxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHR5cGUge0ppaS5iYXNlLk1vZGVsW119XG4gICAgICovXG4gICAgYWRkZWQ6IFtdLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7SmlpLmJhc2UuTW9kZWxbXX1cbiAgICAgKi9cbiAgICByZW1vdmVkOiBbXVxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLm1vZGVsLkxpbmtNb2RlbEV2ZW50JywgLyoqIEBsZW5kcyBKaWkubW9kZWwuTGlua01vZGVsRXZlbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuRXZlbnQsXG5cbiAgICAvKipcbiAgICAgKiBSZWxhdGlvbiBuYW1lXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICByZWxhdGlvbk5hbWU6IG51bGxcblxufSk7XG5cbn0se1wiamlpXCI6MTI0fV0sMTA4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLkJvb2xlYW5WYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLkJvb2xlYW5WYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkJvb2xlYW5WYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG4gICAgdHJ1ZVZhbHVlOiAnMScsXG5cbiAgICBmYWxzZVZhbHVlOiAnMCcsXG5cbiAgICBzdHJpY3Q6IGZhbHNlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJzsgLy8gQHRvZG9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmdldChhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSwge1xuICAgICAgICAgICAgICAgIHRydWVWYWx1ZTogdGhpcy50cnVlVmFsdWUsXG4gICAgICAgICAgICAgICAgZmFsc2VWYWx1ZTogdGhpcy5mYWxzZVZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5zdHJpY3QpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdGhpcy50cnVlVmFsdWUgfHwgdmFsdWUgPT09IHRoaXMuZmFsc2VWYWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZSA9PSB0aGlzLnRydWVWYWx1ZSB8fCB2YWx1ZSA9PSB0aGlzLmZhbHNlVmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTA5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLkNvbXBhcmVWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLkNvbXBhcmVWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkNvbXBhcmVWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG4gICAgY29tcGFyZUF0dHJpYnV0ZTogbnVsbCxcblxuICAgIGNvbXBhcmVWYWx1ZTogbnVsbCxcblxuICAgIG9wZXJhdG9yOiAnPT0nLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJzsgLy8gQHRvZG9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIGNvbXBhcmVMYWJlbCA9IG51bGw7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcblxuICAgICAgICBpZiAoSmlpLl8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIEppaS50KCd7YXR0cmlidXRlfSBpcyBpbnZhbGlkLicpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmNvbXBhcmVWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tcGFyZUF0dHJpYnV0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tcGFyZUF0dHJpYnV0ZSA9IGF0dHJpYnV0ZSArICdfcmVwZWF0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbXBhcmVMYWJlbCA9IG9iamVjdC5nZXRBdHRyaWJ1dGVMYWJlbCh0aGlzLmNvbXBhcmVBdHRyaWJ1dGUpO1xuICAgICAgICAgICAgdGhpcy5jb21wYXJlVmFsdWUgPSBvYmplY3QuZ2V0KHRoaXMuY29tcGFyZUF0dHJpYnV0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb21wYXJlTGFiZWwgPSB0aGlzLmNvbXBhcmVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlLCB7XG4gICAgICAgICAgICAgICAgY29tcGFyZUF0dHJpYnV0ZTogY29tcGFyZUxhYmVsLFxuICAgICAgICAgICAgICAgIGNvbXBhcmVWYWx1ZTogdGhpcy5jb21wYXJlVmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb21wYXJlVmFsdWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignQ29tcGFyZVZhbGlkYXRvcjo6Y29tcGFyZVZhbHVlIG11c3QgYmUgc2V0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLm9wZXJhdG9yKSB7XG4gICAgICAgICAgICBjYXNlICc9PSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSA9PSB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJz09PSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSA9PT0gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICchPSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSAhPSB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJyE9PSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSAhPT0gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICc+JzogcmV0dXJuIHRoaXMuY29tcGFyZVZhbHVlID4gdmFsdWU7XG4gICAgICAgICAgICBjYXNlICc+PSc6IHJldHVybiB0aGlzLmNvbXBhcmVWYWx1ZSA+PSB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJzwnOiByZXR1cm4gdGhpcy5jb21wYXJlVmFsdWUgPCB2YWx1ZTtcbiAgICAgICAgICAgIGNhc2UgJzw9JzogcmV0dXJuIHRoaXMuY29tcGFyZVZhbHVlIDw9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTEwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLkRhdGVWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLkRhdGVWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkRhdGVWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdGZvcm1hdDogJ1ktbS1kJyxcblxuICAgIHRpbWVzdGFtcEF0dHJpYnV0ZTogbnVsbCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gSmlpLnQoJ2ppaScsICdUaGUgZm9ybWF0IG9mIHthdHRyaWJ1dGV9IGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcblxuICAgICAgICBpZiAoSmlpLl8uaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy50aW1lc3RhbXBBdHRyaWJ1dGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEB0b2RvIFBhcnNlIGJ5IGZvcm1hdFxuICAgICAgICAgICAgdmFyIHRpbWVzdGFtcCA9IERhdGUucGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgb2JqZWN0LnNldCh0aGlzLnRpbWVzdGFtcEF0dHJpYnV0ZSwgTWF0aC5yb3VuZCh0aW1lc3RhbXAgLyAxMDAwKSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgLy8gQHRvZG8gVmFsaWRhdGUgYnkgZm9ybWF0XG4gICAgICAgIHZhciB0aW1lc3RhbXAgPSBEYXRlLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICFKaWkuXy5pc05hTih0aW1lc3RhbXApO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuRGVmYXVsdFZhbHVlVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5EZWZhdWx0VmFsdWVWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkRlZmF1bHRWYWx1ZVZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0dmFsdWU6IG51bGwsXG5cbiAgICBza2lwT25FbXB0eTogZmFsc2UsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9ICcnOyAvLyBAdG9kb1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICBpZiAodGhpcy5pc0VtcHR5KG9iamVjdC5nZXQoYXR0cmlidXRlKSkpIHtcbiAgICAgICAgICAgIG9iamVjdC5zZXQoYXR0cmlidXRlLCB0aGlzLnZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5FbWFpbFZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuRW1haWxWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkVtYWlsVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRwYXR0ZXJuOiAvXlthLXpBLVowLTkhIyQlJlxcJyorXFxcXC89P15fYHt8fX4tXSsoPzpcXC5bYS16QS1aMC05ISMkJSZcXCcqK1xcXFwvPT9eX2B7fH1+LV0rKSpAKD86W2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV0qW2EtekEtWjAtOV0pP1xcLikrW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV0qW2EtekEtWjAtOV0pPyQvLFxuXG4gICAgZnVsbFBhdHRlcm46IC9eW15AXSo8W2EtekEtWjAtOSEjJCUmXFwnKitcXFxcLz0/Xl9ge3x9fi1dKyg/OlxcLlthLXpBLVowLTkhIyQlJlxcJyorXFxcXC89P15fYHt8fX4tXSspKkAoPzpbYS16QS1aMC05XSg/OlthLXpBLVowLTktXSpbYS16QS1aMC05XSk/XFwuKStbYS16QS1aMC05XSg/OlthLXpBLVowLTktXSpbYS16QS1aMC05XSk/PiQvLFxuXG4gICAgYWxsb3dOYW1lOiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gaXMgbm90IGEgdmFsaWQgZW1haWwgYWRkcmVzcy4nKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAoIUppaS5fLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiAzMjApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzLnBhdHRlcm4udGVzdCh2YWx1ZSkgfHwgKHRoaXMuYWxsb3dOYW1lICYmIHRoaXMuZnVsbFBhdHRlcm4udGVzdCh2YWx1ZSkpO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuRmlsdGVyVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5GaWx0ZXJWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLkZpbHRlclZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0ZmlsdGVyOiBudWxsLFxuXG4gICAgc2tpcE9uRW1wdHk6IGZhbHNlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5maWx0ZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignVGhlIGBmaWx0ZXJgIHByb3BlcnR5IG11c3QgYmUgc2V0LicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICBvYmplY3Quc2V0KGF0dHJpYnV0ZSwgdGhpcy5maWx0ZXIuY2FsbChvYmplY3QsIG9iamVjdC5nZXQoYXR0cmlidXRlKSkpO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuSW5saW5lVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5JbmxpbmVWYWxpZGF0b3InLCAvKiogQGxlbmRzIEppaS52YWxpZGF0b3JzLklubGluZVZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0bWV0aG9kOiBudWxsLFxuXG4gICAgcGFyYW1zOiBudWxsLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnJzsgLy8gQHRvZG9cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIG1ldGhvZCA9IG9iamVjdFt0aGlzLm1ldGhvZF07XG5cbiAgICAgICAgaWYgKCFKaWkuXy5pc0Z1bmN0aW9uKG1ldGhvZCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignTm90IGZpbmQgbWV0aG9kIGAnICsgdGhpcy5tZXRob2QgKyAnYCBpbiBtb2RlbCBgJyArIG9iamVjdC5kZWJ1Z0NsYXNzTmFtZSArICdgLicpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1ldGhvZC5jYWxsKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLnBhcmFtcyB8fCB7fSk7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5OdW1iZXJWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLk51bWJlclZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuTnVtYmVyVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRpbnRlZ2VyT25seTogZmFsc2UsXG5cbiAgICBtYXg6IG51bGwsXG5cbiAgICBtaW46IG51bGwsXG5cbiAgICB0b29CaWc6IG51bGwsXG5cbiAgICB0b29TbWFsbDogbnVsbCxcblxuICAgIGludGVnZXJQYXR0ZXJuOiAvXlxccypbKy1dP1xcZCtcXHMqJC8sXG5cbiAgICBudW1iZXJQYXR0ZXJuOiAvXlxccypbLStdP1swLTldKlxcLj9bMC05XSsoW2VFXVstK10/WzAtOV0rKT9cXHMqJC8sXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fX3N1cGVyKCk7XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5pbnRlZ2VyT25seSA/XG4gICAgICAgICAgICAgICAgSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBtdXN0IGJlIGFuIGludGVnZXIuJykgOlxuICAgICAgICAgICAgICAgIEppaS50KCdqaWknLCAne2F0dHJpYnV0ZX0gbXVzdCBiZSBhbiBudW1iZXIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluICE9PSBudWxsICYmIHRoaXMudG9vU21hbGwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudG9vU21hbGwgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IG11c3QgYmUgbm8gbGVzcyB0aGFuIHttaW59LicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gbnVsbCAmJiB0aGlzLnRvb0JpZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50b29CaWcgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IG11c3QgYmUgbm8gZ3JlYXRlciB0aGFuIHttYXh9LicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgaWYgKEppaS5fLmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCBKaWkudCgne2F0dHJpYnV0ZX0gaXMgaW52YWxpZC4nKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGF0dGVybiA9IHRoaXMuaW50ZWdlck9ubHkgPyB0aGlzLmludGVnZXJQYXR0ZXJuIDogdGhpcy5udW1iZXJQYXR0ZXJuO1xuICAgICAgICBpZiAoIXBhdHRlcm4udGVzdCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkRXJyb3Iob2JqZWN0LCBhdHRyaWJ1dGUsIHRoaXMubWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5taW4gIT09IG51bGwgJiYgdmFsdWUgPCB0aGlzLm1pbikge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy50b29TbWFsbCwge1xuICAgICAgICAgICAgICAgIG1pbjogdGhpcy5taW5cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm1heCAhPT0gbnVsbCAmJiB2YWx1ZSA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLnRvb0JpZywge1xuICAgICAgICAgICAgICAgIG1heDogdGhpcy5tYXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuID0gdGhpcy5pbnRlZ2VyT25seSA/IHRoaXMuaW50ZWdlclBhdHRlcm4gOiB0aGlzLm51bWJlclBhdHRlcm47XG4gICAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodmFsdWUpICYmXG4gICAgICAgICAgICAodGhpcy5taW4gPT09IG51bGwgfHwgdmFsdWUgPj0gdGhpcy5taW4pICYmXG4gICAgICAgICAgICAodGhpcy5tYXggPT09IG51bGwgfHwgdmFsdWUgPD0gdGhpcy5tYXgpO1xuICAgIH1cblxufSk7XG5cbn0se1wiLi9WYWxpZGF0b3JcIjoxMjIsXCJqaWlcIjoxMjR9XSwxMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCdqaWknKTtcblxucmVxdWlyZSgnLi9WYWxpZGF0b3InKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLnZhbGlkYXRvcnMuUmFuZ2VWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLlJhbmdlVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5SYW5nZVZhbGlkYXRvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IsXG5cblx0cmFuZ2U6IG51bGwsXG5cbiAgICBzdHJpY3Q6IGZhbHNlLFxuXG4gICAgbm90OiBmYWxzZSxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcblxuICAgICAgICBpZiAoIUppaS5fLmlzQXJyYXkodGhpcy5yYW5nZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvbignVGhlIGByYW5nZWAgcHJvcGVydHkgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IGlzIGludmFsaWQuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBpc0ZpbmVkID0gZmFsc2U7XG5cbiAgICAgICAgSmlpLl8uZWFjaCh0aGlzLnJhbmdlLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdCAmJiB2YWx1ZSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgIGlzRmluZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLnN0cmljdCAmJiB2YWx1ZSA9PSBpdGVtKSB7XG4gICAgICAgICAgICAgICAgaXNGaW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuICF0aGlzLm5vdCA/IGlzRmluZWQgOiAhaXNGaW5lZDtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTE3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLlJlZ3VsYXJFeHByZXNzaW9uVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5SZWd1bGFyRXhwcmVzc2lvblZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuUmVndWxhckV4cHJlc3Npb25WYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdHBhdHRlcm46IG51bGwsXG5cbiAgICBub3Q6IGZhbHNlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuXG4gICAgICAgIGlmICghSmlpLl8uaXNSZWdFeHAodGhpcy5wYXR0ZXJuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uKCdUaGUgYHBhdHRlcm5gIHByb3BlcnR5IG11c3QgYmUgc2V0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBpcyBpbnZhbGlkLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG4gICAgICAgIGlmICghdGhpcy52YWxpZGF0ZVZhbHVlKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaXNNYXRjaCA9IHRoaXMucGF0dGVybi50ZXN0KHZhbHVlKTtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5vdCA/IGlzTWF0Y2ggOiAhaXNNYXRjaDtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTE4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLlJlcXVpcmVkVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5SZXF1aXJlZFZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuUmVxdWlyZWRWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdHNraXBPbkVtcHR5OiBmYWxzZSxcblxuICAgIHJlcXVpcmVkVmFsdWU6IG51bGwsXG5cbiAgICBzdHJpY3Q6IGZhbHNlLFxuXG4gICAgaW5pdDogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5yZXF1aXJlZFZhbHVlID09PSBudWxsID9cbiAgICAgICAgICAgICAgICBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IGNhbm5vdCBiZSBibGFuay4nKSA6XG4gICAgICAgICAgICAgICAgSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBtdXN0IGJlIGB7cmVxdWlyZWRWYWx1ZX1gLicpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlQXR0cmlidXRlOiBmdW5jdGlvbiAob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gb2JqZWN0LmdldChhdHRyaWJ1dGUpO1xuICAgICAgICBpZiAoIXRoaXMudmFsaWRhdGVWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB0aGlzLnJlcXVpcmVkVmFsdWUgIT09IG51bGwgPyB7cmVxdWlyZWRWYWx1ZTogdGhpcy5yZXF1aXJlZFZhbHVlfSA6IHt9O1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlLCBwYXJhbXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpcy5yZXF1aXJlZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpY3QgPyB2YWx1ZSAhPT0gbnVsbCA6ICF0aGlzLmlzRW1wdHkodmFsdWUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmljdCA/IHZhbHVlICE9PSB0aGlzLnJlcXVpcmVkVmFsdWUgOiB2YWx1ZSAhPSB0aGlzLnJlcXVpcmVkVmFsdWU7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDExOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5TYWZlVmFsaWRhdG9yXG4gKiBAZXh0ZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkudmFsaWRhdG9ycy5TYWZlVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5TYWZlVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHR2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGUpIHtcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4vVmFsaWRhdG9yXCI6MTIyLFwiamlpXCI6MTI0fV0sMTIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnamlpJyk7XG5cbnJlcXVpcmUoJy4vVmFsaWRhdG9yJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS52YWxpZGF0b3JzLlN0cmluZ1ZhbGlkYXRvclxuICogQGV4dGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLnZhbGlkYXRvcnMuU3RyaW5nVmFsaWRhdG9yJywgLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5TdHJpbmdWYWxpZGF0b3IucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLFxuXG5cdGxlbmd0aDogbnVsbCxcblxuICAgIG1heDogbnVsbCxcblxuICAgIG1pbjogbnVsbCxcblxuICAgIHRvb0xvbmc6IG51bGwsXG5cbiAgICB0b29TaG9ydDogbnVsbCxcblxuICAgIG5vdEVxdWFsOiBudWxsLFxuXG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX19zdXBlcigpO1xuXG4gICAgICAgIGlmIChKaWkuXy5pc0FycmF5KHRoaXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubGVuZ3RoWzBdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taW4gPSB0aGlzLmxlbmd0aFswXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmxlbmd0aFsxXSkge1xuICAgICAgICAgICAgICAgIHRoaXMubWF4ID0gdGhpcy5sZW5ndGhbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmxlbmd0aCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IG11c3QgYmUgYSBzdHJpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWluICE9PSBudWxsICYmIHRoaXMudG9vU2hvcnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudG9vU2hvcnQgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IHNob3VsZCBjb250YWluIGF0IGxlYXN0IHttaW59IGNoYXJhY3RlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4ICE9PSBudWxsICYmIHRoaXMudG9vTG9uZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50b29Mb25nID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBzaG91bGQgY29udGFpbiBhdCBtb3N0IHttYXh9IGNoYXJhY3RlcnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICE9PSBudWxsICYmIHRoaXMubm90RXF1YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMubm90RXF1YWwgPSBKaWkudCgnamlpJywgJ3thdHRyaWJ1dGV9IHNob3VsZCBjb250YWluIHtsZW5ndGh9IGNoYXJhY3RlcnMuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcblxuICAgICAgICBpZiAoIUppaS5fLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5tZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgaWYgKHRoaXMubWluICE9PSBudWxsICYmIGxlbmd0aCA8IHRoaXMubWluKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLnRvb1Nob3J0LCB7XG4gICAgICAgICAgICAgICAgbWluOiB0aGlzLm1pblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubWF4ICE9PSBudWxsICYmIGxlbmd0aCA+IHRoaXMubWF4KSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLnRvb0xvbmcsIHtcbiAgICAgICAgICAgICAgICBtYXg6IHRoaXMubWF4XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sZW5ndGggIT09IG51bGwgJiYgbGVuZ3RoICE9PSB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5hZGRFcnJvcihvYmplY3QsIGF0dHJpYnV0ZSwgdGhpcy5ub3RFcXVhbCwge1xuICAgICAgICAgICAgICAgIGxlbmd0aDogdGhpcy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICghSmlpLl8uaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICByZXR1cm4gKHRoaXMubWluID09PSBudWxsIHx8IGxlbmd0aCA+PSB0aGlzLm1pbikgJiZcbiAgICAgICAgICAgICh0aGlzLm1heCA9PT0gbnVsbCB8fCBsZW5ndGggPD0gdGhpcy5tYXgpICYmXG4gICAgICAgICAgICAodGhpcy5sZW5ndGggPT09IG51bGwgfHwgbGVuZ3RoID09PSB0aGlzLmxlbmd0aCk7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDEyMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG5yZXF1aXJlKCcuL1ZhbGlkYXRvcicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5VcmxWYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS52YWxpZGF0b3JzLlZhbGlkYXRvclxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLlVybFZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuVXJsVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS52YWxpZGF0b3JzLlZhbGlkYXRvcixcblxuXHRwYXR0ZXJuOiAvXntzY2hlbWVzfTpcXC9cXC8oKFtBLVowLTldW0EtWjAtOV8tXSopKFxcLltBLVowLTldW0EtWjAtOV8tXSopKykvaSxcblxuICAgIHZhbGlkU2NoZW1lczogW1xuICAgICAgICAnaHR0cCcsXG4gICAgICAgICdodHRwcydcbiAgICBdLFxuXG4gICAgZGVmYXVsdFNjaGVtZTogbnVsbCxcblxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLl9fc3VwZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gSmlpLnQoJ2ppaScsICd7YXR0cmlidXRlfSBpcyBub3QgYSB2YWxpZCBVUkwuJyk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdGVBdHRyaWJ1dGU6IGZ1bmN0aW9uKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdC5nZXQoYXR0cmlidXRlKTtcbiAgICAgICAgaWYgKCF0aGlzLnZhbGlkYXRlVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEVycm9yKG9iamVjdCwgYXR0cmlidXRlLCB0aGlzLm1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdFNjaGVtZSAhPT0gbnVsbCAmJiB2YWx1ZS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIG9iamVjdC5zZXQoYXR0cmlidXRlLCB0aGlzLmRlZmF1bHRTY2hlbWUgKyAnOi8vJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0ZVZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoIUppaS5fLmlzU3RyaW5nKHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggPiAyMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kZWZhdWx0U2NoZW1lICE9PSBudWxsICYmIHZhbHVlLmluZGV4T2YoJzovLycpID09PSAtMSkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmRlZmF1bHRTY2hlbWUgKyAnOi8vJyArIHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhdHRlcm4gPSB0aGlzLnBhdHRlcm4uc291cmNlO1xuICAgICAgICBwYXR0ZXJuID0gcGF0dGVybi5yZXBsYWNlKCd7c2NoZW1lc30nLCAnKCcgKyB0aGlzLnZhbGlkU2NoZW1lcy5qb2luKCd8JykgKyAnKScpO1xuXG4gICAgICAgIHZhciBmbGFncyA9ICcnO1xuICAgICAgICBKaWkuXy5lYWNoKHtnbG9iYWw6ICdnJywgaWdub3JlQ2FzZTogJ2knLCBtdWx0aWxpbmU6ICdtJ30sIEppaS5fLmJpbmQoZnVuY3Rpb24oZmxhZywga2V5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXR0ZXJuW2tleV0pIHtcbiAgICAgICAgICAgICAgICBmbGFncyArPSBmbGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzKSk7XG5cbiAgICAgICAgcmV0dXJuIChuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKSkudGVzdCh2YWx1ZSk7XG4gICAgfVxuXG59KTtcblxufSx7XCIuL1ZhbGlkYXRvclwiOjEyMixcImppaVwiOjEyNH1dLDEyMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3JcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS52YWxpZGF0b3JzLlZhbGlkYXRvcicsIC8qKiBAbGVuZHMgSmlpLnZhbGlkYXRvcnMuVmFsaWRhdG9yLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkudmFsaWRhdG9ycy5WYWxpZGF0b3IgKi97XG5cblx0XHRkZWZhdWx0VmFsaWRhdG9yczoge1xuXG5cdFx0XHQnYm9vbGVhbic6ICdKaWkudmFsaWRhdG9ycy5Cb29sZWFuVmFsaWRhdG9yJyxcblx0XHRcdCdjb21wYXJlJzogJ0ppaS52YWxpZGF0b3JzLkNvbXBhcmVWYWxpZGF0b3InLFxuXHRcdFx0J2RhdGUnOiAnSmlpLnZhbGlkYXRvcnMuRGF0ZVZhbGlkYXRvcicsXG5cdFx0XHQnZGVmYXVsdCc6ICdKaWkudmFsaWRhdG9ycy5EZWZhdWx0VmFsdWVWYWxpZGF0b3InLFxuXHRcdFx0J2RvdWJsZSc6ICdKaWkudmFsaWRhdG9ycy5OdW1iZXJWYWxpZGF0b3InLFxuXHRcdFx0J2VtYWlsJzogJ0ppaS52YWxpZGF0b3JzLkVtYWlsVmFsaWRhdG9yJyxcblx0XHRcdC8vJ2V4aXN0JzogJ0ppaS52YWxpZGF0b3JzLkV4aXN0VmFsaWRhdG9yJyxcblx0XHRcdC8vJ2ZpbGUnOiAnSmlpLnZhbGlkYXRvcnMuRmlsZVZhbGlkYXRvcicsXG5cdFx0XHQnZmlsdGVyJzogJ0ppaS52YWxpZGF0b3JzLkZpbHRlclZhbGlkYXRvcicsXG5cdFx0XHQvLydpbWFnZSc6ICdKaWkudmFsaWRhdG9ycy5JbWFnZVZhbGlkYXRvcicsXG5cdFx0XHQnaW4nOiAnSmlpLnZhbGlkYXRvcnMuUmFuZ2VWYWxpZGF0b3InLFxuXHRcdFx0J2ludGVnZXInOiB7XG5cdFx0XHRcdCdjbGFzc05hbWUnOiAnSmlpLnZhbGlkYXRvcnMuTnVtYmVyVmFsaWRhdG9yJyxcblx0XHRcdFx0J2ludGVnZXJPbmx5JzogdHJ1ZVxuXHRcdFx0fSxcblx0XHRcdCdtYXRjaCc6ICdKaWkudmFsaWRhdG9ycy5SZWd1bGFyRXhwcmVzc2lvblZhbGlkYXRvcicsXG5cdFx0XHQnbnVtYmVyJzogJ0ppaS52YWxpZGF0b3JzLk51bWJlclZhbGlkYXRvcicsXG5cdFx0XHQncmVxdWlyZWQnOiAnSmlpLnZhbGlkYXRvcnMuUmVxdWlyZWRWYWxpZGF0b3InLFxuXHRcdFx0J3NhZmUnOiAnSmlpLnZhbGlkYXRvcnMuU2FmZVZhbGlkYXRvcicsXG5cdFx0XHQnc3RyaW5nJzogJ0ppaS52YWxpZGF0b3JzLlN0cmluZ1ZhbGlkYXRvcicsXG5cdFx0XHQvLyd1bmlxdWUnOiAnSmlpLnZhbGlkYXRvcnMuVW5pcXVlVmFsaWRhdG9yJyxcblx0XHRcdCd1cmwnOiAnSmlpLnZhbGlkYXRvcnMuVXJsVmFsaWRhdG9yJ1xuXHRcdH0sXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uICh0eXBlLCBvYmplY3QsIGF0dHJpYnV0ZXMsIHBhcmFtcykge1xuXHRcdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXHRcdFx0cGFyYW1zLmF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzO1xuXG5cdFx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbihvYmplY3RbdHlwZV0pKSB7XG5cdFx0XHRcdHBhcmFtcy5jbGFzc05hbWUgPSAnSmlpLnZhbGlkYXRvcnMuSW5saW5lVmFsaWRhdG9yJztcblx0XHRcdFx0cGFyYW1zLm1ldGhvZCA9IHR5cGU7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuZGVmYXVsdFZhbGlkYXRvcnMsIHR5cGUpKSB7XG5cdFx0XHRcdFx0dHlwZSA9IHRoaXMuZGVmYXVsdFZhbGlkYXRvcnNbdHlwZV07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNBcnJheSh0eXBlKSkge1xuXHRcdFx0XHRcdEppaS5fLmV4dGVuZChwYXJhbXMsIHR5cGUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcmFtcy5jbGFzc05hbWUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBKaWkuY3JlYXRlT2JqZWN0KHBhcmFtcyk7XG5cdFx0fVxuXG5cdH0sXG5cbiAgICBhdHRyaWJ1dGVzOiBbXSxcbiAgICBtZXNzYWdlOiBudWxsLFxuICAgIG9uOiBbXSxcbiAgICBleGNlcHQ6IFtdLFxuICAgIHNraXBPbkVycm9yOiB0cnVlLFxuICAgIHNraXBPbkVtcHR5OiB0cnVlLFxuICAgIGRlZmVycmVkOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQGFic3RyYWN0XG4gICAgICogQHBhcmFtIG9iamVjdFxuICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVcblx0ICogQHJldHVybnMge1Byb21pc2V8bnVsbH1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUF0dHJpYnV0ZTogZnVuY3Rpb24gKG9iamVjdCwgYXR0cmlidXRlKSB7XG4gICAgfSxcblxuICAgIHZhbGlkYXRlVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ05vdCBmb3VuZCBpbXBsZW1lbnRhdGlvbiBmb3IgbWV0aG9kIGB2YWxpZGF0ZVZhbHVlKClgLicpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0ZTogZnVuY3Rpb24ob2JqZWN0LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGF0dHJpYnV0ZXMgPSBKaWkuXy5pc0FycmF5KGF0dHJpYnV0ZXMpID9cbiAgICAgICAgICAgIEppaS5fLmludGVyc2VjdGlvbih0aGlzLmF0dHJpYnV0ZXMsIGF0dHJpYnV0ZXMpIDpcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlcztcblxuICAgICAgICB2YXIgcHJvbWlzZXMgPSBKaWkuXy5tYXAoYXR0cmlidXRlcywgSmlpLl8uYmluZChmdW5jdGlvbihhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBPbkVycm9yICYmIG9iamVjdC5oYXNFcnJvcnMoYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2tpcE9uRW1wdHkgJiYgdGhpcy5pc0VtcHR5KG9iamVjdC5nZXQoYXR0cmlidXRlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbGlkYXRlQXR0cmlidXRlKG9iamVjdCwgYXR0cmlidXRlKTtcbiAgICAgICAgfSwgdGhpcykpO1xuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSxcblxuICAgIGlzQWN0aXZlOiBmdW5jdGlvbihzY2VuYXJpbykge1xuICAgICAgICByZXR1cm4gSmlpLl8uaW5kZXhPZih0aGlzLmV4Y2VwdCwgc2NlbmFyaW8pID09PSAtMSAmJlxuICAgICAgICAgICAgKCF0aGlzLm9uIHx8IHRoaXMub24ubGVuZ3RoID09PSAwIHx8IEppaS5fLmluZGV4T2YodGhpcy5vbiwgc2NlbmFyaW8pICE9PSAtMSk7XG4gICAgfSxcblxuICAgIGFkZEVycm9yOiBmdW5jdGlvbihvYmplY3QsIGF0dHJpYnV0ZSwgbWVzc2FnZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcbiAgICAgICAgcGFyYW1zLmF0dHJpYnV0ZSA9IG9iamVjdC5nZXRBdHRyaWJ1dGVMYWJlbChhdHRyaWJ1dGUpO1xuICAgICAgICBwYXJhbXMudmFsdWUgPSBvYmplY3QuZ2V0KGF0dHJpYnV0ZSk7XG5cbiAgICAgICAgLy8gQHRvZG9cbiAgICAgICAgLy9tZXNzYWdlID0gSmlpLnQoJ2ppaScsIG1lc3NhZ2UpO1xuICAgICAgICBKaWkuXy5lYWNoKHBhcmFtcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZSgneycgKyBrZXkgKyAnfScsIHZhbHVlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgb2JqZWN0LmFkZEVycm9yKGF0dHJpYnV0ZSwgbWVzc2FnZSk7XG4gICAgICAgIEppaS53YXJuaW5nKCdWYWxpZGF0aW9uIGVycm9yIGluIG1vZGVsIGAnICsgb2JqZWN0LmNsYXNzTmFtZSgpICsgJ2A6ICcgKyBtZXNzYWdlKTtcbiAgICB9LFxuXG4gICAgaXNFbXB0eTogZnVuY3Rpb24odmFsdWUsIGlzVHJpbSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHxcbiAgICAgICAgICAgIHZhbHVlID09PSAnJyB8fFxuICAgICAgICAgICAgKGlzVHJpbSAmJiBKaWkuXy5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpID09PSAnJykgfHxcbiAgICAgICAgICAgIChKaWkuXy5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApO1xuICAgIH1cblxuXG59KTtcblxufSx7XCJqaWlcIjoxMjR9XSwxMjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xudmFyIEppaSA9IHJlcXVpcmUoJ2ppaScpO1xuSmlpLl8gPSByZXF1aXJlKCd1bmRlcnNjb3JlJyk7XG5KaWkuX3MgPSByZXF1aXJlKCd1bmRlcnNjb3JlLnN0cmluZycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEppaTtcbn0se1wiamlpXCI6MTI0LFwidW5kZXJzY29yZVwiOjE1NSxcInVuZGVyc2NvcmUuc3RyaW5nXCI6MTU0fV0sMTI0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogUmVxdWlyZSByZWxhdGlvbnMgbGlicyBhbmQgamlpIGZpbGVzXG4gKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSBtb2R1bGUuZXhwb3J0cyA9IHdpbmRvdy5KaWkgPSByZXF1aXJlKCcuL2xpYi9KaWknKTtcblxuLy8gR2xvYmFsIGxpYnJhcmllc1xuSmlpLl8gPSB3aW5kb3cuXyB8fCBudWxsO1xuSmlpLl9zID0gd2luZG93Ll9zIHx8IHdpbmRvdy5zIHx8ICh3aW5kb3cuXyA/IHdpbmRvdy5fLnN0cmluZyA6IG51bGwpIHx8IG51bGw7XG5KaWkuaXNOb2RlID0gZmFsc2U7XG5cbi8vIExvYWQgZnJhbWV3b3JrIGZpbGVzXG5yZXF1aXJlKCcuL2xpYi9hcHBsaWNhdGlvbi9XZWJBcHBsaWNhdGlvbicpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9BY3Rpb24nKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQWN0aW9uRXZlbnQnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQXBwbGljYXRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQmVoYXZpb3InKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQ29tcG9uZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL0NvbnRleHQnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvQ29udHJvbGxlcicpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9FdmVudCcpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9IdHRwUmVxdWVzdCcpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9Nb2RlbEV2ZW50Jyk7XG5yZXF1aXJlKCcuL2xpYi9iYXNlL01vZHVsZScpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9PYmplY3QnKTtcbnJlcXVpcmUoJy4vbGliL2Jhc2UvUmVxdWVzdCcpO1xucmVxdWlyZSgnLi9saWIvYmFzZS9SZXNwb25zZScpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9BcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkQ2FsbEV4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkQ29uZmlnRXhjZXB0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9leGNlcHRpb25zL0ludmFsaWRQYXJhbUV4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkUm91dGVFeGNlcHRpb24nKTtcbnJlcXVpcmUoJy4vbGliL2V4Y2VwdGlvbnMvTm90U3VwcG9ydGVkRXhjZXB0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9leGNlcHRpb25zL1Vua25vd25Qcm9wZXJ0eUV4Y2VwdGlvbicpO1xucmVxdWlyZSgnLi9saWIvaGVscGVycy9GaWxlJyk7XG5yZXF1aXJlKCcuL2xpYi9oZWxwZXJzL1N0cmluZycpO1xucmVxdWlyZSgnLi9saWIvaGVscGVycy9VcmwnKTtcbnJlcXVpcmUoJy4vbGliL3JlcXVlc3QvQW5vbnltb3VzQWN0aW9uJyk7XG5yZXF1aXJlKCcuL2xpYi9yZXF1ZXN0L0hlYWRlckNvbGxlY3Rpb24nKTtcbnJlcXVpcmUoJy4vbGliL3JlcXVlc3QvSW5saW5lQWN0aW9uJyk7XG5cbn0se1wiLi9saWIvSmlpXCI6MTI1LFwiLi9saWIvYXBwbGljYXRpb24vV2ViQXBwbGljYXRpb25cIjoxMjYsXCIuL2xpYi9iYXNlL0FjdGlvblwiOjEyNyxcIi4vbGliL2Jhc2UvQWN0aW9uRXZlbnRcIjoxMjgsXCIuL2xpYi9iYXNlL0FwcGxpY2F0aW9uXCI6MTI5LFwiLi9saWIvYmFzZS9CZWhhdmlvclwiOjEzMCxcIi4vbGliL2Jhc2UvQ29tcG9uZW50XCI6MTMxLFwiLi9saWIvYmFzZS9Db250ZXh0XCI6MTMyLFwiLi9saWIvYmFzZS9Db250cm9sbGVyXCI6MTMzLFwiLi9saWIvYmFzZS9FdmVudFwiOjEzNCxcIi4vbGliL2Jhc2UvSHR0cFJlcXVlc3RcIjoxMzUsXCIuL2xpYi9iYXNlL01vZGVsRXZlbnRcIjoxMzYsXCIuL2xpYi9iYXNlL01vZHVsZVwiOjEzNyxcIi4vbGliL2Jhc2UvT2JqZWN0XCI6MTM4LFwiLi9saWIvYmFzZS9SZXF1ZXN0XCI6MTM5LFwiLi9saWIvYmFzZS9SZXNwb25zZVwiOjE0MCxcIi4vbGliL2V4Y2VwdGlvbnMvQXBwbGljYXRpb25FeGNlcHRpb25cIjoxNDEsXCIuL2xpYi9leGNlcHRpb25zL0ludmFsaWRDYWxsRXhjZXB0aW9uXCI6MTQyLFwiLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkQ29uZmlnRXhjZXB0aW9uXCI6MTQzLFwiLi9saWIvZXhjZXB0aW9ucy9JbnZhbGlkUGFyYW1FeGNlcHRpb25cIjoxNDQsXCIuL2xpYi9leGNlcHRpb25zL0ludmFsaWRSb3V0ZUV4Y2VwdGlvblwiOjE0NSxcIi4vbGliL2V4Y2VwdGlvbnMvTm90U3VwcG9ydGVkRXhjZXB0aW9uXCI6MTQ2LFwiLi9saWIvZXhjZXB0aW9ucy9Vbmtub3duUHJvcGVydHlFeGNlcHRpb25cIjoxNDcsXCIuL2xpYi9oZWxwZXJzL0ZpbGVcIjoxNDgsXCIuL2xpYi9oZWxwZXJzL1N0cmluZ1wiOjE0OSxcIi4vbGliL2hlbHBlcnMvVXJsXCI6MTUwLFwiLi9saWIvcmVxdWVzdC9Bbm9ueW1vdXNBY3Rpb25cIjoxNTEsXCIuL2xpYi9yZXF1ZXN0L0hlYWRlckNvbGxlY3Rpb25cIjoxNTIsXCIuL2xpYi9yZXF1ZXN0L0lubGluZUFjdGlvblwiOjE1M31dLDEyNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4oZnVuY3Rpb24gKHByb2Nlc3MsX19kaXJuYW1lKXtcbi8qKlxyXG4gKiBKaWkg4oCUIEZ1bGwtU3RhY2sgSmF2YVNjcmlwdCBGcmFtZXdvcmsgYmFzZWQgb24gUEhQIFlpaSAyIEZyYW1ld29yayBhcmNoaXRlY3R1cmUuXHJcbiAqXHJcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxudmFyIE5lYXRuZXNzID0gcmVxdWlyZSgnbmVhdG5lc3MnKS5uZXdDb250ZXh0KCk7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZVxyXG4gKiBAYWxpYXMgbW9kdWxlOmppaVxyXG4gKi9cclxudmFyIEppaSA9IE5lYXRuZXNzLm5hbWVzcGFjZSgnSmlpJyk7XHJcblxyXG4vKipcclxuICogQGNsYXNzIEppaVxyXG4gKi9cclxuSmlpID0gTmVhdG5lc3MuZGVmaW5lQ2xhc3MoJ0ppaScsIHtcclxuXHJcblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpICove1xyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGFsaWFzIGxvZGFzaFxyXG5cdFx0ICovXHJcblx0XHRfOiBudWxsLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQGFsaWFzIF9zXHJcblx0XHQgKi9cclxuXHRcdF9zOiBudWxsLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHR5cGUgbW9kdWxlOndoZW5cclxuXHRcdCAqL1xyXG5cdFx0d2hlbjogbnVsbCxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEB0eXBlIHtKaWkuYmFzZS5BcHBsaWNhdGlvbn1cclxuXHRcdCAqL1xyXG5cdFx0YXBwOiBudWxsLFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQHR5cGUge29iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0YWxpYXNlczogbnVsbCxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFRydWUsIGlmIHJ1bm5pbmcgaW4gbm9kZSBqc1xyXG5cdFx0ICogQHR5cGUge2Jvb2xlYW59XHJcblx0XHQgKi9cclxuXHRcdGlzTm9kZTogZmFsc2UsXHJcblxyXG5cdFx0X2NvbnRleHRDb25maWc6IG51bGwsXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZXR1cm5zIGZyYW1ld29yayB2ZXJzaW9uXHJcblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG5cdFx0ICovXHJcblx0XHRnZXRWZXJzaW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHJldHVybiByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIEdldCBjbGFzcyBieSBmdWxsIG5hbWVzcGFjZS5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXHJcblx0XHQgKiBAcmV0dXJucyB7ZnVuY3Rpb258b2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHRuYW1lc3BhY2U6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRcdHJldHVybiBKaWkuXy5pc1N0cmluZyhuYW1lKSA/IE5lYXRuZXNzLm5hbWVzcGFjZS5hcHBseShOZWF0bmVzcywgYXJndW1lbnRzKSA6IG5hbWU7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTW92ZSBuYW1lc3BhY2UgdG8gb3RoZXIgb2JqZWN0XHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gbmV3Q29udGV4dFxyXG5cdFx0ICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlRnJvbU9sZF1cclxuXHRcdCAqIEByZXR1cm5zIHsqfEZ1bmN0aW9ufE9iamVjdH1cclxuXHRcdCAqL1xyXG5cdFx0bmFtZXNwYWNlTW92ZUNvbnRleHQ6IGZ1bmN0aW9uIChuZXdDb250ZXh0LCByZW1vdmVGcm9tT2xkKSB7XHJcblx0XHRcdHJldHVybiBOZWF0bmVzcy5tb3ZlQ29udGV4dC5hcHBseShOZWF0bmVzcywgYXJndW1lbnRzKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBNZXRob2QgZm9yIGRlZmluZSBjbGFzcy4gT3B0aW9ucyBvYmplY3Qgd2lsbCBiZSBjb252ZXJ0ZXIgdG8gY2xhc3MgcHJvdG90eXBlLlxyXG5cdFx0ICogRm9yIHNldCBzdGF0aWMgcHJvcGVydGllcyBhbmQgbWV0aG9kcywgc2V0IHBhcmFtIGBfX3N0YXRpY2AgYXMgb2JqZWN0IHdpdGggcHJvcGVydGllcyBhbmQgbWV0aG9kcy5cclxuXHRcdCAqIEZvciBleHRlbmRzIGZyb20gY2xhc3MsIHNldCBgX19leHRlbmRzYCBwcm9wZXJ0eSBhcyBleHRlbmRlZCBjbGFzcyAoZnVuY3Rpb24pLiBFeGFtcGxlIGZvcm1hdDpcclxuXHRcdCAqICAgIHtcclxuXHRcdCAqICAgICAgX19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXHJcblx0XHQgKiAgICAgIF9fc3RhdGljOiB7XHJcblx0XHQgKiAgICAgICAgICBzdGF0aWNQYXJhbTogMTAsXHJcblx0XHQgKiAgICAgICAgICBNWV9DT05TVEFOVDogJ2NvbnN0YW50JyxcclxuXHRcdCAqICAgICAgICAgIG5vcm1hbGl6ZU5hbWU6IGZ1bmN0aW9uKCkge30sXHJcblx0XHQgKiAgICAgIH0sXHJcblx0XHQgKiAgICAgIHByb3RvdHlwZVBhcmFtOiAyMCxcclxuXHRcdCAqICAgICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7fVxyXG5cdFx0ICogfVxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGdsb2JhbE5hbWVcclxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXHJcblx0XHQgKiBAcmV0dXJuIHtvYmplY3R9XHJcblx0XHQgKi9cclxuXHRcdGRlZmluZUNsYXNzOiBmdW5jdGlvbiAoZ2xvYmFsTmFtZSwgb3B0aW9ucykge1xyXG5cdFx0XHRyZXR1cm4gTmVhdG5lc3MuZGVmaW5lQ2xhc3MuYXBwbHkoTmVhdG5lc3MsIGFyZ3VtZW50cyk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogQ3JlYXRlIHdlYiBhcHBsaWNhdGlvbiwgd2hpY2ggYXZhaWxhYmxlIGJ5IEppaS5hcHBcclxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcclxuXHRcdCAqIEByZXR1cm5zIHtKaWkuYXBwLkFwcGxpY2F0aW9ufVxyXG5cdFx0ICovXHJcblx0XHRjcmVhdGVXZWJBcHBsaWNhdGlvbjogZnVuY3Rpb24gKGNvbmZpZykge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5jcmVhdGVBcHBsaWNhdGlvbignSmlpLmFwcGxpY2F0aW9uLldlYkFwcGxpY2F0aW9uJywgY29uZmlnKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBDcmVhdGUgY29uc29sZSBhcHBsaWNhdGlvbiwgd2hpY2ggYXZhaWxhYmxlIGJ5IEppaS5hcHBcclxuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcclxuXHRcdCAqIEByZXR1cm5zIHtKaWkuYXBwLkFwcGxpY2F0aW9ufVxyXG5cdFx0ICovXHJcblx0XHRjcmVhdGVDb25zb2xlQXBwbGljYXRpb246IGZ1bmN0aW9uIChjb25maWcpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlQXBwbGljYXRpb24oJ0ppaS5hcHBsaWNhdGlvbi5Db25zb2xlQXBwbGljYXRpb24nLCBjb25maWcpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIE1haW4gbWV0aG9kIHdoaWNoIGNyZWF0ZSBhcHBsaWNhdGlvbiBieSBjbGFzcyBuYW1lIGFuZCBjb25maWcuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXHJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXHJcblx0XHQgKiBAcmV0dXJucyB7SmlpLmFwcC5BcHBsaWNhdGlvbn1cclxuXHRcdCAqL1xyXG5cdFx0Y3JlYXRlQXBwbGljYXRpb246IGZ1bmN0aW9uKGNsYXNzTmFtZSwgY29uZmlnKSB7XHJcblx0XHRcdGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcclxuXHRcdFx0Y29uZmlnLmFwcGxpY2F0aW9uID0gY29uZmlnLmFwcGxpY2F0aW9uIHx8IHt9O1xyXG5cclxuXHRcdFx0Ly8gU2F2ZSBjb250ZXh0IGNvbmZpZ1xyXG5cdFx0XHR0aGlzLl9jb250ZXh0Q29uZmlnID0gY29uZmlnLmNvbnRleHQgfHwge307XHJcblxyXG5cdFx0XHR2YXIgQXBwbGljYXRpb25DbGFzcyA9IHRoaXMubmFtZXNwYWNlKGNsYXNzTmFtZSk7XHJcblx0XHRcdGlmICghSmlpLl8uaXNGdW5jdGlvbihBcHBsaWNhdGlvbkNsYXNzKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24oJ05vdCBmb3VuZCBhcHBsaWNhdGlvbiBjbGFzczogJyArIGNsYXNzTmFtZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEluaXQgYWxpYXNlc1xyXG5cdFx0XHR0aGlzLmFsaWFzZXMgPSB7fTtcclxuXHRcdFx0aWYgKHRoaXMuaXNOb2RlKSB7XHJcblx0XHRcdFx0dGhpcy5hbGlhc2VzWydAamlpJ10gPSBfX2Rpcm5hbWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIENyZWF0ZSBhcHBsaWNhdGlvbiBpbnN0YW5jZVxyXG5cdFx0XHRyZXR1cm4gbmV3IEFwcGxpY2F0aW9uQ2xhc3MoY29uZmlnLmFwcGxpY2F0aW9uKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBNYWluIG1ldGhvZCB3aGljaCBjcmVhdGUgYXBwbGljYXRpb24gYnkgY2xhc3MgbmFtZSBhbmQgY29uZmlnLlxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xyXG5cdFx0ICogQHJldHVybnMge0ppaS5iYXNlLkNvbnRleHR9XHJcblx0XHQgKi9cclxuXHRcdGNyZWF0ZUNvbnRleHQ6IGZ1bmN0aW9uKGNvbmZpZykge1xyXG5cdFx0XHRjb25maWcgPSBjb25maWcgfHwge307XHJcblxyXG5cdFx0XHQvLyBNZXJnZSB3aXRoIGRlZmF1bHQgY29udGV4dCBjb25maWdcclxuICAgICAgICAgICAgY29uZmlnID0gdGhpcy5tZXJnZUNvbmZpZ3ModGhpcy5fY29udGV4dENvbmZpZyB8fCB7fSwgY29uZmlnKTtcclxuXHJcblx0XHRcdGlmIChjb25maWcuY2xhc3NOYW1lKSB7XHJcblx0XHRcdFx0dmFyIENvbnRleHRDbGFzcyA9IHRoaXMubmFtZXNwYWNlKGNvbmZpZy5jbGFzc05hbWUpO1xyXG5cdFx0XHRcdGlmICghSmlpLl8uaXNGdW5jdGlvbihDb250ZXh0Q2xhc3MpKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdOb3QgZm91bmQgY29udGV4dCBjbGFzczogJyArIGNsYXNzTmFtZSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gbmV3IENvbnRleHRDbGFzcyhjb25maWcpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gbmV3IEppaS5iYXNlLkNvbnRleHQoY29uZmlnKTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBUcmFuc2xhdGVzIGEgcGF0aCBhbGlhcyBpbnRvIGFuIGFjdHVhbCBwYXRoLlxyXG5cdFx0ICpcclxuXHRcdCAqIFRoZSB0cmFuc2xhdGlvbiBpcyBkb25lIGFjY29yZGluZyB0byB0aGUgZm9sbG93aW5nIHByb2NlZHVyZTpcclxuXHRcdCAqXHJcblx0XHQgKiAxLiBJZiB0aGUgZ2l2ZW4gYWxpYXMgZG9lcyBub3Qgc3RhcnQgd2l0aCAnQCcsIGl0IGlzIHJldHVybmVkIGJhY2sgd2l0aG91dCBjaGFuZ2U7XHJcblx0XHQgKiAyLiBPdGhlcndpc2UsIGxvb2sgZm9yIHRoZSBsb25nZXN0IHJlZ2lzdGVyZWQgYWxpYXMgdGhhdCBtYXRjaGVzIHRoZSBiZWdpbm5pbmcgcGFydFxyXG5cdFx0ICogICAgb2YgdGhlIGdpdmVuIGFsaWFzLiBJZiBpdCBleGlzdHMsIHJlcGxhY2UgdGhlIG1hdGNoaW5nIHBhcnQgb2YgdGhlIGdpdmVuIGFsaWFzIHdpdGhcclxuXHRcdCAqICAgIHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lzdGVyZWQgcGF0aC5cclxuXHRcdCAqIDMuIFRocm93IGFuIGV4Y2VwdGlvbiBvciByZXR1cm4gZmFsc2UsIGRlcGVuZGluZyBvbiB0aGUgYCR0aHJvd0V4Y2VwdGlvbmAgcGFyYW1ldGVyLlxyXG5cdFx0ICpcclxuXHRcdCAqIEZvciBleGFtcGxlLCBieSBkZWZhdWx0ICdAamlpJyBpcyByZWdpc3RlcmVkIGFzIHRoZSBhbGlhcyB0byB0aGUgSmlpIGZyYW1ld29yayBkaXJlY3RvcnksXHJcblx0XHQgKiBzYXkgJy9wYXRoL3RvL2ppaScuIFRoZSBhbGlhcyAnQGppaS93ZWInIHdvdWxkIHRoZW4gYmUgdHJhbnNsYXRlZCBpbnRvICcvcGF0aC90by9qaWkvd2ViJy5cclxuXHRcdCAqXHJcblx0XHQgKiBJZiB5b3UgaGF2ZSByZWdpc3RlcmVkIHR3byBhbGlhc2VzICdAZm9vJyBhbmQgJ0Bmb28vYmFyJy4gVGhlbiB0cmFuc2xhdGluZyAnQGZvby9iYXIvY29uZmlnJ1xyXG5cdFx0ICogd291bGQgcmVwbGFjZSB0aGUgcGFydCAnQGZvby9iYXInIChpbnN0ZWFkIG9mICdAZm9vJykgd2l0aCB0aGUgY29ycmVzcG9uZGluZyByZWdpc3RlcmVkIHBhdGguXHJcblx0XHQgKiBUaGlzIGlzIGJlY2F1c2UgdGhlIGxvbmdlc3QgYWxpYXMgdGFrZXMgcHJlY2VkZW5jZS5cclxuXHRcdCAqXHJcblx0XHQgKiBIb3dldmVyLCBpZiB0aGUgYWxpYXMgdG8gYmUgdHJhbnNsYXRlZCBpcyAnQGZvby9iYXJiYXIvY29uZmlnJywgdGhlbiAnQGZvbycgd2lsbCBiZSByZXBsYWNlZFxyXG5cdFx0ICogaW5zdGVhZCBvZiAnQGZvby9iYXInLCBiZWNhdXNlICcvJyBzZXJ2ZXMgYXMgdGhlIGJvdW5kYXJ5IGNoYXJhY3Rlci5cclxuXHRcdCAqXHJcblx0XHQgKiBOb3RlLCB0aGlzIG1ldGhvZCBkb2VzIG5vdCBjaGVjayBpZiB0aGUgcmV0dXJuZWQgcGF0aCBleGlzdHMgb3Igbm90LlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyB0aGUgYWxpYXMgdG8gYmUgdHJhbnNsYXRlZC5cclxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rocm93RXhjZXB0aW9uXSB3aGV0aGVyIHRvIHRocm93IGFuIGV4Y2VwdGlvbiBpZiB0aGUgZ2l2ZW4gYWxpYXMgaXMgaW52YWxpZC5cclxuXHRcdCAqIElmIHRoaXMgaXMgZmFsc2UgYW5kIGFuIGludmFsaWQgYWxpYXMgaXMgZ2l2ZW4sIGZhbHNlIHdpbGwgYmUgcmV0dXJuZWQgYnkgdGhpcyBtZXRob2QuXHJcblx0XHQgKiBAcmV0dXJuIHtzdHJpbmd8Ym9vbGVhbn0gdGhlIHBhdGggY29ycmVzcG9uZGluZyB0byB0aGUgYWxpYXMsIGZhbHNlIGlmIHRoZSByb290IGFsaWFzIGlzIG5vdCBwcmV2aW91c2x5IHJlZ2lzdGVyZWQuXHJcblx0XHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb259IGlmIHRoZSBhbGlhcyBpcyBpbnZhbGlkIHdoaWxlIHRocm93RXhjZXB0aW9uIGlzIHRydWUuXHJcblx0XHQgKiBAc2VlIHNldEFsaWFzKClcclxuXHRcdCAqL1xyXG5cdFx0Z2V0QWxpYXM6IGZ1bmN0aW9uIChhbGlhcywgdGhyb3dFeGNlcHRpb24pIHtcclxuXHRcdFx0aWYgKEppaS5fLmlzVW5kZWZpbmVkKHRocm93RXhjZXB0aW9uKSkge1xyXG5cdFx0XHRcdHRocm93RXhjZXB0aW9uID0gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGFsaWFzLmluZGV4T2YoJ0AnKSAhPT0gMCkge1xyXG5cdFx0XHRcdHJldHVybiBhbGlhcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gYWxpYXMuaW5kZXhPZignLycpO1xyXG5cdFx0XHR2YXIgcm9vdCA9IGluZGV4ID09PSAtMSA/IGFsaWFzIDogYWxpYXMuc3Vic3RyKDAsIGluZGV4KTtcclxuXHJcblx0XHRcdGlmIChKaWkuXy5oYXModGhpcy5hbGlhc2VzLCByb290KSkge1xyXG5cdFx0XHRcdGlmIChKaWkuXy5pc1N0cmluZyh0aGlzLmFsaWFzZXNbcm9vdF0pKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdGhpcy5hbGlhc2VzW3Jvb3RdICsgKGluZGV4ICE9PSAtMSA/IGFsaWFzLnN1YnN0cihpbmRleCkgOiAnJyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgZmluZWRQYXRoID0gbnVsbDtcclxuXHRcdFx0XHRKaWkuXy5lYWNoKHRoaXMuYWxpYXNlc1tyb290XSwgZnVuY3Rpb24gKHBhdGgsIG5hbWUpIHtcclxuXHRcdFx0XHRcdHZhciB0ZXN0QWxpYXMgPSBhbGlhcyArICcvJztcclxuXHRcdFx0XHRcdGlmICh0ZXN0QWxpYXMuaW5kZXhPZihuYW1lICsgJy8nKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRmaW5lZFBhdGggPSBwYXRoICsgYWxpYXMuc3Vic3RyKG5hbWUubGVuZ3RoKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGlmIChmaW5lZFBhdGggIT09IG51bGwpIHtcclxuXHRcdFx0XHRcdHJldHVybiBmaW5lZFBhdGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAodGhyb3dFeGNlcHRpb24pIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uKCdJbnZhbGlkIHBhdGggYWxpYXM6ICcgKyBhbGlhcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFJldHVybnMgdGhlIHJvb3QgYWxpYXMgcGFydCBvZiBhIGdpdmVuIGFsaWFzLlxyXG5cdFx0ICogQSByb290IGFsaWFzIGlzIGFuIGFsaWFzIHRoYXQgaGFzIGJlZW4gcmVnaXN0ZXJlZCB2aWEgW1tzZXRBbGlhcygpXV0gcHJldmlvdXNseS5cclxuXHRcdCAqIElmIGEgZ2l2ZW4gYWxpYXMgbWF0Y2hlcyBtdWx0aXBsZSByb290IGFsaWFzZXMsIHRoZSBsb25nZXN0IG9uZSB3aWxsIGJlIHJldHVybmVkLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIHRoZSBhbGlhc1xyXG5cdFx0ICogQHJldHVybiB7c3RyaW5nfGJvb2xlYW59IHRoZSByb290IGFsaWFzLCBvciBmYWxzZSBpZiBubyByb290IGFsaWFzIGlzIGZvdW5kXHJcblx0XHQgKi9cclxuXHRcdGdldFJvb3RBbGlhczogZnVuY3Rpb24gKGFsaWFzKSB7XHJcblx0XHRcdHZhciBpbmRleCA9IGFsaWFzLmluZGV4T2YoJy8nKTtcclxuXHRcdFx0dmFyIHJvb3QgPSBpbmRleCA9PT0gLTEgPyBhbGlhcyA6IGFsaWFzLnN1YnN0cigwLCBpbmRleCk7XHJcblxyXG5cdFx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuYWxpYXNlcywgcm9vdCkpIHtcclxuXHRcdFx0XHRpZiAoSmlpLl8uaXNTdHJpbmcodGhpcy5hbGlhc2VzW3Jvb3RdKSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHJvb3Q7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHR2YXIgZmluZWRQYXRoID0gbnVsbDtcclxuXHRcdFx0XHRKaWkuXy5lYWNoKHRoaXMuYWxpYXNlc1tyb290XSwgZnVuY3Rpb24gKHBhdGgsIG5hbWUpIHtcclxuXHRcdFx0XHRcdGlmIChKaWkuXy5pbmRleE9mKGFsaWFzICsgJy8nLCBuYW1lICsgJy8nKSA9PT0gMCkge1xyXG5cdFx0XHRcdFx0XHRmaW5lZFBhdGggPSBuYW1lO1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdFx0aWYgKGZpbmVkUGF0aCAhPT0gbnVsbCkge1xyXG5cdFx0XHRcdFx0cmV0dXJuIGZpbmVkUGF0aDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBSZWdpc3RlcnMgYSBwYXRoIGFsaWFzLlxyXG5cdFx0ICpcclxuXHRcdCAqIEEgcGF0aCBhbGlhcyBpcyBhIHNob3J0IG5hbWUgcmVwcmVzZW50aW5nIGEgbG9uZyBwYXRoIChhIGZpbGUgcGF0aCwgYSBVUkwsIGV0Yy4pXHJcblx0XHQgKiBGb3IgZXhhbXBsZSwgd2UgdXNlICdAamlpJyBhcyB0aGUgYWxpYXMgb2YgdGhlIHBhdGggdG8gdGhlIEppaSBmcmFtZXdvcmsgZGlyZWN0b3J5LlxyXG5cdFx0ICpcclxuXHRcdCAqIEEgcGF0aCBhbGlhcyBtdXN0IHN0YXJ0IHdpdGggdGhlIGNoYXJhY3RlciAnQCcgc28gdGhhdCBpdCBjYW4gYmUgZWFzaWx5IGRpZmZlcmVudGlhdGVkXHJcblx0XHQgKiBmcm9tIG5vbi1hbGlhcyBwYXRocy5cclxuXHRcdCAqXHJcblx0XHQgKiBOb3RlIHRoYXQgdGhpcyBtZXRob2QgZG9lcyBub3QgY2hlY2sgaWYgdGhlIGdpdmVuIHBhdGggZXhpc3RzIG9yIG5vdC4gQWxsIGl0IGRvZXMgaXNcclxuXHRcdCAqIHRvIGFzc29jaWF0ZSB0aGUgYWxpYXMgd2l0aCB0aGUgcGF0aC5cclxuXHRcdCAqXHJcblx0XHQgKiBBbnkgdHJhaWxpbmcgJy8nIGFuZCAnXFwnIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHBhdGggd2lsbCBiZSB0cmltbWVkLlxyXG5cdFx0ICpcclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBhbGlhcyB0aGUgYWxpYXMgbmFtZSAoZS5nLiBcIkBqaWlcIikuIEl0IG11c3Qgc3RhcnQgd2l0aCBhICdAJyBjaGFyYWN0ZXIuXHJcblx0XHQgKiBJdCBtYXkgY29udGFpbiB0aGUgZm9yd2FyZCBzbGFzaCAnLycgd2hpY2ggc2VydmVzIGFzIGJvdW5kYXJ5IGNoYXJhY3RlciB3aGVuIHBlcmZvcm1pbmdcclxuXHRcdCAqIGFsaWFzIHRyYW5zbGF0aW9uIGJ5IFtbZ2V0QWxpYXMoKV1dLlxyXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHBhdGggY29ycmVzcG9uZGluZyB0byB0aGUgYWxpYXMuIFRyYWlsaW5nICcvJyBhbmQgJ1xcJyBjaGFyYWN0ZXJzXHJcblx0XHQgKiB3aWxsIGJlIHRyaW1tZWQuIFRoaXMgY2FuIGJlXHJcblx0XHQgKlxyXG5cdFx0ICogLSBhIGRpcmVjdG9yeSBvciBhIGZpbGUgcGF0aCAoZS5nLiBgL3RtcGAsIGAvdG1wL21haW4udHh0YClcclxuXHRcdCAqIC0gYSBVUkwgKGUuZy4gYGh0dHA6Ly9leGFtcGxlLmNvbWApXHJcblx0XHQgKiAtIGEgcGF0aCBhbGlhcyAoZS5nLiBgQGppaS9iYXNlYCkuIEluIHRoaXMgY2FzZSwgdGhlIHBhdGggYWxpYXMgd2lsbCBiZSBjb252ZXJ0ZWQgaW50byB0aGVcclxuXHRcdCAqICAgYWN0dWFsIHBhdGggZmlyc3QgYnkgY2FsbGluZyBbW2dldEFsaWFzKCldXS5cclxuXHRcdCAqXHJcblx0XHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb259IGlmICRwYXRoIGlzIGFuIGludmFsaWQgYWxpYXMuXHJcblx0XHQgKiBAc2VlIGdldEFsaWFzKClcclxuXHRcdCAqL1xyXG5cdFx0c2V0QWxpYXM6IGZ1bmN0aW9uIChhbGlhcywgcGF0aCkge1xyXG5cdFx0XHRpZiAoYWxpYXMuaW5kZXhPZignQCcpICE9PSAwKSB7XHJcblx0XHRcdFx0YWxpYXMgPSAnQCcgKyBhbGlhcztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGluZGV4ID0gYWxpYXMuaW5kZXhPZignLycpO1xyXG5cdFx0XHR2YXIgcm9vdCA9IGluZGV4ID09PSAtMSA/IGFsaWFzIDogYWxpYXMuc3Vic3RyKDAsIGluZGV4KTtcclxuXHJcblx0XHRcdGlmIChwYXRoICE9PSBudWxsKSB7XHJcblx0XHRcdFx0cGF0aCA9IGFsaWFzLmluZGV4T2YoJ0AnKSAhPT0gMCA/IEppaS5fcy5ydHJpbShwYXRoLCAnLycpIDogdGhpcy5nZXRBbGlhcyhwYXRoKTtcclxuXHJcblx0XHRcdFx0aWYgKCFKaWkuXy5oYXModGhpcy5hbGlhc2VzLCByb290KSkge1xyXG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFsaWFzZXNbcm9vdF0gPSBwYXRoO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdID0ge307XHJcblx0XHRcdFx0XHRcdHRoaXMuYWxpYXNlc1tyb290XVthbGlhc10gPSBwYXRoO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoSmlpLl8uaXNTdHJpbmcodGhpcy5hbGlhc2VzW3Jvb3RdKSkge1xyXG5cdFx0XHRcdFx0aWYgKGluZGV4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFsaWFzZXNbcm9vdF0gPSBwYXRoO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0dmFyIG9sZFBhdGggPSB0aGlzLmFsaWFzZXNbcm9vdF07XHJcblx0XHRcdFx0XHRcdHRoaXMuYWxpYXNlc1tyb290XSA9IHt9O1xyXG5cdFx0XHRcdFx0XHR0aGlzLmFsaWFzZXNbcm9vdF1bYWxpYXNdID0gcGF0aDtcclxuXHRcdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdW3Jvb3RdID0gb2xkUGF0aDtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0dGhpcy5hbGlhc2VzW3Jvb3RdW2FsaWFzXSA9IHBhdGg7XHJcblx0XHRcdFx0XHQvL2tyc29ydChzdGF0aWM6OiRhbGlhc2VzWyRyb290XSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKEppaS5fLmhhcyh0aGlzLmFsaWFzZXMsIHJvb3QpKSB7XHJcblx0XHRcdFx0aWYgKEppaS5fLmlzT2JqZWN0KHRoaXMuYWxpYXNlc1tyb290XSkpIHtcclxuXHRcdFx0XHRcdGRlbGV0ZSB0aGlzLmFsaWFzZXNbcm9vdF1bYWxpYXNdO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoaW5kZXggPT09IC0xKSB7XHJcblx0XHRcdFx0XHRkZWxldGUgdGhpcy5hbGlhc2VzW3Jvb3RdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2UgdXNpbmcgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24uXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IGNvbmZpZyBDbGFzcyBuYW1lIG9yIG9iamVjdCB3aXRoIHBhcmFtIGBjbGFzc05hbWVgXHJcblx0XHQgKiBAcmV0dXJucyB7b2JqZWN0fVxyXG5cdFx0ICovXHJcblx0XHRjcmVhdGVPYmplY3Q6IGZ1bmN0aW9uIChjb25maWcpIHtcclxuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IG51bGw7XHJcblxyXG5cdFx0XHQvLyBOb3JtYWxpemUgY29uZmlnXHJcblx0XHRcdGlmIChKaWkuXy5pc1N0cmluZyhjb25maWcpKSB7XHJcblx0XHRcdFx0Y2xhc3NOYW1lID0gY29uZmlnO1xyXG5cdFx0XHRcdGNvbmZpZyA9IHt9O1xyXG5cdFx0XHR9IGVsc2UgaWYgKEppaS5fLmhhcyhjb25maWcsICdjbGFzc05hbWUnKSkge1xyXG5cdFx0XHRcdGNvbmZpZyA9IEppaS5fLmNsb25lKGNvbmZpZyk7XHJcblx0XHRcdFx0Y2xhc3NOYW1lID0gY29uZmlnLmNsYXNzTmFtZTtcclxuXHRcdFx0XHRkZWxldGUgY29uZmlnLmNsYXNzTmFtZTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ1dyb25nIGNvbmZpZ3VyYXRpb24gZm9yIGNyZWF0ZSBvYmplY3QuJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEdldCBjbGFzc1xyXG5cdFx0XHR2YXIgb2JqZWN0Q2xhc3MgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XHJcblx0XHRcdGlmICghSmlpLl8uaXNGdW5jdGlvbihvYmplY3RDbGFzcykpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24oJ05vdCBmb3VuZCBjbGFzcyBgJyArIGNsYXNzTmFtZSArICdgIGZvciBjcmVhdGUgaW5zdGFuY2UuJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIEFyZ3VtZW50cyBmb3IgY29uc3RydWN0b3Igb2YgY2xhc3NcclxuXHRcdFx0dmFyIGFyZ3MgPSBbb2JqZWN0Q2xhc3NdO1xyXG5cdFx0XHRhcmdzID0gYXJncy5jb25jYXQoSmlpLl8ucmVzdChhcmd1bWVudHMpKTtcclxuXHRcdFx0aWYgKCFKaWkuXy5pc0VtcHR5KGNvbmZpZykpIHtcclxuXHRcdFx0XHRhcmdzLnB1c2goY29uZmlnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gQHRvZG8gU3VwcG9ydCBvbGQgYnJvd3NlcnMgKGJpbmQgZnVuY3Rpb24pXHJcblx0XHRcdHJldHVybiBuZXcgKG9iamVjdENsYXNzLmJpbmQuYXBwbHkob2JqZWN0Q2xhc3MsIGFyZ3MpKSgpO1xyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIFNldCBjb25maWd1cmF0aW9uIHRvIG9iamVjdC4gVGhpcyBtZXRob2QgZmluZCBwdWJsaWMgcGFyYW0gaW4gb2JqZWN0IG9yIHNldHRlciBtZXRob2QuXHJcblx0XHQgKiBZb3UgY2FuIG5vdCB1c2Ugc2V0dGVyIGFuZCBwdWJsaWMgcGFyYW0gYXQgdGhlIHNhbWUgdGltZSBmb3Igc2FmZXR5IHJlYXNvblxyXG5cdFx0ICogQHBhcmFtIHtKaWkuYmFzZS5PYmplY3R9IG9iamVjdCBDbGFzcyBpbnN0YW5jZVxyXG5cdFx0ICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBDb25maWd1cmF0aW9uIG9iamVjdCB7a2V5OiB2YWx1ZSwgLi59XHJcblx0XHQgKi9cclxuXHRcdGNvbmZpZ3VyZTogZnVuY3Rpb24gKG9iamVjdCwgY29uZmlnKSB7XHJcblx0XHRcdGZvciAodmFyIGtleSBpbiBjb25maWcpIHtcclxuXHRcdFx0XHRpZiAoIWNvbmZpZy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdCBpbnN0YW5jZW9mIEppaS5iYXNlLkNvbXBvbmVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIG9iamVjdC5zZXQoa2V5LCBjb25maWdba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcblxyXG5cdFx0XHRcdC8vIEdlbmVyYXRlIHNldHRlciBuYW1lXHJcblx0XHRcdFx0dmFyIHNldHRlciA9ICdzZXQnICsgSmlpLl9zLmNhcGl0YWxpemUoa2V5KTtcclxuXHJcblx0XHRcdFx0aWYgKCFKaWkuXy5pc0Z1bmN0aW9uKG9iamVjdFtzZXR0ZXJdKSkge1xyXG5cdFx0XHRcdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W2tleV0pKSB7XHJcblx0XHRcdFx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkQ29uZmlnRXhjZXB0aW9uKCdZb3UgY2FuIG5vdCByZXBsYWNlIGZyb20gY29uZmlnIGZ1bmN0aW9uIGAnICsga2V5ICsgJ2AgaW4gb2JqZWN0IGAnICsgb2JqZWN0LmNsYXNzTmFtZSgpICsgJ2AuJyk7XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0aWYgKEppaS5fLmlzVW5kZWZpbmVkKG9iamVjdFtrZXldKSkge1xyXG5cdFx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbignQ29uZmlnIHBhcmFtIGAnICsga2V5ICsgJ2AgaXMgdW5kZWZpbmVkIGluIG9iamVjdCBgJyArIG9iamVjdC5jbGFzc05hbWUoKSArICdgLicpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0aWYgKCFKaWkuXy5pc1VuZGVmaW5lZChvYmplY3Rba2V5XSkgJiYgIUppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W2tleV0pICYmIEppaS5fLmlzRnVuY3Rpb24ob2JqZWN0W3NldHRlcl0pKSB7XHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbignWW91IGhhdmUgdHdvIHNldHRlcnMgKGZ1bmN0aW9uIGFuZCBwdWJsaWMgcGFyYW0pIGZvciBjb25maWcgcGFyYW0gYCcgKyBrZXkgKyAnYCBpbiBvYmplY3QgYCcgKyBvYmplY3QuY2xhc3NOYW1lKCkgKyAnYC4gIFBsZWFzZSBjaGFuZ2UgcGFyYW0gYWNjZXNzICh0byBgXycgKyBrZXkgKyAnYCkgb3IgcmVtb3ZlIHNldHRlciBtZXRob2QuJyk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoIUppaS5fLmlzVW5kZWZpbmVkKG9iamVjdFtrZXldKSAmJiAhSmlpLl8uaXNGdW5jdGlvbihvYmplY3Rba2V5XSkpIHtcclxuXHRcdFx0XHRcdGlmIChKaWkuXy5pc09iamVjdChvYmplY3Rba2V5XSkgJiYgSmlpLl8uaXNPYmplY3QoY29uZmlnW2tleV0pICYmICFKaWkuXy5pc0FycmF5KG9iamVjdFtrZXldKSAmJiAhSmlpLl8uaXNBcnJheShjb25maWdba2V5XSkpIHtcclxuXHRcdFx0XHRcdFx0b2JqZWN0W2tleV0gPSBKaWkubWVyZ2VDb25maWdzKG9iamVjdFtrZXldLCBjb25maWdba2V5XSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRvYmplY3Rba2V5XSA9IGNvbmZpZ1trZXldO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0gZWxzZSBpZiAoSmlpLl8uaXNGdW5jdGlvbihvYmplY3Rbc2V0dGVyXSkpIHtcclxuXHRcdFx0XHRcdG9iamVjdFtzZXR0ZXJdLmNhbGwob2JqZWN0LCBjb25maWdba2V5XSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTG9ncyBhIHRyYWNlIG1lc3NhZ2UuXHJcblx0XHQgKiBUcmFjZSBtZXNzYWdlcyBhcmUgbG9nZ2VkIG1haW5seSBmb3IgZGV2ZWxvcG1lbnQgcHVycG9zZSB0byBzZWVcclxuXHRcdCAqIHRoZSBleGVjdXRpb24gd29yayBmbG93IG9mIHNvbWUgY29kZS5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZC5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY2F0ZWdvcnldIHRoZSBjYXRlZ29yeSBvZiB0aGUgbWVzc2FnZS5cclxuXHRcdCAqL1xyXG5cdFx0dHJhY2U6IGZ1bmN0aW9uIChtZXNzYWdlLCBjYXRlZ29yeSkge1xyXG5cdFx0XHRjYXRlZ29yeSA9IGNhdGVnb3J5IHx8ICcnO1xyXG5cclxuXHRcdFx0Y29uc29sZS5sb2cobWVzc2FnZSk7XHJcblx0XHRcdC8vaWYgKFlJSV9ERUJVRykge1xyXG5cdFx0XHRcdC8vIEB0b2RvIHN0YXRpYy5nZXRMb2dnZXIoKS5sb2cobWVzc2FnZSwgTG9nZ2VyLkxFVkVMX1RSQUNFLCBjYXRlZ29yeSk7XHJcblx0XHRcdC8vfVxyXG5cdFx0fSxcclxuXHJcblx0XHQvKipcclxuXHRcdCAqIExvZ3MgYW4gZXJyb3IgbWVzc2FnZS5cclxuXHRcdCAqIEFuIGVycm9yIG1lc3NhZ2UgaXMgdHlwaWNhbGx5IGxvZ2dlZCB3aGVuIGFuIHVucmVjb3ZlcmFibGUgZXJyb3Igb2NjdXJzXHJcblx0XHQgKiBkdXJpbmcgdGhlIGV4ZWN1dGlvbiBvZiBhbiBhcHBsaWNhdGlvbi5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGJlIGxvZ2dlZC5cclxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBbY2F0ZWdvcnldIHRoZSBjYXRlZ29yeSBvZiB0aGUgbWVzc2FnZS5cclxuXHRcdCAqL1xyXG5cdFx0ZXJyb3I6IGZ1bmN0aW9uIChtZXNzYWdlLCBjYXRlZ29yeSkge1xyXG5cdFx0XHRjYXRlZ29yeSA9IGNhdGVnb3J5IHx8ICcnO1xyXG5cclxuXHRcdFx0Y29uc29sZS5lcnJvcihtZXNzYWdlKTtcclxuXHRcdFx0Ly8gQHRvZG8gc3RhdGljLmdldExvZ2dlcigpLmxvZyhtZXNzYWdlLCBMb2dnZXIuTEVWRUxfRVJST1IsIGNhdGVnb3J5KTtcclxuXHRcdH0sXHJcblxyXG5cdFx0LyoqXHJcblx0XHQgKiBMb2dzIGEgd2FybmluZyBtZXNzYWdlLlxyXG5cdFx0ICogQSB3YXJuaW5nIG1lc3NhZ2UgaXMgdHlwaWNhbGx5IGxvZ2dlZCB3aGVuIGFuIGVycm9yIG9jY3VycyB3aGlsZSB0aGUgZXhlY3V0aW9uXHJcblx0XHQgKiBjYW4gc3RpbGwgY29udGludWUuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWQuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG1lc3NhZ2UuXHJcblx0XHQgKi9cclxuXHRcdHdhcm5pbmc6IGZ1bmN0aW9uIChtZXNzYWdlLCBjYXRlZ29yeSkge1xyXG5cdFx0XHRjYXRlZ29yeSA9IGNhdGVnb3J5IHx8ICcnO1xyXG5cclxuXHRcdFx0Y29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG5cdFx0XHQvLyBAdG9kbyBzdGF0aWMuZ2V0TG9nZ2VyKCkubG9nKG1lc3NhZ2UsIExvZ2dlci5MRVZFTF9XQVJOSU5HLCBjYXRlZ29yeSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogTG9ncyBhbiBpbmZvcm1hdGl2ZSBtZXNzYWdlLlxyXG5cdFx0ICogQW4gaW5mb3JtYXRpdmUgbWVzc2FnZSBpcyB0eXBpY2FsbHkgbG9nZ2VkIGJ5IGFuIGFwcGxpY2F0aW9uIHRvIGtlZXAgcmVjb3JkIG9mXHJcblx0XHQgKiBzb21ldGhpbmcgaW1wb3J0YW50IChlLmcuIGFuIGFkbWluaXN0cmF0b3IgbG9ncyBpbikuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBiZSBsb2dnZWQuXHJcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gW2NhdGVnb3J5XSB0aGUgY2F0ZWdvcnkgb2YgdGhlIG1lc3NhZ2UuXHJcblx0XHQgKi9cclxuXHRcdGluZm86IGZ1bmN0aW9uIChtZXNzYWdlLCBjYXRlZ29yeSkge1xyXG5cdFx0XHRjYXRlZ29yeSA9IGNhdGVnb3J5IHx8ICcnO1xyXG5cclxuXHRcdFx0Y29uc29sZS5pbmZvKG1lc3NhZ2UpO1xyXG5cdFx0XHQvLyBAdG9kbyBzdGF0aWMuZ2V0TG9nZ2VyKCkubG9nKG1lc3NhZ2UsIExvZ2dlci5MRVZFTF9JTkZPLCBjYXRlZ29yeSk7XHJcblx0XHR9LFxyXG5cclxuXHRcdC8qKlxyXG5cdFx0ICogU2hvcnQgYWxpYXMgZm9yIHRyYW5zbGF0ZSB0ZXh0c1xyXG5cdFx0ICogQHBhcmFtIGdyb3VwXHJcblx0XHQgKiBAcGFyYW0gW21lc3NhZ2VdXHJcblx0XHQgKiBAcmV0dXJucyB7Kn1cclxuXHRcdCAqL1xyXG5cdFx0dDogZnVuY3Rpb24gKGdyb3VwLCBtZXNzYWdlKSB7XHJcblx0XHRcdC8vIEB0b2RvXHJcblx0XHRcdHJldHVybiBtZXNzYWdlO1xyXG5cdFx0fSxcclxuXHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdXHJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdXHJcbiAgICAgICAgICogQHJldHVybnMge29iamVjdH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBtZXJnZUNvbmZpZ3M6IGZ1bmN0aW9uKG9iaikge1xyXG4gICAgICAgICAgICB2YXIgZHN0ID0ge307XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgaWkgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgaWk7ICsraSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIG9iaiA9IGFyZ3VtZW50c1tpXTtcclxuICAgICAgICAgICAgICAgIGlmICghSmlpLl8uaXNPYmplY3Qob2JqKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEppaS5fLmlzT2JqZWN0KG9ialtrZXldKSAmJiAhSmlpLl8uaXNBcnJheShvYmpba2V5XSkgJiYgIUppaS5fLmlzRnVuY3Rpb24ob2JqW2tleV0pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IHRoaXMubWVyZ2VDb25maWdzKGRzdFtrZXldLCBvYmpba2V5XSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IG9ialtrZXldO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICByZXR1cm4gZHN0O1xyXG4gICAgICAgIH0sXHJcblxyXG4gICAgICAgIGNhdGNoSGFuZGxlcjogZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUuc3RhY2sgfHwgZSlcclxuICAgICAgICB9XHJcblx0fVxyXG5cclxufSk7XHJcblxyXG4vLyBAdG9kbyBNb3ZlIHRvIEVycm9ycyBtb2R1bGVcclxucHJvY2Vzcy5vbigndW5oYW5kbGVkUmVqZWN0aW9uJywgZnVuY3Rpb24ocmVhc29uLCBwcm9taXNlKSB7XHJcbiAgICBjb25zb2xlLndhcm4oXCJQb3NzaWJseSBVbmhhbmRsZWQgUmVqZWN0aW9uIGF0OiBQcm9taXNlIFwiLCBwcm9taXNlLCBcIiByZWFzb246IFwiLCByZWFzb24pO1xyXG59KTtcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIEppaVxyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBKaWk7XG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSxcIi8uLi8uLi8uLi9qaWkvbGliXCIpXG59LHtcIi4uL3BhY2thZ2UuanNvblwiOjE1NixcIl9wcm9jZXNzXCI6MzAsXCJuZWF0bmVzc1wiOjE1N31dLDEyNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4uL2Jhc2UvQXBwbGljYXRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmFwcGxpY2F0aW9uLldlYkFwcGxpY2F0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5BcHBsaWNhdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5hcHBsaWNhdGlvbi5XZWJBcHBsaWNhdGlvbicsIC8qKiBAbGVuZHMgSmlpLmFwcGxpY2F0aW9uLldlYkFwcGxpY2F0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkFwcGxpY2F0aW9uLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtzdHJpbmd8Ym9vbGVhbn0gdGhlIGxheW91dCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGZvciB2aWV3cyBpbiB0aGlzIGFwcGxpY2F0aW9uLiBEZWZhdWx0cyB0byAnbWFpbicuXG5cdCAqIElmIHRoaXMgaXMgZmFsc2UsIGxheW91dCB3aWxsIGJlIGRpc2FibGVkLlxuXHQgKi9cblx0bGF5b3V0OiAnbWFpbicsXG5cbiAgICBkZWZhdWx0Um91dGU6ICdzaXRlJyxcblxuXHRfcHJlSW5pdDogZnVuY3Rpb24oY29uZmlnKSB7XG5cdFx0dGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cblx0XHQvLyBTZXQgZGVmYXVsdCB3ZWJyb290XG5cdFx0dGhpcy5zZXRXZWJQYXRoKGNvbmZpZy53ZWJQYXRoIHx8IHRoaXMuZ2V0QmFzZVBhdGgoKSArICcvd2ViJyk7XG5cdFx0dGhpcy5zZXRXZWJVcmwoY29uZmlnLndlYlVybCB8fCAnLycpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcmV0dXJuIHtTdHJpbmd9XG5cdCAqL1xuXHRnZXRXZWJQYXRoOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEppaS5nZXRBbGlhcygnQHdlYnJvb3QnKTtcblx0fSxcblxuXHQvKipcblx0ICogQHBhcmFtICB7U3RyaW5nfSBwYXRoXG5cdCAqL1xuXHRzZXRXZWJQYXRoOiBmdW5jdGlvbiAocGF0aCkge1xuXHRcdEppaS5zZXRBbGlhcygnQHdlYnJvb3QnLCBwYXRoKTtcblx0fSxcblxuXHQvKipcblx0ICogQHJldHVybiB7U3RyaW5nfVxuXHQgKi9cblx0Z2V0V2ViVXJsOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIEppaS5nZXRBbGlhcygnQHdlYicpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGhcblx0ICovXG5cdHNldFdlYlVybDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHRKaWkuc2V0QWxpYXMoJ0B3ZWInLCBwYXRoKTtcblx0fVxuXG59KTtcbn0se1wiLi4vSmlpXCI6MTI1LFwiLi4vYmFzZS9BcHBsaWNhdGlvblwiOjEyOX1dLDEyNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL09iamVjdCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5BY3Rpb25cbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkFjdGlvbicsIC8qKiBAbGVuZHMgSmlpLmJhc2UuQWN0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHR5cGUge3N0cmluZ30gSUQgb2YgdGhlIGFjdGlvblxuXHQgKi9cblx0aWQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtKaWkuYmFzZS5Db250cm9sbGVyfSB0aGUgY29udHJvbGxlciB0aGF0IG93bnMgdGhpcyBhY3Rpb25cblx0ICovXG5cdGNvbnRyb2xsZXI6IG51bGwsXG5cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChpZCwgY29udHJvbGxlciwgY29uZmlnKSB7XG5cdFx0dGhpcy5pZCA9IGlkO1xuXHRcdHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG5cdFx0dGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHVuaXF1ZSBJRCBvZiB0aGlzIGFjdGlvbiBhbW9uZyB0aGUgd2hvbGUgYXBwbGljYXRpb24uXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSB1bmlxdWUgSUQgb2YgdGhpcyBhY3Rpb24gYW1vbmcgdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxuXHQgKi9cblx0Z2V0VW5pcXVlSWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5jb250cm9sbGVyLmdldFVuaXF1ZUlkKCkgKyAnLycgKyB0aGlzLmlkO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcblx0ICovXG5cdHJ1bjogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0fSxcblxuXHQvKipcblx0ICogUnVucyB0aGlzIGFjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgcGFyYW1ldGVycy5cblx0ICogVGhpcyBtZXRob2QgaXMgbWFpbmx5IGludm9rZWQgYnkgdGhlIGNvbnRyb2xsZXIuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuXHQgKiBAcmV0dXJucyB7UHJvbWlzZX0gdGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb259IGlmIHRoZSBhY3Rpb24gY2xhc3MgZG9lcyBub3QgaGF2ZSBhIHJ1bigpIG1ldGhvZFxuXHQgKi9cblx0cnVuV2l0aFBhcmFtczogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRpZiAoIUppaS5fLmlzRnVuY3Rpb24odGhpcy5ydW4pKSB7XG5cdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbih0aGlzLmRlYnVnQ2xhc3NOYW1lICsgJyBtdXN0IGRlZmluZSBhIGBydW4oKWAgbWV0aG9kLicpO1xuXHRcdH1cblxuXHRcdC8vWWlpOjp0cmFjZSgnUnVubmluZyBhY3Rpb246ICcgLiBnZXRfY2xhc3MoJHRoaXMpIC4gJzo6cnVuKCknLCBfX01FVEhPRF9fKTtcblxuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5iZWZvcmVSdW4oY29udGV4dCkpXG5cdFx0XHQudGhlbihKaWkuXy5iaW5kKGZ1bmN0aW9uIChib29sKSB7XG5cdFx0XHRcdGlmICghYm9vbCkge1xuXHRcdFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdCgpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRoaXMucnVuKGNvbnRleHQpO1xuXHRcdFx0fSwgdGhpcykpXG5cdFx0XHQudGhlbihKaWkuXy5iaW5kKGZ1bmN0aW9uIChyZXN1bHQpIHtcblx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLmFmdGVyUnVuKCkpLnRoZW4oZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIGBydW4oKWAgaXMgZXhlY3V0ZWQuXG5cdCAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZG8gcHJlcGFyYXRpb24gd29yayBmb3IgdGhlIGFjdGlvbiBydW4uXG5cdCAqIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSwgaXQgd2lsbCBjYW5jZWwgdGhlIGFjdGlvbi5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqIEByZXR1cm4ge1Byb21pc2V8Ym9vbGVhbn0gd2hldGhlciB0byBydW4gdGhlIGFjdGlvbi5cblx0ICovXG5cdGJlZm9yZVJ1bjogZnVuY3Rpb24gKGNvbnRleHQpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIGBydW4oKWAgaXMgZXhlY3V0ZWQuXG5cdCAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZG8gcG9zdC1wcm9jZXNzaW5nIHdvcmsgZm9yIHRoZSBhY3Rpb24gcnVuLlxuXHQgKi9cblx0YWZ0ZXJSdW46IGZ1bmN0aW9uICgpIHtcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL09iamVjdFwiOjEzOH1dLDEyODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vRXZlbnQnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQWN0aW9uRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuQWN0aW9uRXZlbnQnLCAvKiogQGxlbmRzIEppaS5iYXNlLkFjdGlvbkV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkV2ZW50LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLmJhc2UuQWN0aW9ufVxuXHQgKi9cblx0YWN0aW9uOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7SmlpLmJhc2UuQ29udGV4dH1cblx0ICovXG5cdGNvbnRleHQ6IG51bGxcblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9FdmVudFwiOjEzNH1dLDEyOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcclxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBKaWlcclxuICogQGlnbm9yZVxyXG4gKi9cclxudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xyXG5cclxucmVxdWlyZSgnLi9Nb2R1bGUnKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgSmlpLmJhc2UuQXBwbGljYXRpb25cclxuICogQGV4dGVuZHMgSmlpLmJhc2UuTW9kdWxlXHJcbiAqL1xyXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkFwcGxpY2F0aW9uJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5BcHBsaWNhdGlvbi5wcm90b3R5cGUgKi97XHJcblxyXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuTW9kdWxlLFxyXG5cclxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5BcHBsaWNhdGlvbiAqL3tcclxuXHJcblx0XHRFTlZJUk9OTUVOVF9QUk9EVUNUSU9OOiAncHJvZHVjdGlvbicsXHJcblx0XHRFTlZJUk9OTUVOVF9ERVZFTE9QTUVOVDogJ2RldmVsb3BtZW50JyxcclxuXHRcdEVOVklST05NRU5UX1RFU1Q6ICd0ZXN0J1xyXG5cclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgbmFtZXNwYWNlIHRoYXQgY29udHJvbGxlciBjbGFzc2VzIGFyZSBpbi4gSWYgbm90IHNldCxcclxuXHQgKiBpdCB3aWxsIHVzZSB0aGUgXCJhcHBcXGNvbnRyb2xsZXJzXCIgbmFtZXNwYWNlLlxyXG5cdCAqL1xyXG5cdGNvbnRyb2xsZXJOYW1lc3BhY2U6ICdhcHAuY29udHJvbGxlcnMnLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgYXBwbGljYXRpb24gbmFtZS5cclxuXHQgKi9cclxuXHRuYW1lOiAnTXkgQXBwbGljYXRpb24nLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgdmVyc2lvbiBvZiB0aGlzIGFwcGxpY2F0aW9uLlxyXG5cdCAqL1xyXG5cdHZlcnNpb246ICcxLjAnLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgY2hhcnNldCBjdXJyZW50bHkgdXNlZCBmb3IgdGhlIGFwcGxpY2F0aW9uLlxyXG5cdCAqL1xyXG5cdGNoYXJzZXQ6ICdVVEYtOCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtzdHJpbmd9IHRoZSBsYW5ndWFnZSB0aGF0IGlzIG1lYW50IHRvIGJlIHVzZWQgZm9yIGVuZCB1c2Vycy5cclxuXHQgKiBAc2VlIHNvdXJjZUxhbmd1YWdlXHJcblx0ICovXHJcblx0bGFuZ3VhZ2U6ICdlbicsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtzdHJpbmd9IHRoZSBsYW5ndWFnZSB0aGF0IHRoZSBhcHBsaWNhdGlvbiBpcyB3cml0dGVuIGluLiBUaGlzIG1haW5seSByZWZlcnMgdG9cclxuXHQgKiB0aGUgbGFuZ3VhZ2UgdGhhdCB0aGUgbWVzc2FnZXMgYW5kIHZpZXcgZmlsZXMgYXJlIHdyaXR0ZW4gaW4uXHJcblx0ICogQHNlZSBsYW5ndWFnZVxyXG5cdCAqL1xyXG5cdHNvdXJjZUxhbmd1YWdlOiAnZW4nLFxyXG5cclxuXHQvKipcclxuXHQgKiBUaGUgSURzIG9mIHRoZSBjb21wb25lbnRzIG9yIG1vZHVsZXMgdGhhdCBzaG91bGQgYmUgcHJlbG9hZGVkIHJpZ2h0IGFmdGVyIGluaXRpYWxpemF0aW9uLlxyXG5cdCAqIEB0eXBlIHtzdHJpbmdbXX1cclxuXHQgKi9cclxuXHRib290c3RyYXA6IG51bGwsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEB0eXBlIHtzdHJpbmd9XHJcblx0ICovXHJcblx0ZW52aXJvbm1lbnQ6ICdkZXZlbG9wbWVudCcsXHJcblxyXG5cdC8qKlxyXG5cdCAqIEBjb25zdHJ1Y3RzXHJcblx0ICovXHJcblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChjb25maWcpIHtcclxuXHRcdEppaS5hcHAgPSB0aGlzO1xyXG5cclxuXHRcdHRoaXMuYm9vdHN0cmFwID0gW107XHJcblxyXG5cdFx0Ly8gTWVyZ2Ugd2l0aCBkZWZhdWx0IGNvbmZpZ1xyXG5cdFx0Y29uZmlnID0gSmlpLm1lcmdlQ29uZmlncyh0aGlzLl9nZXRCYXNlQ29uZmlnKCksIGNvbmZpZyk7XHJcblxyXG5cdFx0dGhpcy5fcHJlSW5pdChjb25maWcpO1xyXG5cdFx0dGhpcy5fbG9hZEJvb3RzdHJhcENvbXBvbmVudHMoKTtcclxuXHJcblx0XHR0aGlzLl9fc3VwZXIobnVsbCwgbnVsbCwgY29uZmlnKTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEByZXR1cm5zIHtzdHJpbmd9XHJcblx0ICovXHJcblx0Z2V0VW5pcXVlSWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAnJztcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKiBTZXRzIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgYXBwbGljYXRpb24gYW5kIHRoZSBAYXBwIGFsaWFzLlxyXG5cdCAqIFRoaXMgbWV0aG9kIGNhbiBvbmx5IGJlIGludm9rZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY29uc3RydWN0b3IuXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IHBhdGggdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBhcHBsaWNhdGlvbi5cclxuXHQgKi9cclxuXHRzZXRCYXNlUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcclxuXHRcdHRoaXMuX19zdXBlcihwYXRoKTtcclxuXHRcdEppaS5zZXRBbGlhcygnQGFwcCcsIHRoaXMuZ2V0QmFzZVBhdGgoKSk7XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcndyaXRlIHRoaXMgbWV0aG9kIGZvciByZXR1cm4gZGVmYXVsdCBjb25maWd1cmF0aW9uIHNwZWNpZmllZCBmb3IgYXBwbGljYXRpb25cclxuXHQgKiBAdHlwZSB7b2JqZWN0fSBiYXNlIGFwcGxpY2F0aW9uJ3MgY29uZmlnLlxyXG5cdCAqL1xyXG5cdF9nZXRCYXNlQ29uZmlnOiBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7fTtcclxuXHR9LFxyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjb25maWdcclxuXHQgKiBAcHJpdmF0ZVxyXG5cdCAqL1xyXG5cdF9wcmVJbml0OiBmdW5jdGlvbiAoY29uZmlnKSB7XHJcblx0XHRpZiAoSmlpLl8uaGFzKGNvbmZpZywgJ2Jhc2VQYXRoJykpIHtcclxuXHRcdFx0dGhpcy5zZXRCYXNlUGF0aChjb25maWcuYmFzZVBhdGgpO1xyXG5cdFx0XHRkZWxldGUgY29uZmlnLmJhc2VQYXRoO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oJ1RoZSBgYmFzZVBhdGhgIGNvbmZpZ3VyYXRpb24gaXMgcmVxdWlyZWQuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0LyoqXHJcblx0ICogTG9hZHMgY29tcG9uZW50cyB0aGF0IGFyZSBkZWNsYXJlZCBpbiBbW2Jvb3RzdHJhcF1dLlxyXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb259IGlmIGEgY29tcG9uZW50IG9yIG1vZHVsZSB0byBiZSBwcmVsb2FkZWQgaXMgdW5rbm93blxyXG5cdCAqL1xyXG5cdF9sb2FkQm9vdHN0cmFwQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0SmlpLl8uZWFjaCh0aGlzLmJvb3RzdHJhcCwgSmlpLl8uYmluZChmdW5jdGlvbiAoaWQpIHtcclxuXHRcdFx0aWYgKHRoaXMuaGFzQ29tcG9uZW50KGlkKSkge1xyXG5cdFx0XHRcdHRoaXMuZ2V0Q29tcG9uZW50KGlkKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0aGlzLmhhc01vZHVsZShpZCkpIHtcclxuXHRcdFx0XHR0aGlzLmdldE1vZHVsZShpZCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb24oXCJVbmtub3duIGNvbXBvbmVudCBvciBtb2R1bGU6IFwiICsgaWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKSk7XHJcblx0fVxyXG59KTtcclxuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vTW9kdWxlXCI6MTM3fV0sMTMwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9PYmplY3QnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuQmVoYXZpb3JcbiAqIEBleHRlbmRzIEppaS5iYXNlLk9iamVjdFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkJlaGF2aW9yJywgLyoqIEBsZW5kcyBKaWkuYmFzZS5CZWhhdmlvci5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0LyoqXG5cdCAqIEB2YXIge0ppaS5iYXNlLkNvbXBvbmVudH0gdGhlIG93bmVyIG9mIHRoaXMgYmVoYXZpb3Jcblx0ICovXG5cdG93bmVyOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBEZWNsYXJlcyBldmVudCBoYW5kbGVycyBmb3IgdGhlIFtbb3duZXJdXSdzIGV2ZW50cy5cblx0ICpcblx0ICogQ2hpbGQgY2xhc3NlcyBtYXkgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gZGVjbGFyZSB3aGF0IGNhbGxiYWNrcyBzaG91bGRcblx0ICogYmUgYXR0YWNoZWQgdG8gdGhlIGV2ZW50cyBvZiB0aGUgW1tvd25lcl1dIGNvbXBvbmVudC5cblx0ICpcblx0ICogVGhlIGNhbGxiYWNrcyB3aWxsIGJlIGF0dGFjaGVkIHRvIHRoZSBbW293bmVyXV0ncyBldmVudHMgd2hlbiB0aGUgYmVoYXZpb3IgaXNcblx0ICogYXR0YWNoZWQgdG8gdGhlIG93bmVyOyBhbmQgdGhleSB3aWxsIGJlIGRldGFjaGVkIGZyb20gdGhlIGV2ZW50cyB3aGVuXG5cdCAqIHRoZSBiZWhhdmlvciBpcyBkZXRhY2hlZCBmcm9tIHRoZSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIFRoZSBjYWxsYmFja3MgY2FuIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nczpcblx0ICpcblx0ICogLSBtZXRob2QgaW4gdGhpcyBiZWhhdmlvcjogYCdoYW5kbGVDbGljaydgXG5cdCAqIC0gYW5vbnltb3VzIGZ1bmN0aW9uOiBgZnVuY3Rpb24gKGV2ZW50KSB7IC4uLiB9YFxuXHQgKiAtIG1ldGhvZCB3aXRoIGNvbnRleHQ6IGB7Y2FsbGJhY2s6IGZ1bmN0aW9uIChldmVudCkgeyAuLi4gfSwgY29udGV4dDogdGhpc31gXG5cdCAqXG5cdCAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZTpcblx0ICpcblx0ICogfn5+XG5cdCAqIHtcblx0ICogICAgIGJlZm9yZVZhbGlkYXRlOiAnbXlCZWZvcmVWYWxpZGF0ZScsXG5cdCAqICAgICBhZnRlclZhbGlkYXRlOiB7XG5cdCAqICAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uKCkge30sXG5cdCAqICAgICAgICAgY29udGV4dDogdGhpc1xuXHQgKiAgICAgfVxuXHQgKiB9XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IGV2ZW50cyAoYXJyYXkga2V5cykgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGV2ZW50IGhhbmRsZXIgbWV0aG9kcyAoYXJyYXkgdmFsdWVzKS5cblx0ICovXG5cdGV2ZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB7fTtcblx0fSxcblxuXHQvKipcblx0ICogQXR0YWNoZXMgdGhlIGJlaGF2aW9yIG9iamVjdCB0byB0aGUgY29tcG9uZW50LlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHNldCB0aGUgW1tvd25lcl1dIHByb3BlcnR5XG5cdCAqIGFuZCBhdHRhY2ggZXZlbnQgaGFuZGxlcnMgYXMgZGVjbGFyZWQgaW4gW1tldmVudHNdXS5cblx0ICogTWFrZSBzdXJlIHlvdSBjYWxsIHRoZSBwYXJlbnQgaW1wbGVtZW50YXRpb24gaWYgeW91IG92ZXJyaWRlIHRoaXMgbWV0aG9kLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbXBvbmVudH0gb3duZXIgdGhlIGNvbXBvbmVudCB0aGF0IHRoaXMgYmVoYXZpb3IgaXMgdG8gYmUgYXR0YWNoZWQgdG8uXG5cdCAqL1xuXHRhdHRhY2g6IGZ1bmN0aW9uIChvd25lcikge1xuXHRcdHRoaXMub3duZXIgPSBvd25lcjtcblxuXHRcdEppaS5fLmVhY2godGhpcy5ldmVudHMoKSwgSmlpLl8uYmluZChmdW5jdGlvbihoYW5kbGVyLCBldmVudCkge1xuXHRcdFx0aGFuZGxlciA9IEppaS5iYXNlLkV2ZW50Lm5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlciwgdGhpcyk7XG5cdFx0XHR0aGlzLm93bmVyLm9uKGV2ZW50LCBoYW5kbGVyKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERldGFjaGVzIHRoZSBiZWhhdmlvciBvYmplY3QgZnJvbSB0aGUgY29tcG9uZW50LlxuXHQgKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiB3aWxsIHVuc2V0IHRoZSBbW293bmVyXV0gcHJvcGVydHlcblx0ICogYW5kIGRldGFjaCBldmVudCBoYW5kbGVycyBkZWNsYXJlZCBpbiBbW2V2ZW50c11dLlxuXHQgKiBNYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBpZiB5b3Ugb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG5cdCAqL1xuXHRkZXRhY2g6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMub3duZXIpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRKaWkuXy5lYWNoKHRoaXMuZXZlbnRzKCksIEppaS5fLmJpbmQoZnVuY3Rpb24oaGFuZGxlciwgZXZlbnQpIHtcblx0XHRcdGhhbmRsZXIgPSBKaWkuYmFzZS5FdmVudC5ub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIsIHRoaXMpO1xuXHRcdFx0dGhpcy5vd25lci5vZmYoZXZlbnQsIGhhbmRsZXIpO1xuXHRcdH0sIHRoaXMpKTtcblx0XHR0aGlzLm93bmVyID0gbnVsbDtcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL09iamVjdFwiOjEzOH1dLDEzMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vT2JqZWN0Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkNvbXBvbmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuQ29tcG9uZW50JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5Db21wb25lbnQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtvYmplY3R9IHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVycyAoZXZlbnQgbmFtZTogaGFuZGxlcnMpXG5cdCAqL1xuXHRfZXZlbnRzOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHtvYmplY3R9IHRoZSBhdHRhY2hlZCBiZWhhdmlvcnMgKGJlaGF2aW9yIG5hbWU6IGJlaGF2aW9yKVxuXHQgKi9cblx0X2JlaGF2aW9yczogbnVsbCxcblxuXHQvKipcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIFByb3h5IGJlaGF2aW91ciBtZXRob2RzXG5cdFx0dGhpcy5wcm94eUJlaGF2aW9ycygpO1xuXG5cdFx0dGhpcy5fX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgYSBsaXN0IG9mIGJlaGF2aW9ycyB0aGF0IHRoaXMgY29tcG9uZW50IHNob3VsZCBiZWhhdmUgYXMuXG5cdCAqXG5cdCAqIENoaWxkIGNsYXNzZXMgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHNwZWNpZnkgdGhlIGJlaGF2aW9ycyB0aGV5IHdhbnQgdG8gYmVoYXZlIGFzLlxuXHQgKlxuXHQgKiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgbWV0aG9kIHNob3VsZCBiZSBhbiBhcnJheSBvZiBiZWhhdmlvciBvYmplY3RzIG9yIGNvbmZpZ3VyYXRpb25zXG5cdCAqIGluZGV4ZWQgYnkgYmVoYXZpb3IgbmFtZXMuIEEgYmVoYXZpb3IgY29uZmlndXJhdGlvbiBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIHNwZWNpZnlpbmdcblx0ICogdGhlIGJlaGF2aW9yIGNsYXNzIG9yIGFuIGFycmF5IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXHQgKlxuXHQgKiB+fn5cblx0ICogYmVoYXZpb3JOYW1lOiB7XG5cdCAqICAgICBjbGFzczogJ0JlaGF2aW9yQ2xhc3MnLFxuXHQgKiAgICAgcHJvcGVydHkxOiAndmFsdWUxJyxcblx0ICogICAgIHByb3BlcnR5MjogJ3ZhbHVlMidcblx0ICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogTm90ZSB0aGF0IGEgYmVoYXZpb3IgY2xhc3MgbXVzdCBleHRlbmQgZnJvbSBbW0ppaS5iYXNlLkJlaGF2aW9yXV0uIEJlaGF2aW9yIG5hbWVzIGNhbiBiZSBzdHJpbmdzXG5cdCAqIG9yIGludGVnZXJzLiBJZiB0aGUgZm9ybWVyLCB0aGV5IHVuaXF1ZWx5IGlkZW50aWZ5IHRoZSBiZWhhdmlvcnMuIElmIHRoZSBsYXR0ZXIsIHRoZSBjb3JyZXNwb25kaW5nXG5cdCAqIGJlaGF2aW9ycyBhcmUgYW5vbnltb3VzIGFuZCB0aGVpciBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHdpbGwgTk9UIGJlIG1hZGUgYXZhaWxhYmxlIHZpYSB0aGUgY29tcG9uZW50XG5cdCAqIChob3dldmVyLCB0aGUgYmVoYXZpb3JzIGNhbiBzdGlsbCByZXNwb25kIHRvIHRoZSBjb21wb25lbnQncyBldmVudHMpLlxuXHQgKlxuXHQgKiBCZWhhdmlvcnMgZGVjbGFyZWQgaW4gdGhpcyBtZXRob2Qgd2lsbCBiZSBhdHRhY2hlZCB0byB0aGUgY29tcG9uZW50IGF1dG9tYXRpY2FsbHkgKG9uIGRlbWFuZCkuXG5cdCAqXG5cdCAqIEByZXR1cm4ge29iamVjdH0gdGhlIGJlaGF2aW9yIGNvbmZpZ3VyYXRpb25zLlxuXHQgKi9cblx0YmVoYXZpb3JzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGFueSBoYW5kbGVyIGF0dGFjaGVkIHRvIHRoZSBuYW1lZCBldmVudC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGV2ZW50IG5hbWVcblx0ICogQHJldHVybiB7Ym9vbGVhbn0gd2hldGhlciB0aGVyZSBpcyBhbnkgaGFuZGxlciBhdHRhY2hlZCB0byB0aGUgZXZlbnQuXG5cdCAqL1xuXHRoYXNFdmVudEhhbmRsZXJzOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cblx0XHRyZXR1cm4gdGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1tuYW1lXSAmJiB0aGlzLl9ldmVudHNbbmFtZV0ubGVuZ3RoID4gMCA/IHRydWUgOiBmYWxzZTsvLyBAdG9kbyB8fCBFdmVudDo6aGFzSGFuZGxlcnModGhpcywgbmFtZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYW4gZXZlbnQuXG5cdCAqXG5cdCAqIFRoZSBldmVudCBoYW5kbGVyIG11c3QgYmUgYSB2YWxpZCBQSFAgY2FsbGJhY2suIFRoZSBmb2xsb3dpbmdzIGFyZVxuXHQgKiBzb21lIGV4YW1wbGVzOlxuXHQgKlxuXHQgKiB+fn5cblx0ICogZnVuY3Rpb24gKGV2ZW50KSB7IC4uLiB9ICAgICAgICAgLy8gYW5vbnltb3VzIGZ1bmN0aW9uXG5cdCAqIH5+flxuXHQgKlxuXHQgKiBUaGUgZXZlbnQgaGFuZGxlciBtdXN0IGJlIGRlZmluZWQgd2l0aCB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZSxcblx0ICpcblx0ICogfn5+XG5cdCAqIGZ1bmN0aW9uIChldmVudClcblx0ICogfn5+XG5cdCAqXG5cdCAqIHdoZXJlIGBldmVudGAgaXMgYW4gW1tKaWkuYmFzZS5FdmVudF1dIG9iamVjdCB3aGljaCBpbmNsdWRlcyBwYXJhbWV0ZXJzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lIHRoZSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7ZnVuY3Rpb259IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXJcblx0ICogQHBhcmFtIHsqfSBbZGF0YV0gdGhlIGRhdGEgdG8gYmUgcGFzc2VkIHRvIHRoZSBldmVudCBoYW5kbGVyIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cblx0ICogV2hlbiB0aGUgZXZlbnQgaGFuZGxlciBpcyBpbnZva2VkLCB0aGlzIGRhdGEgY2FuIGJlIGFjY2Vzc2VkIHZpYSBkYXRhLlxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0FwcGVuZF0gd2hldGhlciB0byBhcHBlbmQgbmV3IGV2ZW50IGhhbmRsZXIgdG8gdGhlIGVuZCBvZiB0aGUgZXhpc3Rpbmdcblx0ICogaGFuZGxlciBsaXN0LiBJZiBmYWxzZSwgdGhlIG5ldyBoYW5kbGVyIHdpbGwgYmUgaW5zZXJ0ZWQgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgZXhpc3Rpbmdcblx0ICogaGFuZGxlciBsaXN0LlxuXHQgKiBAc2VlIG9mZigpXG5cdCAqL1xuXHRvbjogZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKSB7XG5cdFx0ZGF0YSA9IGRhdGEgfHwgbnVsbDtcblx0XHRpc0FwcGVuZCA9IEppaS5fLmlzVW5kZWZpbmVkKGlzQXBwZW5kKSA/IHRydWUgOiBpc0FwcGVuZDtcblxuICAgICAgICAvLyBNdWx0aXBsZSBuYW1lcyBzdXBwb3J0XG4gICAgICAgIG5hbWUgPSB0aGlzLl9ub3JtYWxpemVFdmVudE5hbWVzKG5hbWUpO1xuICAgICAgICBpZiAobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKG4sIGhhbmRsZXIsIGRhdGEsIGlzQXBwZW5kKVxuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5hbWUgPSBuYW1lWzBdO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblx0XHRpZiAoaXNBcHBlbmQgfHwgIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW25hbWVdKSB7XG5cdFx0XHR0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG5cdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0gPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwgW107XG5cdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0ucHVzaChbaGFuZGxlciwgZGF0YV0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0udW5zaGlmdChbaGFuZGxlciwgZGF0YV0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogRGV0YWNoZXMgYW4gZXhpc3RpbmcgZXZlbnQgaGFuZGxlciBmcm9tIHRoaXMgY29tcG9uZW50LlxuXHQgKiBUaGlzIG1ldGhvZCBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tvbigpXV0uXG5cdCAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBuYW1lIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIHtmdW5jdGlvbn0gW2hhbmRsZXJdIHRoZSBldmVudCBoYW5kbGVyIHRvIGJlIHJlbW92ZWQuXG5cdCAqIElmIGl0IGlzIG51bGwsIGFsbCBoYW5kbGVycyBhdHRhY2hlZCB0byB0aGUgbmFtZWQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxuXHQgKiBAcmV0dXJuIGJvb2xlYW4gaWYgYSBoYW5kbGVyIGlzIGZvdW5kIGFuZCBkZXRhY2hlZFxuXHQgKiBAc2VlIG9uKClcblx0ICovXG5cdG9mZjogZnVuY3Rpb24gKG5hbWUsIGhhbmRsZXIpIHtcblx0XHRoYW5kbGVyID0gaGFuZGxlciB8fCBudWxsO1xuXG4gICAgICAgIC8vIE11bHRpcGxlIG5hbWVzIHN1cHBvcnRcbiAgICAgICAgbmFtZSA9IHRoaXMuX25vcm1hbGl6ZUV2ZW50TmFtZXMobmFtZSk7XG4gICAgICAgIGlmIChuYW1lLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBib29sID0gZmFsc2U7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vbihuLCBoYW5kbGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBib29sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgcmV0dXJuIGJvb2w7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuYW1lID0gbmFtZVswXTtcbiAgICAgICAgfVxuXG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblx0XHRpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW25hbWVdKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKGhhbmRsZXIgPT09IG51bGwpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV07XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR2YXIgbmV3RXZlbnRzID0gW107XG5cdFx0dmFyIGlzUmVtb3ZlZCA9IGZhbHNlO1xuXHRcdEppaS5fLmVhY2godGhpcy5fZXZlbnRzW25hbWVdLCBmdW5jdGlvbihldmVudCwgaSkge1xuICAgICAgICAgICAgaWYgKEppaS5fLmlzT2JqZWN0KGhhbmRsZXIpICYmIEppaS5fLmhhcyhoYW5kbGVyLCAnY29udGV4dCcpICYmIEppaS5fLmlzRnVuY3Rpb24oaGFuZGxlci5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuY2FsbGJhY2sgIT09IGhhbmRsZXIuY2FsbGJhY2sgfHwgZXZlbnQuY29udGV4dCAhPT0gaGFuZGxlci5jb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LmNhbGxiYWNrICE9PSBoYW5kbGVyLmNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0V2ZW50cy5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpc1JlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblx0XHR0aGlzLl9ldmVudHNbbmFtZV0gPSBuZXdFdmVudHM7XG5cblx0XHRyZXR1cm4gaXNSZW1vdmVkO1xuXHR9LFxuXG4gICAgX25vcm1hbGl6ZUV2ZW50TmFtZXM6IGZ1bmN0aW9uKG5hbWVzKSB7XG4gICAgICAgIHJldHVybiBKaWkuXy5pc1N0cmluZyhuYW1lcykgP1xuICAgICAgICAgICAgbmFtZXMuc3BsaXQoL1sgLF0rLykgOlxuICAgICAgICAgICAgbmFtZXM7XG4gICAgfSxcblxuXHQvKipcblx0ICogVHJpZ2dlcnMgYW4gZXZlbnQuXG5cdCAqIFRoaXMgbWV0aG9kIHJlcHJlc2VudHMgdGhlIGhhcHBlbmluZyBvZiBhbiBldmVudC4gSXQgaW52b2tlc1xuXHQgKiBhbGwgYXR0YWNoZWQgaGFuZGxlcnMgZm9yIHRoZSBldmVudCBpbmNsdWRpbmcgY2xhc3MtbGV2ZWwgaGFuZGxlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBldmVudCBuYW1lXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuRXZlbnR9IFtldmVudF0gdGhlIGV2ZW50IHBhcmFtZXRlci4gSWYgbm90IHNldCwgYSBkZWZhdWx0IFtbSmlpLmJhc2UuRXZlbnRdXSBvYmplY3Qgd2lsbCBiZSBjcmVhdGVkLlxuXHQgKi9cblx0dHJpZ2dlcjogZnVuY3Rpb24gKG5hbWUsIGV2ZW50KSB7XG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblx0XHRpZiAodGhpcy5fZXZlbnRzICYmIHRoaXMuX2V2ZW50c1tuYW1lXSkge1xuXHRcdFx0aWYgKGV2ZW50ID09PSBudWxsKSB7XG5cdFx0XHRcdGV2ZW50ID0gbmV3IEppaS5iYXNlLkV2ZW50KCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIShldmVudCBpbnN0YW5jZW9mIEppaS5iYXNlLkV2ZW50KSkge1xuXHRcdFx0XHRldmVudCA9IG5ldyBKaWkuYmFzZS5FdmVudCh7XG5cdFx0XHRcdFx0cGFyYW1zOiBldmVudFxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGV2ZW50LnNlbmRlciA9PT0gbnVsbCkge1xuXHRcdFx0XHRldmVudC5zZW5kZXIgPSB0aGlzO1xuXHRcdFx0fVxuXG5cdFx0XHRldmVudC5oYW5kbGVkID0gZmFsc2U7XG5cdFx0XHRldmVudC5uYW1lID0gbmFtZTtcblxuXHRcdFx0dmFyIGlzU3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0SmlpLl8uZWFjaCh0aGlzLl9ldmVudHNbbmFtZV0sIGZ1bmN0aW9uKGhhbmRsZXIpIHtcblx0XHRcdFx0aWYgKGlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGV2ZW50LmRhdGEgPSBoYW5kbGVyWzFdO1xuXHRcdFx0XHRoYW5kbGVyWzBdID0gSmlpLmJhc2UuRXZlbnQubm9ybWFsaXplSGFuZGxlcihoYW5kbGVyWzBdKTtcblx0XHRcdFx0aGFuZGxlclswXS5jYWxsYmFjay5jYWxsKGhhbmRsZXJbMF0uY29udGV4dCwgZXZlbnQpO1xuXG5cdFx0XHRcdC8vIHN0b3AgZnVydGhlciBoYW5kbGluZyBpZiB0aGUgZXZlbnQgaXMgaGFuZGxlZFxuXHRcdFx0XHRpZiAoZXZlbnQuaGFuZGxlZCkge1xuXHRcdFx0XHRcdGlzU3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdC8vIGludm9rZSBjbGFzcy1sZXZlbCBhdHRhY2hlZCBoYW5kbGVyc1xuXHRcdEppaS5iYXNlLkV2ZW50LnRyaWdnZXIodGhpcywgbmFtZSwgZXZlbnQpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lZCBiZWhhdmlvciBvYmplY3QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBiZWhhdmlvciBuYW1lXG5cdCAqIEByZXR1cm4ge0ppaS5iYXNlLkJlaGF2aW9yfSB0aGUgYmVoYXZpb3Igb2JqZWN0LCBvciBudWxsIGlmIHRoZSBiZWhhdmlvciBkb2VzIG5vdCBleGlzdFxuXHQgKi9cblx0Z2V0QmVoYXZpb3I6IGZ1bmN0aW9uIChuYW1lKSB7XG5cdFx0dGhpcy5lbnN1cmVCZWhhdmlvcnMoKTtcblxuXHRcdHJldHVybiB0aGlzLl9iZWhhdmlvcnMgJiYgdGhpcy5fYmVoYXZpb3JzW25hbWVdID8gdGhpcy5fYmVoYXZpb3JzW25hbWVdIDogbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyBhbGwgYmVoYXZpb3JzIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50LlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IGxpc3Qgb2YgYmVoYXZpb3JzIGF0dGFjaGVkIHRvIHRoaXMgY29tcG9uZW50XG5cdCAqL1xuXHRnZXRCZWhhdmlvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2JlaGF2aW9ycztcblx0fSxcblxuXHQvKipcblx0ICogQXR0YWNoZXMgYSBiZWhhdmlvciB0byB0aGlzIGNvbXBvbmVudC5cblx0ICogVGhpcyBtZXRob2Qgd2lsbCBjcmVhdGUgdGhlIGJlaGF2aW9yIG9iamVjdCBiYXNlZCBvbiB0aGUgZ2l2ZW5cblx0ICogY29uZmlndXJhdGlvbi4gQWZ0ZXIgdGhhdCwgdGhlIGJlaGF2aW9yIG9iamVjdCB3aWxsIGJlIGF0dGFjaGVkIHRvXG5cdCAqIHRoaXMgY29tcG9uZW50IGJ5IGNhbGxpbmcgdGhlIGF0dGFjaCBtZXRob2QuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBiZWhhdmlvci5cblx0ICogQHBhcmFtIHtzdHJpbmd8SmlpLmJhc2UuQmVoYXZpb3JbXXxKaWkuYmFzZS5CZWhhdmlvcn0gYmVoYXZpb3IgdGhlIGJlaGF2aW9yIGNvbmZpZ3VyYXRpb24uIFRoaXMgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuXHQgKlxuXHQgKiAgLSBhIFtbSmlpLmJhc2UuQmVoYXZpb3JdXSBvYmplY3Rcblx0ICogIC0gYSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgYmVoYXZpb3IgY2xhc3Ncblx0ICogIC0gYW4gb2JqZWN0IGNvbmZpZ3VyYXRpb24gYXJyYXkgdGhhdCB3aWxsIGJlIHBhc3NlZCB0byBbW0ppaS5jcmVhdGVPYmplY3QoKV1dIHRvIGNyZWF0ZSB0aGUgYmVoYXZpb3Igb2JqZWN0LlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5CZWhhdmlvcn0gdGhlIGJlaGF2aW9yIG9iamVjdFxuXHQgKiBAc2VlIGRldGFjaEJlaGF2aW9yKClcblx0ICovXG5cdGF0dGFjaEJlaGF2aW9yOiBmdW5jdGlvbiAobmFtZSwgYmVoYXZpb3IpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXG5cdFx0cmV0dXJuIHRoaXMuX2F0dGFjaEJlaGF2aW9ySW50ZXJuYWwobmFtZSwgYmVoYXZpb3IpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBdHRhY2hlcyBhIGxpc3Qgb2YgYmVoYXZpb3JzIHRvIHRoZSBjb21wb25lbnQuXG5cdCAqIEVhY2ggYmVoYXZpb3IgaXMgaW5kZXhlZCBieSBpdHMgbmFtZSBhbmQgc2hvdWxkIGJlIGEgW1tKaWkuYmFzZS5CZWhhdmlvcl1dIG9iamVjdCxcblx0ICogYSBzdHJpbmcgc3BlY2lmeWluZyB0aGUgYmVoYXZpb3IgY2xhc3MsIG9yIGFuIGNvbmZpZ3VyYXRpb24gYXJyYXkgZm9yIGNyZWF0aW5nIHRoZSBiZWhhdmlvci5cblx0ICogQHBhcmFtIHtbXX0gYmVoYXZpb3JzIGxpc3Qgb2YgYmVoYXZpb3JzIHRvIGJlIGF0dGFjaGVkIHRvIHRoZSBjb21wb25lbnRcblx0ICogQHNlZSBhdHRhY2hCZWhhdmlvcigpXG5cdCAqL1xuXHRhdHRhY2hCZWhhdmlvcnM6IGZ1bmN0aW9uIChiZWhhdmlvcnMpIHtcblx0XHR0aGlzLmVuc3VyZUJlaGF2aW9ycygpO1xuXG5cdFx0SmlpLl8uZWFjaChiZWhhdmlvcnMsIEppaS5fLmJpbmQoZnVuY3Rpb24oYmVoYXZpb3IsIG5hbWUpIHtcblx0XHRcdHRoaXMuX2F0dGFjaEJlaGF2aW9ySW50ZXJuYWwobmFtZSwgYmVoYXZpb3IpO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogRGV0YWNoZXMgYSBiZWhhdmlvciBmcm9tIHRoZSBjb21wb25lbnQuXG5cdCAqIFRoZSBiZWhhdmlvcidzIGRldGFjaCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgYmVoYXZpb3IncyBuYW1lLlxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5CZWhhdmlvcn0gdGhlIGRldGFjaGVkIGJlaGF2aW9yLiBOdWxsIGlmIHRoZSBiZWhhdmlvciBkb2VzIG5vdCBleGlzdC5cblx0ICovXG5cdGRldGFjaEJlaGF2aW9yOiBmdW5jdGlvbiAobmFtZSkge1xuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cdFx0aWYgKHRoaXMuX2JlaGF2aW9ycyAmJiB0aGlzLl9iZWhhdmlvcnNbbmFtZV0pIHtcblx0XHRcdHZhciBiZWhhdmlvciA9IHRoaXMuX2JlaGF2aW9yc1tuYW1lXTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9iZWhhdmlvcnNbbmFtZV07XG5cdFx0XHRiZWhhdmlvci5kZXRhY2goKTtcblxuXHRcdFx0cmV0dXJuIGJlaGF2aW9yO1xuXHRcdH1cblxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEZXRhY2hlcyBhbGwgYmVoYXZpb3JzIGZyb20gdGhlIGNvbXBvbmVudC5cblx0ICovXG5cdGRldGFjaEJlaGF2aW9yczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuZW5zdXJlQmVoYXZpb3JzKCk7XG5cblx0XHRKaWkuXy5lYWNoKEppaS5fLmtleXModGhpcy5fYmVoYXZpb3JzKSwgSmlpLl8uYmluZCh0aGlzLmRldGFjaEJlaGF2aW9yLCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1ha2VzIHN1cmUgdGhhdCB0aGUgYmVoYXZpb3JzIGRlY2xhcmVkIGluIFtbYmVoYXZpb3JzKCldXSBhcmUgYXR0YWNoZWQgdG8gdGhpcyBjb21wb25lbnQuXG5cdCAqL1xuXHRlbnN1cmVCZWhhdmlvcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fYmVoYXZpb3JzICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fYmVoYXZpb3JzID0gW107XG5cdFx0SmlpLl8uZWFjaCh0aGlzLmJlaGF2aW9ycygpLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKGJlaGF2aW9yLCBuYW1lKSB7XG5cdFx0XHR0aGlzLl9hdHRhY2hCZWhhdmlvckludGVybmFsKG5hbWUsIGJlaGF2aW9yKTtcblx0XHR9LCB0aGlzKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqXG5cdCAqL1xuXHRwcm94eUJlaGF2aW9yczogZnVuY3Rpb24gKCkge1xuXHRcdEppaS5fLmVhY2godGhpcy5iZWhhdmlvcnMoKSwgSmlpLl8uYmluZChmdW5jdGlvbihiZWhhdmlvciwgbmFtZSkge1xuXHRcdFx0dmFyIGNsYXNzTmFtZSA9IEppaS5fLmlzU3RyaW5nKGJlaGF2aW9yKSA/IGJlaGF2aW9yIDogYmVoYXZpb3IuY2xhc3NOYW1lO1xuXHRcdFx0dGhpcy5fcHJveHlCZWhhdmlvckludGVybmFsKG5hbWUsIGNsYXNzTmFtZSk7XG5cdFx0fSwgdGhpcykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBBdHRhY2hlcyBhIGJlaGF2aW9yIHRvIHRoaXMgY29tcG9uZW50LlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgYmVoYXZpb3IuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfEppaS5iYXNlLkJlaGF2aW9yW118SmlpLmJhc2UuQmVoYXZpb3J9IGJlaGF2aW9yIHRoZSBiZWhhdmlvciB0byBiZSBhdHRhY2hlZFxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5CZWhhdmlvcn0gdGhlIGF0dGFjaGVkIGJlaGF2aW9yLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0X2F0dGFjaEJlaGF2aW9ySW50ZXJuYWw6IGZ1bmN0aW9uIChuYW1lLCBiZWhhdmlvcikge1xuXHRcdGlmICghKGJlaGF2aW9yIGluc3RhbmNlb2YgSmlpLmJhc2UuQmVoYXZpb3IpKSB7XG5cdFx0XHRiZWhhdmlvciA9IEppaS5jcmVhdGVPYmplY3QoYmVoYXZpb3IpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9iZWhhdmlvcnNbbmFtZV0pIHtcblx0XHRcdHRoaXMuX2JlaGF2aW9yc1tuYW1lXS5kZXRhY2goKTtcblx0XHR9XG5cdFx0YmVoYXZpb3IuYXR0YWNoKHRoaXMpO1xuXG5cdFx0dGhpcy5fcHJveHlCZWhhdmlvckludGVybmFsKG5hbWUsIGJlaGF2aW9yLmNsYXNzTmFtZSgpKTtcblxuXHRcdHRoaXMuX2JlaGF2aW9yc1tuYW1lXSA9IGJlaGF2aW9yO1xuXHRcdHJldHVybiBiZWhhdmlvcjtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICovXG5cdF9wcm94eUJlaGF2aW9ySW50ZXJuYWw6IGZ1bmN0aW9uIChiZWhhdmlvck5hbWUsIGNsYXNzTmFtZSkge1xuXHRcdHZhciBiZWhhdmlvckNsYXNzID0gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuXG5cdFx0d2hpbGUgKHRydWUpIHtcblx0XHRcdGlmICghYmVoYXZpb3JDbGFzcyB8fCAhYmVoYXZpb3JDbGFzcy5wcm90b3R5cGUgfHwgY2xhc3NOYW1lID09PSAnSmlpLmJhc2UuQmVoYXZpb3InKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIGJlaGF2aW9yQ2xhc3MucHJvdG90eXBlKSB7XG5cdFx0XHRcdGlmICghYmVoYXZpb3JDbGFzcy5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNraXAgY29uc3RydWN0b3IgYW5kIG5vbi1wdWJsaWMgbWV0aG9kc1xuXHRcdFx0XHRpZiAobmFtZSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBuYW1lLnN1YnN0cigwLCAxKSA9PT0gJ18nKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTa2lwIHByb3BlcnRpZXNcblx0XHRcdFx0aWYgKCFKaWkuXy5pc0Z1bmN0aW9uKGJlaGF2aW9yQ2xhc3MucHJvdG90eXBlW25hbWVdKSkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dGhpc1tuYW1lXSA9IHRoaXMuX2dldFByb3h5QmVoYXZpb3JNZXRob2QoYmVoYXZpb3JOYW1lLCBuYW1lKTtcblx0XHRcdH1cblxuXHRcdFx0Y2xhc3NOYW1lID0gYmVoYXZpb3JDbGFzcy5wYXJlbnRDbGFzc05hbWUoKTtcblx0XHRcdGJlaGF2aW9yQ2xhc3MgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRQcm94eUJlaGF2aW9yTWV0aG9kOiBmdW5jdGlvbihiZWhhdmlvck5hbWUsIG1ldGhvZE5hbWUpIHtcblx0XHR2YXIgY29udGV4dCA9IHRoaXM7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRCZWhhdmlvcihiZWhhdmlvck5hbWUpW21ldGhvZE5hbWVdLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0fSxcblxuXHRoYXNQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgY2hlY2tWYXJzLCBjaGVja0JlaGF2aW9ycykge1xuXHRcdGNoZWNrVmFycyA9IGNoZWNrVmFycyAhPT0gZmFsc2U7XG5cdFx0Y2hlY2tCZWhhdmlvcnMgPSBjaGVja0JlaGF2aW9ycyAhPT0gZmFsc2U7XG5cblx0XHRyZXR1cm4gdGhpcy5jYW5HZXRQcm9wZXJ0eShuYW1lLCBjaGVja1ZhcnMsIGNoZWNrQmVoYXZpb3JzKSB8fCB0aGlzLmNhblNldFByb3BlcnR5KG5hbWUsIGZhbHNlLCBjaGVja0JlaGF2aW9ycyk7XG5cdH0sXG5cblx0Ly8gQHRvZG8gbW92ZSBnZXQsIHNldCB0byBPYmplY3Rcblx0c2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICAvLyBPYmplY3QgZm9ybWF0IHN1cHBvcnRcbiAgICAgICAgaWYgKEppaS5fLmlzT2JqZWN0KG5hbWUpKSB7XG4gICAgICAgICAgICBKaWkuXy5lYWNoKG5hbWUsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG5cdFx0Ly8gR2VuZXJhdGUgc2V0dGVyIG5hbWVcblx0XHR2YXIgc2V0dGVyID0gJ3NldCcgKyBKaWkuX3MuY2FwaXRhbGl6ZShuYW1lKTtcblxuXHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKHRoaXNbc2V0dGVyXSkpIHtcblx0XHRcdHRoaXNbc2V0dGVyXS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHR9IGVsc2UgaWYgKHRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcblx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHR9IGVsc2UgaWYgKG5hbWUuc3Vic3RyKDAsIDMpID09PSAnb24gJykge1xuICAgICAgICAgICAgdGhpcy5vbihuYW1lLnN1YnN0cigzKSwgdmFsdWUpO1xuXHRcdH0gZWxzZSBpZiAobmFtZS5zdWJzdHIoMCwgMykgPT09ICdhcyAnKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEJlaGF2aW9yKG5hbWUuc3Vic3RyKDMpLCB2YWx1ZSBpbnN0YW5jZW9mIEppaS5iYXNlLkJlaGF2aW9yID8gdmFsdWUgOiBKaWkuY3JlYXRlT2JqZWN0KHZhbHVlKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIEB0b2RvIGFzLCBzZWUgQ29tcG9uZW50IFlpaTJcblxuXHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLlVua25vd25Qcm9wZXJ0eUV4Y2VwdGlvbignU2V0dGluZyB1bmtub3duIHByb3BlcnR5OiAnICsgdGhpcy5jbGFzc05hbWUoKSArICcuJyArIG5hbWUpO1xuXHRcdH1cblx0fSxcblxuXHRjYW5TZXRQcm9wZXJ0eTogZnVuY3Rpb24obmFtZSwgY2hlY2tWYXJzLCBjaGVja0JlaGF2aW9ycykge1xuXHRcdGNoZWNrVmFycyA9IGNoZWNrVmFycyAhPT0gZmFsc2U7XG5cdFx0Y2hlY2tCZWhhdmlvcnMgPSBjaGVja0JlaGF2aW9ycyAhPT0gZmFsc2U7XG5cblx0XHR2YXIgc2V0dGVyID0gJ3NldCcgKyBKaWkuX3MuY2FwaXRhbGl6ZShuYW1lKTtcblx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbih0aGlzW3NldHRlcl0pIHx8IChjaGVja1ZhcnMgJiYgdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoY2hlY2tCZWhhdmlvcnMpIHtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHQvLyBHZW5lcmF0ZSBnZXR0ZXIgbmFtZVxuXHRcdHZhciBzZXR0ZXIgPSAnZ2V0JyArIEppaS5fcy5jYXBpdGFsaXplKG5hbWUpO1xuXG5cdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1tzZXR0ZXJdKSkge1xuXHRcdFx0cmV0dXJuIHRoaXNbc2V0dGVyXS5jYWxsKHRoaXMpO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRocm93IG5ldyBKaWkuZXhjZXB0aW9ucy5Vbmtub3duUHJvcGVydHlFeGNlcHRpb24oJ0dldHRpbmcgdW5rbm93biBwcm9wZXJ0eTogJyArIHRoaXMuY2xhc3NOYW1lKCkgKyAnLicgKyBuYW1lKTtcblx0XHR9XG5cdH0sXG5cblx0Y2FuR2V0UHJvcGVydHk6IGZ1bmN0aW9uKG5hbWUsIGNoZWNrVmFycywgY2hlY2tCZWhhdmlvcnMpIHtcblx0XHRjaGVja1ZhcnMgPSBjaGVja1ZhcnMgIT09IGZhbHNlO1xuXHRcdGNoZWNrQmVoYXZpb3JzID0gY2hlY2tCZWhhdmlvcnMgIT09IGZhbHNlO1xuXG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgSmlpLl9zLmNhcGl0YWxpemUoa2V5KTtcblx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbih0aGlzW2dldHRlcl0pIHx8IChjaGVja1ZhcnMgJiYgdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoY2hlY2tCZWhhdmlvcnMpIHtcblxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL09iamVjdFwiOjEzOH1dLDEzMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQ29tcG9uZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkNvbnRleHRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkNvbnRleHQnLCAvKiogQGxlbmRzIEppaS5iYXNlLkNvbnRleHQucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG5cdC8qKlxuXHQgKiBDdXN0b20gY29udGV4dCBwYXJhbWV0ZXJzIChuYW1lID0+IHZhbHVlKS5cblx0ICogQHR5cGUge29iamVjdH1cblx0ICovXG5cdHBhcmFtczoge30sXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtvYmplY3R9XG5cdCAqL1xuXHRfY29tcG9uZW50czoge30sXG5cblx0LyoqXG5cdCAqIENoZWNrcyB3aGV0aGVyIHRoZSBuYW1lZCBjb21wb25lbnQgZXhpc3RzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgY29tcG9uZW50IElEXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG5hbWVkIGNvbXBvbmVudCBleGlzdHMuIEJvdGggbG9hZGVkIGFuZCB1bmxvYWRlZCBjb21wb25lbnRzXG5cdCAqIGFyZSBjb25zaWRlcmVkLlxuXHQgKi9cblx0aGFzQ29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHRoaXMuX2NvbXBvbmVudHMsIGlkKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0cmlldmVzIHRoZSBuYW1lZCBjb21wb25lbnQuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBjb21wb25lbnQgSUQgKGNhc2Utc2Vuc2l0aXZlKVxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5Db21wb25lbnR8bnVsbH0gdGhlIGNvbXBvbmVudCBpbnN0YW5jZSwgbnVsbCBpZiB0aGUgY29tcG9uZW50IGRvZXMgbm90IGV4aXN0LlxuXHQgKi9cblx0Z2V0Q29tcG9uZW50OiBmdW5jdGlvbiAoaWQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpZF0gfHwgbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmVnaXN0ZXJzIGEgY29tcG9uZW50IHdpdGggdGhpcyBtb2R1bGUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBjb21wb25lbnQgSURcblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db21wb25lbnR8YXJyYXl8bnVsbH0gY29tcG9uZW50IHRoZSBjb21wb25lbnQgdG8gYmUgcmVnaXN0ZXJlZCB3aXRoIHRoZSBtb2R1bGUuIFRoaXMgY2FuXG5cdCAqIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nczpcblx0ICpcblx0ICogLSBhIFtbSmlpLmJhc2UuQ29tcG9uZW50XV0gb2JqZWN0XG5cdCAqIC0gYSBjb25maWd1cmF0aW9uIGFycmF5OiB3aGVuIFtbZ2V0Q29tcG9uZW50KCldXSBpcyBjYWxsZWQgaW5pdGlhbGx5IGZvciB0aGlzIGNvbXBvbmVudCwgdGhlIGFycmF5XG5cdCAqICAgd2lsbCBiZSB1c2VkIHRvIGluc3RhbnRpYXRlIHRoZSBjb21wb25lbnQgdmlhIFtbSmlpLmNyZWF0ZU9iamVjdCgpXV0uXG5cdCAqIC0gbnVsbDogdGhlIG5hbWVkIGNvbXBvbmVudCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgbW9kdWxlXG5cdCAqL1xuXHRzZXRDb21wb25lbnQ6IGZ1bmN0aW9uIChpZCwgY29tcG9uZW50KSB7XG5cdFx0aWYgKGNvbXBvbmVudCA9PT0gbnVsbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbXBvbmVudHNbaWRdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBDcmVhdGUgY29tcG9uZW50IGluc3RhbmNlXG5cdFx0XHRpZiAoIShjb21wb25lbnQgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db21wb25lbnQpKSB7XG5cdFx0XHRcdGNvbXBvbmVudCA9IEppaS5jcmVhdGVPYmplY3QoY29tcG9uZW50KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGxpbmtzXG5cdFx0XHR0aGlzW2lkXSA9IHRoaXMuX2NvbXBvbmVudHNbaWRdID0gY29tcG9uZW50O1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgcmVnaXN0ZXJlZCBjb21wb25lbnRzLlxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5Db21wb25lbnRbXX0gdGhlIGNvbXBvbmVudHMgKGluZGV4ZWQgYnkgdGhlaXIgSURzKVxuXHQgKi9cblx0Z2V0Q29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb21wb25lbnRzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgYSBzZXQgb2YgY29tcG9uZW50cyBpbiB0aGlzIG1vZHVsZS5cblx0ICpcblx0ICogRWFjaCBjb21wb25lbnQgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIG5hbWUtdmFsdWUgcGFpciwgd2hlcmVcblx0ICogbmFtZSByZWZlcnMgdG8gdGhlIElEIG9mIHRoZSBjb21wb25lbnQgYW5kIHZhbHVlIHRoZSBjb21wb25lbnQgb3IgYSBjb25maWd1cmF0aW9uXG5cdCAqIGFycmF5IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQuIEluIHRoZSBsYXR0ZXIgY2FzZSwgW1tKaWkuY3JlYXRlT2JqZWN0KCldXVxuXHQgKiB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBjb21wb25lbnQuXG5cdCAqXG5cdCAqIElmIGEgbmV3IGNvbXBvbmVudCBoYXMgdGhlIHNhbWUgSUQgYXMgYW4gZXhpc3Rpbmcgb25lLCB0aGUgZXhpc3Rpbmcgb25lIHdpbGwgYmUgb3ZlcndyaXR0ZW4gc2lsZW50bHkuXG5cdCAqXG5cdCAqIFRoZSBmb2xsb3dpbmcgaXMgYW4gZXhhbXBsZSBmb3Igc2V0dGluZyB0d28gY29tcG9uZW50czpcblx0ICpcblx0ICogfn5+XG5cdCAqIHtcbiAgICAgKiAgICAgZGI6IHtcbiAgICAgKiAgICAgICAgIGNsYXNzOiAnSmlpLmRiLkNvbm5lY3Rpb24nLFxuICAgICAqICAgICAgICAgZHNuOiAnc3FsaXRlOnBhdGgvdG8vZmlsZS5kYidcbiAgICAgKiAgICAgfSxcbiAgICAgKiAgICAgY2FjaGU6IHtcbiAgICAgKiAgICAgICAgIGNsYXNzOiAnSmlpLmNhY2hpbmcuRGJDYWNoZScsXG4gICAgICogICAgICAgICBkYjogJ2RiJ1xuICAgICAqICAgICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHthcnJheX0gY29tcG9uZW50cyBjb21wb25lbnRzIChpZCA9PiBjb21wb25lbnQgY29uZmlndXJhdGlvbiBvciBpbnN0YW5jZSlcblx0ICovXG5cdHNldENvbXBvbmVudHM6IGZ1bmN0aW9uIChjb21wb25lbnRzKSB7XG5cdFx0SmlpLl8uZWFjaChjb21wb25lbnRzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uIChjb21wb25lbnQsIGlkKSB7XG5cdFx0XHQvLyBFeHRlbmQgZGVmYXVsdCBjbGFzcyBuYW1lXG5cdFx0XHRpZiAoIShjb21wb25lbnQgaW5zdGFuY2VvZiBKaWkuYmFzZS5Db21wb25lbnQpICYmIHRoaXMuX2NvbXBvbmVudHNbaWRdICYmICFjb21wb25lbnQuY2xhc3NOYW1lKSB7XG5cdFx0XHRcdGNvbXBvbmVudC5jbGFzc05hbWUgPSB0aGlzLl9jb21wb25lbnRzW2lkXS5jbGFzc05hbWU7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuc2V0Q29tcG9uZW50KGlkLCBjb21wb25lbnQpO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogTG9hZHMgY29tcG9uZW50cyB0aGF0IGFyZSBkZWNsYXJlZCBpbiBbW3ByZWxvYWRdXS5cblx0ICogQHRocm93cyB7SmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbn0gaWYgYSBjb21wb25lbnQgb3IgbW9kdWxlIHRvIGJlIHByZWxvYWRlZCBpcyB1bmtub3duXG5cdCAqL1xuXHRwcmVsb2FkQ29tcG9uZW50czogZnVuY3Rpb24gKCkge1xuXHRcdEppaS5fLmVhY2godGhpcy5wcmVsb2FkLCBKaWkuXy5iaW5kKGZ1bmN0aW9uIChpZCkge1xuXHRcdFx0aWYgKHRoaXMuaGFzQ29tcG9uZW50KGlkKSkge1xuXHRcdFx0XHR0aGlzLmdldENvbXBvbmVudChpZCk7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuaGFzTW9kdWxlKGlkKSkge1xuXHRcdFx0XHR0aGlzLmdldE1vZHVsZShpZCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbihcIlVua25vd24gY29tcG9uZW50IG9yIG1vZHVsZTogXCIgKyBpZCk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcykpO1xuXHR9XG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vQ29tcG9uZW50XCI6MTMxfV0sMTMzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vT2JqZWN0Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLkNvbnRyb2xsZXJcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLkNvbnRyb2xsZXInLCAvKiogQGxlbmRzIEppaS5iYXNlLkNvbnRyb2xsZXIucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG4gICAgX19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmJhc2UuQ29udHJvbGxlciAqL3tcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLk1vZHVsZSNiZWZvcmVBY3Rpb25cbiAgICAgICAgICogQHByb3BlcnR5IHtKaWkuYmFzZS5BY3Rpb25FdmVudH0gZXZlbnRcbiAgICAgICAgICovXG4gICAgICAgIEVWRU5UX0JFRk9SRV9BQ1RJT046ICdiZWZvcmVBY3Rpb24nLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAZXZlbnQgSmlpLmJhc2UuTW9kdWxlI2FmdGVyQWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLmJhc2UuQWN0aW9uRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9BRlRFUl9BQ1RJT046ICdhZnRlckFjdGlvbidcblxuICAgIH0sXG5cblx0LyoqXG5cdCAqIEB0eXBlIHtzdHJpbmd9IFRoZSBJRCBvZiB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqL1xuXHRpZDogbnVsbCxcblxuXHQvKipcblx0ICogQHR5cGUge0ppaS5iYXNlLk1vZHVsZX0gVGhlIG1vZHVsZSB0aGF0IHRoaXMgY29udHJvbGxlciBiZWxvbmdzIHRvLlxuXHQgKi9cblx0bW9kdWxlOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfSBUaGUgSUQgb2YgdGhlIGFjdGlvbiB0aGF0IGlzIHVzZWQgd2hlbiB0aGUgYWN0aW9uIElEIGlzIG5vdCBzcGVjaWZpZWRcblx0ICogaW4gdGhlIHJlcXVlc3QuIERlZmF1bHRzIHRvICdpbmRleCcuXG5cdCAqL1xuXHRkZWZhdWx0QWN0aW9uOiAnaW5kZXgnLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfGJvb2xlYW59IHRoZSBuYW1lIG9mIHRoZSBsYXlvdXQgdG8gYmUgYXBwbGllZCB0byB0aGlzIGNvbnRyb2xsZXIncyB2aWV3cy5cblx0ICogVGhpcyBwcm9wZXJ0eSBtYWlubHkgYWZmZWN0cyB0aGUgYmVoYXZpb3Igb2YgW1tyZW5kZXIoKV1dLlxuXHQgKiBEZWZhdWx0cyB0byBudWxsLCBtZWFuaW5nIHRoZSBhY3R1YWwgbGF5b3V0IHZhbHVlIHNob3VsZCBpbmhlcml0IHRoYXQgZnJvbSBbW21vZHVsZV1dJ3MgbGF5b3V0IHZhbHVlLlxuXHQgKiBJZiBmYWxzZSwgbm8gbGF5b3V0IHdpbGwgYmUgYXBwbGllZC5cblx0ICovXG5cdGxheW91dDogbnVsbCxcblxuXHQvKipcblx0ICogVGhlIHZpZXcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIHZpZXdzIG9yIHZpZXcgZmlsZXMuXG5cdCAqIEB0eXBlIHtKaWkudmlldy5WaWV3fVxuXHQgKi9cblx0X3ZpZXc6IG51bGwsXG5cblx0LyoqXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKi9cblx0Y29uc3RydWN0b3I6IGZ1bmN0aW9uIChpZCwgbW9kdWxlT2JqZWN0LCBjb25maWcpIHtcblx0XHR0aGlzLmlkID0gaWQ7XG5cdFx0dGhpcy5tb2R1bGUgPSBtb2R1bGVPYmplY3Q7XG5cdFx0dGhpcy5fX3N1cGVyKGNvbmZpZyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIERlY2xhcmVzIGV4dGVybmFsIGFjdGlvbnMgZm9yIHRoZSBjb250cm9sbGVyLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBtZWFudCB0byBiZSBvdmVyd3JpdHRlbiB0byBkZWNsYXJlIGV4dGVybmFsIGFjdGlvbnMgZm9yIHRoZSBjb250cm9sbGVyLlxuXHQgKiBJdCBzaG91bGQgcmV0dXJuIGFuIGFycmF5LCB3aXRoIGFycmF5IGtleXMgYmVpbmcgYWN0aW9uIElEcywgYW5kIGFycmF5IHZhbHVlcyB0aGUgY29ycmVzcG9uZGluZ1xuXHQgKiBhY3Rpb24gY2xhc3MgbmFtZXMgb3IgYWN0aW9uIGNvbmZpZ3VyYXRpb24gYXJyYXlzLiBGb3IgZXhhbXBsZSxcblx0ICpcblx0ICogfn5+XG5cdCAqIHJldHVybiB7XG4gICAgICogICAgICdhY3Rpb24xJzogJ2FwcC5jb21wb25lbnRzLkFjdGlvbjEnLFxuICAgICAqICAgICAnYWN0aW9uMic6IHtcbiAgICAgKiAgICAgICAgICdjbGFzc05hbWUnOiAnYXBwLmNvbXBvbmVudHMuQWN0aW9uMicsXG4gICAgICogICAgICAgICAncHJvcGVydHkxJzogJ3ZhbHVlMScsXG4gICAgICogICAgICAgICAncHJvcGVydHkyJzogJ3ZhbHVlMidcbiAgICAgKiAgICAgfVxuICAgICAqIH07XG5cdCAqIH5+flxuXHQgKlxuXHQgKiBbW0ppaS5jcmVhdGVPYmplY3QoKV1dIHdpbGwgYmUgdXNlZCBsYXRlciB0byBjcmVhdGUgdGhlIHJlcXVlc3RlZCBhY3Rpb25cblx0ICogdXNpbmcgdGhlIGNvbmZpZ3VyYXRpb24gcHJvdmlkZWQgaGVyZS5cblx0ICogQHJldHVybnMge29iamVjdH1cblx0ICovXG5cdGFjdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4ge307XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1bnMgYSByZXF1ZXN0IHNwZWNpZmllZCBpbiB0ZXJtcyBvZiBhIHJvdXRlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcm91dGUgdGhlIHJvdXRlIHRvIGJlIGhhbmRsZWQsIGUuZy4sICd2aWV3JywgJ2NvbW1lbnQvdmlldycsICdhZG1pbi9jb21tZW50L3ZpZXcnLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcblx0ICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdHJ1bjogZnVuY3Rpb24gKHJvdXRlLCBjb250ZXh0KSB7XG5cdFx0dmFyIHNsYXNoSW5kZXggPSByb3V0ZS5pbmRleE9mKCcvJyk7XG5cdFx0aWYgKHNsYXNoSW5kZXggPT09IC0xKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5ydW5BY3Rpb24ocm91dGUsIGNvbnRleHQpO1xuXHRcdH0gZWxzZSBpZiAoc2xhc2hJbmRleCA+IDApIHtcblx0XHRcdHJldHVybiB0aGlzLm1vZHVsZS5ydW5BY3Rpb24ocm91dGUsIGNvbnRleHQpO1xuXHRcdH1cblxuXHRcdHJvdXRlID0gSmlpLl9zLmx0cmltKHJvdXRlLCAnLycpO1xuXHRcdHJldHVybiBKaWkuYXBwLnJ1bkFjdGlvbihyb3V0ZSwgY29udGV4dCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJ1bnMgYW4gYWN0aW9uIHdpdGhpbiB0aGlzIGNvbnRyb2xsZXIgd2l0aCB0aGUgc3BlY2lmaWVkIGFjdGlvbiBJRCBhbmQgcGFyYW1ldGVycy5cblx0ICogSWYgdGhlIGFjdGlvbiBJRCBpcyBlbXB0eSwgdGhlIG1ldGhvZCB3aWxsIHVzZSBbW2RlZmF1bHRBY3Rpb25dXS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgYWN0aW9uIHRvIGJlIGV4ZWN1dGVkLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcblx0ICogQHJldHVybiB7UHJvbWlzZX0gVGhlIHJlc3VsdCBvZiB0aGUgYWN0aW9uLlxuXHQgKiBAdGhyb3dzIHtKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUm91dGVFeGNlcHRpb259IGlmIHRoZSByZXF1ZXN0ZWQgYWN0aW9uIElEIGNhbm5vdCBiZSByZXNvbHZlZCBpbnRvIGFuIGFjdGlvbiBzdWNjZXNzZnVsbHkuXG5cdCAqL1xuXHRydW5BY3Rpb246IGZ1bmN0aW9uIChpZCwgY29udGV4dCkge1xuXHRcdHZhciBhY3Rpb24gPSB0aGlzLmNyZWF0ZUFjdGlvbihpZCk7XG5cdFx0aWYgKGFjdGlvbiA9PT0gbnVsbCkge1xuXHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvbihKaWkudCgnamlpJywgJ1VuYWJsZSB0byByZXNvbHZlIHRoZSByZXF1ZXN0OiAnICsgdGhpcy5nZXRVbmlxdWVJZCgpICsgJy8nICsgaWQpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoW1xuXHRcdFx0XHR0aGlzLm1vZHVsZS5iZWZvcmVBY3Rpb24oYWN0aW9uLCBjb250ZXh0KSxcblx0XHRcdFx0dGhpcy5iZWZvcmVBY3Rpb24oYWN0aW9uLCBjb250ZXh0KVxuXHRcdFx0XSkudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuXHRcdFx0XHRpZiAocmVzdWx0cy5pbmRleE9mKGZhbHNlKSAhPT0gLTEpIHtcblx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcblx0XHRcdFx0fVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhY3Rpb24ucnVuV2l0aFBhcmFtcyhjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFKaWkuXy5pc1VuZGVmaW5lZChkYXRhKSAmJiBjb250ZXh0LnJlc3BvbnNlIGluc3RhbmNlb2YgSmlpLmJhc2UuUmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2UuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2R1bGUuYWZ0ZXJBY3Rpb24oYWN0aW9uLCBjb250ZXh0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWZ0ZXJBY3Rpb24oYWN0aW9uLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICAgICBdKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRleHQucmVzcG9uc2UgaW5zdGFuY2VvZiBKaWkuYmFzZS5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2Uuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpLmNhdGNoKEppaS5jYXRjaEhhbmRsZXIpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFjdGlvbiBiYXNlZCBvbiB0aGUgZ2l2ZW4gYWN0aW9uIElELlxuXHQgKiBUaGUgbWV0aG9kIGZpcnN0IGNoZWNrcyBpZiB0aGUgYWN0aW9uIElEIGhhcyBiZWVuIGRlY2xhcmVkIGluIFtbYWN0aW9ucygpXV0uIElmIHNvLFxuXHQgKiBpdCB3aWxsIHVzZSB0aGUgY29uZmlndXJhdGlvbiBkZWNsYXJlZCB0aGVyZSB0byBjcmVhdGUgdGhlIGFjdGlvbiBvYmplY3QuXG5cdCAqIElmIG5vdCwgaXQgd2lsbCBsb29rIGZvciBhIGNvbnRyb2xsZXIgbWV0aG9kIHdob3NlIG5hbWUgaXMgaW4gdGhlIGZvcm1hdCBvZiBgYWN0aW9uWHl6YFxuXHQgKiB3aGVyZSBgWHl6YCBzdGFuZHMgZm9yIHRoZSBhY3Rpb24gSUQuIElmIGZvdW5kLCBhbiBbW0lubGluZUFjdGlvbl1dIHJlcHJlc2VudGluZyB0aGF0XG5cdCAqIG1ldGhvZCB3aWxsIGJlIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgdGhlIGFjdGlvbiBJRC5cblx0ICogQHJldHVybiB7SmlpLmJhc2UuQWN0aW9ufSB0aGUgbmV3bHkgY3JlYXRlZCBhY3Rpb24gaW5zdGFuY2UuIE51bGwgaWYgdGhlIElEIGRvZXNuJ3QgcmVzb2x2ZSBpbnRvIGFueSBhY3Rpb24uXG5cdCAqL1xuXHRjcmVhdGVBY3Rpb246IGZ1bmN0aW9uIChpZCkge1xuXHRcdGlmIChpZCA9PT0gJycpIHtcblx0XHRcdGlkID0gdGhpcy5kZWZhdWx0QWN0aW9uO1xuXHRcdH1cblxuXHRcdHZhciBhY3Rpb25NYXAgPSB0aGlzLmFjdGlvbnMoKTtcblx0XHRpZiAoSmlpLl8uaGFzKGFjdGlvbk1hcCwgaWQpKSB7XG5cdFx0XHRyZXR1cm4gSmlpLmNyZWF0ZU9iamVjdChhY3Rpb25NYXBbaWRdLCBpZCwgdGhpcyk7XG5cdFx0fSBlbHNlIGlmICgvXlthLXowLTlcXFxcLV9dKyQvLnRlc3QoaWQpKSB7XG5cdFx0XHR2YXIgbWV0aG9kID0gJ2FjdGlvbicgKyAoJy0nICsgaWQpLnJlcGxhY2UoLy0oW2Etel0pL2csIGZ1bmN0aW9uKG0sIHYpIHsgcmV0dXJuIHYudG9VcHBlckNhc2UoKTsgfSlcblxuXHRcdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24odGhpc1ttZXRob2RdKSkge1xuXHRcdFx0XHRyZXR1cm4gbmV3IEppaS5yZXF1ZXN0LklubGluZUFjdGlvbihpZCwgdGhpcywgbWV0aG9kKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRoYXNBY3Rpb246IGZ1bmN0aW9uKGlkKSB7XG5cdFx0aWYgKGlkID09PSAnJykge1xuXHRcdFx0aWQgPSB0aGlzLmRlZmF1bHRBY3Rpb247XG5cdFx0fVxuXG5cdFx0dmFyIGFjdGlvbk1hcCA9IHRoaXMuYWN0aW9ucygpO1xuXHRcdGlmIChKaWkuXy5oYXMoYWN0aW9uTWFwLCBpZCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAoL15bYS16MC05XFxcXC1fXSskLy50ZXN0KGlkKSkge1xuXHRcdFx0dmFyIG1ldGhvZCA9IGlkLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgaWQuc2xpY2UoMSk7XG5cdFx0XHRtZXRob2QgPSAnYWN0aW9uJyArIG1ldGhvZC5yZXBsYWNlKCctJywgJyAnKTtcblxuXHRcdFx0cmV0dXJuIEppaS5fLmlzRnVuY3Rpb24odGhpc1ttZXRob2RdKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEByZXR1cm4gc3RyaW5nIHRoZSBjb250cm9sbGVyIElEIHRoYXQgaXMgcHJlZml4ZWQgd2l0aCB0aGUgbW9kdWxlIElEIChpZiBhbnkpLlxuXHQgKi9cblx0Z2V0VW5pcXVlSWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5tb2R1bGUgaW5zdGFuY2VvZiBKaWkuYmFzZS5BcHBsaWNhdGlvbiA/IHRoaXMuaWQgOiB0aGlzLm1vZHVsZS5nZXRVbmlxdWVJZCgpICsgJy8nICsgdGhpcy5pZDtcblx0fSxcblxuXHQvKipcblx0ICogVGhpcyBtZXRob2QgaXMgaW52b2tlZCByaWdodCBiZWZvcmUgYW4gYWN0aW9uIGlzIHRvIGJlIGV4ZWN1dGVkIChhZnRlciBhbGwgcG9zc2libGUgZmlsdGVycykuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aW9ufSBhY3Rpb25cbiAgICAgKiBAcGFyYW0ge0ppaS5iYXNlLkNvbnRleHR9IGNvbnRleHRcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuXHQgKi9cblx0YmVmb3JlQWN0aW9uOiBmdW5jdGlvbiAoYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0JFRk9SRV9BQ1RJT04sIG5ldyBKaWkuYmFzZS5BY3Rpb25FdmVudCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSkpO1xuXHRcdHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgcmlnaHQgYWZ0ZXIgYW4gYWN0aW9uIGlzIGV4ZWN1dGVkLlxuXHQgKiBAcGFyYW0ge0ppaS5iYXNlLkFjdGlvbn0gYWN0aW9uXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRhZnRlckFjdGlvbjogZnVuY3Rpb24gKGFjdGlvbiwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyaWdnZXIodGhpcy5fX3N0YXRpYy5FVkVOVF9BRlRFUl9BQ1RJT04sIG5ldyBKaWkuYmFzZS5BY3Rpb25FdmVudCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgYSB2aWV3IGFuZCBhcHBsaWVzIGxheW91dCBpZiBhdmFpbGFibGUuXG5cdCAqXG5cdCAqIFRoZSB2aWV3IHRvIGJlIHJlbmRlcmVkIGNhbiBiZSBzcGVjaWZpZWQgaW4gb25lIG9mIHRoZSBmb2xsb3dpbmcgZm9ybWF0czpcblx0ICpcblx0ICogLSBwYXRoIGFsaWFzIChlLmcuIFwiQGFwcC92aWV3cy9zaXRlL2luZGV4XCIpO1xuXHQgKiAtIGFic29sdXRlIHBhdGggd2l0aGluIGFwcGxpY2F0aW9uIChlLmcuIFwiLy9zaXRlL2luZGV4XCIpOiB0aGUgdmlldyBuYW1lIHN0YXJ0cyB3aXRoIGRvdWJsZSBzbGFzaGVzLlxuXHQgKiAgIFRoZSBhY3R1YWwgdmlldyBmaWxlIHdpbGwgYmUgbG9va2VkIGZvciB1bmRlciB0aGUgW1tBcHBsaWNhdGlvbjo6dmlld1BhdGh8dmlldyBwYXRoXV0gb2YgdGhlIGFwcGxpY2F0aW9uLlxuXHQgKiAtIGFic29sdXRlIHBhdGggd2l0aGluIG1vZHVsZSAoZS5nLiBcIi9zaXRlL2luZGV4XCIpOiB0aGUgdmlldyBuYW1lIHN0YXJ0cyB3aXRoIGEgc2luZ2xlIHNsYXNoLlxuXHQgKiAgIFRoZSBhY3R1YWwgdmlldyBmaWxlIHdpbGwgYmUgbG9va2VkIGZvciB1bmRlciB0aGUgW1tNb2R1bGU6OnZpZXdQYXRofHZpZXcgcGF0aF1dIG9mIFtbbW9kdWxlXV0uXG5cdCAqIC0gcmVsYXRpdmUgcGF0aCAoZS5nLiBcImluZGV4XCIpOiB0aGUgYWN0dWFsIHZpZXcgZmlsZSB3aWxsIGJlIGxvb2tlZCBmb3IgdW5kZXIgW1t2aWV3UGF0aF1dLlxuXHQgKlxuXHQgKiBUbyBkZXRlcm1pbmUgd2hpY2ggbGF5b3V0IHNob3VsZCBiZSBhcHBsaWVkLCB0aGUgZm9sbG93aW5nIHR3byBzdGVwcyBhcmUgY29uZHVjdGVkOlxuXHQgKlxuXHQgKiAxLiBJbiB0aGUgZmlyc3Qgc3RlcCwgaXQgZGV0ZXJtaW5lcyB0aGUgbGF5b3V0IG5hbWUgYW5kIHRoZSBjb250ZXh0IG1vZHVsZTpcblx0ICpcblx0ICogLSBJZiBbW2xheW91dF1dIGlzIHNwZWNpZmllZCBhcyBhIHN0cmluZywgdXNlIGl0IGFzIHRoZSBsYXlvdXQgbmFtZSBhbmQgW1ttb2R1bGVdXSBhcyB0aGUgY29udGV4dCBtb2R1bGU7XG5cdCAqIC0gSWYgW1tsYXlvdXRdXSBpcyBudWxsLCBzZWFyY2ggdGhyb3VnaCBhbGwgYW5jZXN0b3IgbW9kdWxlcyBvZiB0aGlzIGNvbnRyb2xsZXIgYW5kIGZpbmQgdGhlIGZpcnN0XG5cdCAqICAgbW9kdWxlIHdob3NlIFtbTW9kdWxlOjpsYXlvdXR8bGF5b3V0XV0gaXMgbm90IG51bGwuIFRoZSBsYXlvdXQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIG1vZHVsZVxuXHQgKiAgIGFyZSB1c2VkIGFzIHRoZSBsYXlvdXQgbmFtZSBhbmQgdGhlIGNvbnRleHQgbW9kdWxlLCByZXNwZWN0aXZlbHkuIElmIHN1Y2ggYSBtb2R1bGUgaXMgbm90IGZvdW5kXG5cdCAqICAgb3IgdGhlIGNvcnJlc3BvbmRpbmcgbGF5b3V0IGlzIG5vdCBhIHN0cmluZywgaXQgd2lsbCByZXR1cm4gZmFsc2UsIG1lYW5pbmcgbm8gYXBwbGljYWJsZSBsYXlvdXQuXG5cdCAqXG5cdCAqIDIuIEluIHRoZSBzZWNvbmQgc3RlcCwgaXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIGxheW91dCBmaWxlIGFjY29yZGluZyB0byB0aGUgcHJldmlvdXNseSBmb3VuZCBsYXlvdXQgbmFtZVxuXHQgKiAgICBhbmQgY29udGV4dCBtb2R1bGUuIFRoZSBsYXlvdXQgbmFtZSBjYW4gYmU6XG5cdCAqXG5cdCAqIC0gYSBwYXRoIGFsaWFzIChlLmcuIFwiQGFwcC92aWV3cy9sYXlvdXRzL21haW5cIik7XG5cdCAqIC0gYW4gYWJzb2x1dGUgcGF0aCAoZS5nLiBcIi9tYWluXCIpOiB0aGUgbGF5b3V0IG5hbWUgc3RhcnRzIHdpdGggYSBzbGFzaC4gVGhlIGFjdHVhbCBsYXlvdXQgZmlsZSB3aWxsIGJlXG5cdCAqICAgbG9va2VkIGZvciB1bmRlciB0aGUgW1tBcHBsaWNhdGlvbjo6bGF5b3V0UGF0aHxsYXlvdXQgcGF0aF1dIG9mIHRoZSBhcHBsaWNhdGlvbjtcblx0ICogLSBhIHJlbGF0aXZlIHBhdGggKGUuZy4gXCJtYWluXCIpOiB0aGUgYWN0dWFsIGxheW91dCBsYXlvdXQgZmlsZSB3aWxsIGJlIGxvb2tlZCBmb3IgdW5kZXIgdGhlXG5cdCAqICAgW1tNb2R1bGU6OmxheW91dFBhdGh8bGF5b3V0IHBhdGhdXSBvZiB0aGUgY29udGV4dCBtb2R1bGUuXG5cdCAqXG5cdCAqIElmIHRoZSBsYXlvdXQgbmFtZSBkb2VzIG5vdCBjb250YWluIGEgZmlsZSBleHRlbnNpb24sIGl0IHdpbGwgdXNlIHRoZSBkZWZhdWx0IG9uZSBgLnBocGAuXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2aWV3ICAgdGhlIHZpZXcgbmFtZS4gUGxlYXNlIHJlZmVyIHRvIFtbZmluZFZpZXdGaWxlKCldXSBvbiBob3cgdG8gc3BlY2lmeSBhIHZpZXcgbmFtZS5cblx0ICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIChuYW1lLXZhbHVlIHBhaXJzKSB0aGF0IHNob3VsZCBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgdmlldy5cblx0ICogVGhlc2UgcGFyYW1ldGVycyB3aWxsIG5vdCBiZSBhdmFpbGFibGUgaW4gdGhlIGxheW91dC5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVuZGVyaW5nIHJlc3VsdC5cblx0ICovXG5cdHJlbmRlcjogZnVuY3Rpb24gKHZpZXcsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuXHRcdHZhciBvdXRwdXQgPSB0aGlzLmdldFZpZXcoKS5yZW5kZXIodmlldywgcGFyYW1zLCB0aGlzKTtcblx0XHRpZiAodGhpcy5nZXRWaWV3KCkgaW5zdGFuY2VvZiBKaWkudmlldy5XZWJWaWV3KSB7XG5cdFx0XHR2YXIgbGF5b3V0RmlsZSA9IHRoaXMuX2ZpbmRMYXlvdXRGaWxlKHRoaXMuZ2V0VmlldygpKTtcblx0XHRcdGlmIChsYXlvdXRGaWxlICE9PSBmYWxzZSkge1xuXHRcdFx0XHRwYXJhbXMuY29udGVudCA9IG91dHB1dDtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZ2V0VmlldygpLnJlbmRlckxheW91dChsYXlvdXRGaWxlLCB7Y29udGVudDogb3V0cHV0fSwgdGhpcyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fSxcblxuXHQvKipcblx0ICogUmVuZGVycyBhIHZpZXcuXG5cdCAqIFRoaXMgbWV0aG9kIGRpZmZlcnMgZnJvbSBbW3JlbmRlcigpXV0gaW4gdGhhdCBpdCBkb2VzIG5vdCBhcHBseSBhbnkgbGF5b3V0LlxuXHQgKiBAcGFyYW0gIHtzdHJpbmd9IHZpZXcgICB0aGUgdmlldyBuYW1lLiBQbGVhc2UgcmVmZXIgdG8gW1tyZW5kZXIoKV1dIG9uIGhvdyB0byBzcGVjaWZ5IGEgdmlldyBuYW1lLlxuXHQgKiBAcGFyYW0gIHtvYmplY3R9IFtwYXJhbXNdIHRoZSBwYXJhbWV0ZXJzIChuYW1lLXZhbHVlIHBhaXJzKSB0aGF0IHNob3VsZCBiZSBtYWRlIGF2YWlsYWJsZSBpbiB0aGUgdmlldy5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcmVuZGVyaW5nIHJlc3VsdC5cblx0ICovXG5cdHJlbmRlclBhcnRpYWw6IGZ1bmN0aW9uICh2aWV3LCBwYXJhbXMpIHtcblx0XHRwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cblx0XHRyZXR1cm4gdGhpcy5nZXRWaWV3KCkucmVuZGVyKHZpZXcsIHBhcmFtcywgdGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJlbmRlcnMgYSB2aWV3IGZpbGUuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gZmlsZSAgIHRoZSB2aWV3IGZpbGUgdG8gYmUgcmVuZGVyZWQuIFRoaXMgY2FuIGJlIGVpdGhlciBhIGZpbGUgcGF0aCBvciBhIHBhdGggYWxpYXMuXG5cdCAqIEBwYXJhbSAge29iamVjdH0gW3BhcmFtc10gdGhlIHBhcmFtZXRlcnMgKG5hbWUtdmFsdWUgcGFpcnMpIHRoYXQgc2hvdWxkIGJlIG1hZGUgYXZhaWxhYmxlIGluIHRoZSB2aWV3LlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByZW5kZXJpbmcgcmVzdWx0LlxuXHQgKi9cblx0cmVuZGVyRmlsZTogZnVuY3Rpb24gKGZpbGUsIHBhcmFtcykge1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblxuXHRcdHJldHVybiB0aGlzLmdldFZpZXcoKS5yZW5kZXJGaWxlKGZpbGUsIHBhcmFtcywgdGhpcyk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHZpZXcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIHZpZXdzIG9yIHZpZXcgZmlsZXMuXG5cdCAqIFRoZSBbW3JlbmRlcigpXV0sIFtbcmVuZGVyUGFydGlhbCgpXV0gYW5kIFtbcmVuZGVyRmlsZSgpXV0gbWV0aG9kcyB3aWxsIHVzZVxuXHQgKiB0aGlzIHZpZXcgb2JqZWN0IHRvIGltcGxlbWVudCB0aGUgYWN0dWFsIHZpZXcgcmVuZGVyaW5nLlxuXHQgKiBJZiBub3Qgc2V0LCBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIFwidmlld1wiIGFwcGxpY2F0aW9uIGNvbXBvbmVudC5cblx0ICogQHJldHVybiB7SmlpLnZpZXcuVmlld30gdGhlIHZpZXcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIHZpZXdzIG9yIHZpZXcgZmlsZXMuXG5cdCAqL1xuXHRnZXRWaWV3OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3ZpZXcgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3ZpZXcgPSBKaWkuYXBwLnZpZXc7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHZpZXcgb2JqZWN0IHRvIGJlIHVzZWQgYnkgdGhpcyBjb250cm9sbGVyLlxuXHQgKiBAcGFyYW0ge0ppaS52aWV3LlZpZXd9IHZpZXcgdGhlIHZpZXcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVuZGVyIHZpZXdzIG9yIHZpZXcgZmlsZXMuXG5cdCAqL1xuXHRzZXRWaWV3OiBmdW5jdGlvbiAodmlldykge1xuXHRcdHRoaXMuX3ZpZXcgPSB2aWV3O1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgY29udGFpbmluZyB2aWV3IGZpbGVzIGZvciB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIGRpcmVjdG9yeSBuYW1lZCBhcyBjb250cm9sbGVyIFtbaWRdXSB1bmRlciB0aGUgW1ttb2R1bGVdXSdzXG5cdCAqIFtbdmlld1BhdGhdXSBkaXJlY3RvcnkuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGRpcmVjdG9yeSBjb250YWluaW5nIHRoZSB2aWV3IGZpbGVzIGZvciB0aGlzIGNvbnRyb2xsZXIuXG5cdCAqL1xuXHRnZXRWaWV3UGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLm1vZHVsZS5nZXRWaWV3UGF0aCgpICsgJy8nICsgdGhpcy5pZDtcblx0fSxcblxuXHQvKipcblx0ICogRmluZHMgdGhlIHZpZXcgZmlsZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gdmlldyBuYW1lLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmlldyB0aGUgdmlldyBuYW1lIG9yIHRoZSBwYXRoIGFsaWFzIG9mIHRoZSB2aWV3IGZpbGUuIFBsZWFzZSByZWZlciB0byBbW3JlbmRlcigpXV1cblx0ICogb24gaG93IHRvIHNwZWNpZnkgdGhpcyBwYXJhbWV0ZXIuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHZpZXcgZmlsZSBwYXRoLiBOb3RlIHRoYXQgdGhlIGZpbGUgbWF5IG5vdCBleGlzdC5cblx0ICovXG5cdGZpbmRWaWV3RmlsZTogZnVuY3Rpb24gKHZpZXcpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWaWV3UGF0aCgpICsgJy8nICsgdmlldztcblx0fSxcblxuXHQvKipcblx0ICogRmluZHMgdGhlIGFwcGxpY2FibGUgbGF5b3V0IGZpbGUuXG5cdCAqIEBwYXJhbSB7SmlpLnZpZXcuVmlld30gdmlldyB0aGUgdmlldyBvYmplY3QgdG8gcmVuZGVyIHRoZSBsYXlvdXQgZmlsZS5cblx0ICogQHJldHVybiB7c3RyaW5nfGJvb2xlYW59IHRoZSBsYXlvdXQgZmlsZSBwYXRoLCBvciBmYWxzZSBpZiBsYXlvdXQgaXMgbm90IG5lZWRlZC5cblx0ICogUGxlYXNlIHJlZmVyIHRvIFtbcmVuZGVyKCldXSBvbiBob3cgdG8gc3BlY2lmeSB0aGlzIHBhcmFtZXRlci5cblx0ICovXG5cdF9maW5kTGF5b3V0RmlsZTogZnVuY3Rpb24gKHZpZXcpIHtcblx0XHR2YXIgbW9kdWxlID0gdGhpcy5tb2R1bGU7XG5cdFx0dmFyIGxheW91dCA9IG51bGw7XG5cblx0XHRpZiAoSmlpLl8uaXNTdHJpbmcodGhpcy5sYXlvdXQpKSB7XG5cdFx0XHRsYXlvdXQgPSB0aGlzLmxheW91dDtcblx0XHR9IGVsc2UgaWYgKHRoaXMubGF5b3V0ID09PSBudWxsKSB7XG5cdFx0XHR3aGlsZSAobW9kdWxlICE9PSBudWxsICYmIG1vZHVsZS5sYXlvdXQgPT09IG51bGwpIHtcblx0XHRcdFx0bW9kdWxlID0gbW9kdWxlLm1vZHVsZTtcblx0XHRcdH1cblx0XHRcdGlmIChtb2R1bGUgIT09IG51bGwgJiYgSmlpLl8uaXNTdHJpbmcobW9kdWxlLmxheW91dCkpIHtcblx0XHRcdFx0bGF5b3V0ID0gbW9kdWxlLmxheW91dDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIWxheW91dCkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBmaWxlID0gbnVsbDtcblx0XHRpZiAobGF5b3V0LmluZGV4T2YoJ0AnKSA9PT0gMCkge1xuXHRcdFx0ZmlsZSA9IEppaS5nZXRBbGlhcyhsYXlvdXQpO1xuXHRcdH0gZWxzZSBpZiAobGF5b3V0LmluZGV4T2YoJy8nKSA9PT0gMCkge1xuXHRcdFx0ZmlsZSA9IEppaS5hcHAuZ2V0TGF5b3V0UGF0aCgpICsgJy8nICsgbGF5b3V0LnN1YnN0cigxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZmlsZSA9IG1vZHVsZS5nZXRMYXlvdXRQYXRoKCkgKyAnLycgKyBsYXlvdXQ7XG5cdFx0fVxuXG5cdFx0dmFyIGV4dCA9IEppaS5oZWxwZXJzLkZpbGUuZ2V0RmlsZUV4dGVuc2lvbihmaWxlKTtcblx0XHRpZiAoZXh0ICE9PSAnJykge1xuXHRcdFx0cmV0dXJuIGZpbGU7XG5cdFx0fVxuXG5cdFx0dmFyIHBhdGggPSBmaWxlICsgJy4nICsgdmlldy5kZWZhdWx0RXh0ZW5zaW9uO1xuXHRcdGlmICh2aWV3LmRlZmF1bHRFeHRlbnNpb24gIT09ICdlanMnICYmIGV4dCA9PT0gJycpIHtcblx0XHRcdHBhdGggPSBmaWxlICsgJy5lanMnO1xuXHRcdH1cblxuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cbn0pO1xuXG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9PYmplY3RcIjoxMzh9XSwxMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL09iamVjdCcpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5FdmVudFxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuRXZlbnQnLCAvKiogQGxlbmRzIEppaS5iYXNlLkV2ZW50LnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHQvKipcblx0ICogQHZhciB7c3RyaW5nfSB0aGUgZXZlbnQgbmFtZS4gVGhpcyBwcm9wZXJ0eSBpcyBzZXQgYnkgW1tKaWkuYmFzZS5Db21wb25lbnQudHJpZ2dlcigpXV0gYW5kIFtbdHJpZ2dlcigpXV0uXG5cdCAqIEV2ZW50IGhhbmRsZXJzIG1heSB1c2UgdGhpcyBwcm9wZXJ0eSB0byBjaGVjayB3aGF0IGV2ZW50IGl0IGlzIGhhbmRsaW5nLlxuXHQgKi9cblx0bmFtZTogbnVsbCxcblxuXHQvKipcblx0ICogQHZhciB7b2JqZWN0fSB0aGUgc2VuZGVyIG9mIHRoaXMgZXZlbnQuIElmIG5vdCBzZXQsIHRoaXMgcHJvcGVydHkgd2lsbCBiZVxuXHQgKiBzZXQgYXMgdGhlIG9iamVjdCB3aG9zZSBcInRyaWdnZXIoKVwiIG1ldGhvZCBpcyBjYWxsZWQuXG5cdCAqIFRoaXMgcHJvcGVydHkgbWF5IGFsc28gYmUgYSBgbnVsbGAgd2hlbiB0aGlzIGV2ZW50IGlzIGFcblx0ICogY2xhc3MtbGV2ZWwgZXZlbnQgd2hpY2ggaXMgdHJpZ2dlcmVkIGluIGEgc3RhdGljIGNvbnRleHQuXG5cdCAqL1xuXHRzZW5kZXI6IG51bGwsXG5cblx0LyoqXG5cdCAqIEB2YXIge2Jvb2xlYW59IHdoZXRoZXIgdGhlIGV2ZW50IGlzIGhhbmRsZWQuIERlZmF1bHRzIHRvIGZhbHNlLlxuXHQgKiBXaGVuIGEgaGFuZGxlciBzZXRzIHRoaXMgdG8gYmUgdHJ1ZSwgdGhlIGV2ZW50IHByb2Nlc3Npbmcgd2lsbCBzdG9wIGFuZFxuXHQgKiBpZ25vcmUgdGhlIHJlc3Qgb2YgdGhlIHVuaW52b2tlZCBldmVudCBoYW5kbGVycy5cblx0ICovXG5cdGhhbmRsZWQ6IGZhbHNlLFxuXG5cdC8qKlxuXHQgKiBAdmFyIHsqfSB0aGUgZGF0YSB0aGF0IGlzIHBhc3NlZCB0byBbW0ppaS5iYXNlLkNvbXBvbmVudC5vbigpXV0gd2hlbiBhdHRhY2hpbmcgYW4gZXZlbnQgaGFuZGxlci5cblx0ICogTm90ZSB0aGF0IHRoaXMgdmFyaWVzIGFjY29yZGluZyB0byB3aGljaCBldmVudCBoYW5kbGVyIGlzIGN1cnJlbnRseSBleGVjdXRpbmcuXG5cdCAqL1xuXHRkYXRhOiBudWxsLFxuXG5cdHBhcmFtczoge30sXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmJhc2UuRXZlbnQgKi97XG5cblx0XHQvKipcblx0XHQgKiBDb252ZXJ0IHN0cmluZy9mdW5jdGlvbi9vYmplY3QgdG8gb2JqZWN0IGhhbmRsZXIgd2l0aCBjb250ZXh0IGFuZCBjYWxsYmFjayBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R8W119IGhhbmRsZXJcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdXG5cdFx0ICogQHJldHVybnMgeyp9XG5cdFx0ICovXG5cdFx0bm9ybWFsaXplSGFuZGxlcjogZnVuY3Rpb24gKGhhbmRsZXIsIGNvbnRleHQpIHtcblx0XHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IG51bGw7XG5cblx0XHRcdGlmIChKaWkuXy5pc09iamVjdChoYW5kbGVyKSAmJiBKaWkuXy5oYXMoaGFuZGxlciwgJ2NhbGxiYWNrJykgJiYgSmlpLl8uaGFzKGhhbmRsZXIsICdjb250ZXh0JykpIHtcblx0XHRcdFx0cmV0dXJuIGhhbmRsZXI7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKaWkuXy5pc0FycmF5KGhhbmRsZXIpICYmIGhhbmRsZXIubGVuZ3RoID09PSAyKSB7XG5cdFx0XHRcdGlmIChKaWkuXy5pc0Z1bmN0aW9uKGhhbmRsZXJbMF0pICYmIEppaS5fLmlzT2JqZWN0KGhhbmRsZXJbMV0pKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdGNvbnRleHQ6IGhhbmRsZXJbMV0sXG5cdFx0XHRcdFx0XHRjYWxsYmFjazogaGFuZGxlclswXVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoSmlpLl8uaXNTdHJpbmcoaGFuZGxlclswXSkpIHtcblx0XHRcdFx0XHRoYW5kbGVyWzBdID0gSmlpLm5hbWVzcGFjZShoYW5kbGVyWzBdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbnRleHQ6IGhhbmRsZXJbMF0sXG5cdFx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXJbMF1baGFuZGxlclsxXV1cblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKEppaS5fLmlzU3RyaW5nKGhhbmRsZXIpKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0Y29udGV4dDogY29udGV4dCxcblx0XHRcdFx0XHRjYWxsYmFjazogdGhpc1toYW5kbGVyXVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoSmlpLl8uaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdGNvbnRleHQ6IGNvbnRleHQsXG5cdFx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXJcblx0XHRcdFx0fTtcblx0XHRcdH1cblxuXHRcdFx0dGhyb3cgbmV3IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uKCdXcm9uZyBoYW5kbGVyIGZvcm1hdDonICsgSlNPTi5zdHJpbmdpZnkoaGFuZGxlcikpO1xuXHRcdH0sXG5cblx0XHRfZXZlbnRzOiB7fSxcblxuXHRcdC8qKlxuXHRcdCAqIEF0dGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgdG8gYSBjbGFzcy1sZXZlbCBldmVudC5cblx0XHQgKlxuXHRcdCAqIFdoZW4gYSBjbGFzcy1sZXZlbCBldmVudCBpcyB0cmlnZ2VyZWQsIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkXG5cdFx0ICogdG8gdGhhdCBjbGFzcyBhbmQgYWxsIHBhcmVudCBjbGFzc2VzIHdpbGwgYmUgaW52b2tlZC5cblx0XHQgKlxuXHRcdCAqIEZvciBleGFtcGxlLCB0aGUgZm9sbG93aW5nIGNvZGUgYXR0YWNoZXMgYW4gZXZlbnQgaGFuZGxlciB0byBgQWN0aXZlUmVjb3JkYCdzXG5cdFx0ICogYGFmdGVySW5zZXJ0YCBldmVudDpcblx0XHQgKlxuXHRcdCAqIH5+flxuXHRcdCAqIEppaS5iYXNlLkV2ZW50Lm9uKEFjdGl2ZVJlY29yZC5jbGFzc05hbWUoKSwgQWN0aXZlUmVjb3JkLkVWRU5UX0FGVEVSX0lOU0VSVCwgZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0ICogICAgIGNvbnNvbGUubG9nKGV2ZW50LnNlbmRlci5jbGFzc05hbWUoKSArICcgaXMgaW5zZXJ0ZWQuJyk7XG5cdFx0ICogfSk7XG5cdFx0ICogfn5+XG5cdFx0ICpcblx0XHQgKiBUaGUgaGFuZGxlciB3aWxsIGJlIGludm9rZWQgZm9yIEVWRVJZIHN1Y2Nlc3NmdWwgQWN0aXZlUmVjb3JkIGluc2VydGlvbi5cblx0XHQgKlxuXHRcdCAqIEZvciBtb3JlIGRldGFpbHMgYWJvdXQgaG93IHRvIGRlY2xhcmUgYW4gZXZlbnQgaGFuZGxlciwgcGxlYXNlIHJlZmVyIHRvIFtbSmlpLmJhc2UuQ29tcG9uZW50Lm9uKCldXS5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWUgdGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIHRvIHdoaWNoIHRoZSBldmVudCBoYW5kbGVyIG5lZWRzIHRvIGF0dGFjaC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R9IGhhbmRsZXIgdGhlIGV2ZW50IGhhbmRsZXIuXG5cdFx0ICogQHBhcmFtIHsqfSBbZGF0YV0gdGhlIGRhdGEgdG8gYmUgcGFzc2VkIHRvIHRoZSBldmVudCBoYW5kbGVyIHdoZW4gdGhlIGV2ZW50IGlzIHRyaWdnZXJlZC5cblx0XHQgKiBXaGVuIHRoZSBldmVudCBoYW5kbGVyIGlzIGludm9rZWQsIHRoaXMgZGF0YSBjYW4gYmUgYWNjZXNzZWQgdmlhIFtbSmlpLmJhc2UuRXZlbnQuZGF0YV1dLlxuXHRcdCAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzQXBwZW5kXSB3aGV0aGVyIHRvIGFwcGVuZCBuZXcgZXZlbnQgaGFuZGxlciB0byB0aGUgZW5kIG9mIHRoZSBleGlzdGluZ1xuXHRcdCAqIGhhbmRsZXIgbGlzdC4gSWYgZmFsc2UsIHRoZSBuZXcgaGFuZGxlciB3aWxsIGJlIGluc2VydGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGV4aXN0aW5nXG5cdFx0ICogaGFuZGxlciBsaXN0LlxuXHRcdCAqIEBzZWUgb2ZmKClcblx0XHQgKi9cblx0XHRvbjogZnVuY3Rpb24gKGNsYXNzTmFtZSwgbmFtZSwgaGFuZGxlciwgZGF0YSwgaXNBcHBlbmQpIHtcblx0XHRcdGRhdGEgPSBkYXRhIHx8IG51bGw7XG5cdFx0XHRpc0FwcGVuZCA9IEppaS5fLmlzVW5kZWZpbmVkKGlzQXBwZW5kKSA/IHRydWUgOiBpc0FwcGVuZDtcblxuXHRcdFx0aWYgKGlzQXBwZW5kIHx8ICF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSB8fCAhdGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0pIHtcblx0XHRcdFx0dGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzIHx8IHt9O1xuXHRcdFx0XHR0aGlzLl9ldmVudHNbbmFtZV0gPSB0aGlzLl9ldmVudHNbbmFtZV0gfHwge307XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdID0gdGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0gfHwgW107XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdLnB1c2goW2hhbmRsZXIsIGRhdGFdKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tuYW1lXS51bnNoaWZ0KFtoYW5kbGVyLCBkYXRhXSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIERldGFjaGVzIGFuIGV2ZW50IGhhbmRsZXIgZnJvbSBhIGNsYXNzLWxldmVsIGV2ZW50LlxuXHRcdCAqXG5cdFx0ICogVGhpcyBtZXRob2QgaXMgdGhlIG9wcG9zaXRlIG9mIFtbb24oKV1dLlxuXHRcdCAqXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSB0aGUgZnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWUgZnJvbSB3aGljaCB0aGUgZXZlbnQgaGFuZGxlciBuZWVkcyB0byBiZSBkZXRhY2hlZC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgZXZlbnQgbmFtZS5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ3xmdW5jdGlvbnxvYmplY3R9IFtoYW5kbGVyXSB0aGUgZXZlbnQgaGFuZGxlciB0byBiZSByZW1vdmVkLlxuXHRcdCAqIElmIGl0IGlzIG51bGwsIGFsbCBoYW5kbGVycyBhdHRhY2hlZCB0byB0aGUgbmFtZWQgZXZlbnQgd2lsbCBiZSByZW1vdmVkLlxuXHRcdCAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIGEgaGFuZGxlciBpcyBmb3VuZCBhbmQgZGV0YWNoZWQuXG5cdFx0ICogQHNlZSBvbigpXG5cdFx0ICovXG5cdFx0b2ZmOiBmdW5jdGlvbiAoY2xhc3NOYW1lLCBuYW1lLCBoYW5kbGVyKSB7XG5cdFx0XHRoYW5kbGVyID0gaGFuZGxlciB8fCBudWxsO1xuXG5cdFx0XHRpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW25hbWVdIHx8ICF0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChoYW5kbGVyID09PSBudWxsKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXTtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cblx0XHRcdHZhciBuZXdFdmVudHMgPSBbXTtcblx0XHRcdHZhciBpc1JlbW92ZWQgPSBmYWxzZTtcblx0XHRcdEppaS5fLmVhY2godGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0sIEppaS5fLmJpbmQoZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKGV2ZW50WzBdICE9PSBoYW5kbGVyKSB7XG5cdFx0XHRcdFx0bmV3RXZlbnRzLnB1c2goZXZlbnQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlzUmVtb3ZlZCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH0sIHRoaXMpKTtcblx0XHRcdGlmIChuZXdFdmVudHMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9ldmVudHNbbmFtZV1bY2xhc3NOYW1lXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdID0gbmV3RXZlbnRzO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gaXNSZW1vdmVkO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGEgdmFsdWUgaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGFueSBoYW5kbGVyIGF0dGFjaGVkIHRvIHRoZSBzcGVjaWZpZWQgY2xhc3MtbGV2ZWwgZXZlbnQuXG5cdFx0ICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHdpbGwgYWxzbyBjaGVjayBhbGwgcGFyZW50IGNsYXNzZXMgdG8gc2VlIGlmIHRoZXJlIGlzIGFueSBoYW5kbGVyIGF0dGFjaGVkXG5cdFx0ICogdG8gdGhlIG5hbWVkIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gY2xhc3NOYW1lIHRoZSBvYmplY3Qgb3IgdGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIHNwZWNpZnlpbmcgdGhlIGNsYXNzLWxldmVsIGV2ZW50LlxuXHRcdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBldmVudCBuYW1lLlxuXHRcdCAqIEByZXR1cm4gYm9vbGVhbiB3aGV0aGVyIHRoZXJlIGlzIGFueSBoYW5kbGVyIGF0dGFjaGVkIHRvIHRoZSBldmVudC5cblx0XHQgKi9cblx0XHRoYXNIYW5kbGVyczogZnVuY3Rpb24gKGNsYXNzTmFtZSwgbmFtZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChKaWkuXy5pc09iamVjdChjbGFzc05hbWUpKSB7XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5jbGFzc05hbWUoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnRDbGFzcyA9IEppaS5fLmlzT2JqZWN0KGNsYXNzTmFtZSkgPyBjbGFzc05hbWUgOiBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0pIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNsYXNzTmFtZSA9IGN1cnJlbnRDbGFzcy5wYXJlbnRDbGFzc05hbWUoKTtcblx0XHRcdFx0Y3VycmVudENsYXNzID0gY2xhc3NOYW1lID8gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpIDogbnVsbDtcblxuXHRcdFx0XHRpZiAoIWN1cnJlbnRDbGFzcykge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogVHJpZ2dlcnMgYSBjbGFzcy1sZXZlbCBldmVudC5cblx0XHQgKiBUaGlzIG1ldGhvZCB3aWxsIGNhdXNlIGludm9jYXRpb24gb2YgZXZlbnQgaGFuZGxlcnMgdGhhdCBhcmUgYXR0YWNoZWQgdG8gdGhlIG5hbWVkIGV2ZW50XG5cdFx0ICogZm9yIHRoZSBzcGVjaWZpZWQgY2xhc3MgYW5kIGFsbCBpdHMgcGFyZW50IGNsYXNzZXMuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSBjbGFzc05hbWUgdGhlIG9iamVjdCBvciB0aGUgZnVsbHkgcXVhbGlmaWVkIGNsYXNzIG5hbWUgc3BlY2lmeWluZyB0aGUgY2xhc3MtbGV2ZWwgZXZlbnQuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIGV2ZW50IG5hbWUuXG5cdFx0ICogQHBhcmFtIHtKaWkuYmFzZS5FdmVudH0gW2V2ZW50XSB0aGUgZXZlbnQgcGFyYW1ldGVyLiBJZiBub3Qgc2V0LCBhIGRlZmF1bHQgW1tFdmVudF1dIG9iamVjdCB3aWxsIGJlIGNyZWF0ZWQuXG5cdFx0ICovXG5cdFx0dHJpZ2dlcjogZnVuY3Rpb24gKGNsYXNzTmFtZSwgbmFtZSwgZXZlbnQpIHtcblx0XHRcdGV2ZW50ID0gZXZlbnQgfHwgbnVsbDtcblxuXHRcdFx0aWYgKCF0aGlzLl9ldmVudHMgfHwgIXRoaXMuX2V2ZW50c1tuYW1lXSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmIChldmVudCA9PT0gbnVsbCkge1xuXHRcdFx0XHRldmVudCA9IG5ldyB0aGlzKCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGV2ZW50LmhhbmRsZWQgPSBmYWxzZTtcblx0XHRcdGV2ZW50Lm5hbWUgPSBuYW1lO1xuXG5cdFx0XHRpZiAoSmlpLl8uaXNPYmplY3QoY2xhc3NOYW1lKSkge1xuXHRcdFx0XHRpZiAoZXZlbnQuc2VuZGVyID09PSBudWxsKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc2VuZGVyID0gY2xhc3NOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5jbGFzc05hbWUoKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGN1cnJlbnRDbGFzcyA9IEppaS5fLmlzT2JqZWN0KGNsYXNzTmFtZSkgPyBjbGFzc05hbWUgOiBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xuXHRcdFx0XHRpZiAodGhpcy5fZXZlbnRzW25hbWVdW2NsYXNzTmFtZV0pIHtcblx0XHRcdFx0XHRmb3IgKHZhciBoYW5kbGVyLCBpID0gMCwgbCA9IHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0aGFuZGxlciA9IHRoaXMuX2V2ZW50c1tuYW1lXVtjbGFzc05hbWVdW2ldO1xuXG5cdFx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlclsxXTtcblx0XHRcdFx0XHRcdGhhbmRsZXJbMF0gPSB0aGlzLm5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlclswXSk7XG5cdFx0XHRcdFx0XHRoYW5kbGVyWzBdLmNhbGxiYWNrLmNhbGwoaGFuZGxlclswXS5jb250ZXh0LCBldmVudCk7XG5cblx0XHRcdFx0XHRcdGlmIChldmVudC5oYW5kbGVkKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjbGFzc05hbWUgPSBjdXJyZW50Q2xhc3MucGFyZW50Q2xhc3NOYW1lKCk7XG5cdFx0XHRcdGN1cnJlbnRDbGFzcyA9IGNsYXNzTmFtZSA/IEppaS5uYW1lc3BhY2UoY2xhc3NOYW1lKSA6IG51bGw7XG5cblx0XHRcdFx0aWYgKCFjdXJyZW50Q2xhc3MpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL09iamVjdFwiOjEzOH1dLDEzNTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL1JlcXVlc3QnKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmJhc2UuSHR0cFJlcXVlc3RcbiAqIEBleHRlbmRzIEppaS5iYXNlLlJlcXVlc3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuYmFzZS5IdHRwUmVxdWVzdCcsIC8qKiBAbGVuZHMgSmlpLmJhc2UuSHR0cFJlcXVlc3QucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuUmVxdWVzdCxcblxuXHQvKipcblx0ICpcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGdldE1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnR0VUJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYSBHRVQgcmVxdWVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzR2V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0aG9kKCkgPT09ICdHRVQnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBpcyBhIE9QVElPTlMgcmVxdWVzdC5cblx0ICogQHJldHVybiB7Ym9vbGVhbn1cblx0ICovXG5cdGlzT3B0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGhvZCgpID09PSAnT1BUSU9OUyc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGEgSEVBRCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNIZWFkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWV0aG9kKCkgPT09ICdIRUFEJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYSBQT1NUIHJlcXVlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1Bvc3Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRob2QoKSA9PT0gJ1BPU1QnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBpcyBhIERFTEVURSByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNEZWxldGU6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRNZXRob2QoKSA9PT0gJ0RFTEVURSc7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgd2hldGhlciB0aGlzIGlzIGEgUFVUIHJlcXVlc3QuXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRpc1B1dDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGhvZCgpID09PSAnUFVUJztcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYSBQQVRDSCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIHtib29sZWFufVxuXHQgKi9cblx0aXNQYXRjaDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE1ldGhvZCgpID09PSAnUEFUQ0gnO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBpcyBhbiBBSkFYIChYTUxIdHRwUmVxdWVzdCkgcmVxdWVzdC5cblx0ICogQHJldHVybiBib29sZWFuIHdoZXRoZXIgdGhpcyBpcyBhbiBBSkFYIChYTUxIdHRwUmVxdWVzdCkgcmVxdWVzdC5cblx0ICovXG5cdGlzQWpheDogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB3aGV0aGVyIHRoaXMgaXMgYW4gQWRvYmUgRmxhc2ggb3IgRmxleCByZXF1ZXN0LlxuXHQgKiBAcmV0dXJuIGJvb2xlYW4gd2hldGhlciB0aGlzIGlzIGFuIEFkb2JlIEZsYXNoIG9yIEFkb2JlIEZsZXggcmVxdWVzdC5cblx0ICovXG5cdGlzRmxhc2g6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIG5hbWVkIHJlcXVlc3QgYm9keSBwYXJhbWV0ZXIgdmFsdWUuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBwYXJhbWV0ZXIgbmFtZVxuXHQgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIHRoZSBkZWZhdWx0IHBhcmFtZXRlciB2YWx1ZSBpZiB0aGUgcGFyYW1ldGVyIGRvZXMgbm90IGV4aXN0LlxuXHQgKiBAcmV0dXJuIHsqfSB0aGUgcGFyYW1ldGVyIHZhbHVlXG5cdCAqL1xuXHRnZXRCb2R5UGFyYW06IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRkZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcblxuXHRcdHZhciBib2R5UGFyYW1zID0gdGhpcy5nZXRCb2R5UGFyYW1zKCk7XG5cdFx0cmV0dXJuIEppaS5fLmhhcyhib2R5UGFyYW1zLCBuYW1lKSA/IGJvZHlQYXJhbXNbbmFtZV0gOiBkZWZhdWx0VmFsdWU7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgUE9TVCBwYXJhbWV0ZXIgd2l0aCBhIGdpdmVuIG5hbWUuIElmIG5hbWUgaXNuJ3Qgc3BlY2lmaWVkLCByZXR1cm5zIGFuIGFycmF5IG9mIGFsbCBQT1NUIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV0gdGhlIHBhcmFtZXRlciBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gdGhlIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIGlmIHRoZSBwYXJhbWV0ZXIgZG9lcyBub3QgZXhpc3QuXG5cdCAqIEByZXR1cm4geyp9IFRoZSBQT1NUIHBhcmFtZXRlciB2YWx1ZVxuXHQgKi9cblx0cG9zdDogZnVuY3Rpb24gKG5hbWUsIGRlZmF1bHRWYWx1ZSkge1xuXHRcdG5hbWUgPSBuYW1lIHx8IG51bGw7XG5cdFx0ZGVmYXVsdFZhbHVlID0gZGVmYXVsdFZhbHVlIHx8IG51bGw7XG5cblx0XHRyZXR1cm4gbmFtZSA9PT0gbnVsbCA/IHRoaXMuZ2V0Qm9keVBhcmFtcygpIDogdGhpcy5nZXRCb2R5UGFyYW0obmFtZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHRfcXVlcnlQYXJhbXM6IG51bGwsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHJlcXVlc3QgcGFyYW1ldGVycyBnaXZlbiBpbiB0aGUgW1txdWVyeVN0cmluZ11dLlxuXHQgKiBAcmV0dXJuIHtvYmplY3R9IHRoZSByZXF1ZXN0IEdFVCBwYXJhbWV0ZXIgdmFsdWVzLlxuXHQgKi9cblx0Z2V0UXVlcnlQYXJhbXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcXVlcnlQYXJhbXMgPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3F1ZXJ5UGFyYW1zID0gdGhpcy5fcGFyc2VRdWVyeVBhcmFtcygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcXVlcnlQYXJhbXM7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHJlcXVlc3QgW1txdWVyeVN0cmluZ11dIHBhcmFtZXRlcnMuXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgdGhlIHJlcXVlc3QgcXVlcnkgcGFyYW1ldGVycyAobmFtZS12YWx1ZSBwYWlycylcblx0ICovXG5cdHNldFF1ZXJ5UGFyYW1zOiBmdW5jdGlvbiAodmFsdWVzKSB7XG5cdFx0dGhpcy5fcXVlcnlQYXJhbXMgPSB2YWx1ZXM7XG5cdH0sXG5cblx0X3BhcnNlUXVlcnlQYXJhbXM6IGZ1bmN0aW9uICgpIHtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgbmFtZWQgR0VUIHBhcmFtZXRlciB2YWx1ZS5cblx0ICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIHBhcmFtZXRlciBuYW1lXG5cdCAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gdGhlIGRlZmF1bHQgcGFyYW1ldGVyIHZhbHVlIGlmIHRoZSBwYXJhbWV0ZXIgZG9lcyBub3QgZXhpc3QuXG5cdCAqIEByZXR1cm4geyp9IHRoZSBwYXJhbWV0ZXIgdmFsdWVcblx0ICovXG5cdGdldFF1ZXJ5UGFyYW06IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRkZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcblxuXHRcdHZhciBxdWVyeVBhcmFtcyA9IHRoaXMuZ2V0UXVlcnlQYXJhbXMoKTtcblx0XHRyZXR1cm4gSmlpLl8uaGFzKHF1ZXJ5UGFyYW1zLCBuYW1lKSA/IHF1ZXJ5UGFyYW1zW25hbWVdIDogZGVmYXVsdFZhbHVlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBuYW1lZCBHRVQgcGFyYW1ldGVyIHZhbHVlLlxuXHQgKiBJZiB0aGUgR0VUIHBhcmFtZXRlciBkb2VzIG5vdCBleGlzdCwgdGhlIHNlY29uZCBwYXJhbWV0ZXIgdG8gdGhpcyBtZXRob2Qgd2lsbCBiZSByZXR1cm5lZC5cblx0ICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXSB0aGUgR0VUIHBhcmFtZXRlciBuYW1lLiBJZiBub3Qgc3BlY2lmaWVkLCB3aG9sZSBhbGwgZ2V0IHBhcmFtcyBpcyByZXR1cm5lZC5cblx0ICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSB0aGUgZGVmYXVsdCBwYXJhbWV0ZXIgdmFsdWUgaWYgdGhlIEdFVCBwYXJhbWV0ZXIgZG9lcyBub3QgZXhpc3QuXG5cdCAqIEByZXR1cm4geyp9IHRoZSBHRVQgcGFyYW1ldGVyIHZhbHVlXG5cdCAqL1xuXHRnZXQ6IGZ1bmN0aW9uIChuYW1lLCBkZWZhdWx0VmFsdWUpIHtcblx0XHRuYW1lID0gbmFtZSB8fCBudWxsO1xuXHRcdGRlZmF1bHRWYWx1ZSA9IGRlZmF1bHRWYWx1ZSB8fCBudWxsO1xuXG5cdFx0cmV0dXJuIG5hbWUgPT09IG51bGwgPyB0aGlzLmdldFF1ZXJ5UGFyYW1zKCkgOiB0aGlzLmdldFF1ZXJ5UGFyYW0obmFtZSwgZGVmYXVsdFZhbHVlKTtcblx0fSxcblxuXHRfcGF0aEluZm86IG51bGwsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHBhdGggaW5mbyBvZiB0aGUgY3VycmVudGx5IHJlcXVlc3RlZCBVUkwuXG5cdCAqIEEgcGF0aCBpbmZvIHJlZmVycyB0byB0aGUgcGFydCB0aGF0IGlzIGFmdGVyIHRoZSBlbnRyeSBzY3JpcHQgYW5kIGJlZm9yZSB0aGUgcXVlc3Rpb24gbWFyayAocXVlcnkgc3RyaW5nKS5cblx0ICogVGhlIHN0YXJ0aW5nIGFuZCBlbmRpbmcgc2xhc2hlcyBhcmUgYm90aCByZW1vdmVkLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFBhcnQgb2YgdGhlIHJlcXVlc3QgVVJMIHRoYXQgaXMgYWZ0ZXIgdGhlIGVudHJ5IHNjcmlwdCBhbmQgYmVmb3JlIHRoZSBxdWVzdGlvbiBtYXJrLlxuXHQgKiBOb3RlLCB0aGUgcmV0dXJuZWQgcGF0aCBpbmZvIGlzIGFscmVhZHkgVVJMLWRlY29kZWQuXG5cdCAqL1xuXHRnZXRQYXRoSW5mbzogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9wYXRoSW5mbyA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fcGF0aEluZm8gPSB0aGlzLl9wYXJzZVBhdGhJbmZvKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wYXRoSW5mbztcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcGF0aCBpbmZvIG9mIHRoZSBjdXJyZW50IHJlcXVlc3QuXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG1haW5seSBwcm92aWRlZCBmb3IgdGVzdGluZyBwdXJwb3NlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgVGhlIHBhdGggaW5mbyBvZiB0aGUgY3VycmVudCByZXF1ZXN0XG5cdCAqL1xuXHRzZXRQYXRoSW5mbzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5fcGF0aEluZm8gPSBKaWkuX3MubHRyaW0odmFsdWUsICcvJyk7XG5cdH0sXG5cblx0X3BhcnNlUGF0aEluZm86IGZ1bmN0aW9uICgpIHtcblx0fSxcblxuXHRfaG9zdEluZm86IG51bGwsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNjaGVtYSBhbmQgaG9zdCBwYXJ0IG9mIHRoZSBjdXJyZW50IHJlcXVlc3QgVVJMLlxuXHQgKiBUaGUgcmV0dXJuZWQgVVJMIGRvZXMgbm90IGhhdmUgYW4gZW5kaW5nIHNsYXNoLlxuXHQgKiBCeSBkZWZhdWx0IHRoaXMgaXMgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aGUgdXNlciByZXF1ZXN0IGluZm9ybWF0aW9uLlxuXHQgKiBZb3UgbWF5IGV4cGxpY2l0bHkgc3BlY2lmeSBpdCBieSBzZXR0aW5nIHRoZSBzZXRIb3N0SW5mbygpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFNjaGVtYSBhbmQgaG9zdG5hbWUgcGFydCAod2l0aCBwb3J0IG51bWJlciBpZiBuZWVkZWQpIG9mIHRoZSByZXF1ZXN0IFVSTFxuXHQgKi9cblx0Z2V0SG9zdEluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faG9zdEluZm8gPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hvc3RJbmZvID0gdGhpcy5fcGFyc2VIb3N0SW5mbygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faG9zdEluZm87XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNjaGVtYSBhbmQgaG9zdCBwYXJ0IG9mIHRoZSBhcHBsaWNhdGlvbiBVUkwuXG5cdCAqIFRoaXMgc2V0dGVyIGlzIHByb3ZpZGVkIGluIGNhc2UgdGhlIHNjaGVtYSBhbmQgaG9zdG5hbWUgY2Fubm90IGJlIGRldGVybWluZWRcblx0ICogb24gY2VydGFpbiBXZWIgc2VydmVycy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgYXBwbGljYXRpb24gVVJMLiBUaGUgdHJhaWxpbmcgc2xhc2hlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRzZXRIb3N0SW5mbzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5faG9zdEluZm8gPSBKaWkuX3MucnRyaW0odmFsdWUsICcvJyk7XG5cdFx0cmV0dXJuIHRoaXMuX2hvc3RJbmZvO1xuXHR9LFxuXG5cdF9wYXJzZUhvc3RJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdH1cblxufSk7XG5cblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL1JlcXVlc3RcIjoxMzl9XSwxMzY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0V2ZW50Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLk1vZGVsRXZlbnRcbiAqIEBleHRlbmRzIEppaS5iYXNlLkV2ZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuTW9kZWxFdmVudCcsIC8qKiBAbGVuZHMgSmlpLmJhc2UuTW9kZWxFdmVudC5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5FdmVudCxcblxuXHQvKipcblx0ICogQSBtb2RlbCBpcyBpbiB2YWxpZCBzdGF0dXMgaWYgaXQgcGFzc2VzIHZhbGlkYXRpb25zIG9yIGNlcnRhaW4gY2hlY2tzLlxuXHQgKiBAdHlwZSB7Ym9vbGVhbn0gV2hldGhlciB0aGUgbW9kZWwgaXMgaW4gdmFsaWQgc3RhdHVzLiBEZWZhdWx0cyB0byB0cnVlLlxuXHQgKi9cblx0aXNWYWxpZDogdHJ1ZVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0V2ZW50XCI6MTM0fV0sMTM3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9Db250ZXh0Jyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLk1vZHVsZVxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29udGV4dFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLk1vZHVsZScsIC8qKiBAbGVuZHMgSmlpLmJhc2UuTW9kdWxlLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLkNvbnRleHQsXG5cbiAgICBfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuYmFzZS5Nb2R1bGUgKi97XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBldmVudCBKaWkuYmFzZS5Nb2R1bGUjYmVmb3JlQWN0aW9uXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7SmlpLmJhc2UuQWN0aW9uRXZlbnR9IGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICBFVkVOVF9CRUZPUkVfQUNUSU9OOiAnYmVmb3JlQWN0aW9uJyxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQGV2ZW50IEppaS5iYXNlLk1vZHVsZSNhZnRlckFjdGlvblxuICAgICAgICAgKiBAcHJvcGVydHkge0ppaS5iYXNlLkFjdGlvbkV2ZW50fSBldmVudFxuICAgICAgICAgKi9cbiAgICAgICAgRVZFTlRfQUZURVJfQUNUSU9OOiAnYWZ0ZXJBY3Rpb24nXG5cbiAgICB9LFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0aWQ6IG51bGwsXG5cblx0LyoqXG5cdCAqIFRoZSBwYXJlbnQgbW9kdWxlIG9mIHRoaXMgbW9kdWxlLiBOdWxsIGlmIHRoaXMgbW9kdWxlIGRvZXMgbm90IGhhdmUgYSBwYXJlbnQuXG5cdCAqIEB0eXBlIHtKaWkuYmFzZS5Nb2R1bGV9XG5cdCAqL1xuXHRtb2R1bGU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7e3N0cmluZzogZnVuY3Rpb259fVxuICAgICAqL1xuICAgIGlubGluZUFjdGlvbnM6IHt9LFxuXG5cdC8qKlxuXHQgKiBNYXBwaW5nIGZyb20gY29udHJvbGxlciBJRCB0byBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb25zLlxuXHQgKiBFYWNoIG5hbWUtdmFsdWUgcGFpciBzcGVjaWZpZXMgdGhlIGNvbmZpZ3VyYXRpb24gb2YgYSBzaW5nbGUgY29udHJvbGxlci5cblx0ICogQSBjb250cm9sbGVyIGNvbmZpZ3VyYXRpb24gY2FuIGJlIGVpdGhlciBhIHN0cmluZyBvciBhbiBhcnJheS5cblx0ICogSWYgdGhlIGZvcm1lciwgdGhlIHN0cmluZyBzaG91bGQgYmUgdGhlIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lIG9mIHRoZSBjb250cm9sbGVyLlxuXHQgKiBJZiB0aGUgbGF0dGVyLCB0aGUgYXJyYXkgbXVzdCBjb250YWluIGEgJ2NsYXNzJyBlbGVtZW50IHdoaWNoIHNwZWNpZmllc1xuXHQgKiB0aGUgY29udHJvbGxlcidzIGZ1bGx5IHF1YWxpZmllZCBjbGFzcyBuYW1lLCBhbmQgdGhlIHJlc3Qgb2YgdGhlIG5hbWUtdmFsdWUgcGFpcnNcblx0ICogaW4gdGhlIGFycmF5IGFyZSB1c2VkIHRvIGluaXRpYWxpemUgdGhlIGNvcnJlc3BvbmRpbmcgY29udHJvbGxlciBwcm9wZXJ0aWVzLiBGb3IgZXhhbXBsZSxcblx0ICpcblx0ICogfn5+XG5cdCAqIHtcbiAgICAgKiAgIGFjY291bnQ6ICdhcHAuY29udHJvbGxlcnMuVXNlckNvbnRyb2xsZXInLFxuICAgICAqICAgYXJ0aWNsZToge1xuICAgICAqICAgICAgY2xhc3NOYW1lOiAnYXBwLmNvbnRyb2xsZXJzLlBvc3RDb250cm9sbGVyJyxcbiAgICAgKiAgICAgIHBhZ2VUaXRsZTogJ3NvbWV0aGluZyBuZXcnXG4gICAgICogICB9XG4gICAgICogfVxuXHQgKiB+fn5cblx0ICogQHR5cGUge29iamVjdH1cblx0ICovXG5cdGNvbnRyb2xsZXJNYXA6IHt9LFxuXG5cdC8qKlxuXHQgKiBTdHJpbmcgdGhlIG5hbWVzcGFjZSB0aGF0IGNvbnRyb2xsZXIgY2xhc3NlcyBhcmUgaW4uIElmIG5vdCBzZXQsXG5cdCAqIGl0IHdpbGwgdXNlIHRoZSBcImNvbnRyb2xsZXJzXCIgc3ViLW5hbWVzcGFjZSB1bmRlciB0aGUgbmFtZXNwYWNlIG9mIHRoaXMgbW9kdWxlLlxuXHQgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIG5hbWVzcGFjZSBvZiB0aGlzIG1vZHVsZSBpcyBcImZvb1xcYmFyXCIsIHRoZW4gdGhlIGRlZmF1bHRcblx0ICogY29udHJvbGxlciBuYW1lc3BhY2Ugd291bGQgYmUgXCJmb29cXGJhclxcY29udHJvbGxlcnNcIi5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGNvbnRyb2xsZXJOYW1lc3BhY2U6IG51bGwsXG5cblx0LyoqXG5cdCAqIFRoZSBkZWZhdWx0IHJvdXRlIG9mIHRoaXMgbW9kdWxlLiBEZWZhdWx0cyB0byAnZGVmYXVsdCcuXG5cdCAqIFRoZSByb3V0ZSBtYXkgY29uc2lzdCBvZiBjaGlsZCBtb2R1bGUgSUQsIGNvbnRyb2xsZXIgSUQsIGFuZC9vciBhY3Rpb24gSUQuXG5cdCAqIEZvciBleGFtcGxlLCBgaGVscGAsIGBwb3N0L2NyZWF0ZWAsIGBhZG1pbi9wb3N0L2NyZWF0ZWAuXG5cdCAqIElmIGFjdGlvbiBJRCBpcyBub3QgZ2l2ZW4sIGl0IHdpbGwgdGFrZSB0aGUgZGVmYXVsdCB2YWx1ZSBhcyBzcGVjaWZpZWQgaW4gZGVmYXVsdEFjdGlvbi5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdGRlZmF1bHRSb3V0ZTogJ2RlZmF1bHQnLFxuXG5cdC8qKlxuXHQgKiBUaGUgbGF5b3V0IHRoYXQgc2hvdWxkIGJlIGFwcGxpZWQgZm9yIHZpZXdzIHdpdGhpbiB0aGlzIG1vZHVsZS4gVGhpcyByZWZlcnMgdG8gYSB2aWV3IG5hbWVcblx0ICogcmVsYXRpdmUgdG8gW1tsYXlvdXRQYXRoXV0uIElmIHRoaXMgaXMgbm90IHNldCwgaXQgbWVhbnMgdGhlIGxheW91dCB2YWx1ZSBvZiB0aGUgW1ttb2R1bGV8cGFyZW50IG1vZHVsZV1dXG5cdCAqIHdpbGwgYmUgdGFrZW4uIElmIHRoaXMgaXMgZmFsc2UsIGxheW91dCB3aWxsIGJlIGRpc2FibGVkIHdpdGhpbiB0aGlzIG1vZHVsZS5cblx0ICogQHR5cGUge3N0cmluZ3xib29sZWFufVxuXHQgKi9cblx0bGF5b3V0OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7b2JqZWN0fVxuXHQgKi9cblx0X21vZHVsZXM6IG51bGwsXG5cblx0LyoqXG4gICAgICogU3RvcmVkIGNvbnRyb2xsZXIgaW5zdGFuY2VzXG5cdCAqIEB0eXBlIHtvYmplY3R9XG5cdCAqL1xuICAgIF9jb250cm9sbGVyczoge30sXG5cblx0LyoqXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGlkLCBtb2R1bGVPYmplY3QsIGNvbmZpZykge1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLm1vZHVsZSA9IG1vZHVsZU9iamVjdDtcblx0XHR0aGlzLl9tb2R1bGVzID0ge307XG5cblx0XHR0aGlzLl9fc3VwZXIoY29uZmlnKTtcblx0fSxcblxuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuY29udHJvbGxlck5hbWVzcGFjZSA9PT0gbnVsbCkge1xuXHRcdFx0dmFyIGluZGV4ID0gSmlpLl8ubGFzdEluZGV4T2YodGhpcy5jbGFzc05hbWUoKSwgJy4nKTtcblx0XHRcdHRoaXMuY29udHJvbGxlck5hbWVzcGFjZSA9IHRoaXMuY2xhc3NOYW1lKCkuc3Vic3RyKDAsIGluZGV4KTtcblx0XHR9XG5cdH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHByb21pc2VzID0gW107XG4gICAgICAgIEppaS5fLmVhY2godGhpcy5fY29tcG9uZW50cywgZnVuY3Rpb24oY29tcG9uZW50KSB7XG4gICAgICAgICAgICBpZiAoSmlpLl8uaXNGdW5jdGlvbihjb21wb25lbnQuc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChjb21wb25lbnQuc3RhcnQoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgICAqL1xuICAgIHN0b3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvbWlzZXMgPSBbXTtcbiAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9jb21wb25lbnRzLCBmdW5jdGlvbihjb21wb25lbnQpIHtcbiAgICAgICAgICAgIGlmIChKaWkuXy5pc0Z1bmN0aW9uKGNvbXBvbmVudC5zdG9wKSkge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goY29tcG9uZW50LnN0b3AoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH0sXG5cblx0Z2V0VW5pcXVlSWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5tb2R1bGUpIHtcblx0XHRcdHZhciBpZCA9IHRoaXMubW9kdWxlLmdldFVuaXF1ZUlkKCkgKyAnLycgKyB0aGlzLmlkO1xuXHRcdFx0cmV0dXJuIEppaS5fcy5sdHJpbShpZCwgJy8nKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuaWQ7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgbW9kdWxlLlxuXHQgKiBAdHlwZSB7c3RyaW5nfVxuXHQgKi9cblx0X2Jhc2VQYXRoOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgbW9kdWxlLlxuXHQgKiBJdCBkZWZhdWx0cyB0byB0aGUgZGlyZWN0b3J5IGNvbnRhaW5pbmcgdGhlIG1vZHVsZSBjbGFzcyBmaWxlLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgbW9kdWxlLlxuXHQgKi9cblx0Z2V0QmFzZVBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fYmFzZVBhdGggPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2Jhc2VQYXRoID0gSmlpLmdldEFsaWFzKCdAJyArIHRoaXMuY2xhc3NOYW1lKCkucmVwbGFjZSgvXFwuW14uXSskLywgJycpKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLl9iYXNlUGF0aDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhlIG1vZHVsZS5cblx0ICogVGhpcyBtZXRob2QgY2FuIG9ubHkgYmUgaW52b2tlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBjb25zdHJ1Y3Rvci5cblx0ICogQHBhcmFtICB7c3RyaW5nfSBwYXRoIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGUgbW9kdWxlLiBUaGlzIGNhbiBiZSBlaXRoZXIgYSBkaXJlY3RvcnkgbmFtZSBvciBhIHBhdGggYWxpYXMuXG5cdCAqL1xuXHRzZXRCYXNlUGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR0aGlzLl9iYXNlUGF0aCA9IEppaS5nZXRBbGlhcyhwYXRoKTtcblx0fSxcblxuXHQvKipcblx0ICogUmV0dXJucyB0aGUgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgdGhlIGNvbnRyb2xsZXIgY2xhc3NlcyBhY2NvcmRpbmcgdG8gW1tjb250cm9sbGVyTmFtZXNwYWNlXV0uXG5cdCAqIE5vdGUgdGhhdCBpbiBvcmRlciBmb3IgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGEgdmFsdWUsIHlvdSBtdXN0IGRlZmluZVxuXHQgKiBhbiBhbGlhcyBmb3IgdGhlIHJvb3QgbmFtZXNwYWNlIG9mIFtbY29udHJvbGxlck5hbWVzcGFjZV1dLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyB0aGUgY29udHJvbGxlciBjbGFzc2VzLlxuXHQgKi9cblx0Z2V0Q29udHJvbGxlclBhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gSmlpLmdldEFsaWFzKCdAJyArIHRoaXMuY29udHJvbGxlck5hbWVzcGFjZS5yZXBsYWNlKCcuJywgJy8nKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSByb290IGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHZpZXcgZmlsZXMgZm9yIHRoaXMgbW9kdWxlXG5cdCAqIEB0eXBlIHtzdHJpbmd9XG5cdCAqL1xuXHRfdmlld1BhdGg6IG51bGwsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSB2aWV3IGZpbGVzIGZvciB0aGlzIG1vZHVsZS5cblx0ICogQHJldHVybiB7c3RyaW5nfSB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdmlldyBmaWxlcy4gRGVmYXVsdHMgdG8gXCJbW2Jhc2VQYXRoXV0vdmlld1wiLlxuXHQgKi9cblx0Z2V0Vmlld1BhdGg6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fdmlld1BhdGggPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX3ZpZXdQYXRoID0gdGhpcy5nZXRCYXNlUGF0aCgpICsgJy92aWV3cyc7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl92aWV3UGF0aDtcblx0fSxcblxuXHQvKipcblx0ICogU2V0cyB0aGUgZGlyZWN0b3J5IHRoYXQgY29udGFpbnMgdGhlIHZpZXcgZmlsZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIHRoZSByb290IGRpcmVjdG9yeSBvZiB2aWV3IGZpbGVzLlxuXHQgKi9cblx0c2V0Vmlld1BhdGg6IGZ1bmN0aW9uIChwYXRoKSB7XG5cdFx0dGhpcy5fdmlld1BhdGggPSBKaWkuZ2V0QWxpYXMocGF0aCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoZSByb290IGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIGxheW91dCB2aWV3IGZpbGVzIGZvciB0aGlzIG1vZHVsZS5cblx0ICogQHR5cGUge3N0cmluZ31cblx0ICovXG5cdF9sYXlvdXRQYXRoOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBsYXlvdXQgdmlldyBmaWxlcyBmb3IgdGhpcyBtb2R1bGUuXG5cdCAqIEByZXR1cm4ge3N0cmluZ30gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIGxheW91dCBmaWxlcy4gRGVmYXVsdHMgdG8gXCJbW3ZpZXdQYXRoXV0vbGF5b3V0c1wiLlxuXHQgKi9cblx0Z2V0TGF5b3V0UGF0aDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9sYXlvdXRQYXRoID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9sYXlvdXRQYXRoID0gdGhpcy5nZXRWaWV3UGF0aCgpICsgJy9sYXlvdXRzJztcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xheW91dFBhdGg7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBsYXlvdXQgZmlsZXMuXG5cdCAqIEBwYXJhbSAge3N0cmluZ30gcGF0aCB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgbGF5b3V0IGZpbGVzLlxuXHQgKi9cblx0c2V0TGF5b3V0UGF0aDogZnVuY3Rpb24gKHBhdGgpIHtcblx0XHR0aGlzLl9sYXlvdXRQYXRoID0gSmlpLmdldEFsaWFzKHBhdGgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVja3Mgd2hldGhlciB0aGUgY2hpbGQgbW9kdWxlIG9mIHRoZSBzcGVjaWZpZWQgSUQgZXhpc3RzLlxuXHQgKiBUaGlzIG1ldGhvZCBzdXBwb3J0cyBjaGVja2luZyB0aGUgZXhpc3RlbmNlIG9mIGJvdGggY2hpbGQgYW5kIGdyYW5kIGNoaWxkIG1vZHVsZXMuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBtb2R1bGUgSUQuIEZvciBncmFuZCBjaGlsZCBtb2R1bGVzLCB1c2UgSUQgcGF0aCByZWxhdGl2ZSB0byB0aGlzIG1vZHVsZSAoZS5nLiBgYWRtaW4vY29udGVudGApLlxuXHQgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBuYW1lZCBtb2R1bGUgZXhpc3RzLiBCb3RoIGxvYWRlZCBhbmQgdW5sb2FkZWQgbW9kdWxlc1xuXHQgKiBhcmUgY29uc2lkZXJlZC5cblx0ICovXG5cdGhhc01vZHVsZTogZnVuY3Rpb24gKGlkKSB7XG5cdFx0dmFyIGluZGV4ID0gSmlpLl8uaW5kZXhPZihpZCwgJy4nKTtcblx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHR2YXIgbW9kdWxlSWQgPSBpZC5zdWJzdHIoMCwgaW5kZXgpO1xuXHRcdFx0dmFyIGNoaWxkTW9kdWxlSWQgPSBpZC5zdWJzdHIoaW5kZXggKyAxKTtcblxuXHRcdFx0Ly8gQ2hlY2sgc3ViLW1vZHVsZVxuXHRcdFx0dmFyIG1vZHVsZU9iamVjdCA9IHRoaXMuZ2V0TW9kdWxlKG1vZHVsZUlkKTtcblx0XHRcdHJldHVybiBtb2R1bGVPYmplY3QgIT09IG51bGwgPyBtb2R1bGVPYmplY3QuaGFzTW9kdWxlKGNoaWxkTW9kdWxlSWQpIDogZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEppaS5fLmhhcyh0aGlzLl9tb2R1bGVzW2lkXSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHJpZXZlcyB0aGUgY2hpbGQgbW9kdWxlIG9mIHRoZSBzcGVjaWZpZWQgSUQuXG5cdCAqIFRoaXMgbWV0aG9kIHN1cHBvcnRzIHJldHJpZXZpbmcgYm90aCBjaGlsZCBtb2R1bGVzIGFuZCBncmFuZCBjaGlsZCBtb2R1bGVzLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgbW9kdWxlIElEIChjYXNlLXNlbnNpdGl2ZSkuIFRvIHJldHJpZXZlIGdyYW5kIGNoaWxkIG1vZHVsZXMsXG5cdCAqIHVzZSBJRCBwYXRoIHJlbGF0aXZlIHRvIHRoaXMgbW9kdWxlIChlLmcuIGBhZG1pbi9jb250ZW50YCkuXG5cdCAqIEByZXR1cm4ge0ppaS5iYXNlLk1vZHVsZX0gdGhlIG1vZHVsZSBpbnN0YW5jZSwgbnVsbCBpZiB0aGUgbW9kdWxlIGRvZXMgbm90IGV4aXN0LlxuXHQgKi9cblx0Z2V0TW9kdWxlOiBmdW5jdGlvbiAoaWQpIHtcblx0XHQvLyBHZXQgc3ViLW1vZHVsZVxuXHRcdHZhciBpbmRleCA9IEppaS5fLmluZGV4T2YoaWQsICcuJyk7XG5cdFx0aWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0dmFyIG1vZHVsZUlkID0gaWQuc3Vic3RyKDAsIGluZGV4KTtcblx0XHRcdHZhciBjaGlsZE1vZHVsZUlkID0gaWQuc3Vic3RyKGluZGV4ICsgMSk7XG5cblx0XHRcdHZhciBtb2R1bGVPYmplY3QgPSB0aGlzLmdldE1vZHVsZShtb2R1bGVJZCk7XG5cdFx0XHRyZXR1cm4gbW9kdWxlT2JqZWN0ICE9PSBudWxsID8gbW9kdWxlT2JqZWN0LmdldE1vZHVsZShjaGlsZE1vZHVsZUlkKSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX21vZHVsZXNbaWRdIHx8IG51bGw7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFkZHMgYSBzdWItbW9kdWxlIHRvIHRoaXMgbW9kdWxlLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgbW9kdWxlIElEXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuTW9kdWxlfGFycmF5fG51bGx9IG1vZHVsZU9iamVjdCB0aGUgc3ViLW1vZHVsZSB0byBiZSBhZGRlZCB0byB0aGlzIG1vZHVsZS4gVGhpcyBjYW5cblx0ICogYmUgb25lIG9mIHRoZSBmb2xsb3dpbmdzOlxuXHQgKlxuXHQgKiAtIGEgW1tKaWkuYmFzZS5Nb2R1bGVdXSBvYmplY3Rcblx0ICogLSBhIGNvbmZpZ3VyYXRpb24gYXJyYXk6IHdoZW4gW1tnZXRNb2R1bGUoKV1dIGlzIGNhbGxlZCBpbml0aWFsbHksIHRoZSBhcnJheVxuXHQgKiAgIHdpbGwgYmUgdXNlZCB0byBpbnN0YW50aWF0ZSB0aGUgc3ViLW1vZHVsZVxuXHQgKiAtIG51bGw6IHRoZSBuYW1lZCBzdWItbW9kdWxlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoaXMgbW9kdWxlXG5cdCAqL1xuXHRzZXRNb2R1bGU6IGZ1bmN0aW9uIChpZCwgbW9kdWxlT2JqZWN0KSB7XG5cdFx0aWYgKG1vZHVsZU9iamVjdCA9PT0gbnVsbCkge1xuXHRcdFx0ZGVsZXRlIHRoaXMuX21vZHVsZXNbaWRdO1xuICAgICAgICB9IGVsc2Uge1xuXHRcdFx0Ly8gQ3JlYXRlIG1vZHVsZSBpbnN0YW5jZVxuICAgICAgICAgICAgaWYgKCEobW9kdWxlT2JqZWN0IGluc3RhbmNlb2YgSmlpLmJhc2UuTW9kdWxlKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZU9iamVjdCA9IEppaS5jcmVhdGVPYmplY3QobW9kdWxlT2JqZWN0LCBpZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG5cblx0XHRcdC8vIEFkZCBsaW5rXG5cdFx0XHR0aGlzLl9tb2R1bGVzW2lkXSA9IG1vZHVsZU9iamVjdDtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHN1Yi1tb2R1bGVzIGluIHRoaXMgbW9kdWxlLlxuXHQgKiBAcmV0dXJuIHtKaWkuYmFzZS5Nb2R1bGVbXX0gdGhlIG1vZHVsZXMgKGluZGV4ZWQgYnkgdGhlaXIgSURzKVxuXHQgKi9cblx0Z2V0TW9kdWxlczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9tb2R1bGVzO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZWdpc3RlcnMgc3ViLW1vZHVsZXMgaW4gdGhlIGN1cnJlbnQgbW9kdWxlLlxuXHQgKlxuXHQgKiBFYWNoIHN1Yi1tb2R1bGUgc2hvdWxkIGJlIHNwZWNpZmllZCBhcyBhIG5hbWUtdmFsdWUgcGFpciwgd2hlcmVcblx0ICogbmFtZSByZWZlcnMgdG8gdGhlIElEIG9mIHRoZSBtb2R1bGUgYW5kIHZhbHVlIHRoZSBtb2R1bGUgb3IgYSBjb25maWd1cmF0aW9uXG5cdCAqIGFycmF5IHRoYXQgY2FuIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBtb2R1bGUuIEluIHRoZSBsYXR0ZXIgY2FzZSwgW1tKaWkuY3JlYXRlT2JqZWN0KCldXVxuXHQgKiB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIHRoZSBtb2R1bGUuXG5cdCAqXG5cdCAqIElmIGEgbmV3IHN1Yi1tb2R1bGUgaGFzIHRoZSBzYW1lIElEIGFzIGFuIGV4aXN0aW5nIG9uZSwgdGhlIGV4aXN0aW5nIG9uZSB3aWxsIGJlIG92ZXJ3cml0dGVuIHNpbGVudGx5LlxuXHQgKlxuXHQgKiBUaGUgZm9sbG93aW5nIGlzIGFuIGV4YW1wbGUgZm9yIHJlZ2lzdGVyaW5nIHR3byBzdWItbW9kdWxlczpcblx0ICpcblx0ICogfn5+XG5cdCAqIFtcblx0ICogICAgICdjb21tZW50JyA9PiBbXG5cdCAqICAgICAgICAgJ2NsYXNzJyA9PiAnYXBwXFxtb2R1bGVzXFxjb21tZW50XFxDb21tZW50TW9kdWxlJyxcblx0ICogICAgICAgICAnZGInID0+ICdkYicsXG5cdCAqICAgICBdLFxuXHQgKiAgICAgJ2Jvb2tpbmcnID0+IFsnY2xhc3MnID0+ICdhcHBcXG1vZHVsZXNcXGJvb2tpbmdcXEJvb2tpbmdNb2R1bGUnXSxcblx0ICogXVxuXHQgKiB+fn5cblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG1vZHVsZXMgbW9kdWxlcyAoaWQgPT4gbW9kdWxlIGNvbmZpZ3VyYXRpb24gb3IgaW5zdGFuY2VzKVxuXHQgKi9cblx0c2V0TW9kdWxlczogZnVuY3Rpb24gKG1vZHVsZXMpIHtcblx0XHRKaWkuXy5lYWNoKG1vZHVsZXMsIEppaS5fLmJpbmQoZnVuY3Rpb24gKG1vZHVsZU9iamVjdCwgaWQpIHtcblx0XHRcdHRoaXMuc2V0TW9kdWxlKGlkLCBtb2R1bGVPYmplY3QpO1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHQvKipcblx0ICogUnVucyBhIGNvbnRyb2xsZXIgYWN0aW9uIHNwZWNpZmllZCBieSBhIHJvdXRlLlxuXHQgKiBUaGlzIG1ldGhvZCBwYXJzZXMgdGhlIHNwZWNpZmllZCByb3V0ZSBhbmQgY3JlYXRlcyB0aGUgY29ycmVzcG9uZGluZyBjaGlsZCBtb2R1bGUocyksIGNvbnRyb2xsZXIgYW5kIGFjdGlvblxuXHQgKiBpbnN0YW5jZXMuIEl0IHRoZW4gY2FsbHMgW1tKaWkuYmFzZS5Db250cm9sbGVyOjpydW5BY3Rpb24oKV1dIHRvIHJ1biB0aGUgYWN0aW9uIHdpdGggdGhlIGdpdmVuIHBhcmFtZXRlcnMuXG5cdCAqIElmIHRoZSByb3V0ZSBpcyBlbXB0eSwgdGhlIG1ldGhvZCB3aWxsIHVzZSBbW2RlZmF1bHRSb3V0ZV1dLlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gcm91dGUgdGhlIHJvdXRlIHRoYXQgc3BlY2lmaWVzIHRoZSBhY3Rpb24uXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxuXHQgKiBAcmV0dXJuIHtQcm9taXNlfSB0aGUgcmVzdWx0IG9mIHRoZSBhY3Rpb24uXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvbn0gaWYgdGhlIHJlcXVlc3RlZCByb3V0ZSBjYW5ub3QgYmUgcmVzb2x2ZWQgaW50byBhbiBhY3Rpb24gc3VjY2Vzc2Z1bGx5XG5cdCAqL1xuXHRydW5BY3Rpb246IGZ1bmN0aW9uIChyb3V0ZSwgY29udGV4dCkge1xuICAgICAgICB2YXIgcm91dGVQYXJhbXMgPSB0aGlzLl9wYXJzZVJvdXRlKHJvdXRlKTtcblxuICAgICAgICB2YXIgZnVsbFJvdXRlID0gcm91dGVQYXJhbXMuaWQgKyAnLycgKyAocm91dGVQYXJhbXMucm91dGUgfHwgJ2luZGV4Jyk7XG4gICAgICAgIGlmIChKaWkuXy5oYXModGhpcy5pbmxpbmVBY3Rpb25zLCBmdWxsUm91dGUpKSB7XG4gICAgICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5pbmxpbmVBY3Rpb25zW2Z1bGxSb3V0ZV0gaW5zdGFuY2VvZiBKaWkuYmFzZS5BY3Rpb24gP1xuICAgICAgICAgICAgICAgIHRoaXMuaW5saW5lQWN0aW9uc1tmdWxsUm91dGVdIDpcbiAgICAgICAgICAgICAgICBuZXcgSmlpLnJlcXVlc3QuQW5vbnltb3VzQWN0aW9uKGZ1bGxSb3V0ZSwgdGhpcywgdGhpcy5pbmxpbmVBY3Rpb25zW2Z1bGxSb3V0ZV0pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iZWZvcmVBY3Rpb24oYWN0aW9uLCBjb250ZXh0KS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbi5ydW5XaXRoUGFyYW1zKGNvbnRleHQpO1xuICAgICAgICAgICAgICAgIH0pLnRoZW4oZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIUppaS5fLmlzVW5kZWZpbmVkKGRhdGEpICYmIGNvbnRleHQucmVzcG9uc2UgaW5zdGFuY2VvZiBKaWkuYmFzZS5SZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC5yZXNwb25zZS5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQucmVzcG9uc2Uuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmVmb3JlQWN0aW9uKGFjdGlvbiwgY29udGV4dCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICAgICAgfS5iaW5kKHRoaXMpKS5jYXRjaChKaWkuY2F0Y2hIYW5kbGVyKTtcbiAgICAgICAgfVxuXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5jcmVhdGVDb250cm9sbGVyKHJvdXRlKTtcblx0XHRpZiAocGFydHMgIT09IG51bGwpIHtcblx0XHRcdC8qKiBAdHlwZSB7SmlpLmJhc2UuQ29udHJvbGxlcn0gKi9cblx0XHRcdHZhciBjb250cm9sbGVyID0gcGFydHNbMF07XG5cdFx0XHR2YXIgYWN0aW9uSWQgPSBwYXJ0c1sxXTtcblxuXHRcdFx0cmV0dXJuIGNvbnRyb2xsZXIucnVuQWN0aW9uKGFjdGlvbklkLCBjb250ZXh0KTtcblx0XHR9XG5cblx0XHR2YXIgaWQgPSB0aGlzLmdldFVuaXF1ZUlkKCk7XG5cdFx0dmFyIHJlcXVlc3ROYW1lID0gaWQgPyBpZCArICcvJyArIHJvdXRlIDogcm91dGU7XG5cdFx0Ly90aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFJvdXRlRXhjZXB0aW9uKCdVbmFibGUgdG8gcmVzb2x2ZSB0aGUgcmVxdWVzdCBgJyArIHJlcXVlc3ROYW1lICsgJ2AuJyk7XG5cdFx0SmlpLmluZm8oJ1VuYWJsZSB0byByZXNvbHZlIHRoZSByZXF1ZXN0IGAnICsgcmVxdWVzdE5hbWUgKyAnYC4nKTtcblx0fSxcblxuXHQvKipcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlXG5cdCAqIEByZXR1cm4ge2Jvb2xlYW59XG5cdCAqL1xuXHRleGlzdHNSb3V0ZTogZnVuY3Rpb24ocm91dGUpIHtcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gdGhpcy5fcGFyc2VSb3V0ZShyb3V0ZSk7XG4gICAgICAgIHZhciBpZCA9IHJvdXRlUGFyYW1zLmlkO1xuICAgICAgICByb3V0ZSA9IHJvdXRlUGFyYW1zLnJvdXRlO1xuXG4gICAgICAgIGlmIChKaWkuXy5oYXModGhpcy5pbmxpbmVBY3Rpb25zLCBpZCArICcvJyArIChyb3V0ZSB8fCAnaW5kZXgnKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cblx0XHRpZiAoSmlpLl8uaGFzKHRoaXMuY29udHJvbGxlck1hcCwgaWQpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHR2YXIgbW9kdWxlT2JqZWN0ID0gdGhpcy5nZXRNb2R1bGUoaWQpO1xuXHRcdGlmIChtb2R1bGVPYmplY3QgIT09IG51bGwpIHtcblx0XHRcdHJldHVybiBtb2R1bGVPYmplY3QuZXhpc3RzUm91dGUocm91dGUpO1xuXHRcdH1cblxuXHRcdGlmICgvXlthLXowLTlcXFxcLV9dKyQvLnRlc3QoaWQpKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lID0gaWQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBpZC5zbGljZSgxKTtcblx0XHRcdGNsYXNzTmFtZSA9IGNsYXNzTmFtZS5yZXBsYWNlKCctJywgJycpICsgJ0NvbnRyb2xsZXInO1xuXHRcdFx0Y2xhc3NOYW1lID0gdGhpcy5jb250cm9sbGVyTmFtZXNwYWNlICsgJy4nICsgY2xhc3NOYW1lO1xuXG5cdFx0XHR2YXIgY29udHJvbGxlckNsYXNzID0gSmlpLm5hbWVzcGFjZShjbGFzc05hbWUpO1xuXHRcdFx0aWYgKEppaS5fLmlzRnVuY3Rpb24oY29udHJvbGxlckNsYXNzKSkge1xuXHRcdFx0XHR2YXIgY29udHJvbGxlciA9IG5ldyBjb250cm9sbGVyQ2xhc3MoaWQsIHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gY29udHJvbGxlci5oYXNBY3Rpb24ocm91dGUpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIGNvbnRyb2xsZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGNvbnRyb2xsZXIgSUQuXG5cdCAqXG5cdCAqIFRoZSBjb250cm9sbGVyIGlzIGNyZWF0ZWQgd2l0aGluIHRoaXMgbW9kdWxlLiBUaGUgbWV0aG9kIGZpcnN0IGF0dGVtcHRzIHRvXG5cdCAqIGNyZWF0ZSB0aGUgY29udHJvbGxlciBiYXNlZCBvbiB0aGUgW1tjb250cm9sbGVyTWFwXV0gb2YgdGhlIG1vZHVsZS5cblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IHJvdXRlIHRoZSByb3V0ZSBjb25zaXN0aW5nIG9mIG1vZHVsZSwgY29udHJvbGxlciBhbmQgYWN0aW9uIElEcy5cblx0ICogQHJldHVybiB7W118bnVsbH0gSWYgdGhlIGNvbnRyb2xsZXIgaXMgY3JlYXRlZCBzdWNjZXNzZnVsbHksIGl0IHdpbGwgYmUgcmV0dXJuZWQgdG9nZXRoZXJcblx0ICogd2l0aCB0aGUgcmVxdWVzdGVkIGFjdGlvbiBJRC4gT3RoZXJ3aXNlIGZhbHNlIHdpbGwgYmUgcmV0dXJuZWQuXG5cdCAqIEB0aHJvd3Mge0ppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb259IGlmIHRoZSBjb250cm9sbGVyIGNsYXNzIGFuZCBpdHMgZmlsZSBkbyBub3QgbWF0Y2guXG5cdCAqL1xuXHRjcmVhdGVDb250cm9sbGVyOiBmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gdGhpcy5fcGFyc2VSb3V0ZShyb3V0ZSk7XG4gICAgICAgIHZhciBpZCA9IHJvdXRlUGFyYW1zLmlkO1xuICAgICAgICByb3V0ZSA9IHJvdXRlUGFyYW1zLnJvdXRlO1xuXG5cdFx0dmFyIGNvbnRyb2xsZXIgPSBudWxsO1xuXHRcdGlmIChKaWkuXy5oYXModGhpcy5jb250cm9sbGVyTWFwLCBpZCkpIHtcblx0XHRcdGNvbnRyb2xsZXIgPSBKaWkuY3JlYXRlT2JqZWN0KHRoaXMuY29udHJvbGxlck1hcFtpZF0sIGlkLCB0aGlzKTtcblx0XHRcdHJldHVybiBjb250cm9sbGVyICE9PSBudWxsID8gW2NvbnRyb2xsZXIsIHJvdXRlXSA6IG51bGw7XG5cdFx0fVxuXG5cdFx0dmFyIG1vZHVsZU9iamVjdCA9IHRoaXMuZ2V0TW9kdWxlKGlkKTtcblx0XHRpZiAobW9kdWxlT2JqZWN0ICE9PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4gbW9kdWxlT2JqZWN0LmNyZWF0ZUNvbnRyb2xsZXIocm91dGUpO1xuXHRcdH1cblxuXHRcdGlmICgvXlthLXowLTlcXFxcLV9dKyQvLnRlc3QoaWQpKSB7XG5cblx0XHRcdHZhciBjbGFzc05hbWUgPSBpZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGlkLnNsaWNlKDEpO1xuXHRcdFx0Y2xhc3NOYW1lID0gY2xhc3NOYW1lLnJlcGxhY2UoJy0nLCAnJykgKyAnQ29udHJvbGxlcic7XG5cdFx0XHRjbGFzc05hbWUgPSB0aGlzLmNvbnRyb2xsZXJOYW1lc3BhY2UgKyAnLicgKyBjbGFzc05hbWU7XG5cbiAgICAgICAgICAgIC8vIENhY2hlIGNvbnRyb2xsZXIgaW5zdGFuY2VzXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2NvbnRyb2xsZXJzW2NsYXNzTmFtZV0pIHtcblxuICAgICAgICAgICAgICAgIHZhciBjb250cm9sbGVyQ2xhc3MgPSBKaWkubmFtZXNwYWNlKGNsYXNzTmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKEppaS5fLmlzRnVuY3Rpb24oY29udHJvbGxlckNsYXNzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb250cm9sbGVyc1tjbGFzc05hbWVdID0gbmV3IGNvbnRyb2xsZXJDbGFzcyhpZCwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodGhpcy5fY29udHJvbGxlcnNbY2xhc3NOYW1lXSBpbnN0YW5jZW9mIEppaS5iYXNlLkNvbnRyb2xsZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbihcIkNvbnRyb2xsZXIgY2xhc3MgbXVzdCBleHRlbmQgZnJvbSBKaWkuYmFzZS5Db250cm9sbGVyLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblx0XHRcdH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIgPSB0aGlzLl9jb250cm9sbGVyc1tjbGFzc05hbWVdIHx8IG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbnRyb2xsZXIgIT09IG51bGwgPyBbY29udHJvbGxlciwgcm91dGVdIDogbnVsbDtcblx0fSxcblxuICAgIF9wYXJzZVJvdXRlOiBmdW5jdGlvbihyb3V0ZSkge1xuICAgICAgICBpZiAocm91dGUgPT09ICcnKSB7XG4gICAgICAgICAgICByb3V0ZSA9IHRoaXMuZGVmYXVsdFJvdXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgcm91dGUgPSBKaWkuX3MudHJpbShyb3V0ZSwgJy8nKTtcblxuICAgICAgICB2YXIgaW5kZXggPSByb3V0ZS5pbmRleE9mKCcvJyk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IHJvdXRlLnN1YnN0cigwLCBpbmRleCksXG4gICAgICAgICAgICAgICAgcm91dGU6IHJvdXRlLnN1YnN0cihpbmRleCArIDEpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogcm91dGUsXG4gICAgICAgICAgICByb3V0ZTogJydcbiAgICAgICAgfVxuICAgIH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgcmlnaHQgYmVmb3JlIGFuIGFjdGlvbiBvZiB0aGlzIG1vZHVsZSBpcyB0byBiZSBleGVjdXRlZCAoYWZ0ZXIgYWxsIHBvc3NpYmxlIGZpbHRlcnMuKVxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIGxhc3QtbWludXRlIHByZXBhcmF0aW9uIGZvciB0aGUgYWN0aW9uLlxuXHQgKiBNYWtlIHN1cmUgeW91IGNhbGwgdGhlIHBhcmVudCBpbXBsZW1lbnRhdGlvbiBzbyB0aGF0IHRoZSByZWxldmFudCBldmVudCBpcyB0cmlnZ2VyZWQuXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQWN0aW9ufSBhY3Rpb24gdGhlIGFjdGlvbiB0byBiZSBleGVjdXRlZC5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqIEByZXR1cm4ge1Byb21pc2V9XG5cdCAqL1xuXHRiZWZvcmVBY3Rpb246IGZ1bmN0aW9uIChhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKHRoaXMuX19zdGF0aWMuRVZFTlRfQkVGT1JFX0FDVElPTiwgbmV3IEppaS5iYXNlLkFjdGlvbkV2ZW50KHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgcmlnaHQgYWZ0ZXIgYW4gYWN0aW9uIG9mIHRoaXMgbW9kdWxlIGhhcyBiZWVuIGV4ZWN1dGVkLlxuXHQgKiBZb3UgbWF5IG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGRvIHNvbWUgcG9zdHByb2Nlc3NpbmcgZm9yIHRoZSBhY3Rpb24uXG5cdCAqIE1ha2Ugc3VyZSB5b3UgY2FsbCB0aGUgcGFyZW50IGltcGxlbWVudGF0aW9uIHNvIHRoYXQgdGhlIHJlbGV2YW50IGV2ZW50IGlzIHRyaWdnZXJlZC5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5BY3Rpb259IGFjdGlvbiB0aGUgYWN0aW9uIGp1c3QgZXhlY3V0ZWQuXG4gICAgICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cblx0ICovXG5cdGFmdGVyQWN0aW9uOiBmdW5jdGlvbiAoYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcih0aGlzLl9fc3RhdGljLkVWRU5UX0FGVEVSX0FDVElPTiwgbmV3IEppaS5iYXNlLkFjdGlvbkV2ZW50KHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9uLFxuICAgICAgICAgICAgY29udGV4dDogY29udGV4dFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcblx0fVxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0NvbnRleHRcIjoxMzJ9XSwxMzg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG4vKipcbiAqXG4gKiBAY2xhc3MgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuT2JqZWN0JywgLyoqIEBsZW5kcyBKaWkuYmFzZS5PYmplY3QucHJvdG90eXBlICove1xuXG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5iYXNlLk9iamVjdCAqL3tcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBmdWxsIGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdGNsYXNzTmFtZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX19jbGFzc05hbWU7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybiBleHRlbmRlZCBjbGFzcyBuYW1lIHdpdGggbmFtZXNwYWNlXG5cdFx0ICogQHJldHVybnMge3N0cmluZ31cblx0XHQgKi9cblx0XHRwYXJlbnRDbGFzc05hbWU6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLl9fcGFyZW50Q2xhc3NOYW1lO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8qKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gW2NvbmZpZ11cblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqL1xuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKGNvbmZpZykge1xuXHRcdHRoaXMuX19zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG5cdFx0Ly8gQXBwbHkgY29uZmlndXJhdGlvbiB0byBpbnN0YW5jZVxuXHRcdGlmIChKaWkuXy5pc09iamVjdChjb25maWcpKSB7XG5cdFx0XHRKaWkuY29uZmlndXJlKHRoaXMsIGNvbmZpZyk7XG5cdFx0fVxuXG5cdFx0Ly8gUnVuIGN1c3RvbSBpbml0IG1ldGhvZFxuXHRcdHRoaXMuaW5pdCgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDdXN0b21pemVkIGluaXRpYWxpemUgbWV0aG9kXG5cdCAqL1xuXHRpbml0OiBmdW5jdGlvbiAoKSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE1ldGhvZCBkZWZpbmVkIGpzZG9jIGZvciBoaWRlIGVycm9ycyBpbiBJREVcblx0ICogQHBhcmFtIHsuLi4qfSBbcGFyYW1zXVxuXHQgKiBAcHJvdGVjdGVkXG5cdCAqL1xuXHRfX3N1cGVyOiBmdW5jdGlvbiAocGFyYW1zKSB7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFJldHVybiBmdWxsIGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0ICogQHJldHVybnMge3N0cmluZ31cblx0ICovXG5cdGNsYXNzTmFtZTogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9fY2xhc3NOYW1lO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXR1cm4gZXh0ZW5kZWQgY2xhc3MgbmFtZSB3aXRoIG5hbWVzcGFjZVxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHQgKi9cblx0cGFyZW50Q2xhc3NOYW1lOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX19wYXJlbnRDbGFzc05hbWU7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1fV0sMTM5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5iYXNlLlJlcXVlc3RcbiAqIEBleHRlbmRzIEppaS5iYXNlLkNvbXBvbmVudFxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5iYXNlLlJlcXVlc3QnLCAvKiogQGxlbmRzIEppaS5iYXNlLlJlcXVlc3QucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQ29tcG9uZW50LFxuXG5cdC8qKlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7c3RyaW5nfG51bGx9XG5cdCAqL1xuXHRnZXRNZXRob2Q6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHQvKipcblx0ICogUmVzb2x2ZXMgdGhlIGN1cnJlbnQgcmVxdWVzdCBpbnRvIGEgcm91dGUgYW5kIHRoZSBhc3NvY2lhdGVkIHBhcmFtZXRlcnMuXG5cdCAqIEByZXR1cm5zIHthcnJheXxudWxsfSB0aGUgZmlyc3QgZWxlbWVudCBpcyB0aGUgcm91dGUsIGFuZCB0aGUgc2Vjb25kIGlzIHRoZSBhc3NvY2lhdGVkIHBhcmFtZXRlcnMuXG5cdCAqL1xuXHRyZXNvbHZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0X3BhdGhJbmZvOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBSZXR1cm5zIHRoZSBwYXRoIGluZm8gb2YgdGhlIGN1cnJlbnRseSByZXF1ZXN0ZWQgVVJMLlxuXHQgKiBBIHBhdGggaW5mbyByZWZlcnMgdG8gdGhlIHBhcnQgdGhhdCBpcyBhZnRlciB0aGUgZW50cnkgc2NyaXB0IGFuZCBiZWZvcmUgdGhlIHF1ZXN0aW9uIG1hcmsgKHF1ZXJ5IHN0cmluZykuXG5cdCAqIFRoZSBzdGFydGluZyBhbmQgZW5kaW5nIHNsYXNoZXMgYXJlIGJvdGggcmVtb3ZlZC5cblx0ICogQHJldHVybnMge3N0cmluZ30gUGFydCBvZiB0aGUgcmVxdWVzdCBVUkwgdGhhdCBpcyBhZnRlciB0aGUgZW50cnkgc2NyaXB0IGFuZCBiZWZvcmUgdGhlIHF1ZXN0aW9uIG1hcmsuXG5cdCAqIE5vdGUsIHRoZSByZXR1cm5lZCBwYXRoIGluZm8gaXMgYWxyZWFkeSBVUkwtZGVjb2RlZC5cblx0ICovXG5cdGdldFBhdGhJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BhdGhJbmZvID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLl9wYXRoSW5mbyA9IHRoaXMuX3BhcnNlUGF0aEluZm8oKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGhJbmZvO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBTZXRzIHRoZSBwYXRoIGluZm8gb2YgdGhlIGN1cnJlbnQgcmVxdWVzdC5cblx0ICogVGhpcyBtZXRob2QgaXMgbWFpbmx5IHByb3ZpZGVkIGZvciB0ZXN0aW5nIHB1cnBvc2UuXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZSBUaGUgcGF0aCBpbmZvIG9mIHRoZSBjdXJyZW50IHJlcXVlc3Rcblx0ICovXG5cdHNldFBhdGhJbmZvOiBmdW5jdGlvbiAodmFsdWUpIHtcblx0XHR0aGlzLl9wYXRoSW5mbyA9IEppaS5fcy5sdHJpbSh2YWx1ZSwgJy8nKTtcblx0fSxcblxuXHRfcGFyc2VQYXRoSW5mbzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAnJztcblx0fSxcblxuXHRfaG9zdEluZm86IG51bGwsXG5cblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIHNjaGVtYSBhbmQgaG9zdCBwYXJ0IG9mIHRoZSBjdXJyZW50IHJlcXVlc3QgVVJMLlxuXHQgKiBUaGUgcmV0dXJuZWQgVVJMIGRvZXMgbm90IGhhdmUgYW4gZW5kaW5nIHNsYXNoLlxuXHQgKiBCeSBkZWZhdWx0IHRoaXMgaXMgZGV0ZXJtaW5lZCBiYXNlZCBvbiB0aGUgdXNlciByZXF1ZXN0IGluZm9ybWF0aW9uLlxuXHQgKiBZb3UgbWF5IGV4cGxpY2l0bHkgc3BlY2lmeSBpdCBieSBzZXR0aW5nIHRoZSBzZXRIb3N0SW5mbygpLlxuXHQgKiBAcmV0dXJuIHtzdHJpbmd9IFNjaGVtYSBhbmQgaG9zdG5hbWUgcGFydCAod2l0aCBwb3J0IG51bWJlciBpZiBuZWVkZWQpIG9mIHRoZSByZXF1ZXN0IFVSTFxuXHQgKi9cblx0Z2V0SG9zdEluZm86IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faG9zdEluZm8gPT09IG51bGwpIHtcblx0XHRcdHRoaXMuX2hvc3RJbmZvID0gdGhpcy5fcGFyc2VIb3N0SW5mbygpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faG9zdEluZm87XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNldHMgdGhlIHNjaGVtYSBhbmQgaG9zdCBwYXJ0IG9mIHRoZSBhcHBsaWNhdGlvbiBVUkwuXG5cdCAqIFRoaXMgc2V0dGVyIGlzIHByb3ZpZGVkIGluIGNhc2UgdGhlIHNjaGVtYSBhbmQgaG9zdG5hbWUgY2Fubm90IGJlIGRldGVybWluZWRcblx0ICogb24gY2VydGFpbiBXZWIgc2VydmVycy5cblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIFRoZSBzY2hlbWEgYW5kIGhvc3QgcGFydCBvZiB0aGUgYXBwbGljYXRpb24gVVJMLiBUaGUgdHJhaWxpbmcgc2xhc2hlcyB3aWxsIGJlIHJlbW92ZWQuXG5cdCAqL1xuXHRzZXRIb3N0SW5mbzogZnVuY3Rpb24gKHZhbHVlKSB7XG5cdFx0dGhpcy5faG9zdEluZm8gPSBKaWkuX3MucnRyaW0odmFsdWUsICcvJyk7XG5cdFx0cmV0dXJuIHRoaXMuX2hvc3RJbmZvO1xuXHR9LFxuXG5cdF9wYXJzZUhvc3RJbmZvOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNX1dLDE0MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuYmFzZS5SZXNwb25zZVxuICogQGV4dGVuZHMgSmlpLmJhc2UuQ29tcG9uZW50XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmJhc2UuUmVzcG9uc2UnLCB7XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5Db21wb25lbnQsXG5cblx0LyoqXG5cdCAqIEB2YXIge2Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlc3BvbnNlIGhhcyBiZWVuIHNlbnQuIElmIHRoaXMgaXMgdHJ1ZSwgY2FsbGluZyBbW3NlbmQoKV1dIHdpbGwgZG8gbm90aGluZy5cblx0ICovXG5cdGlzU2VudDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3JpZ2luYWwgcmVzcG9uc2UgZGF0YVxuICAgICAqIEB0eXBlIHsqfVxuICAgICAqL1xuICAgIGRhdGE6IG51bGwsXG5cblx0LyoqXG5cdCAqIFNlbmRzIHRoZSByZXNwb25zZSB0byBjbGllbnQuXG5cdCAqL1xuXHRzZW5kOiBmdW5jdGlvbiAoKSB7XG5cdH1cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1fV0sMTQxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cbiAqIEBleHRlbmRzIEVycm9yXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb24nLCAvKiogQGxlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uLnByb3RvdHlwZSAqLyB7XG5cblx0X19leHRlbmRzOiBFcnJvcixcblxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0XHRpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcblx0XHRcdEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuX19zdGF0aWMpO1xuXHRcdH1cblx0XHR0aGlzLm5hbWUgPSB0aGlzLl9fY2xhc3NOYW1lO1xuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2UgfHwgJyc7XG5cdH1cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNX1dLDE0MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQXBwbGljYXRpb25FeGNlcHRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENhbGxFeGNlcHRpb25cbiAqIEBleHRlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENhbGxFeGNlcHRpb24nLCAvKiogQGxlbmRzIEppaS5leGNlcHRpb25zLkludmFsaWRDYWxsRXhjZXB0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vQXBwbGljYXRpb25FeGNlcHRpb25cIjoxNDF9XSwxNDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0FwcGxpY2F0aW9uRXhjZXB0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5leGNlcHRpb25zLkludmFsaWRDb25maWdFeGNlcHRpb25cbiAqIEBleHRlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbicsIC8qKiBAbGVuZHMgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZENvbmZpZ0V4Y2VwdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0FwcGxpY2F0aW9uRXhjZXB0aW9uXCI6MTQxfV0sMTQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9BcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb25cbiAqIEBleHRlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFBhcmFtRXhjZXB0aW9uJywgLyoqIEBsZW5kcyBKaWkuZXhjZXB0aW9ucy5JbnZhbGlkUGFyYW1FeGNlcHRpb24ucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9BcHBsaWNhdGlvbkV4Y2VwdGlvblwiOjE0MX1dLDE0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4vQXBwbGljYXRpb25FeGNlcHRpb24nKTtcblxuLyoqXG4gKiBAY2xhc3MgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFJvdXRlRXhjZXB0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5leGNlcHRpb25zLkludmFsaWRSb3V0ZUV4Y2VwdGlvbicsIC8qKiBAbGVuZHMgSmlpLmV4Y2VwdGlvbnMuSW52YWxpZFJvdXRlRXhjZXB0aW9uLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4vQXBwbGljYXRpb25FeGNlcHRpb25cIjoxNDF9XSwxNDY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuL0FwcGxpY2F0aW9uRXhjZXB0aW9uJyk7XG5cbi8qKlxuICogQGNsYXNzIEppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvblxuICogQGV4dGVuZHMgSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuZXhjZXB0aW9ucy5Ob3RTdXBwb3J0ZWRFeGNlcHRpb24nLCAvKiogQGxlbmRzIEppaS5leGNlcHRpb25zLk5vdFN1cHBvcnRlZEV4Y2VwdGlvbi5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuZXhjZXB0aW9ucy5BcHBsaWNhdGlvbkV4Y2VwdGlvblxuXG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuL0FwcGxpY2F0aW9uRXhjZXB0aW9uXCI6MTQxfV0sMTQ3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi9BcHBsaWNhdGlvbkV4Y2VwdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkuZXhjZXB0aW9ucy5Vbmtub3duUHJvcGVydHlFeGNlcHRpb25cbiAqIEBleHRlbmRzIEppaS5leGNlcHRpb25zLkFwcGxpY2F0aW9uRXhjZXB0aW9uXG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmV4Y2VwdGlvbnMuVW5rbm93blByb3BlcnR5RXhjZXB0aW9uJywgLyoqIEBsZW5kcyBKaWkuZXhjZXB0aW9ucy5Vbmtub3duUHJvcGVydHlFeGNlcHRpb24ucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmV4Y2VwdGlvbnMuQXBwbGljYXRpb25FeGNlcHRpb25cblxufSk7XG5cbn0se1wiLi4vSmlpXCI6MTI1LFwiLi9BcHBsaWNhdGlvbkV4Y2VwdGlvblwiOjE0MX1dLDE0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbnJlcXVpcmUoJy4uL2Jhc2UvT2JqZWN0Jyk7XG5cbi8qKlxuICogQmFzZUZpbGVIZWxwZXIgcHJvdmlkZXMgY29uY3JldGUgaW1wbGVtZW50YXRpb24gZm9yIFtbRmlsZUhlbHBlcl1dLlxuICpcbiAqIERvIG5vdCB1c2UgQmFzZUZpbGVIZWxwZXIuIFVzZSBbW0ZpbGVIZWxwZXJdXSBpbnN0ZWFkLlxuICpcbiAqIEBjbGFzcyBKaWkuaGVscGVycy5GaWxlXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuaGVscGVycy5GaWxlJywgLyoqIEBsZW5kcyBKaWkuaGVscGVycy5GaWxlLnByb3RvdHlwZSAqL3tcblxuXHRfX2V4dGVuZHM6IEppaS5iYXNlLk9iamVjdCxcblxuXHRfX3N0YXRpYzogLyoqIEBsZW5kcyBKaWkuaGVscGVycy5GaWxlICove1xuXG5cdFx0UEFUVEVSTl9OT0RJUjogMSxcblx0XHRQQVRURVJOX0VORFNXSVRIOiA0LFxuXHRcdFBBVFRFUk5fTVVTVEJFRElSOiA4LFxuXHRcdFBBVFRFUk5fTkVHQVRJVkU6IDE2LFxuXHRcdFBBVFRFUk5fQ0FTRV9JTlNFTlNJVElWRTogMzIsXG5cblx0XHQvKipcblx0XHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgcGF0aCAob3IgYWxpYXMpIG9mIGEgUEhQIGZpbGUgY29udGFpbmluZyBNSU1FIHR5cGUgaW5mb3JtYXRpb24uXG5cdFx0ICovXG5cdFx0bWltZU1hZ2ljRmlsZTogJ0BqaWkvaGVscGVycy9taW1lVHlwZXMucGhwJyxcblxuXHRcdGdldEZpbGVEaXJlY3Rvcnk6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLnJlcGxhY2UoL1xcLz9bXlxcL10rJC8sICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0RmlsZU5hbWU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBwYXRoLnJlcGxhY2UoLyguKlxcLyk/KFteXFwvXSspJC8sICckMicpO1xuXHRcdH0sXG5cblx0XHRnZXRGaWxlRXh0ZW5zaW9uOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyA9IC9cXC4oW2Etel0rKSQvLmV4ZWMocGF0aCk7XG5cdFx0XHRyZXR1cm4gbWF0Y2hlcyAhPT0gbnVsbCA/IG1hdGNoZXNbMV0gOiAnJztcblx0XHR9LFxuXG5cdFx0aXNGaWxlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gcGF0aC5tYXRjaCgvW15cXC9dK1xcLlteXFwvXSskLykgIT09IG51bGw7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIE5vcm1hbGl6ZXMgYSBmaWxlL2RpcmVjdG9yeSBwYXRoLlxuXHRcdCAqIFRoZSBub3JtYWxpemF0aW9uIGRvZXMgdGhlIGZvbGxvd2luZyB3b3JrOlxuXHRcdCAqXG5cdFx0ICogLSBDb252ZXJ0IGFsbCBkaXJlY3Rvcnkgc2VwYXJhdG9ycyBpbnRvIGBESVJFQ1RPUllfU0VQQVJBVE9SYCAoZS5nLiBcIlxcYS9iXFxjXCIgYmVjb21lcyBcIi9hL2IvY1wiKVxuXHRcdCAqIC0gUmVtb3ZlIHRyYWlsaW5nIGRpcmVjdG9yeSBzZXBhcmF0b3JzIChlLmcuIFwiL2EvYi9jL1wiIGJlY29tZXMgXCIvYS9iL2NcIilcblx0XHQgKiAtIFR1cm4gbXVsdGlwbGUgY29uc2VjdXRpdmUgc2xhc2hlcyBpbnRvIGEgc2luZ2xlIG9uZSAoZS5nLiBcIi9hLy8vYi9jXCIgYmVjb21lcyBcIi9hL2IvY1wiKVxuXHRcdCAqIC0gUmVtb3ZlIFwiLi5cIiBhbmQgXCIuXCIgYmFzZWQgb24gdGhlaXIgbWVhbmluZ3MgKGUuZy4gXCIvYS8uL2IvLi4vY1wiIGJlY29tZXMgXCIvYS9jXCIpXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCB0aGUgZmlsZS9kaXJlY3RvcnkgcGF0aCB0byBiZSBub3JtYWxpemVkXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IFtkc10gdGhlIGRpcmVjdG9yeSBzZXBhcmF0b3IgdG8gYmUgdXNlZCBpbiB0aGUgbm9ybWFsaXplZCByZXN1bHQuIERlZmF1bHRzIHRvIGBESVJFQ1RPUllfU0VQQVJBVE9SYC5cblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfSB0aGUgbm9ybWFsaXplZCBmaWxlL2RpcmVjdG9yeSBwYXRoXG5cdFx0ICovXG5cdFx0bm9ybWFsaXplUGF0aDogZnVuY3Rpb24gKHBhdGgsIGRzKSB7XG5cdFx0XHRkcyA9IGRzIHx8ICcvJztcblxuXHRcdFx0cGF0aCA9IEppaS5fcy5ydHJpbShwYXRoLnJlcGxhY2UoL1xcL1xcXFwvZywgZHMgKyBkcyksIGRzKTtcblx0XHRcdGlmICgoZHMgKyBwYXRoKS5pbmRleE9mKGRzICsgJy4nKSA9PT0gLTEgJiYgcGF0aC5pbmRleE9mKGRzICsgZHMpID09PSAtMSkge1xuXHRcdFx0XHRyZXR1cm4gcGF0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gdGhlIHBhdGggbWF5IGNvbnRhaW4gXCIuXCIsIFwiLi5cIiBvciBkb3VibGUgc2xhc2hlcywgbmVlZCB0byBjbGVhbiB0aGVtIHVwXG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblx0XHRcdEppaS5fLmVhY2gocGF0aC5zcGxpdChkcyksIGZ1bmN0aW9uKHBhcnQpIHtcblx0XHRcdFx0aWYgKHBhcnQgPT09ICcuLicgJiYgcGFydHMubGVuZ3RoID4gMCAmJiBwYXJ0c1twYXJ0cy5sZW5ndGggLSAxXSAhPT0gJy4uJykge1xuXHRcdFx0XHRcdHBhcnRzLnBvcCgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwYXJ0ID09PSAnLicgfHwgKHBhcnQgPT09ICcnICYmIHBhcnRzLmxlbmd0aCA+IDApKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cGFydHMucHVzaChwYXJ0KTtcblx0XHRcdH0pO1xuXG5cdFx0XHRwYXRoID0gcGFydHMuam9pbihkcyk7XG5cdFx0XHRyZXR1cm4gcGF0aCA9PT0gJycgPyAnLicgOiBwYXRoO1xuXHRcdH1cblx0fVxuXG59KTtcbn0se1wiLi4vSmlpXCI6MTI1LFwiLi4vYmFzZS9PYmplY3RcIjoxMzh9XSwxNDk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuLyoqXG4gKiBAYXV0aG9yIFZsYWRpbWlyIEtvemhpbiA8YWZma2FAYWZma2EucnU+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuLi9iYXNlL09iamVjdCcpO1xuXG4vKipcbiAqIEJhc2VGaWxlSGVscGVyIHByb3ZpZGVzIGNvbmNyZXRlIGltcGxlbWVudGF0aW9uIGZvciBbW0ZpbGVIZWxwZXJdXS5cbiAqXG4gKiBEbyBub3QgdXNlIEJhc2VGaWxlSGVscGVyLiBVc2UgW1tGaWxlSGVscGVyXV0gaW5zdGVhZC5cbiAqXG4gKiBAY2xhc3MgSmlpLmhlbHBlcnMuU3RyaW5nXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkuaGVscGVycy5TdHJpbmcnLCAvKiogQGxlbmRzIEppaS5oZWxwZXJzLlN0cmluZy5wcm90b3R5cGUgKi97XG5cblx0X19leHRlbmRzOiBKaWkuYmFzZS5PYmplY3QsXG5cblx0X19zdGF0aWM6IC8qKiBAbGVuZHMgSmlpLmhlbHBlcnMuU3RyaW5nICove1xuXG5cdFx0LyoqXG5cdFx0ICogR2VuZXJhdGUgdW5pcXVlIGhhc2ggZm9yIHN0cmluZy4gaHR0cDovL2pzcGVyZi5jb20vaGFzaGNvZGVsb3JkdmxhZFxuXHRcdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcblx0XHQgKiBAcmV0dXJucyB7U3RyaW5nfVxuXHRcdCAqL1xuXHRcdGhhc2hDb2RlOiBmdW5jdGlvbihzdHIpe1xuXHRcdFx0cmV0dXJuIHN0ci5zcGxpdChcIlwiKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcblx0XHRcdFx0YSA9ICgoYSA8PCA1KSAtIGEpICsgYi5jaGFyQ29kZUF0KDApO1xuXHRcdFx0XHRyZXR1cm4gYSAmIGE7XG5cdFx0XHR9LCAwKS50b1N0cmluZygpLnJlcGxhY2UoLy0vZywgJzEnKTtcblx0XHR9LFxuXG5cdFx0Z2VuZXJhdGVVaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIGZ1bmN0aW9uKGMpIHtcblx0XHRcdFx0dmFyIHIgPSBNYXRoLnJhbmRvbSgpKjE2fDA7XG5cdFx0XHRcdHZhciB2ID0gYyA9PSAneCcgPyByIDogKHImMHgzfDB4OCk7XG5cblx0XHRcdFx0cmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdH1cblxufSk7XG59LHtcIi4uL0ppaVwiOjEyNSxcIi4uL2Jhc2UvT2JqZWN0XCI6MTM4fV0sMTUwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciBWbGFkaW1pciBLb3poaW4gPGFmZmthQGFmZmthLnJ1PlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBuYW1lc3BhY2UgSmlpXG4gKiBAaWdub3JlXG4gKi9cbnZhciBKaWkgPSByZXF1aXJlKCcuLi9KaWknKTtcblxucmVxdWlyZSgnLi4vYmFzZS9PYmplY3QnKTtcblxuLyoqXG4gKlxuICogQGNsYXNzIEppaS5oZWxwZXJzLlVybFxuICogQGV4dGVuZHMgSmlpLmJhc2UuT2JqZWN0XG4gKi9cbkppaS5kZWZpbmVDbGFzcygnSmlpLmhlbHBlcnMuVXJsJywgLyoqIEBsZW5kcyBKaWkuaGVscGVycy5VcmwucHJvdG90eXBlICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG5cdF9fc3RhdGljOiAvKiogQGxlbmRzIEppaS5oZWxwZXJzLlVybCAqL3tcblxuXHRcdC8qKlxuXHRcdCAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgYSBVUkwgaXMgcmVsYXRpdmUuXG5cdFx0ICogQSByZWxhdGl2ZSBVUkwgZG9lcyBub3QgaGF2ZSBob3N0IGluZm8gcGFydC5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gdXJsIHRoZSBVUkwgdG8gYmUgY2hlY2tlZFxuXHRcdCAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIHRoZSBVUkwgaXMgcmVsYXRpdmVcblx0XHQgKi9cblx0XHRpc1JlbGF0aXZlOiBmdW5jdGlvbiAodXJsKSB7XG5cdFx0XHRyZXR1cm4gdXJsLmluZGV4T2YoJy8vJykgIT09IDAgJiYgdXJsLmluZGV4T2YoJzovLycpID09PSAtMTtcblx0XHR9XG5cdH1cblxufSk7XG59LHtcIi4uL0ppaVwiOjEyNSxcIi4uL2Jhc2UvT2JqZWN0XCI6MTM4fV0sMTUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxyXG4gKiBAYXV0aG9yIDxhIGhyZWY9XCJodHRwOi8vd3d3LmFmZmthLnJ1XCI+VmxhZGltaXIgS296aGluPC9hPlxyXG4gKiBAbGljZW5zZSBNSVRcclxuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKipcclxuICogQG5hbWVzcGFjZSBKaWlcclxuICogQGlnbm9yZVxyXG4gKi9cclxudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xyXG5cclxucmVxdWlyZSgnLi4vYmFzZS9BY3Rpb24nKTtcclxuXHJcbi8qKlxyXG4gKiBAY2xhc3MgSmlpLnJlcXVlc3QuQW5vbnltb3VzQWN0aW9uXHJcbiAqIEBleHRlbmRzIEppaS5iYXNlLkFjdGlvblxyXG4gKi9cclxuSmlpLmRlZmluZUNsYXNzKCdKaWkucmVxdWVzdC5Bbm9ueW1vdXNBY3Rpb24nLCAvKiogQGxlbmRzIEppaS5yZXF1ZXN0LkFub255bW91c0FjdGlvbi5wcm90b3R5cGUgKi97XHJcblxyXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQWN0aW9uLFxyXG5cclxuXHQvKipcclxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgY29udHJvbGxlciBtZXRob2QgdGhhdCAgdGhpcyBpbmxpbmUgYWN0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aFxyXG5cdCAqL1xyXG5cdHJvdXRlOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge2Z1bmN0aW9ufVxyXG4gICAgICovXHJcbiAgICBoYW5kbGVyOiBudWxsLFxyXG5cclxuICAgIC8qKlxyXG4gICAgICogQHR5cGUge0ppaS5iYXNlLk1vZHVsZX1cclxuICAgICAqL1xyXG4gICAgbW9kdWxlOiBudWxsLFxyXG5cclxuXHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKHJvdXRlLCBtb2R1bGUsIGhhbmRsZXIsIGNvbmZpZykge1xyXG5cdFx0dGhpcy5yb3V0ZSA9IHJvdXRlO1xyXG5cdFx0dGhpcy5oYW5kbGVyID0gaGFuZGxlcjtcclxuXHRcdHRoaXMubW9kdWxlID0gbW9kdWxlO1xyXG5cclxuICAgICAgICB2YXIgaWQgPSByb3V0ZS5zcGxpdCgnLycpLnBvcCgpO1xyXG5cdFx0dGhpcy5fX3N1cGVyKGlkLCBudWxsLCBjb25maWcpO1xyXG5cdH0sXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSB1bmlxdWUgSUQgb2YgdGhpcyBhY3Rpb24gYW1vbmcgdGhlIHdob2xlIGFwcGxpY2F0aW9uLlxyXG4gICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHVuaXF1ZSBJRCBvZiB0aGlzIGFjdGlvbiBhbW9uZyB0aGUgd2hvbGUgYXBwbGljYXRpb24uXHJcbiAgICAgKi9cclxuICAgIGdldFVuaXF1ZUlkOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucm91dGU7XHJcbiAgICB9LFxyXG5cclxuXHQvKipcclxuXHQgKiBSdW5zIHRoaXMgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxyXG5cdCAqIFRoaXMgbWV0aG9kIGlzIG1haW5seSBpbnZva2VkIGJ5IHRoZSBjb250cm9sbGVyLlxyXG5cdCAqIEBwYXJhbSB7SmlpLmJhc2UuQ29udGV4dH0gY29udGV4dFxyXG5cdCAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIHRoZSBhY3Rpb25cclxuXHQgKi9cclxuXHRydW5XaXRoUGFyYW1zOiBmdW5jdGlvbiAoY29udGV4dCkge1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVyLmNhbGwodGhpcy5tb2R1bGUsIGNvbnRleHQpO1xyXG4gICAgICAgIH0uYmluZCh0aGlzKSk7XHJcblx0fVxyXG59KTtcclxuXG59LHtcIi4uL0ppaVwiOjEyNSxcIi4uL2Jhc2UvQWN0aW9uXCI6MTI3fV0sMTUyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbi8qKlxuICogQGF1dGhvciA8YSBocmVmPVwiaHR0cDovL3d3dy5hZmZrYS5ydVwiPlZsYWRpbWlyIEtvemhpbjwvYT5cbiAqIEBsaWNlbnNlIE1JVFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAbmFtZXNwYWNlIEppaVxuICogQGlnbm9yZVxuICovXG52YXIgSmlpID0gcmVxdWlyZSgnLi4vSmlpJyk7XG5cbi8qKlxuICogSGVhZGVyQ29sbGVjdGlvbiBpcyB1c2VkIGJ5IFtbSmlpLmJhc2UuUmVzcG9uc2VdXSB0byBtYWludGFpbiB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgSFRUUCBoZWFkZXJzLlxuICpcbiAqIEBjbGFzcyBKaWkucmVxdWVzdC5IZWFkZXJDb2xsZWN0aW9uXG4gKiBAZXh0ZW5kcyBKaWkuYmFzZS5PYmplY3RcbiAqL1xuSmlpLmRlZmluZUNsYXNzKCdKaWkucmVxdWVzdC5IZWFkZXJDb2xsZWN0aW9uJywgLyoqIEBsZW5kcyBKaWkucmVxdWVzdC5IZWFkZXJDb2xsZWN0aW9uICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuT2JqZWN0LFxuXG4gICAgX2hlYWRlcnM6IG51bGwsXG5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5faGVhZGVycyA9IHt9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBuYW1lZCBoZWFkZXIocykuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGhlYWRlciB0byByZXR1cm5cbiAgICAgKiBAcGFyYW0geyp9IFtkZWZhdWx0VmFsdWVdIHRoZSB2YWx1ZSB0byByZXR1cm4gaW4gY2FzZSB0aGUgbmFtZWQgaGVhZGVyIGRvZXMgbm90IGV4aXN0XG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNGaXJzdF0gd2hldGhlciB0byBvbmx5IHJldHVybiB0aGUgZmlyc3QgaGVhZGVyIG9mIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKiBJZiBmYWxzZSwgYWxsIGhlYWRlcnMgb2YgdGhlIHNwZWNpZmllZCBuYW1lIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQHJldHVybiBbc3RyaW5nfGFycmF5XSB0aGUgbmFtZWQgaGVhZGVyKHMpLiBJZiBgZmlyc3RgIGlzIHRydWUsIGEgc3RyaW5nIHdpbGwgYmUgcmV0dXJuZWQ7XG4gICAgICogSWYgYGZpcnN0YCBpcyBmYWxzZSwgYW4gYXJyYXkgd2lsbCBiZSByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBnZXQ6IGZ1bmN0aW9uKG5hbWUsIGRlZmF1bHRWYWx1ZSwgaXNGaXJzdCkge1xuICAgICAgICBkZWZhdWx0VmFsdWUgPSBkZWZhdWx0VmFsdWUgfHwgbnVsbDtcbiAgICAgICAgaWYgKEppaS5fLmlzVW5kZWZpbmVkKGlzRmlyc3QpKSB7XG4gICAgICAgICAgICBpc0ZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChKaWkuXy5oYXModGhpcy5faGVhZGVycywgbmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZpcnN0ID8gSmlpLl8uZmlyc3QodGhpcy5faGVhZGVyc1tuYW1lXSkgOiB0aGlzLl9oZWFkZXJzW25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBoZWFkZXIuXG4gICAgICogSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUsIGl0IHdpbGwgYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdmFsdWVdIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHJldHVybiB7c3RhdGljfSB0aGUgY29sbGVjdGlvbiBvYmplY3QgaXRzZWxmXG4gICAgICovXG4gICAgc2V0OiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlIHx8ICcnO1xuXG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNbbmFtZV0gPSBKaWkuXy5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWRkcyBhIG5ldyBoZWFkZXIuXG4gICAgICogSWYgdGhlcmUgaXMgYWxyZWFkeSBhIGhlYWRlciB3aXRoIHRoZSBzYW1lIG5hbWUsIHRoZSBuZXcgb25lIHdpbGxcbiAgICAgKiBiZSBhcHBlbmRlZCB0byBpdCBpbnN0ZWFkIG9mIHJlcGxhY2luZyBpdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSB0aGUgbmFtZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlIHRoZSB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gICAgICogQHJldHVybiB7c3RhdGljfSB0aGUgY29sbGVjdGlvbiBvYmplY3QgaXRzZWxmXG4gICAgICovXG4gICAgYWRkOiBmdW5jdGlvbihuYW1lLCB2YWx1ZSkge1xuICAgICAgICBuYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoSmlpLl8uaXNBcnJheSh0aGlzLl9oZWFkZXJzW25hbWVdKSkge1xuICAgICAgICAgICAgdGhpcy5faGVhZGVyc1tuYW1lXSA9IHRoaXMuX2hlYWRlcnNbbmFtZV0uY29uY2F0KHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbmV3IGhlYWRlciBvbmx5IGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgKiBJZiB0aGVyZSBpcyBhbHJlYWR5IGEgaGVhZGVyIHdpdGggdGhlIHNhbWUgbmFtZSwgdGhlIG5ldyBvbmUgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIHRoZSBuYW1lIG9mIHRoZSBoZWFkZXJcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3ZhbHVlXSB0aGUgdmFsdWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4ge3N0YXRpY30gdGhlIGNvbGxlY3Rpb24gb2JqZWN0IGl0c2VsZlxuICAgICAqL1xuICAgIHNldERlZmF1bHQ6IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUgfHwgJyc7XG5cbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCF0aGlzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgdGhpcy5zZXQobmFtZSwgdmFsdWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG5hbWVkIGhlYWRlciBleGlzdHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGhlYWRlclxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IHdoZXRoZXIgdGhlIG5hbWVkIGhlYWRlciBleGlzdHNcbiAgICAgKi9cbiAgICBoYXM6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0dXJuIEppaS5fLmhhcyh0aGlzLl9oZWFkZXJzLCBuYW1lKSAmJiB0aGlzLl9oZWFkZXJzW25hbWVdLmxlbmd0aCA+IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBoZWFkZXIuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGhlYWRlciB0byBiZSByZW1vdmVkLlxuICAgICAqIEByZXR1cm4ge3N0cmluZ3xudWxsfSB0aGUgdmFsdWUgb2YgdGhlIHJlbW92ZWQgaGVhZGVyLiBOdWxsIGlzIHJldHVybmVkIGlmIHRoZSBoZWFkZXIgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgcmVtb3ZlOiBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChKaWkuXy5oYXModGhpcy5faGVhZGVycywgbmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX2hlYWRlcnNbbmFtZV07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5faGVhZGVyc1tuYW1lXTtcblxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBoZWFkZXJzLlxuICAgICAqL1xuICAgIHJlbW92ZUFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuX2hlYWRlcnMgPSB7fTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29sbGVjdGlvbiBhcyBhIGtleS12YWx1ZSBvYmplY3QuXG4gICAgICogQHJldHVybiB7b2JqZWN0fVxuICAgICAqL1xuICAgIHRvT2JqZWN0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICAgICAgSmlpLl8uZWFjaCh0aGlzLl9oZWFkZXJzLCBKaWkuXy5iaW5kKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IEppaS5fLmZpcnN0KHZhbHVlKTtcbiAgICAgICAgfSwgdGhpcykpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG5cbn0pO1xuXG59LHtcIi4uL0ppaVwiOjEyNX1dLDE1MzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vKipcbiAqIEBhdXRob3IgPGEgaHJlZj1cImh0dHA6Ly93d3cuYWZma2EucnVcIj5WbGFkaW1pciBLb3poaW48L2E+XG4gKiBAbGljZW5zZSBNSVRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQG5hbWVzcGFjZSBKaWlcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEppaSA9IHJlcXVpcmUoJy4uL0ppaScpO1xuXG5yZXF1aXJlKCcuLi9iYXNlL0FjdGlvbicpO1xuXG4vKipcbiAqIEBjbGFzcyBKaWkucmVxdWVzdC5JbmxpbmVBY3Rpb25cbiAqIEBleHRlbmRzIEppaS5iYXNlLkFjdGlvblxuICovXG5KaWkuZGVmaW5lQ2xhc3MoJ0ppaS5yZXF1ZXN0LklubGluZUFjdGlvbicsIC8qKiBAbGVuZHMgSmlpLnJlcXVlc3QuSW5saW5lQWN0aW9uICove1xuXG5cdF9fZXh0ZW5kczogSmlpLmJhc2UuQWN0aW9uLFxuXG5cdC8qKlxuXHQgKiBAdHlwZSB7c3RyaW5nfSB0aGUgY29udHJvbGxlciBtZXRob2QgdGhhdCAgdGhpcyBpbmxpbmUgYWN0aW9uIGlzIGFzc29jaWF0ZWQgd2l0aFxuXHQgKi9cblx0YWN0aW9uTWV0aG9kOiBudWxsLFxuXG5cdGNvbnN0cnVjdG9yOiBmdW5jdGlvbiAoaWQsIGNvbnRyb2xsZXIsIGFjdGlvbk1ldGhvZCwgY29uZmlnKSB7XG5cdFx0dGhpcy5hY3Rpb25NZXRob2QgPSBhY3Rpb25NZXRob2Q7XG5cdFx0dGhpcy5fX3N1cGVyKGlkLCBjb250cm9sbGVyLCBjb25maWcpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSdW5zIHRoaXMgYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBwYXJhbWV0ZXJzLlxuXHQgKiBUaGlzIG1ldGhvZCBpcyBtYWlubHkgaW52b2tlZCBieSB0aGUgY29udHJvbGxlci5cblx0ICogQHBhcmFtIHtKaWkuYmFzZS5Db250ZXh0fSBjb250ZXh0XG5cdCAqIEByZXR1cm5zIHsqfSB0aGUgcmVzdWx0IG9mIHRoZSBhY3Rpb25cblx0ICovXG5cdHJ1bldpdGhQYXJhbXM6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbGxlclt0aGlzLmFjdGlvbk1ldGhvZF0uY2FsbCh0aGlzLmNvbnRyb2xsZXIsIGNvbnRleHQpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuXHR9XG59KTtcblxufSx7XCIuLi9KaWlcIjoxMjUsXCIuLi9iYXNlL0FjdGlvblwiOjEyN31dLDE1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG4vLyAgVW5kZXJzY29yZS5zdHJpbmdcbi8vICAoYykgMjAxMCBFc2EtTWF0dGkgU3V1cm9uZW4gPGVzYS1tYXR0aSBhZXQgc3V1cm9uZW4gZG90IG9yZz5cbi8vICBVbmRlcnNjb3JlLnN0cmluZyBpcyBmcmVlbHkgZGlzdHJpYnV0YWJsZSB1bmRlciB0aGUgdGVybXMgb2YgdGhlIE1JVCBsaWNlbnNlLlxuLy8gIERvY3VtZW50YXRpb246IGh0dHBzOi8vZ2l0aHViLmNvbS9lcGVsaS91bmRlcnNjb3JlLnN0cmluZ1xuLy8gIFNvbWUgY29kZSBpcyBib3Jyb3dlZCBmcm9tIE1vb1Rvb2xzIGFuZCBBbGV4YW5kcnUgTWFyYXN0ZWFudS5cbi8vICBWZXJzaW9uICcyLjQuMCdcblxuIWZ1bmN0aW9uKHJvb3QsIFN0cmluZyl7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBEZWZpbmluZyBoZWxwZXIgZnVuY3Rpb25zLlxuXG4gIHZhciBuYXRpdmVUcmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltO1xuICB2YXIgbmF0aXZlVHJpbVJpZ2h0ID0gU3RyaW5nLnByb3RvdHlwZS50cmltUmlnaHQ7XG4gIHZhciBuYXRpdmVUcmltTGVmdCA9IFN0cmluZy5wcm90b3R5cGUudHJpbUxlZnQ7XG5cbiAgdmFyIHBhcnNlTnVtYmVyID0gZnVuY3Rpb24oc291cmNlKSB7IHJldHVybiBzb3VyY2UgKiAxIHx8IDA7IH07XG5cbiAgdmFyIHN0clJlcGVhdCA9IGZ1bmN0aW9uKHN0ciwgcXR5KXtcbiAgICBpZiAocXR5IDwgMSkgcmV0dXJuICcnO1xuICAgIHZhciByZXN1bHQgPSAnJztcbiAgICB3aGlsZSAocXR5ID4gMCkge1xuICAgICAgaWYgKHF0eSAmIDEpIHJlc3VsdCArPSBzdHI7XG4gICAgICBxdHkgPj49IDEsIHN0ciArPSBzdHI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHNsaWNlID0gW10uc2xpY2U7XG5cbiAgdmFyIGRlZmF1bHRUb1doaXRlU3BhY2UgPSBmdW5jdGlvbihjaGFyYWN0ZXJzKSB7XG4gICAgaWYgKGNoYXJhY3RlcnMgPT0gbnVsbClcbiAgICAgIHJldHVybiAnXFxcXHMnO1xuICAgIGVsc2UgaWYgKGNoYXJhY3RlcnMuc291cmNlKVxuICAgICAgcmV0dXJuIGNoYXJhY3RlcnMuc291cmNlO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiAnWycgKyBfcy5lc2NhcGVSZWdFeHAoY2hhcmFjdGVycykgKyAnXSc7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZvciB0b0Jvb2xlYW5cbiAgZnVuY3Rpb24gYm9vbE1hdGNoKHMsIG1hdGNoZXJzKSB7XG4gICAgdmFyIGksIG1hdGNoZXIsIGRvd24gPSBzLnRvTG93ZXJDYXNlKCk7XG4gICAgbWF0Y2hlcnMgPSBbXS5jb25jYXQobWF0Y2hlcnMpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgbWF0Y2hlciA9IG1hdGNoZXJzW2ldO1xuICAgICAgaWYgKCFtYXRjaGVyKSBjb250aW51ZTtcbiAgICAgIGlmIChtYXRjaGVyLnRlc3QgJiYgbWF0Y2hlci50ZXN0KHMpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChtYXRjaGVyLnRvTG93ZXJDYXNlKCkgPT09IGRvd24pIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlc2NhcGVDaGFycyA9IHtcbiAgICBsdDogJzwnLFxuICAgIGd0OiAnPicsXG4gICAgcXVvdDogJ1wiJyxcbiAgICBhbXA6ICcmJyxcbiAgICBhcG9zOiBcIidcIlxuICB9O1xuXG4gIHZhciByZXZlcnNlZEVzY2FwZUNoYXJzID0ge307XG4gIGZvcih2YXIga2V5IGluIGVzY2FwZUNoYXJzKSByZXZlcnNlZEVzY2FwZUNoYXJzW2VzY2FwZUNoYXJzW2tleV1dID0ga2V5O1xuICByZXZlcnNlZEVzY2FwZUNoYXJzW1wiJ1wiXSA9ICcjMzknO1xuXG4gIC8vIHNwcmludGYoKSBmb3IgSmF2YVNjcmlwdCAwLjctYmV0YTFcbiAgLy8gaHR0cDovL3d3dy5kaXZlaW50b2phdmFzY3JpcHQuY29tL3Byb2plY3RzL2phdmFzY3JpcHQtc3ByaW50ZlxuICAvL1xuICAvLyBDb3B5cmlnaHQgKGMpIEFsZXhhbmRydSBNYXJhc3RlYW51IDxhbGV4YWhvbGljIFthdCkgZ21haWwgKGRvdF0gY29tPlxuICAvLyBBbGwgcmlnaHRzIHJlc2VydmVkLlxuXG4gIHZhciBzcHJpbnRmID0gKGZ1bmN0aW9uKCkge1xuICAgIGZ1bmN0aW9uIGdldF90eXBlKHZhcmlhYmxlKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhcmlhYmxlKS5zbGljZSg4LCAtMSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICB2YXIgc3RyX3JlcGVhdCA9IHN0clJlcGVhdDtcblxuICAgIHZhciBzdHJfZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXN0cl9mb3JtYXQuY2FjaGUuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzWzBdKSkge1xuICAgICAgICBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0gPSBzdHJfZm9ybWF0LnBhcnNlKGFyZ3VtZW50c1swXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3RyX2Zvcm1hdC5mb3JtYXQuY2FsbChudWxsLCBzdHJfZm9ybWF0LmNhY2hlW2FyZ3VtZW50c1swXV0sIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuZm9ybWF0ID0gZnVuY3Rpb24ocGFyc2VfdHJlZSwgYXJndikge1xuICAgICAgdmFyIGN1cnNvciA9IDEsIHRyZWVfbGVuZ3RoID0gcGFyc2VfdHJlZS5sZW5ndGgsIG5vZGVfdHlwZSA9ICcnLCBhcmcsIG91dHB1dCA9IFtdLCBpLCBrLCBtYXRjaCwgcGFkLCBwYWRfY2hhcmFjdGVyLCBwYWRfbGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRyZWVfbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbm9kZV90eXBlID0gZ2V0X3R5cGUocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIGlmIChub2RlX3R5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3V0cHV0LnB1c2gocGFyc2VfdHJlZVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobm9kZV90eXBlID09PSAnYXJyYXknKSB7XG4gICAgICAgICAgbWF0Y2ggPSBwYXJzZV90cmVlW2ldOyAvLyBjb252ZW5pZW5jZSBwdXJwb3NlcyBvbmx5XG4gICAgICAgICAgaWYgKG1hdGNoWzJdKSB7IC8vIGtleXdvcmQgYXJndW1lbnRcbiAgICAgICAgICAgIGFyZyA9IGFyZ3ZbY3Vyc29yXTtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBtYXRjaFsyXS5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICBpZiAoIWFyZy5oYXNPd25Qcm9wZXJ0eShtYXRjaFsyXVtrXSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc3ByaW50ZignW18uc3ByaW50Zl0gcHJvcGVydHkgXCIlc1wiIGRvZXMgbm90IGV4aXN0JywgbWF0Y2hbMl1ba10pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmcgPSBhcmdbbWF0Y2hbMl1ba11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobWF0Y2hbMV0pIHsgLy8gcG9zaXRpb25hbCBhcmd1bWVudCAoZXhwbGljaXQpXG4gICAgICAgICAgICBhcmcgPSBhcmd2W21hdGNoWzFdXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7IC8vIHBvc2l0aW9uYWwgYXJndW1lbnQgKGltcGxpY2l0KVxuICAgICAgICAgICAgYXJnID0gYXJndltjdXJzb3IrK107XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKC9bXnNdLy50ZXN0KG1hdGNoWzhdKSAmJiAoZ2V0X3R5cGUoYXJnKSAhPSAnbnVtYmVyJykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzcHJpbnRmKCdbXy5zcHJpbnRmXSBleHBlY3RpbmcgbnVtYmVyIGJ1dCBmb3VuZCAlcycsIGdldF90eXBlKGFyZykpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChtYXRjaFs4XSkge1xuICAgICAgICAgICAgY2FzZSAnYic6IGFyZyA9IGFyZy50b1N0cmluZygyKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjJzogYXJnID0gU3RyaW5nLmZyb21DaGFyQ29kZShhcmcpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2QnOiBhcmcgPSBwYXJzZUludChhcmcsIDEwKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlJzogYXJnID0gbWF0Y2hbN10gPyBhcmcudG9FeHBvbmVudGlhbChtYXRjaFs3XSkgOiBhcmcudG9FeHBvbmVudGlhbCgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2YnOiBhcmcgPSBtYXRjaFs3XSA/IHBhcnNlRmxvYXQoYXJnKS50b0ZpeGVkKG1hdGNoWzddKSA6IHBhcnNlRmxvYXQoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdvJzogYXJnID0gYXJnLnRvU3RyaW5nKDgpOyBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3MnOiBhcmcgPSAoKGFyZyA9IFN0cmluZyhhcmcpKSAmJiBtYXRjaFs3XSA/IGFyZy5zdWJzdHJpbmcoMCwgbWF0Y2hbN10pIDogYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd1JzogYXJnID0gTWF0aC5hYnMoYXJnKTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd4JzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdYJzogYXJnID0gYXJnLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgYXJnID0gKC9bZGVmXS8udGVzdChtYXRjaFs4XSkgJiYgbWF0Y2hbM10gJiYgYXJnID49IDAgPyAnKycrIGFyZyA6IGFyZyk7XG4gICAgICAgICAgcGFkX2NoYXJhY3RlciA9IG1hdGNoWzRdID8gbWF0Y2hbNF0gPT0gJzAnID8gJzAnIDogbWF0Y2hbNF0uY2hhckF0KDEpIDogJyAnO1xuICAgICAgICAgIHBhZF9sZW5ndGggPSBtYXRjaFs2XSAtIFN0cmluZyhhcmcpLmxlbmd0aDtcbiAgICAgICAgICBwYWQgPSBtYXRjaFs2XSA/IHN0cl9yZXBlYXQocGFkX2NoYXJhY3RlciwgcGFkX2xlbmd0aCkgOiAnJztcbiAgICAgICAgICBvdXRwdXQucHVzaChtYXRjaFs1XSA/IGFyZyArIHBhZCA6IHBhZCArIGFyZyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQuam9pbignJyk7XG4gICAgfTtcblxuICAgIHN0cl9mb3JtYXQuY2FjaGUgPSB7fTtcblxuICAgIHN0cl9mb3JtYXQucGFyc2UgPSBmdW5jdGlvbihmbXQpIHtcbiAgICAgIHZhciBfZm10ID0gZm10LCBtYXRjaCA9IFtdLCBwYXJzZV90cmVlID0gW10sIGFyZ19uYW1lcyA9IDA7XG4gICAgICB3aGlsZSAoX2ZtdCkge1xuICAgICAgICBpZiAoKG1hdGNoID0gL15bXlxceDI1XSsvLmV4ZWMoX2ZtdCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgcGFyc2VfdHJlZS5wdXNoKG1hdGNoWzBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSAvXlxceDI1ezJ9Ly5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIHBhcnNlX3RyZWUucHVzaCgnJScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IC9eXFx4MjUoPzooWzEtOV1cXGQqKVxcJHxcXCgoW15cXCldKylcXCkpPyhcXCspPygwfCdbXiRdKT8oLSk/KFxcZCspPyg/OlxcLihcXGQrKSk/KFtiLWZvc3V4WF0pLy5leGVjKF9mbXQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICAgICAgYXJnX25hbWVzIHw9IDE7XG4gICAgICAgICAgICB2YXIgZmllbGRfbGlzdCA9IFtdLCByZXBsYWNlbWVudF9maWVsZCA9IG1hdGNoWzJdLCBmaWVsZF9tYXRjaCA9IFtdO1xuICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGZpZWxkX2xpc3QucHVzaChmaWVsZF9tYXRjaFsxXSk7XG4gICAgICAgICAgICAgIHdoaWxlICgocmVwbGFjZW1lbnRfZmllbGQgPSByZXBsYWNlbWVudF9maWVsZC5zdWJzdHJpbmcoZmllbGRfbWF0Y2hbMF0ubGVuZ3RoKSkgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKChmaWVsZF9tYXRjaCA9IC9eXFwuKFthLXpfXVthLXpfXFxkXSopL2kuZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoZmllbGRfbWF0Y2ggPSAvXlxcWyhcXGQrKVxcXS8uZXhlYyhyZXBsYWNlbWVudF9maWVsZCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaWVsZF9saXN0LnB1c2goZmllbGRfbWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW18uc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW18uc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWF0Y2hbMl0gPSBmaWVsZF9saXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFyZ19uYW1lcyB8PSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYXJnX25hbWVzID09PSAzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1tfLnNwcmludGZdIG1peGluZyBwb3NpdGlvbmFsIGFuZCBuYW1lZCBwbGFjZWhvbGRlcnMgaXMgbm90ICh5ZXQpIHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJzZV90cmVlLnB1c2gobWF0Y2gpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignW18uc3ByaW50Zl0gaHVoPycpO1xuICAgICAgICB9XG4gICAgICAgIF9mbXQgPSBfZm10LnN1YnN0cmluZyhtYXRjaFswXS5sZW5ndGgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcnNlX3RyZWU7XG4gICAgfTtcblxuICAgIHJldHVybiBzdHJfZm9ybWF0O1xuICB9KSgpO1xuXG5cblxuICAvLyBEZWZpbmluZyB1bmRlcnNjb3JlLnN0cmluZ1xuXG4gIHZhciBfcyA9IHtcblxuICAgIFZFUlNJT046ICcyLjQuMCcsXG5cbiAgICBpc0JsYW5rOiBmdW5jdGlvbihzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSBzdHIgPSAnJztcbiAgICAgIHJldHVybiAoL15cXHMqJC8pLnRlc3Qoc3RyKTtcbiAgICB9LFxuXG4gICAgc3RyaXBUYWdzOiBmdW5jdGlvbihzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvPFxcLz9bXj5dKz4vZywgJycpO1xuICAgIH0sXG5cbiAgICBjYXBpdGFsaXplIDogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHN0ciA9IHN0ciA9PSBudWxsID8gJycgOiBTdHJpbmcoc3RyKTtcbiAgICAgIHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG4gICAgfSxcblxuICAgIGNob3A6IGZ1bmN0aW9uKHN0ciwgc3RlcCl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiBbXTtcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpO1xuICAgICAgc3RlcCA9IH5+c3RlcDtcbiAgICAgIHJldHVybiBzdGVwID4gMCA/IHN0ci5tYXRjaChuZXcgUmVnRXhwKCcuezEsJyArIHN0ZXAgKyAnfScsICdnJykpIDogW3N0cl07XG4gICAgfSxcblxuICAgIGNsZWFuOiBmdW5jdGlvbihzdHIpe1xuICAgICAgcmV0dXJuIF9zLnN0cmlwKHN0cikucmVwbGFjZSgvXFxzKy9nLCAnICcpO1xuICAgIH0sXG5cbiAgICBjb3VudDogZnVuY3Rpb24oc3RyLCBzdWJzdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsIHx8IHN1YnN0ciA9PSBudWxsKSByZXR1cm4gMDtcblxuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICBzdWJzdHIgPSBTdHJpbmcoc3Vic3RyKTtcblxuICAgICAgdmFyIGNvdW50ID0gMCxcbiAgICAgICAgcG9zID0gMCxcbiAgICAgICAgbGVuZ3RoID0gc3Vic3RyLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcG9zID0gc3RyLmluZGV4T2Yoc3Vic3RyLCBwb3MpO1xuICAgICAgICBpZiAocG9zID09PSAtMSkgYnJlYWs7XG4gICAgICAgIGNvdW50Kys7XG4gICAgICAgIHBvcyArPSBsZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgY2hhcnM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikuc3BsaXQoJycpO1xuICAgIH0sXG5cbiAgICBzd2FwQ2FzZTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9cXFMvZywgZnVuY3Rpb24oYyl7XG4gICAgICAgIHJldHVybiBjID09PSBjLnRvVXBwZXJDYXNlKCkgPyBjLnRvTG93ZXJDYXNlKCkgOiBjLnRvVXBwZXJDYXNlKCk7XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgZXNjYXBlSFRNTDogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKC9bJjw+XCInXS9nLCBmdW5jdGlvbihtKXsgcmV0dXJuICcmJyArIHJldmVyc2VkRXNjYXBlQ2hhcnNbbV0gKyAnOyc7IH0pO1xuICAgIH0sXG5cbiAgICB1bmVzY2FwZUhUTUw6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZSgvXFwmKFteO10rKTsvZywgZnVuY3Rpb24oZW50aXR5LCBlbnRpdHlDb2RlKXtcbiAgICAgICAgdmFyIG1hdGNoO1xuXG4gICAgICAgIGlmIChlbnRpdHlDb2RlIGluIGVzY2FwZUNoYXJzKSB7XG4gICAgICAgICAgcmV0dXJuIGVzY2FwZUNoYXJzW2VudGl0eUNvZGVdO1xuICAgICAgICB9IGVsc2UgaWYgKG1hdGNoID0gZW50aXR5Q29kZS5tYXRjaCgvXiN4KFtcXGRhLWZBLUZdKykkLykpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChtYXRjaFsxXSwgMTYpKTtcbiAgICAgICAgfSBlbHNlIGlmIChtYXRjaCA9IGVudGl0eUNvZGUubWF0Y2goL14jKFxcZCspJC8pKSB7XG4gICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUofn5tYXRjaFsxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGVudGl0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcblxuICAgIGVzY2FwZVJlZ0V4cDogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UoLyhbLiorP149IToke30oKXxbXFxdXFwvXFxcXF0pL2csICdcXFxcJDEnKTtcbiAgICB9LFxuXG4gICAgc3BsaWNlOiBmdW5jdGlvbihzdHIsIGksIGhvd21hbnksIHN1YnN0cil7XG4gICAgICB2YXIgYXJyID0gX3MuY2hhcnMoc3RyKTtcbiAgICAgIGFyci5zcGxpY2Uofn5pLCB+fmhvd21hbnksIHN1YnN0cik7XG4gICAgICByZXR1cm4gYXJyLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBpbnNlcnQ6IGZ1bmN0aW9uKHN0ciwgaSwgc3Vic3RyKXtcbiAgICAgIHJldHVybiBfcy5zcGxpY2Uoc3RyLCBpLCAwLCBzdWJzdHIpO1xuICAgIH0sXG5cbiAgICBpbmNsdWRlOiBmdW5jdGlvbihzdHIsIG5lZWRsZSl7XG4gICAgICBpZiAobmVlZGxlID09PSAnJykgcmV0dXJuIHRydWU7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5pbmRleE9mKG5lZWRsZSkgIT09IC0xO1xuICAgIH0sXG5cbiAgICBqb2luOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgICBzZXBhcmF0b3IgPSBhcmdzLnNoaWZ0KCk7XG5cbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkgc2VwYXJhdG9yID0gJyc7XG5cbiAgICAgIHJldHVybiBhcmdzLmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbGluZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikuc3BsaXQoXCJcXG5cIik7XG4gICAgfSxcblxuICAgIHJldmVyc2U6IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gX3MuY2hhcnMoc3RyKS5yZXZlcnNlKCkuam9pbignJyk7XG4gICAgfSxcblxuICAgIHN0YXJ0c1dpdGg6IGZ1bmN0aW9uKHN0ciwgc3RhcnRzKXtcbiAgICAgIGlmIChzdGFydHMgPT09ICcnKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCB8fCBzdGFydHMgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IHN0YXJ0cyA9IFN0cmluZyhzdGFydHMpO1xuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPj0gc3RhcnRzLmxlbmd0aCAmJiBzdHIuc2xpY2UoMCwgc3RhcnRzLmxlbmd0aCkgPT09IHN0YXJ0cztcbiAgICB9LFxuXG4gICAgZW5kc1dpdGg6IGZ1bmN0aW9uKHN0ciwgZW5kcyl7XG4gICAgICBpZiAoZW5kcyA9PT0gJycpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKHN0ciA9PSBudWxsIHx8IGVuZHMgPT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IGVuZHMgPSBTdHJpbmcoZW5kcyk7XG4gICAgICByZXR1cm4gc3RyLmxlbmd0aCA+PSBlbmRzLmxlbmd0aCAmJiBzdHIuc2xpY2Uoc3RyLmxlbmd0aCAtIGVuZHMubGVuZ3RoKSA9PT0gZW5kcztcbiAgICB9LFxuXG4gICAgc3VjYzogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7XG4gICAgICByZXR1cm4gc3RyLnNsaWNlKDAsIC0xKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyLmNoYXJDb2RlQXQoc3RyLmxlbmd0aC0xKSArIDEpO1xuICAgIH0sXG5cbiAgICB0aXRsZWl6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgc3RyICA9IFN0cmluZyhzdHIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICByZXR1cm4gc3RyLnJlcGxhY2UoLyg/Ol58XFxzfC0pXFxTL2csIGZ1bmN0aW9uKGMpeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpOyB9KTtcbiAgICB9LFxuXG4gICAgY2FtZWxpemU6IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gX3MudHJpbShzdHIpLnJlcGxhY2UoL1stX1xcc10rKC4pPy9nLCBmdW5jdGlvbihtYXRjaCwgYyl7IHJldHVybiBjID8gYy50b1VwcGVyQ2FzZSgpIDogXCJcIjsgfSk7XG4gICAgfSxcblxuICAgIHVuZGVyc2NvcmVkOiBmdW5jdGlvbihzdHIpe1xuICAgICAgcmV0dXJuIF9zLnRyaW0oc3RyKS5yZXBsYWNlKC8oW2EtelxcZF0pKFtBLVpdKykvZywgJyQxXyQyJykucmVwbGFjZSgvWy1cXHNdKy9nLCAnXycpLnRvTG93ZXJDYXNlKCk7XG4gICAgfSxcblxuICAgIGRhc2hlcml6ZTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHJldHVybiBfcy50cmltKHN0cikucmVwbGFjZSgvKFtBLVpdKS9nLCAnLSQxJykucmVwbGFjZSgvWy1fXFxzXSsvZywgJy0nKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG5cbiAgICBjbGFzc2lmeTogZnVuY3Rpb24oc3RyKXtcbiAgICAgIHJldHVybiBfcy5jYXBpdGFsaXplKF9zLmNhbWVsaXplKFN0cmluZyhzdHIpLnJlcGxhY2UoL1tcXFdfXS9nLCAnICcpKS5yZXBsYWNlKC9cXHMvZywgJycpKTtcbiAgICB9LFxuXG4gICAgaHVtYW5pemU6IGZ1bmN0aW9uKHN0cil7XG4gICAgICByZXR1cm4gX3MuY2FwaXRhbGl6ZShfcy51bmRlcnNjb3JlZChzdHIpLnJlcGxhY2UoL19pZCQvLCcnKS5yZXBsYWNlKC9fL2csICcgJykpO1xuICAgIH0sXG5cbiAgICB0cmltOiBmdW5jdGlvbihzdHIsIGNoYXJhY3RlcnMpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBpZiAoIWNoYXJhY3RlcnMgJiYgbmF0aXZlVHJpbSkgcmV0dXJuIG5hdGl2ZVRyaW0uY2FsbChzdHIpO1xuICAgICAgY2hhcmFjdGVycyA9IGRlZmF1bHRUb1doaXRlU3BhY2UoY2hhcmFjdGVycyk7XG4gICAgICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShuZXcgUmVnRXhwKCdeJyArIGNoYXJhY3RlcnMgKyAnK3wnICsgY2hhcmFjdGVycyArICcrJCcsICdnJyksICcnKTtcbiAgICB9LFxuXG4gICAgbHRyaW06IGZ1bmN0aW9uKHN0ciwgY2hhcmFjdGVycyl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIGlmICghY2hhcmFjdGVycyAmJiBuYXRpdmVUcmltTGVmdCkgcmV0dXJuIG5hdGl2ZVRyaW1MZWZ0LmNhbGwoc3RyKTtcbiAgICAgIGNoYXJhY3RlcnMgPSBkZWZhdWx0VG9XaGl0ZVNwYWNlKGNoYXJhY3RlcnMpO1xuICAgICAgcmV0dXJuIFN0cmluZyhzdHIpLnJlcGxhY2UobmV3IFJlZ0V4cCgnXicgKyBjaGFyYWN0ZXJzICsgJysnKSwgJycpO1xuICAgIH0sXG5cbiAgICBydHJpbTogZnVuY3Rpb24oc3RyLCBjaGFyYWN0ZXJzKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgaWYgKCFjaGFyYWN0ZXJzICYmIG5hdGl2ZVRyaW1SaWdodCkgcmV0dXJuIG5hdGl2ZVRyaW1SaWdodC5jYWxsKHN0cik7XG4gICAgICBjaGFyYWN0ZXJzID0gZGVmYXVsdFRvV2hpdGVTcGFjZShjaGFyYWN0ZXJzKTtcbiAgICAgIHJldHVybiBTdHJpbmcoc3RyKS5yZXBsYWNlKG5ldyBSZWdFeHAoY2hhcmFjdGVycyArICcrJCcpLCAnJyk7XG4gICAgfSxcblxuICAgIHRydW5jYXRlOiBmdW5jdGlvbihzdHIsIGxlbmd0aCwgdHJ1bmNhdGVTdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBzdHIgPSBTdHJpbmcoc3RyKTsgdHJ1bmNhdGVTdHIgPSB0cnVuY2F0ZVN0ciB8fCAnLi4uJztcbiAgICAgIGxlbmd0aCA9IH5+bGVuZ3RoO1xuICAgICAgcmV0dXJuIHN0ci5sZW5ndGggPiBsZW5ndGggPyBzdHIuc2xpY2UoMCwgbGVuZ3RoKSArIHRydW5jYXRlU3RyIDogc3RyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBfcy5wcnVuZTogYSBtb3JlIGVsZWdhbnQgdmVyc2lvbiBvZiB0cnVuY2F0ZVxuICAgICAqIHBydW5lIGV4dHJhIGNoYXJzLCBuZXZlciBsZWF2aW5nIGEgaGFsZi1jaG9wcGVkIHdvcmQuXG4gICAgICogQGF1dGhvciBnaXRodWIuY29tL3J3elxuICAgICAqL1xuICAgIHBydW5lOiBmdW5jdGlvbihzdHIsIGxlbmd0aCwgcHJ1bmVTdHIpe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG5cbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpOyBsZW5ndGggPSB+fmxlbmd0aDtcbiAgICAgIHBydW5lU3RyID0gcHJ1bmVTdHIgIT0gbnVsbCA/IFN0cmluZyhwcnVuZVN0cikgOiAnLi4uJztcblxuICAgICAgaWYgKHN0ci5sZW5ndGggPD0gbGVuZ3RoKSByZXR1cm4gc3RyO1xuXG4gICAgICB2YXIgdG1wbCA9IGZ1bmN0aW9uKGMpeyByZXR1cm4gYy50b1VwcGVyQ2FzZSgpICE9PSBjLnRvTG93ZXJDYXNlKCkgPyAnQScgOiAnICc7IH0sXG4gICAgICAgIHRlbXBsYXRlID0gc3RyLnNsaWNlKDAsIGxlbmd0aCsxKS5yZXBsYWNlKC8uKD89XFxXKlxcdyokKS9nLCB0bXBsKTsgLy8gJ0hlbGxvLCB3b3JsZCcgLT4gJ0hlbGxBQSBBQUFBQSdcblxuICAgICAgaWYgKHRlbXBsYXRlLnNsaWNlKHRlbXBsYXRlLmxlbmd0aC0yKS5tYXRjaCgvXFx3XFx3LykpXG4gICAgICAgIHRlbXBsYXRlID0gdGVtcGxhdGUucmVwbGFjZSgvXFxzKlxcUyskLywgJycpO1xuICAgICAgZWxzZVxuICAgICAgICB0ZW1wbGF0ZSA9IF9zLnJ0cmltKHRlbXBsYXRlLnNsaWNlKDAsIHRlbXBsYXRlLmxlbmd0aC0xKSk7XG5cbiAgICAgIHJldHVybiAodGVtcGxhdGUrcHJ1bmVTdHIpLmxlbmd0aCA+IHN0ci5sZW5ndGggPyBzdHIgOiBzdHIuc2xpY2UoMCwgdGVtcGxhdGUubGVuZ3RoKStwcnVuZVN0cjtcbiAgICB9LFxuXG4gICAgd29yZHM6IGZ1bmN0aW9uKHN0ciwgZGVsaW1pdGVyKSB7XG4gICAgICBpZiAoX3MuaXNCbGFuayhzdHIpKSByZXR1cm4gW107XG4gICAgICByZXR1cm4gX3MudHJpbShzdHIsIGRlbGltaXRlcikuc3BsaXQoZGVsaW1pdGVyIHx8IC9cXHMrLyk7XG4gICAgfSxcblxuICAgIHBhZDogZnVuY3Rpb24oc3RyLCBsZW5ndGgsIHBhZFN0ciwgdHlwZSkge1xuICAgICAgc3RyID0gc3RyID09IG51bGwgPyAnJyA6IFN0cmluZyhzdHIpO1xuICAgICAgbGVuZ3RoID0gfn5sZW5ndGg7XG5cbiAgICAgIHZhciBwYWRsZW4gID0gMDtcblxuICAgICAgaWYgKCFwYWRTdHIpXG4gICAgICAgIHBhZFN0ciA9ICcgJztcbiAgICAgIGVsc2UgaWYgKHBhZFN0ci5sZW5ndGggPiAxKVxuICAgICAgICBwYWRTdHIgPSBwYWRTdHIuY2hhckF0KDApO1xuXG4gICAgICBzd2l0Y2godHlwZSkge1xuICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgcGFkbGVuID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gc3RyICsgc3RyUmVwZWF0KHBhZFN0ciwgcGFkbGVuKTtcbiAgICAgICAgY2FzZSAnYm90aCc6XG4gICAgICAgICAgcGFkbGVuID0gbGVuZ3RoIC0gc3RyLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gc3RyUmVwZWF0KHBhZFN0ciwgTWF0aC5jZWlsKHBhZGxlbi8yKSkgKyBzdHJcbiAgICAgICAgICAgICAgICAgICsgc3RyUmVwZWF0KHBhZFN0ciwgTWF0aC5mbG9vcihwYWRsZW4vMikpO1xuICAgICAgICBkZWZhdWx0OiAvLyAnbGVmdCdcbiAgICAgICAgICBwYWRsZW4gPSBsZW5ndGggLSBzdHIubGVuZ3RoO1xuICAgICAgICAgIHJldHVybiBzdHJSZXBlYXQocGFkU3RyLCBwYWRsZW4pICsgc3RyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGxwYWQ6IGZ1bmN0aW9uKHN0ciwgbGVuZ3RoLCBwYWRTdHIpIHtcbiAgICAgIHJldHVybiBfcy5wYWQoc3RyLCBsZW5ndGgsIHBhZFN0cik7XG4gICAgfSxcblxuICAgIHJwYWQ6IGZ1bmN0aW9uKHN0ciwgbGVuZ3RoLCBwYWRTdHIpIHtcbiAgICAgIHJldHVybiBfcy5wYWQoc3RyLCBsZW5ndGgsIHBhZFN0ciwgJ3JpZ2h0Jyk7XG4gICAgfSxcblxuICAgIGxycGFkOiBmdW5jdGlvbihzdHIsIGxlbmd0aCwgcGFkU3RyKSB7XG4gICAgICByZXR1cm4gX3MucGFkKHN0ciwgbGVuZ3RoLCBwYWRTdHIsICdib3RoJyk7XG4gICAgfSxcblxuICAgIHNwcmludGY6IHNwcmludGYsXG5cbiAgICB2c3ByaW50ZjogZnVuY3Rpb24oZm10LCBhcmd2KXtcbiAgICAgIGFyZ3YudW5zaGlmdChmbXQpO1xuICAgICAgcmV0dXJuIHNwcmludGYuYXBwbHkobnVsbCwgYXJndik7XG4gICAgfSxcblxuICAgIHRvTnVtYmVyOiBmdW5jdGlvbihzdHIsIGRlY2ltYWxzKSB7XG4gICAgICBpZiAoIXN0cikgcmV0dXJuIDA7XG4gICAgICBzdHIgPSBfcy50cmltKHN0cik7XG4gICAgICBpZiAoIXN0ci5tYXRjaCgvXi0/XFxkKyg/OlxcLlxcZCspPyQvKSkgcmV0dXJuIE5hTjtcbiAgICAgIHJldHVybiBwYXJzZU51bWJlcihwYXJzZU51bWJlcihzdHIpLnRvRml4ZWQofn5kZWNpbWFscykpO1xuICAgIH0sXG5cbiAgICBudW1iZXJGb3JtYXQgOiBmdW5jdGlvbihudW1iZXIsIGRlYywgZHNlcCwgdHNlcCkge1xuICAgICAgaWYgKGlzTmFOKG51bWJlcikgfHwgbnVtYmVyID09IG51bGwpIHJldHVybiAnJztcblxuICAgICAgbnVtYmVyID0gbnVtYmVyLnRvRml4ZWQofn5kZWMpO1xuICAgICAgdHNlcCA9IHR5cGVvZiB0c2VwID09ICdzdHJpbmcnID8gdHNlcCA6ICcsJztcblxuICAgICAgdmFyIHBhcnRzID0gbnVtYmVyLnNwbGl0KCcuJyksIGZudW1zID0gcGFydHNbMF0sXG4gICAgICAgIGRlY2ltYWxzID0gcGFydHNbMV0gPyAoZHNlcCB8fCAnLicpICsgcGFydHNbMV0gOiAnJztcblxuICAgICAgcmV0dXJuIGZudW1zLnJlcGxhY2UoLyhcXGQpKD89KD86XFxkezN9KSskKS9nLCAnJDEnICsgdHNlcCkgKyBkZWNpbWFscztcbiAgICB9LFxuXG4gICAgc3RyUmlnaHQ6IGZ1bmN0aW9uKHN0ciwgc2VwKXtcbiAgICAgIGlmIChzdHIgPT0gbnVsbCkgcmV0dXJuICcnO1xuICAgICAgc3RyID0gU3RyaW5nKHN0cik7IHNlcCA9IHNlcCAhPSBudWxsID8gU3RyaW5nKHNlcCkgOiBzZXA7XG4gICAgICB2YXIgcG9zID0gIXNlcCA/IC0xIDogc3RyLmluZGV4T2Yoc2VwKTtcbiAgICAgIHJldHVybiB+cG9zID8gc3RyLnNsaWNlKHBvcytzZXAubGVuZ3RoLCBzdHIubGVuZ3RoKSA6IHN0cjtcbiAgICB9LFxuXG4gICAgc3RyUmlnaHRCYWNrOiBmdW5jdGlvbihzdHIsIHNlcCl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpOyBzZXAgPSBzZXAgIT0gbnVsbCA/IFN0cmluZyhzZXApIDogc2VwO1xuICAgICAgdmFyIHBvcyA9ICFzZXAgPyAtMSA6IHN0ci5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgcmV0dXJuIH5wb3MgPyBzdHIuc2xpY2UocG9zK3NlcC5sZW5ndGgsIHN0ci5sZW5ndGgpIDogc3RyO1xuICAgIH0sXG5cbiAgICBzdHJMZWZ0OiBmdW5jdGlvbihzdHIsIHNlcCl7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpOyBzZXAgPSBzZXAgIT0gbnVsbCA/IFN0cmluZyhzZXApIDogc2VwO1xuICAgICAgdmFyIHBvcyA9ICFzZXAgPyAtMSA6IHN0ci5pbmRleE9mKHNlcCk7XG4gICAgICByZXR1cm4gfnBvcyA/IHN0ci5zbGljZSgwLCBwb3MpIDogc3RyO1xuICAgIH0sXG5cbiAgICBzdHJMZWZ0QmFjazogZnVuY3Rpb24oc3RyLCBzZXApe1xuICAgICAgaWYgKHN0ciA9PSBudWxsKSByZXR1cm4gJyc7XG4gICAgICBzdHIgKz0gJyc7IHNlcCA9IHNlcCAhPSBudWxsID8gJycrc2VwIDogc2VwO1xuICAgICAgdmFyIHBvcyA9IHN0ci5sYXN0SW5kZXhPZihzZXApO1xuICAgICAgcmV0dXJuIH5wb3MgPyBzdHIuc2xpY2UoMCwgcG9zKSA6IHN0cjtcbiAgICB9LFxuXG4gICAgdG9TZW50ZW5jZTogZnVuY3Rpb24oYXJyYXksIHNlcGFyYXRvciwgbGFzdFNlcGFyYXRvciwgc2VyaWFsKSB7XG4gICAgICBzZXBhcmF0b3IgPSBzZXBhcmF0b3IgfHwgJywgJztcbiAgICAgIGxhc3RTZXBhcmF0b3IgPSBsYXN0U2VwYXJhdG9yIHx8ICcgYW5kICc7XG4gICAgICB2YXIgYSA9IGFycmF5LnNsaWNlKCksIGxhc3RNZW1iZXIgPSBhLnBvcCgpO1xuXG4gICAgICBpZiAoYXJyYXkubGVuZ3RoID4gMiAmJiBzZXJpYWwpIGxhc3RTZXBhcmF0b3IgPSBfcy5ydHJpbShzZXBhcmF0b3IpICsgbGFzdFNlcGFyYXRvcjtcblxuICAgICAgcmV0dXJuIGEubGVuZ3RoID8gYS5qb2luKHNlcGFyYXRvcikgKyBsYXN0U2VwYXJhdG9yICsgbGFzdE1lbWJlciA6IGxhc3RNZW1iZXI7XG4gICAgfSxcblxuICAgIHRvU2VudGVuY2VTZXJpYWw6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICBhcmdzWzNdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBfcy50b1NlbnRlbmNlLmFwcGx5KF9zLCBhcmdzKTtcbiAgICB9LFxuXG4gICAgc2x1Z2lmeTogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcblxuICAgICAgdmFyIGZyb20gID0gXCLEhcOgw6HDpMOiw6PDpcOmxIPEh8SZw6jDqcOrw6rDrMOtw6/DrsWCxYTDssOzw7bDtMO1w7jFm8iZyJvDucO6w7zDu8Oxw6fFvMW6XCIsXG4gICAgICAgICAgdG8gICAgPSBcImFhYWFhYWFhYWNlZWVlZWlpaWlsbm9vb29vb3NzdHV1dXVuY3p6XCIsXG4gICAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKGRlZmF1bHRUb1doaXRlU3BhY2UoZnJvbSksICdnJyk7XG5cbiAgICAgIHN0ciA9IFN0cmluZyhzdHIpLnRvTG93ZXJDYXNlKCkucmVwbGFjZShyZWdleCwgZnVuY3Rpb24oYyl7XG4gICAgICAgIHZhciBpbmRleCA9IGZyb20uaW5kZXhPZihjKTtcbiAgICAgICAgcmV0dXJuIHRvLmNoYXJBdChpbmRleCkgfHwgJy0nO1xuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBfcy5kYXNoZXJpemUoc3RyLnJlcGxhY2UoL1teXFx3XFxzLV0vZywgJycpKTtcbiAgICB9LFxuXG4gICAgc3Vycm91bmQ6IGZ1bmN0aW9uKHN0ciwgd3JhcHBlcikge1xuICAgICAgcmV0dXJuIFt3cmFwcGVyLCBzdHIsIHdyYXBwZXJdLmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICBxdW90ZTogZnVuY3Rpb24oc3RyLCBxdW90ZUNoYXIpIHtcbiAgICAgIHJldHVybiBfcy5zdXJyb3VuZChzdHIsIHF1b3RlQ2hhciB8fCAnXCInKTtcbiAgICB9LFxuXG4gICAgdW5xdW90ZTogZnVuY3Rpb24oc3RyLCBxdW90ZUNoYXIpIHtcbiAgICAgIHF1b3RlQ2hhciA9IHF1b3RlQ2hhciB8fCAnXCInO1xuICAgICAgaWYgKHN0clswXSA9PT0gcXVvdGVDaGFyICYmIHN0cltzdHIubGVuZ3RoLTFdID09PSBxdW90ZUNoYXIpXG4gICAgICAgIHJldHVybiBzdHIuc2xpY2UoMSxzdHIubGVuZ3RoLTEpO1xuICAgICAgZWxzZSByZXR1cm4gc3RyO1xuICAgIH0sXG5cbiAgICBleHBvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcblxuICAgICAgZm9yICh2YXIgcHJvcCBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShwcm9wKSB8fCBwcm9wLm1hdGNoKC9eKD86aW5jbHVkZXxjb250YWluc3xyZXZlcnNlKSQvKSkgY29udGludWU7XG4gICAgICAgIHJlc3VsdFtwcm9wXSA9IHRoaXNbcHJvcF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHJlcGVhdDogZnVuY3Rpb24oc3RyLCBxdHksIHNlcGFyYXRvcil7XG4gICAgICBpZiAoc3RyID09IG51bGwpIHJldHVybiAnJztcblxuICAgICAgcXR5ID0gfn5xdHk7XG5cbiAgICAgIC8vIHVzaW5nIGZhc3RlciBpbXBsZW1lbnRhdGlvbiBpZiBzZXBhcmF0b3IgaXMgbm90IG5lZWRlZDtcbiAgICAgIGlmIChzZXBhcmF0b3IgPT0gbnVsbCkgcmV0dXJuIHN0clJlcGVhdChTdHJpbmcoc3RyKSwgcXR5KTtcblxuICAgICAgLy8gdGhpcyBvbmUgaXMgYWJvdXQgMzAweCBzbG93ZXIgaW4gR29vZ2xlIENocm9tZVxuICAgICAgZm9yICh2YXIgcmVwZWF0ID0gW107IHF0eSA+IDA7IHJlcGVhdFstLXF0eV0gPSBzdHIpIHt9XG4gICAgICByZXR1cm4gcmVwZWF0LmpvaW4oc2VwYXJhdG9yKTtcbiAgICB9LFxuXG4gICAgbmF0dXJhbENtcDogZnVuY3Rpb24oc3RyMSwgc3RyMil7XG4gICAgICBpZiAoc3RyMSA9PSBzdHIyKSByZXR1cm4gMDtcbiAgICAgIGlmICghc3RyMSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKCFzdHIyKSByZXR1cm4gMTtcblxuICAgICAgdmFyIGNtcFJlZ2V4ID0gLyhcXC5cXGQrKXwoXFxkKyl8KFxcRCspL2csXG4gICAgICAgIHRva2VuczEgPSBTdHJpbmcoc3RyMSkudG9Mb3dlckNhc2UoKS5tYXRjaChjbXBSZWdleCksXG4gICAgICAgIHRva2VuczIgPSBTdHJpbmcoc3RyMikudG9Mb3dlckNhc2UoKS5tYXRjaChjbXBSZWdleCksXG4gICAgICAgIGNvdW50ID0gTWF0aC5taW4odG9rZW5zMS5sZW5ndGgsIHRva2VuczIubGVuZ3RoKTtcblxuICAgICAgZm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIGEgPSB0b2tlbnMxW2ldLCBiID0gdG9rZW5zMltpXTtcblxuICAgICAgICBpZiAoYSAhPT0gYil7XG4gICAgICAgICAgdmFyIG51bTEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICAgICAgaWYgKCFpc05hTihudW0xKSl7XG4gICAgICAgICAgICB2YXIgbnVtMiA9IHBhcnNlSW50KGIsIDEwKTtcbiAgICAgICAgICAgIGlmICghaXNOYU4obnVtMikgJiYgbnVtMSAtIG51bTIpXG4gICAgICAgICAgICAgIHJldHVybiBudW0xIC0gbnVtMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGEgPCBiID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0b2tlbnMxLmxlbmd0aCA9PT0gdG9rZW5zMi5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0b2tlbnMxLmxlbmd0aCAtIHRva2VuczIubGVuZ3RoO1xuXG4gICAgICByZXR1cm4gc3RyMSA8IHN0cjIgPyAtMSA6IDE7XG4gICAgfSxcblxuICAgIGxldmVuc2h0ZWluOiBmdW5jdGlvbihzdHIxLCBzdHIyKSB7XG4gICAgICBpZiAoc3RyMSA9PSBudWxsICYmIHN0cjIgPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgICBpZiAoc3RyMSA9PSBudWxsKSByZXR1cm4gU3RyaW5nKHN0cjIpLmxlbmd0aDtcbiAgICAgIGlmIChzdHIyID09IG51bGwpIHJldHVybiBTdHJpbmcoc3RyMSkubGVuZ3RoO1xuXG4gICAgICBzdHIxID0gU3RyaW5nKHN0cjEpOyBzdHIyID0gU3RyaW5nKHN0cjIpO1xuXG4gICAgICB2YXIgY3VycmVudCA9IFtdLCBwcmV2LCB2YWx1ZTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc3RyMi5sZW5ndGg7IGkrKylcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gc3RyMS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGlmIChpICYmIGopXG4gICAgICAgICAgICBpZiAoc3RyMS5jaGFyQXQoaiAtIDEpID09PSBzdHIyLmNoYXJBdChpIC0gMSkpXG4gICAgICAgICAgICAgIHZhbHVlID0gcHJldjtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgdmFsdWUgPSBNYXRoLm1pbihjdXJyZW50W2pdLCBjdXJyZW50W2ogLSAxXSwgcHJldikgKyAxO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHZhbHVlID0gaSArIGo7XG5cbiAgICAgICAgICBwcmV2ID0gY3VycmVudFtqXTtcbiAgICAgICAgICBjdXJyZW50W2pdID0gdmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgcmV0dXJuIGN1cnJlbnQucG9wKCk7XG4gICAgfSxcblxuICAgIHRvQm9vbGVhbjogZnVuY3Rpb24oc3RyLCB0cnVlVmFsdWVzLCBmYWxzZVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiBzdHIgPT09IFwibnVtYmVyXCIpIHN0ciA9IFwiXCIgKyBzdHI7XG4gICAgICBpZiAodHlwZW9mIHN0ciAhPT0gXCJzdHJpbmdcIikgcmV0dXJuICEhc3RyO1xuICAgICAgc3RyID0gX3MudHJpbShzdHIpO1xuICAgICAgaWYgKGJvb2xNYXRjaChzdHIsIHRydWVWYWx1ZXMgfHwgW1widHJ1ZVwiLCBcIjFcIl0pKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChib29sTWF0Y2goc3RyLCBmYWxzZVZhbHVlcyB8fCBbXCJmYWxzZVwiLCBcIjBcIl0pKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8vIEFsaWFzZXNcblxuICBfcy5zdHJpcCAgICA9IF9zLnRyaW07XG4gIF9zLmxzdHJpcCAgID0gX3MubHRyaW07XG4gIF9zLnJzdHJpcCAgID0gX3MucnRyaW07XG4gIF9zLmNlbnRlciAgID0gX3MubHJwYWQ7XG4gIF9zLnJqdXN0ICAgID0gX3MubHBhZDtcbiAgX3MubGp1c3QgICAgPSBfcy5ycGFkO1xuICBfcy5jb250YWlucyA9IF9zLmluY2x1ZGU7XG4gIF9zLnEgICAgICAgID0gX3MucXVvdGU7XG4gIF9zLnRvQm9vbCAgID0gX3MudG9Cb29sZWFuO1xuXG4gIC8vIEV4cG9ydGluZ1xuXG4gIC8vIENvbW1vbkpTIG1vZHVsZSBpcyBkZWZpbmVkXG4gIGlmICh0eXBlb2YgZXhwb3J0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpXG4gICAgICBtb2R1bGUuZXhwb3J0cyA9IF9zO1xuXG4gICAgZXhwb3J0cy5fcyA9IF9zO1xuICB9XG5cbiAgLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBtb2R1bGUgd2l0aCBBTUQuXG4gIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlLnN0cmluZycsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gX3M7IH0pO1xuXG5cbiAgLy8gSW50ZWdyYXRlIHdpdGggVW5kZXJzY29yZS5qcyBpZiBkZWZpbmVkXG4gIC8vIG9yIGNyZWF0ZSBvdXIgb3duIHVuZGVyc2NvcmUgb2JqZWN0LlxuICByb290Ll8gPSByb290Ll8gfHwge307XG4gIHJvb3QuXy5zdHJpbmcgPSByb290Ll8uc3RyID0gX3M7XG59KHRoaXMsIFN0cmluZyk7XG5cbn0se31dLDE1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XG5hcmd1bWVudHNbNF1bMV1bMF0uYXBwbHkoZXhwb3J0cyxhcmd1bWVudHMpXG59LHtcImR1cFwiOjF9XSwxNTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xubW9kdWxlLmV4cG9ydHM9e1xuICBcIm5hbWVcIjogXCJqaWlcIixcbiAgXCJ2ZXJzaW9uXCI6IFwiMC43LjFcIixcbiAgXCJkZXNjcmlwdGlvblwiOiBcIkppaSAtIEZ1bGwtU3RhY2sgSmF2YVNjcmlwdCBGcmFtZXdvcmtcIixcbiAgXCJtYWluXCI6IFwiaW5kZXguanNcIixcbiAgXCJicm93c2VyXCI6IFwiaW5kZXgtY2xpZW50LmpzXCIsXG4gIFwiYXV0aG9yXCI6IFwiVmxhZGltaXIgS296aGluIDxhZmZrYUBhZmZrYS5ydT5cIixcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcInRlc3RcIjogXCJub2RldW5pdCB0ZXN0cy91bml0XCJcbiAgfSxcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9qaWlzb2Z0L2ppaVwiXG4gIH0sXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwieWlpXCIsXG4gICAgXCJwaHBcIixcbiAgICBcImZyYW1ld29ya1wiLFxuICAgIFwiamF2YXNjcmlwdFwiXG4gIF0sXG4gIFwibGljZW5zZVwiOiBcIk1JVFwiLFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL2ppaXNvZnQvamlpXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vamlpc29mdC9qaWkvaXNzdWVzXCJcbiAgfSxcbiAgXCJkZXBlbmRlbmNpZXNcIjoge1xuICAgIFwibmVhdG5lc3NcIjogXCJeMS4xLjEwXCIsXG4gICAgXCJyZXF1aXJlLWFsbFwiOiBcIjAuMC44XCIsXG4gICAgXCJ1bmRlcnNjb3JlXCI6IFwiXjEuOC4zXCIsXG4gICAgXCJ1bmRlcnNjb3JlLnN0cmluZ1wiOiBcIl4yLjQuMFwiXG4gIH0sXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcIm5vZGV1bml0XCI6IFwiKlwiXG4gIH1cbn1cblxufSx7fV0sMTU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9zcmMvTmVhdG5lc3MnKTtcbn0se1wiLi9zcmMvTmVhdG5lc3NcIjoxNjB9XSwxNTg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKE5lYXRuZXNzKSB7XG5cblx0cmV0dXJuIE5lYXRuZXNzLmNyZWF0ZUNsYXNzKCdOZWF0bmVzcy5FeGNlcHRpb24nLCAvKiogQGxlbmRzIE5lYXRuZXNzLkV4Y2VwdGlvbi5wcm90b3R5cGUgKi97XG5cblx0XHRfX2V4dGVuZHM6IEVycm9yLFxuXG5cdFx0LyoqXG5cdFx0ICogVGV4dCBtZXNzYWdlXG5cdFx0ICogQHR5cGUge3N0cmluZ31cblx0XHQgKi9cblx0XHRtZXNzYWdlOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRXh0cmEgaW5mb3JtYXRpb24gZHVtcHNcblx0XHQgKiBAdHlwZSB7QXJyYXl9XG5cdFx0ICovXG5cdFx0ZXh0cmE6IG51bGwsXG5cblx0XHQvKipcblx0XHQgKiBCYXNlIGNsYXNzIGZvciBpbXBsZW1lbnQgZXhjZXB0aW9uLiBUaGlzIGNsYXNzIGV4dGVuZCBmcm9tIG5hdGl2ZSBFcnJvciBhbmQgc3VwcG9ydFxuXHRcdCAqIHN0YWNrIHRyYWNlIGFuZCBtZXNzYWdlLlxuXHRcdCAqIEBjb25zdHJ1Y3RzXG5cdFx0ICogQGV4dGVuZHMgRXJyb3Jcblx0XHQgKi9cblx0XHRjb25zdHJ1Y3RvcjogZnVuY3Rpb24gKG1lc3NhZ2UpIHtcblx0XHRcdGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuXHRcdFx0XHRFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yIHx8IHRoaXMpO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG5cdFx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlIHx8ICcnO1xuXG5cdFx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy5leHRyYSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX19zdXBlcigpO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKlxuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJldHVybiB0aGlzLm1lc3NhZ2U7XG5cdFx0fVxuXG5cdH0pO1xuXG59O1xufSx7fV0sMTU5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihOZWF0bmVzcykge1xuXG5cdC8qKlxuXHQgKiBCYXNlIGNsYXNzLiBFeHRlbmQgYWxsIHlvdSBiYXNlIGNsYXNzZXMgZnJvbSB0aGlzIGNsYXNzIGZvciB0cnVlIG5hdmlnYXRpb24gaW4gSURFXG5cdCAqIGFuZCBzdXBwb3J0IG1ldGhvZHMgc3VjaCBhcyB7QGxpbmsgTmVhdG5lc3MuT2JqZWN0I2NsYXNzTmFtZX1cblx0ICogQGNsYXNzIE5lYXRuZXNzLk9iamVjdFxuXHQgKi9cblx0cmV0dXJuIE5lYXRuZXNzLmNyZWF0ZUNsYXNzKCdOZWF0bmVzcy5PYmplY3QnLCB7XG5cblx0XHQvKipcblx0XHQgKiBMaW5rIHRvIHVzZWQgY2xhc3MuIElmIHlvdSBhY2Nlc3MgdG8gdGhpcyBwcm9wZXJ0eSBpbiBleHRlbmRzIGNsYXNzZXMsIHRoZW4geW91IGdpdmUgdG9wLWxldmVsIGNsYXNzLlxuXHRcdCAqIEB0eXBlIHsqfVxuXHRcdCAqL1xuXHRcdF9fc3RhdGljOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogRnVsbCBjdXJyZW50IGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0XHQgKiBAZXhhbXBsZSBSZXR1cm5zIHZhbHVlIGV4YW1wbGVcblx0XHQgKiAgYXBwLk15Q2xhc3Ncblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfX2NsYXNzTmFtZTogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIFVuaXF1ZSBpbnN0YW5jZSBuYW1lXG5cdFx0ICogQGV4YW1wbGUgUmV0dXJucyB2YWx1ZSBleGFtcGxlXG5cdFx0ICogIGFwcC5NeUNsYXNzNTBcblx0XHQgKiBAdHlwZSB7c3RyaW5nfVxuXHRcdCAqIEBwcm90ZWN0ZWRcblx0XHQgKi9cblx0XHRfX2luc3RhbmNlTmFtZTogbnVsbCxcblxuXHRcdC8qKlxuXHRcdCAqIEZ1bGwgcGFyZW50IChleHRlbmRzKSBjbGFzcyBuYW1lIHdpdGggbmFtZXNwYWNlXG5cdFx0ICogQGV4YW1wbGUgUmV0dXJucyB2YWx1ZSBleGFtcGxlXG5cdFx0ICogIGFwcC5NeUJhc2VDbGFzc1xuXHRcdCAqIEB0eXBlIHtzdHJpbmd9XG5cdFx0ICogQHByb3RlY3RlZFxuXHRcdCAqL1xuXHRcdF9fcGFyZW50Q2xhc3NOYW1lOiBudWxsLFxuXG5cdFx0LyoqXG5cdFx0ICogUmV0dXJucyBmdWxsIGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICBhcHAuTXlDbGFzc1xuXHRcdCAqIEByZXR1cm5zIHtzdHJpbmd9XG5cdFx0ICovXG5cdFx0Y2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9fY2xhc3NOYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIHVuaXF1ZSBpbnN0YW5jZSBuYW1lXG5cdFx0ICogQGV4YW1wbGVcblx0XHQgKiAgYXBwLk15Q2xhc3Ncblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdGNsYXNzSW5zdGFuY2VOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9faW5zdGFuY2VOYW1lO1xuXHRcdH0sXG5cblx0XHQvKipcblx0XHQgKiBSZXR1cm5zIGZ1bGwgcGFyZW50IGNsYXNzIG5hbWUgd2l0aCBuYW1lc3BhY2Vcblx0XHQgKiBAZXhhbXBsZVxuXHRcdCAqICBhcHAuTXlCYXNlQ2xhc3Ncblx0XHQgKiBAcmV0dXJucyB7c3RyaW5nfVxuXHRcdCAqL1xuXHRcdHBhcmVudENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fX3BhcmVudENsYXNzTmFtZTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQ2FsbCBwYXJlbnQgY2xhc3MgbWV0aG9kcyB0aHJvdWdoIHRoaXMgbWV0aG9kLiBUaGlzIG1ldGhvZCBzdXBwb3J0IG9ubHkgc3luY2hyb25vdXMgbmVzdGVkIGNhbGxzLlxuXHRcdCAqIEBwYXJhbSB7Li4uKn1cblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICovXG5cdFx0X19zdXBlcjogZnVuY3Rpb24gKCkge1xuXHRcdH1cblxuXHR9KTtcblxufTtcblxufSx7fV0sMTYwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcblxyXG52YXIgZXh0ZW5kQ2xhc3MgPSByZXF1aXJlKCcuL2V4dGVuZENsYXNzJyk7XHJcbnZhciBmb3JtYXRzID0gcmVxdWlyZSgnLi9mb3JtYXRzJyk7XHJcblxyXG4vLyBGb3IgLm5vQ29uZmxpY3QoKSBpbXBsZW1lbnRhdGlvblxyXG52YXIgaGFzUHJldmlvdXNOZWF0bmVzcyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5oYXNPd25Qcm9wZXJ0eSgnTmVhdG5lc3MnKTtcclxudmFyIHByZXZpb3VzTmVhdG5lc3MgPSBoYXNQcmV2aW91c05lYXRuZXNzID8gd2luZG93Lk5lYXRuZXNzIDogbnVsbDtcclxuXHJcbi8qKlxyXG4gKiBOZWF0bmVzcyBjbGFzc1xyXG4gKiBAZnVuY3Rpb24gTmVhdG5lc3NcclxuICovXHJcbnZhciBOZWF0bmVzcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvKipcclxuXHQgKlxyXG5cdCAqIEB0eXBlIHtvYmplY3R9XHJcblx0ICovXHJcblx0dGhpcy5fY29udGV4dCA9IHt9O1xyXG5cclxuXHR0aGlzLl9jb250ZXh0S2V5cyA9IHt9O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUubmV3Q29udGV4dFxyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZW1vdmVHbG9iYWxdIFNldCB0cnVlIGZvciByZW1vdmUgTmVhdG5lc3Mgb2JqZWN0IGZyb20gd2luZG93IChicm93c2VyIGdsb2JhbCBvYmplY3QpXHJcbiAqIEByZXR1cm5zIHtOZWF0bmVzc31cclxuICovXHJcbk5lYXRuZXNzLnByb3RvdHlwZS5uZXdDb250ZXh0ID0gZnVuY3Rpb24ocmVtb3ZlR2xvYmFsKSB7XHJcblx0cmVtb3ZlR2xvYmFsID0gcmVtb3ZlR2xvYmFsIHx8IGZhbHNlO1xyXG5cclxuXHRpZiAocmVtb3ZlR2xvYmFsKSB7XHJcblx0XHR0aGlzLm5vQ29uZmxpY3QoKTtcclxuXHR9XHJcblxyXG5cdHJldHVybiBuZXcgTmVhdG5lc3MoKTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBAZnVuY3Rpb24gTmVhdG5lc3MucHJvdG90eXBlLm1vdmVDb250ZXh0XHJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbmV3Q29udGV4dCBOZXcgY29udGV4dCBvYmplY3RcclxuICogQHBhcmFtIHtib29sZWFufSBbcmVtb3ZlRnJvbU9sZF0gU2V0IHRydWUgZm9yIHJlbW92ZSBrZXlzIGZyb20gb2xkIGNvbnRleHRcclxuICogQHJldHVybnMge05lYXRuZXNzfVxyXG4gKi9cclxuTmVhdG5lc3MucHJvdG90eXBlLm1vdmVDb250ZXh0ID0gZnVuY3Rpb24obmV3Q29udGV4dCwgcmVtb3ZlRnJvbU9sZCkge1xyXG5cdHJlbW92ZUZyb21PbGQgPSByZW1vdmVGcm9tT2xkIHx8IGZhbHNlO1xyXG5cclxuXHRmb3IgKHZhciBrZXkgaW4gdGhpcy5fY29udGV4dEtleXMpIHtcclxuXHRcdGlmICh0aGlzLl9jb250ZXh0S2V5cy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdG5ld0NvbnRleHRba2V5XSA9IHRoaXMuX2NvbnRleHRba2V5XTtcclxuXHRcdFx0aWYgKHJlbW92ZUZyb21PbGQpIHtcclxuXHRcdFx0XHRkZWxldGUgdGhpcy5fY29udGV4dFtrZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHRoaXMuX2NvbnRleHQgPSBuZXdDb250ZXh0O1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUubm9Db25mbGljdFxyXG4gKiBAcmV0dXJucyB7TmVhdG5lc3N9XHJcbiAqL1xyXG5OZWF0bmVzcy5wcm90b3R5cGUubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xyXG5cdC8vIFJvb3QgbmFtZXNwYWNlIG9iamVjdFxyXG5cdHZhciByb290ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB7fTtcclxuXHJcblx0aWYgKGhhc1ByZXZpb3VzTmVhdG5lc3MpIHtcclxuXHRcdHJvb3QuTmVhdG5lc3MgPSBwcmV2aW91c05lYXRuZXNzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHRkZWxldGUgcm9vdC5OZWF0bmVzcztcclxuXHR9XHJcblxyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUubmFtZXNwYWNlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEZ1bGwgbmFtZXNwYWNlIG5hbWVcclxuICogQHJldHVybnMge29iamVjdH1cclxuICovXHJcbk5lYXRuZXNzLnByb3RvdHlwZS5uYW1lc3BhY2UgPSBmdW5jdGlvbiAobmFtZSkge1xyXG5cdG5hbWUgPSBuYW1lIHx8ICcnO1xyXG5cclxuXHR2YXIgbmFtZVBhcnRzID0gbmFtZS5zcGxpdCgnLicpO1xyXG5cdHZhciBjdXJyZW50U2NvcGUgPSB0aGlzLl9jb250ZXh0O1xyXG5cclxuXHRpZiAoIW5hbWUpIHtcclxuXHRcdHJldHVybiBjdXJyZW50U2NvcGU7XHJcblx0fVxyXG5cclxuXHQvLyBGaW5kIG9yIGNyZWF0ZVxyXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZVBhcnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHR2YXIgc2NvcGVOYW1lID0gbmFtZVBhcnRzW2ldO1xyXG5cdFx0aWYgKGkgPT09IDApIHtcclxuXHRcdFx0dGhpcy5fY29udGV4dEtleXNbc2NvcGVOYW1lXSA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFjdXJyZW50U2NvcGVbc2NvcGVOYW1lXSkge1xyXG5cdFx0XHRjdXJyZW50U2NvcGVbc2NvcGVOYW1lXSA9IHtcclxuXHRcdFx0XHRfX2NsYXNzTmFtZTogbmFtZVBhcnRzLnNsaWNlKDAsIGkpLmpvaW4oJy4nKSxcclxuXHRcdFx0XHRfX3BhcmVudENsYXNzTmFtZTogbnVsbFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdFx0Y3VycmVudFNjb3BlID0gY3VycmVudFNjb3BlW3Njb3BlTmFtZV07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gY3VycmVudFNjb3BlO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1ldGhvZCBmb3IgZGVmaW5lIGNsYXNzXHJcbiAqIEBmdW5jdGlvbiBOZWF0bmVzcy5wcm90b3R5cGUuY3JlYXRlQ2xhc3NcclxuICogQHBhcmFtIHtzdHJpbmd9IGdsb2JhbE5hbWVcclxuICogQHBhcmFtIHsoZnVuY3Rpb258b2JqZWN0fG51bGwpfSBvcHRpb25zT3JFeHRlbmRcclxuICogQHBhcmFtIHtvYmplY3R9IFtwcm90b3R5cGVQcm9wZXJ0aWVzXVxyXG4gKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BlcnRpZXNdXHJcbiAqIEByZXR1cm4ge29iamVjdH1cclxuICovXHJcbk5lYXRuZXNzLnByb3RvdHlwZS5jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uIChnbG9iYWxOYW1lLCBvcHRpb25zT3JFeHRlbmQsIHByb3RvdHlwZVByb3BlcnRpZXMsIHN0YXRpY1Byb3BlcnRpZXMpIHtcclxuXHR2YXIgcGFyYW1zID0gZm9ybWF0cy5wYXJzZUZvcm1hdChnbG9iYWxOYW1lLCBvcHRpb25zT3JFeHRlbmQsIHByb3RvdHlwZVByb3BlcnRpZXMsIHN0YXRpY1Byb3BlcnRpZXMpO1xyXG5cclxuXHQvLyBTdXBwb3J0IGV4dGVuZHMgYW5kIG1peGlucyBhcyBzdHJpbmdzIGNsYXNzIG5hbWVzXHJcblx0aWYgKHR5cGVvZiBwYXJhbXNbMl0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRwYXJhbXNbMl0gPSB0aGlzLm5hbWVzcGFjZShwYXJhbXNbMl0pO1xyXG5cdH1cclxuXHR2YXIgbWl4aW5zID0gcGFyYW1zWzZdO1xyXG5cdGZvciAodmFyIGkgPSAwLCBsID0gbWl4aW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0aWYgKHR5cGVvZiBtaXhpbnNbaV0gPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdG1peGluc1tpXSA9IHRoaXMubmFtZXNwYWNlKG1peGluc1tpXSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvLyBTaG93IGVycm9yIGlmIG5vdCBkZWZpbmVkIGV4dGVuZGVkIGNsYXNzXHJcblx0aWYgKHBhcmFtc1syXSAhPT0gbnVsbCAmJiB0eXBlb2YgcGFyYW1zWzJdICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vdCBmb3VuZCBleHRlbmQgY2xhc3MgZm9yIGAnICsgZ2xvYmFsTmFtZSArICdgLicpO1xyXG5cdH1cclxuXHJcblx0dmFyIG5ld0NsYXNzID0gZXh0ZW5kQ2xhc3MocGFyYW1zWzBdLCBwYXJhbXNbMV0sIHBhcmFtc1syXSwgcGFyYW1zWzZdLCBwYXJhbXNbM10sIHBhcmFtc1s0XSwgcGFyYW1zWzddKTtcclxuXHRmb3JtYXRzLmFwcGx5Q2xhc3NDb25maWcobmV3Q2xhc3MsIHBhcmFtc1s1XSwgcGFyYW1zWzBdLCBwYXJhbXNbMV0pO1xyXG5cclxuXHRyZXR1cm4gbmV3Q2xhc3M7XHJcbn07XHJcblxyXG4vKipcclxuICogTWV0aG9kIGZvciBkZWZpbmUgY2xhc3NcclxuICogQGZ1bmN0aW9uIE5lYXRuZXNzLnByb3RvdHlwZS5kZWZpbmVDbGFzc1xyXG4gKiBAcGFyYW0ge3N0cmluZ30gZ2xvYmFsTmFtZVxyXG4gKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3R8bnVsbCl9IG9wdGlvbnNPckV4dGVuZFxyXG4gKiBAcGFyYW0ge29iamVjdH0gW3Byb3RvdHlwZVByb3BlcnRpZXNdXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc3RhdGljUHJvcGVydGllc11cclxuICogQHJldHVybiB7b2JqZWN0fVxyXG4gKi9cclxuTmVhdG5lc3MucHJvdG90eXBlLmRlZmluZUNsYXNzID0gZnVuY3Rpb24gKGdsb2JhbE5hbWUsIG9wdGlvbnNPckV4dGVuZCwgcHJvdG90eXBlUHJvcGVydGllcywgc3RhdGljUHJvcGVydGllcykge1xyXG5cdHZhciBuZXdDbGFzcyA9IHRoaXMuY3JlYXRlQ2xhc3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR2YXIgbmFtZU9iamVjdCA9IGZvcm1hdHMucGFyc2VGdWxsTmFtZShnbG9iYWxOYW1lKTtcclxuXHJcblx0dGhpcy5uYW1lc3BhY2UobmFtZU9iamVjdC5uYW1lc3BhY2UpW25hbWVPYmplY3QubmFtZV0gPSBuZXdDbGFzcztcclxuXHRyZXR1cm4gbmV3Q2xhc3M7XHJcbn07XHJcblxyXG4vKipcclxuICogTWV0aG9kIGZvciBkZWZpbmUgZW51bVxyXG4gKiBAZnVuY3Rpb24gTmVhdG5lc3MucHJvdG90eXBlLmRlZmluZUNsYXNzXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBnbG9iYWxOYW1lXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbc3RhdGljUHJvcGVydGllc11cclxuICogQHJldHVybiB7b2JqZWN0fVxyXG4gKi9cclxuTmVhdG5lc3MucHJvdG90eXBlLmRlZmluZUVudW0gPSBmdW5jdGlvbiAoZ2xvYmFsTmFtZSwgc3RhdGljUHJvcGVydGllcykge1xyXG5cdHZhciBuZXdDbGFzcyA9IHRoaXMuY3JlYXRlQ2xhc3MoZ2xvYmFsTmFtZSwgbnVsbCwge30sIHN0YXRpY1Byb3BlcnRpZXMpO1xyXG5cdHZhciBuYW1lT2JqZWN0ID0gZm9ybWF0cy5wYXJzZUZ1bGxOYW1lKGdsb2JhbE5hbWUpO1xyXG5cclxuXHR0aGlzLm5hbWVzcGFjZShuYW1lT2JqZWN0Lm5hbWVzcGFjZSlbbmFtZU9iamVjdC5uYW1lXSA9IG5ld0NsYXNzO1xyXG5cdHJldHVybiBuZXdDbGFzcztcclxufTtcclxuXHJcbnZhciBuZWF0bmVzcyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IE5lYXRuZXNzKCk7XHJcblxyXG4vLyBXZWIgYnJvd3NlciBleHBvcnRcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcblx0d2luZG93Lk5lYXRuZXNzID0gbmVhdG5lc3M7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7TmVhdG5lc3MucHJvdG90eXBlLk9iamVjdH1cclxuICovXHJcbk5lYXRuZXNzLnByb3RvdHlwZS5PYmplY3QgPSByZXF1aXJlKCcuL05lYXRuZXNzLk9iamVjdCcpKG5lYXRuZXNzKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7TmVhdG5lc3MucHJvdG90eXBlLkV4Y2VwdGlvbn1cclxuICovXHJcbk5lYXRuZXNzLnByb3RvdHlwZS5FeGNlcHRpb24gPSByZXF1aXJlKCcuL05lYXRuZXNzLkV4Y2VwdGlvbicpKG5lYXRuZXNzKTtcclxuXHJcbi8qKlxyXG4gKiBAdHlwZSB7c3RyaW5nfVxyXG4gKi9cclxuTmVhdG5lc3MucHJvdG90eXBlLnZlcnNpb24gPSAnJUpPSU5UU19DVVJSRU5UX1ZFUlNJT04lJztcclxuXG59LHtcIi4vTmVhdG5lc3MuRXhjZXB0aW9uXCI6MTU4LFwiLi9OZWF0bmVzcy5PYmplY3RcIjoxNTksXCIuL2V4dGVuZENsYXNzXCI6MTYxLFwiLi9mb3JtYXRzXCI6MTYyfV0sMTYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBpc0V2YWxFbmFibGUgPSB0cnVlO1xyXG52YXIgaW5zdGFuY2VDb3VudGVyID0gMDtcclxuXHJcbnZhciBfbm9vcCA9IGZ1bmN0aW9uKCkge1xyXG59O1xyXG5cclxudmFyIF9jcmVhdGVGdW5jdGlvbiA9IGZ1bmN0aW9uKG5hbWVPYmplY3QsIGNvbnN0cnVjdG9yKSB7XHJcblx0aWYgKCFpc0V2YWxFbmFibGUgfHwgIW5hbWVPYmplY3QpIHtcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zdHJ1Y3Rvci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XHJcblx0fVxyXG5cclxuXHR2YXIgbmFtZVJlZ0V4cCA9IC9bXmEteiRfXFwuXS9pO1xyXG5cdHZhciBuYW1lID0gbmFtZU9iamVjdC5uYW1lIHx8ICdGdW5jdGlvbic7XHJcblx0dmFyIG5hbWVQYXJ0cyA9IG5hbWVPYmplY3QuZ2xvYmFsTmFtZS5zcGxpdCgnLicpO1xyXG5cclxuXHQvLyBDcmVhdGUgcm9vdCBvYmplY3RcclxuXHR2YXIgcm9vdE5hbWUgPSBuYW1lUGFydHMuc2hpZnQoKTtcclxuXHR2YXIgY3M7XHJcblxyXG5cdHJvb3ROYW1lID0gcm9vdE5hbWUucmVwbGFjZShuYW1lUmVnRXhwLCAnJyk7XHJcblx0ZXZhbCgndmFyICcgKyByb290TmFtZSArICcgPSBjcyA9IHt9OycpO1xyXG5cclxuXHQvLyBDcmVhdGUgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lUGFydHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBzY29wZU5hbWUgPSBuYW1lUGFydHNbaV07XHJcblx0XHRpZiAoIWNzW3Njb3BlTmFtZV0pIHtcclxuXHRcdFx0Y3Nbc2NvcGVOYW1lXSA9IHt9O1xyXG5cdFx0fVxyXG5cdFx0Y3MgPSBjc1tzY29wZU5hbWVdO1xyXG5cdH1cclxuXHJcblx0dmFyIGZ1bmM7XHJcblx0dmFyIGZ1bGxOYW1lID0gKG5hbWVPYmplY3QubmFtZXNwYWNlID8gbmFtZU9iamVjdC5uYW1lc3BhY2UgKyAnLicgOiAnJykgKyBuYW1lO1xyXG5cclxuXHRmdWxsTmFtZSA9IGZ1bGxOYW1lLnJlcGxhY2UobmFtZVJlZ0V4cCwgJycpO1xyXG5cdGV2YWwoJ2Z1bmMgPSAnICsgZnVsbE5hbWUgKyAnID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gY29uc3RydWN0b3IuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfScpO1xyXG5cclxuXHRyZXR1cm4gZnVuYztcclxufTtcclxuXHJcbnZhciBfaXNTdHJpY3RPYmplY3QgPSBmdW5jdGlvbiAob2JqKSB7XHJcblx0aWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqIGluc3RhbmNlb2YgUmVnRXhwIHx8IG9iaiBpbnN0YW5jZW9mIERhdGUpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHZhciBib29sID0gdHJ1ZTtcclxuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0XHRib29sID0gYm9vbCAmJiBvYmouaGFzT3duUHJvcGVydHkoa2V5KTtcclxuXHR9XHJcblx0cmV0dXJuIGJvb2w7XHJcbn07XHJcblxyXG52YXIgX2Nsb25lID0gZnVuY3Rpb24ob2JqKSB7XHJcblx0aWYgKCFfaXNTdHJpY3RPYmplY3Qob2JqKSkge1xyXG5cdFx0cmV0dXJuIG9iajtcclxuXHR9XHJcblxyXG5cdHZhciBjb3B5ID0gb2JqLmNvbnN0cnVjdG9yKCk7XHJcblx0Zm9yICh2YXIga2V5IGluIG9iaikge1xyXG5cdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcblx0XHRcdGNvcHlba2V5XSA9IF9jbG9uZShvYmpba2V5XSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb3B5O1xyXG59O1xyXG5cclxudmFyIF9jbG9uZU9iakluUHJvdG8gPSBmdW5jdGlvbihvYmopIHtcclxuXHRmb3IgKHZhciBrZXkgaW4gb2JqKSB7XHJcblx0XHRpZiAodHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIikge1xyXG5cdFx0XHRvYmpba2V5XSA9IF9jbG9uZShvYmpba2V5XSk7XHJcblx0XHR9XHJcblx0fVxyXG59O1xyXG5cclxudmFyIF9jb3ZlclZpcnR1YWwgPSBmdW5jdGlvbiAoY2hpbGRNZXRob2QsIHBhcmVudE1ldGhvZCwgc3VwZXJOYW1lKSB7XHJcblx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBjdXJyZW50U3VwZXIgPSB0aGlzW3N1cGVyTmFtZV07XHJcblx0XHR0aGlzW3N1cGVyTmFtZV0gPSBwYXJlbnRNZXRob2Q7XHJcblx0XHR2YXIgciA9IGNoaWxkTWV0aG9kLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHR0aGlzW3N1cGVyTmFtZV0gPSBjdXJyZW50U3VwZXI7XHJcblx0XHRyZXR1cm4gcjtcclxuXHR9O1xyXG59O1xyXG5cclxudmFyIF9leHRlbmRXaXRoU3VwZXIgPSBmdW5jdGlvbiAoY2hpbGRDbGFzcywgbmV3UHJvcGVydGllcywgc3VwZXJOYW1lKSB7XHJcblx0aWYgKCFuZXdQcm9wZXJ0aWVzKSB7XHJcblx0XHRyZXR1cm47XHJcblx0fVxyXG5cclxuXHQvLyBFeHRlbmQgYW5kIHNldHVwIHZpcnR1YWwgbWV0aG9kc1xyXG5cdGZvciAodmFyIGtleSBpbiBuZXdQcm9wZXJ0aWVzKSB7XHJcblx0XHRpZiAoIW5ld1Byb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xyXG5cdFx0XHRjb250aW51ZTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW2tleV07XHJcblx0XHRpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGNoaWxkQ2xhc3Nba2V5XSA9PSAnZnVuY3Rpb24nICYmIGNoaWxkQ2xhc3Nba2V5XSAhPT0gX25vb3ApIHtcclxuXHRcdFx0Y2hpbGRDbGFzc1trZXldID0gX2NvdmVyVmlydHVhbCh2YWx1ZSwgY2hpbGRDbGFzc1trZXldLCBzdXBlck5hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2hpbGRDbGFzc1trZXldID0gX2Nsb25lKHZhbHVlKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8vIERlZmF1bHQgc3RhdGVcclxuXHRpZiAoIWNoaWxkQ2xhc3Nbc3VwZXJOYW1lXSkge1xyXG5cdFx0Y2hpbGRDbGFzc1tzdXBlck5hbWVdID0gX25vb3A7XHJcblx0fVxyXG59O1xyXG5cclxuLyoqXHJcbiAqIEV4dGVuZCBjbGFzc1xyXG4gKiBAcGFyYW0ge29iamVjdH0gbmFtZU9iamVjdFxyXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyZW50TmFtZU9iamVjdFxyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBbcGFyZW50Q2xhc3NdXHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFttaXhpbnNdXHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvdG90eXBlUHJvcGVydGllc11cclxuICogQHBhcmFtIHtvYmplY3R9IFtzdGF0aWNQcm9wZXJ0aWVzXVxyXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259IE5ldyBjbGFzc1xyXG4gKi9cclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZU9iamVjdCwgcGFyZW50TmFtZU9iamVjdCwgcGFyZW50Q2xhc3MsIG1peGlucywgcHJvdG90eXBlUHJvcGVydGllcywgc3RhdGljUHJvcGVydGllcywgc3VwZXJOYW1lKSB7XHJcblx0cGFyZW50Q2xhc3MgPSBwYXJlbnRDbGFzcyB8fCBfbm9vcDtcclxuXHRtaXhpbnMgPSBtaXhpbnMgfHwgW107XHJcblxyXG5cdC8vIFRoZSBjb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIG5ldyBzdWJjbGFzcyBpcyBlaXRoZXIgZGVmaW5lZCBieSB5b3VcclxuXHQvLyAodGhlIFwiY29uc3RydWN0b3JcIiBwcm9wZXJ0eSBpbiB5b3VyIGBleHRlbmRgIGRlZmluaXRpb24pLCBvciBkZWZhdWx0ZWRcclxuXHQvLyBieSB1cyB0byBzaW1wbHkgY2FsbCB0aGUgcGFyZW50J3MgY29uc3RydWN0b3IuXHJcblx0dmFyIGNvbnN0cnVjdG9yID0gcHJvdG90eXBlUHJvcGVydGllcyAmJiBwcm90b3R5cGVQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCdjb25zdHJ1Y3RvcicpID9cclxuXHRcdF9jb3ZlclZpcnR1YWwocHJvdG90eXBlUHJvcGVydGllcy5jb25zdHJ1Y3RvciwgcGFyZW50Q2xhc3MsIHN1cGVyTmFtZSkgOlxyXG5cdFx0cGFyZW50Q2xhc3M7XHJcblx0dmFyIGNoaWxkQ2xhc3MgPSBfY3JlYXRlRnVuY3Rpb24obmFtZU9iamVjdCwgZnVuY3Rpb24oKSB7XHJcblx0XHRpZiAoIXRoaXMuX19pbnN0YW5jZU5hbWUpIHtcclxuXHRcdFx0X2Nsb25lT2JqSW5Qcm90byh0aGlzKTtcclxuXHRcdFx0dGhpcy5fX2luc3RhbmNlTmFtZSAgPSBuYW1lT2JqZWN0Lmdsb2JhbE5hbWUgKyBpbnN0YW5jZUNvdW50ZXIrKztcclxuXHRcdH1cclxuXHRcdGNvbnN0cnVjdG9yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0fSk7XHJcblxyXG5cdC8vIEFkZCBzdGF0aWMgcHJvcGVydGllcyB0byB0aGUgY29uc3RydWN0b3IgZnVuY3Rpb24sIGlmIHN1cHBsaWVkLlxyXG5cdGZvciAodmFyIHByb3AgaW4gcGFyZW50Q2xhc3MpIHtcclxuXHRcdGNoaWxkQ2xhc3NbcHJvcF0gPSBwYXJlbnRDbGFzc1twcm9wXTtcclxuXHR9XHJcblx0X2V4dGVuZFdpdGhTdXBlcihjaGlsZENsYXNzLCBzdGF0aWNQcm9wZXJ0aWVzLCBzdXBlck5hbWUpO1xyXG5cclxuXHQvLyBTZXQgdGhlIHByb3RvdHlwZSBjaGFpbiB0byBpbmhlcml0IGZyb20gYHBhcmVudGAsIHdpdGhvdXQgY2FsbGluZ1xyXG5cdC8vIGBwYXJlbnRgJ3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXHJcblx0dmFyIFN1cnJvZ2F0ZSA9IF9jcmVhdGVGdW5jdGlvbihwYXJlbnROYW1lT2JqZWN0LCBfbm9vcCk7XHJcblx0U3Vycm9nYXRlLnByb3RvdHlwZSA9IHBhcmVudENsYXNzLnByb3RvdHlwZTtcclxuXHJcblx0Y2hpbGRDbGFzcy5wcm90b3R5cGUgPSBuZXcgU3Vycm9nYXRlKCk7XHJcblxyXG5cdC8vIENvcHkgb2JqZWN0cyBmcm9tIGNoaWxkIHByb3RvdHlwZVxyXG5cdGZvciAodmFyIHByb3AyIGluIHBhcmVudENsYXNzLnByb3RvdHlwZSkge1xyXG5cdFx0aWYgKHBhcmVudENsYXNzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShwcm9wMikgJiYgcHJvcDIgIT09ICdjb25zdHJ1Y3RvcicpIHtcclxuXHRcdFx0Y2hpbGRDbGFzcy5wcm90b3R5cGVbcHJvcDJdID0gX2Nsb25lKHBhcmVudENsYXNzLnByb3RvdHlwZVtwcm9wMl0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0Ly8gQWRkIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChpbnN0YW5jZSBwcm9wZXJ0aWVzKSB0byB0aGUgc3ViY2xhc3MsXHJcblx0Ly8gaWYgc3VwcGxpZWQuXHJcblx0aWYgKHByb3RvdHlwZVByb3BlcnRpZXMpIHtcclxuXHRcdF9leHRlbmRXaXRoU3VwZXIoY2hpbGRDbGFzcy5wcm90b3R5cGUsIHByb3RvdHlwZVByb3BlcnRpZXMsIHN1cGVyTmFtZSk7XHJcblx0fVxyXG5cclxuXHQvLyBBZGQgcHJvdG90eXBlIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgZnJvbSBtaXhpbnNcclxuXHRmb3IgKHZhciBpID0gMCwgbCA9IG1peGlucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdGZvciAodmFyIG1peGluUHJvcCBpbiBtaXhpbnNbaV0ucHJvdG90eXBlKSB7XHJcblx0XHRcdC8vIFNraXAgcHJpdmF0ZVxyXG5cdFx0XHRpZiAobWl4aW5Qcm9wLnN1YnN0cigwLCAyKSA9PT0gJ19fJykge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RzIHByb3BlcnR5IG9yIG1ldGhvZC4gTWl4aW4gY2FuIG9ubHkgYWRkIHByb3BlcnRpZXMsIGJ1dCBubyByZXBsYWNlIGl0XHJcblx0XHRcdGlmICh0eXBlb2YgY2hpbGRDbGFzcy5wcm90b3R5cGVbbWl4aW5Qcm9wXSA9PT0gJ2Z1bmN0aW9uJyB8fCBjaGlsZENsYXNzLnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eShtaXhpblByb3ApKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdUcnkgdG8gcmVwbGFjZSBwcm90b3R5cGUgcHJvcGVydHkgYCcgKyBtaXhpblByb3AgKyAnYCBpbiBjbGFzcyBgJyArIGNoaWxkQ2xhc3MuX19jbGFzc05hbWUgKyAnYCBieSBtaXhpbiBgJyArIG1peGluc1tpXS5fX2NsYXNzTmFtZSArICdgJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2hpbGRDbGFzcy5wcm90b3R5cGVbbWl4aW5Qcm9wXSA9IG1peGluc1tpXS5wcm90b3R5cGVbbWl4aW5Qcm9wXTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gQWRkIHN0YXRpYyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIGZyb20gbWl4aW5zXHJcblx0Zm9yICh2YXIgaSA9IDAsIGwgPSBtaXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XHJcblx0XHRmb3IgKHZhciBtaXhpblByb3AgaW4gbWl4aW5zW2ldKSB7XHJcblx0XHRcdC8vIFNraXAgcHJpdmF0ZVxyXG5cdFx0XHRpZiAobWl4aW5Qcm9wLnN1YnN0cigwLCAyKSA9PT0gJ19fJykge1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBDaGVjayBmb3IgZXhpc3RzIHByb3BlcnR5IG9yIG1ldGhvZC4gTWl4aW4gY2FuIG9ubHkgYWRkIHByb3BlcnRpZXMsIGJ1dCBubyByZXBsYWNlIGl0XHJcblx0XHRcdGlmICh0eXBlb2YgY2hpbGRDbGFzc1ttaXhpblByb3BdID09PSAnZnVuY3Rpb24nIHx8IGNoaWxkQ2xhc3MuaGFzT3duUHJvcGVydHkobWl4aW5Qcm9wKSkge1xyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignVHJ5IHRvIHJlcGxhY2Ugc3RhdGljIHByb3BlcnR5IGAnICsgbWl4aW5Qcm9wICsgJ2AgaW4gY2xhc3MgYCcgKyBjaGlsZENsYXNzLl9fY2xhc3NOYW1lICsgJ2AgYnkgbWl4aW4gYCcgKyBtaXhpbnNbaV0uX19jbGFzc05hbWUgKyAnYCcpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNoaWxkQ2xhc3NbbWl4aW5Qcm9wXSA9IG1peGluc1tpXVttaXhpblByb3BdO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIGNoaWxkQ2xhc3M7XHJcbn07XHJcblxufSx7fV0sMTYyOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcbnZhciBGT1JNQVRfSk9JTlRTX1YwMiA9ICduZWF0bmVzc192MDInO1xyXG52YXIgRk9STUFUX0pPSU5UU19WMTAgPSAnbmVhdG5lc3NfdjEwJztcclxuXHJcbm1vZHVsZS5leHBvcnRzID0ge1xyXG5cclxuXHQvKipcclxuXHQgKiBEZXRlY3QgZm9ybWF0IGFuZCByZXR1cm4gY2xhc3MgcGFyYW1zXHJcblx0ICogQHBhcmFtIHtzdHJpbmd9IGdsb2JhbE5hbWVcclxuXHQgKiBAcGFyYW0geyhmdW5jdGlvbnxvYmplY3R8bnVsbCl9IG9wdGlvbnNPckV4dGVuZFxyXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBbcHJvdG9Qcm9wc11cclxuXHQgKiBAcGFyYW0ge29iamVjdH0gW3N0YXRpY1Byb3BzXVxyXG5cdCAqIEByZXR1cm5zIHtvYmplY3R9XHJcblx0ICovXHJcblx0cGFyc2VGb3JtYXQ6IGZ1bmN0aW9uIChnbG9iYWxOYW1lLCBvcHRpb25zT3JFeHRlbmQsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XHJcblx0XHR2YXIgbmFtZU9iamVjdCA9IHRoaXMucGFyc2VGdWxsTmFtZShnbG9iYWxOYW1lKTtcclxuXHRcdHZhciBwYXJlbnROYW1lT2JqZWN0ID0gbnVsbDtcclxuXHRcdHZhciBwYXJlbnRDbGFzcyA9IG51bGw7XHJcblx0XHR2YXIgcHJvdG90eXBlUHJvcGVydGllcyA9IG51bGw7XHJcblx0XHR2YXIgc3RhdGljUHJvcGVydGllcyA9IG51bGw7XHJcblx0XHR2YXIgZm9ybWF0ID0gbnVsbDtcclxuXHRcdHZhciBtaXhpbnMgPSBbXTtcclxuXHJcblx0XHQvLyBOZWF0bmVzcyB2MC4yIChvbGQpIGZvcm1hdFxyXG5cdFx0aWYgKG9wdGlvbnNPckV4dGVuZCA9PT0gbnVsbCB8fCB0eXBlb2Ygb3B0aW9uc09yRXh0ZW5kID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHBhcmVudENsYXNzID0gb3B0aW9uc09yRXh0ZW5kO1xyXG5cdFx0XHRwcm90b3R5cGVQcm9wZXJ0aWVzID0gcHJvdG9Qcm9wcztcclxuXHRcdFx0c3RhdGljUHJvcGVydGllcyA9IHN0YXRpY1Byb3BzO1xyXG5cdFx0XHRmb3JtYXQgPSBGT1JNQVRfSk9JTlRTX1YwMjtcclxuXHJcblx0XHRcdGlmIChwYXJlbnRDbGFzcyAmJiB0eXBlb2YgcGFyZW50Q2xhc3MuZGVidWdDbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0cGFyZW50TmFtZU9iamVjdCA9IHRoaXMucGFyc2VGdWxsTmFtZShwYXJlbnRDbGFzcy5kZWJ1Z0NsYXNzTmFtZSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIE5lYXRuZXNzIHYxLjAgZm9ybWF0XHJcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zT3JFeHRlbmQgPT09ICdvYmplY3QnKSB7XHJcblx0XHRcdGlmIChvcHRpb25zT3JFeHRlbmQuaGFzT3duUHJvcGVydHkoJ19fZXh0ZW5kcycpKSB7XHJcblx0XHRcdFx0cGFyZW50Q2xhc3MgPSBvcHRpb25zT3JFeHRlbmQuX19leHRlbmRzO1xyXG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zT3JFeHRlbmQuX19leHRlbmRzO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAob3B0aW9uc09yRXh0ZW5kLmhhc093blByb3BlcnR5KCdfX3N0YXRpYycpKSB7XHJcblx0XHRcdFx0c3RhdGljUHJvcGVydGllcyA9IG9wdGlvbnNPckV4dGVuZC5fX3N0YXRpYztcclxuXHRcdFx0XHRkZWxldGUgb3B0aW9uc09yRXh0ZW5kLl9fc3RhdGljO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAob3B0aW9uc09yRXh0ZW5kLmhhc093blByb3BlcnR5KCdfX21peGlucycpKSB7XHJcblx0XHRcdFx0bWl4aW5zID0gbWl4aW5zLmNvbmNhdChvcHRpb25zT3JFeHRlbmQuX19taXhpbnMpO1xyXG5cdFx0XHRcdGRlbGV0ZSBvcHRpb25zT3JFeHRlbmQuX19taXhpbnM7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnNPckV4dGVuZC5oYXNPd25Qcm9wZXJ0eSgnX19taXhpbicpKSB7XHJcblx0XHRcdFx0bWl4aW5zID0gbWl4aW5zLmNvbmNhdChvcHRpb25zT3JFeHRlbmQuX19taXhpbik7XHJcblx0XHRcdFx0ZGVsZXRlIG9wdGlvbnNPckV4dGVuZC5fX21peGluO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRmb3JtYXQgPSBGT1JNQVRfSk9JTlRTX1YxMDtcclxuXHRcdFx0cHJvdG90eXBlUHJvcGVydGllcyA9IG9wdGlvbnNPckV4dGVuZDtcclxuXHJcblx0XHRcdGlmIChwYXJlbnRDbGFzcyAmJiB0eXBlb2YgcGFyZW50Q2xhc3MuX19jbGFzc05hbWUgPT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdFx0cGFyZW50TmFtZU9iamVjdCA9IHRoaXMucGFyc2VGdWxsTmFtZShwYXJlbnRDbGFzcy5fX2NsYXNzTmFtZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRuYW1lT2JqZWN0LFxyXG5cdFx0XHRwYXJlbnROYW1lT2JqZWN0LFxyXG5cdFx0XHRwYXJlbnRDbGFzcyxcclxuXHRcdFx0cHJvdG90eXBlUHJvcGVydGllcyxcclxuXHRcdFx0c3RhdGljUHJvcGVydGllcyxcclxuXHRcdFx0Zm9ybWF0LFxyXG5cdFx0XHRtaXhpbnMsXHJcblx0XHRcdGZvcm1hdCA9PT0gRk9STUFUX0pPSU5UU19WMDIgPyAnX3N1cGVyJyA6ICdfX3N1cGVyJ1xyXG5cdFx0XTtcclxuXHR9LFxyXG5cclxuXHRhcHBseUNsYXNzQ29uZmlnOiBmdW5jdGlvbihuZXdDbGFzcywgZm9ybWF0LCBuYW1lT2JqZWN0LCBwYXJlbnROYW1lT2JqZWN0KSB7XHJcblx0XHQvLyBTZXQgX19jbGFzc05hbWUgZm9yIGFsbCBmb3JtYXRzXHJcblx0XHRuZXdDbGFzcy5fX2NsYXNzTmFtZSA9IG5ld0NsYXNzLnByb3RvdHlwZS5fX2NsYXNzTmFtZSA9IG5hbWVPYmplY3QuZ2xvYmFsTmFtZTtcclxuXHJcblx0XHR2YXIgY2xhc3NOYW1lS2V5ID0gZm9ybWF0ID09PSBGT1JNQVRfSk9JTlRTX1YwMiA/ICdkZWJ1Z0NsYXNzTmFtZScgOiAnX19jbGFzc05hbWUnO1xyXG5cdFx0dmFyIHBhcmVudENsYXNzTmFtZUtleSA9IGZvcm1hdCA9PT0gRk9STUFUX0pPSU5UU19WMDIgPyAnJyA6ICdfX3BhcmVudENsYXNzTmFtZSc7XHJcblx0XHR2YXIgc3RhdGljTmFtZUtleSA9IGZvcm1hdCA9PT0gRk9STUFUX0pPSU5UU19WMDIgPyAnX3N0YXRpYycgOiAnX19zdGF0aWMnO1xyXG5cclxuXHRcdG5ld0NsYXNzW2NsYXNzTmFtZUtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbY2xhc3NOYW1lS2V5XSA9IG5hbWVPYmplY3QuZ2xvYmFsTmFtZTtcclxuXHRcdGlmIChwYXJlbnRDbGFzc05hbWVLZXkpIHtcclxuXHRcdFx0bmV3Q2xhc3NbcGFyZW50Q2xhc3NOYW1lS2V5XSA9IG5ld0NsYXNzLnByb3RvdHlwZVtwYXJlbnRDbGFzc05hbWVLZXldID0gcGFyZW50TmFtZU9iamVjdCA/IChwYXJlbnROYW1lT2JqZWN0Lmdsb2JhbE5hbWUgfHwgbnVsbCkgOiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0bmV3Q2xhc3Nbc3RhdGljTmFtZUtleV0gPSBuZXdDbGFzcy5wcm90b3R5cGVbc3RhdGljTmFtZUtleV0gPSBuZXdDbGFzcztcclxuXHJcblx0XHRyZXR1cm4gbmV3Q2xhc3M7XHJcblx0fSxcclxuXHJcblx0cGFyc2VGdWxsTmFtZTogZnVuY3Rpb24oZ2xvYmFsTmFtZSkge1xyXG5cdFx0Ly8gU3BsaXQgbmFtZXNwYWNlXHJcblx0XHR2YXIgcG9zID0gZ2xvYmFsTmFtZS5sYXN0SW5kZXhPZignLicpO1xyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGdsb2JhbE5hbWU6IGdsb2JhbE5hbWUsXHJcblx0XHRcdG5hbWU6IHBvcyAhPT0gLTEgPyBnbG9iYWxOYW1lLnN1YnN0cihwb3MgKyAxKSA6IGdsb2JhbE5hbWUsXHJcblx0XHRcdG5hbWVzcGFjZTogcG9zICE9PSAtMSA/IGdsb2JhbE5hbWUuc3Vic3RyKDAsIHBvcykgOiAnJ1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG59O1xyXG5cbn0se31dfSx7fSxbOTRdKTtcbiJdLCJmaWxlIjoiYXBwLWNsaWVudC5qcyIsInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
